import { collectCss } from '../../helpers/styles/collect-css';
import { JSONObject } from '../../types/json';
import { MitosisComponent } from '../../types/mitosis-component';
import { convertMethodToFunction } from './convertMethodToFunction';
import { renderJSXNodes } from './jsx';
import { arrowFnBlock, File, invoke, SrcBuilder } from './src-generator';
import { babelTransformExpression } from '../../helpers/babel-transform';
import { BaseTranspilerOptions, Transpiler } from '../../types/transpiler';
import { MitosisNode } from '../../types/mitosis-node';

Error.stackTraceLimit = 9999;

// TODO(misko): styles are not processed.

export interface ToQwikOptions extends BaseTranspilerOptions {}

type StateInit = [Record<string, any>, ...string[]];

export const componentToQwik =
  (userOptions: ToQwikOptions = {}): Transpiler =>
  ({ component, path }): string => {
    const file = new File(
      component.name + '.js',
      {
        isPretty: true,
        isJSX: true,
        isTypeScript: false,
        isModule: true,
        isBuilder: false,
      },
      '@builder.io/qwik',
      '',
    );
    try {
      // file.exportConst('COMPONENT', JSON.stringify(component, null, 2));
      emitImports(file, component);
      emitTypes(file, component);
      const state: StateInit = emitStateMethodsAndRewriteBindings(file, component);
      let hasState = Boolean(Object.keys(component.state).length);
      let css: string | null = null;
      file.src.const(
        component.name,
        invoke(file.import(file.qwikModule, 'component$'), [
          arrowFnBlock(
            ['props'],
            [
              function (this: SrcBuilder) {
                css = emitUseStyles(file, component);
                hasState && emitUseStore(file, state);
                emitUseRef(file, component);
                emitUseContextProvider(file, component);
                emitUseContext(file, component);
                emitUseMount(file, component);
                emitUseWatch(file, component);
                emitUseCleanup(file, component);
                emitJSX(file, component);
              },
            ],
            [component.propsTypeRef || 'any'],
          ),
        ]),
      );
      file.exportDefault(component.name);
      emitStyles(file, css);
      return '// GENERATED BY MITOSIS\n\n' + file.toString();
    } catch (e) {
      console.error(e);
      return (e as Error).stack || String(e);
    }
  };

function emitUseMount(file: File, component: MitosisComponent) {
  if (component.hooks.onMount) {
    // This is called useMount, but in practice it is used as
    // useClientEffect. Not sure if this is correct, but for now.
    const code = component.hooks.onMount.code;
    file.src.emit(
      file.import(file.qwikModule, 'useClientEffect$').localName,
      '(()=>{',
      code,
      '});',
    );
  }
}
function emitUseWatch(file: File, component: MitosisComponent) {
  if (component.hooks.onUpdate) {
    component.hooks.onUpdate.forEach((onUpdate) => {
      file.src.emit(file.import(file.qwikModule, 'useWatch$').localName, '((track)=>{');
      emitTrackExpressions(file.src, onUpdate.deps);
      file.src.emit(convertTypeScriptToJS(onUpdate.code), '});');
    });
  }
}

function emitTrackExpressions(src: SrcBuilder, deps?: string) {
  if (deps && deps.startsWith('[') && deps.endsWith(']')) {
    const dependencies = deps.substring(1, deps.length - 1).split(',');
    dependencies.forEach((dep) => {
      const lastDotIdx = dep.lastIndexOf('.');
      const objExp = dep.substring(0, lastDotIdx).replace(/\?$/, '');
      const objProp = dep.substring(lastDotIdx + 1);
      src.emit(objExp, '&&track(', objExp, ',"', objProp, '");');
    });
  }
}
function emitUseCleanup(file: File, component: MitosisComponent) {
  if (component.hooks.onUnMount) {
    const code = component.hooks.onUnMount.code;
    file.src.emit(file.import(file.qwikModule, 'useCleanup$').localName, '(()=>{', code, '});');
  }
}

function emitJSX(file: File, component: MitosisComponent) {
  const directives = new Map();
  const handlers = new Map<string, string>();
  const styles = new Map();
  const parentSymbolBindings = {};
  file.src.emit(
    'return ',
    renderJSXNodes(file, directives, handlers, component.children, styles, parentSymbolBindings),
  );
}

function emitUseContextProvider(file: File, component: MitosisComponent) {
  Object.keys(component.context.set).forEach((ctxKey) => {
    const context = component.context.set[ctxKey];
    file.src.emit(
      file.import(file.qwikModule, 'useContextProvider').localName,
      '(',
      context.name,
      ',',
      file.import(file.qwikModule, 'useStore').localName,
      '({',
    );
    context.value &&
      Object.keys(context.value).forEach((prop) => {
        const propValue = context.value![prop];
        file.src.emit(prop, ':');
        if (isGetter(propValue)) {
          const methodMap = stateToMethodOrGetter(component.state);
          const code = convertMethodToFunction(
            extractGetterBody(propValue),
            methodMap,
            getLexicalScopeVars(component),
          );
          file.src.emit('(()=>{', code, '})(),');
        } else if (typeof propValue == 'function') {
          throw new Error('Qwik: Functions are not supported in context');
        } else {
          file.src.emit(JSON.stringify(propValue));
        }
      });
    file.src.emit('})', ');');
  });
}

function emitUseContext(file: File, component: MitosisComponent) {
  Object.keys(component.context.get).forEach((ctxKey) => {
    const context = component.context.get[ctxKey];
    file.src.emit(
      'const ',
      ctxKey,
      '=',
      file.import(file.qwikModule, 'useContext').localName,
      '(',
      context.name,
      ');',
    );
  });
}

function emitUseRef(file: File, component: MitosisComponent) {
  Object.keys(component.refs).forEach((refKey) => {
    file.src.emit(`const `, refKey, '=', file.import(file.qwikModule, 'useRef').localName, '();');
  });
}

function emitUseStyles(file: File, component: MitosisComponent): string {
  const css = collectCss(component);
  if (css) {
    file.src.emit(file.import(file.qwikModule, 'useScopedStyles$').localName, '(STYLES);');
  }
  return css;
}

function emitStyles(file: File, css: string | null) {
  if (css) {
    file.exportConst('STYLES', '`' + css.replace(/`/g, '\\`') + '`');
  }
}

function emitUseStore(file: File, stateInit: StateInit) {
  const state = stateInit[0];
  file.src.emit('const state=', file.import(file.qwikModule, 'useStore').localName, '(');
  if (stateInit.length == 1) {
    file.src.emit(JSON.stringify(state));
  } else {
    file.src.emit('()=>{const state=', JSON.stringify(state), ';');
    file.src.emitList(stateInit.slice(1), ';');
    file.src.emit(';return state;');
    file.src.emit('}');
  }
  file.src.emit(');');
}

function emitTypes(file: File, component: MitosisComponent) {
  if (file.options.isTypeScript) {
    component.types?.forEach((t) => file.src.emit(t, '\n'));
    component.interfaces?.forEach((i) => file.src.emit(i));
  }
}

function emitStateMethodsAndRewriteBindings(file: File, component: MitosisComponent): StateInit {
  const lexicalArgs = getLexicalScopeVars(component);
  const state: StateInit = emitStateMethods(file, component.state, lexicalArgs);
  const methodMap = stateToMethodOrGetter(component.state);

  component.children?.forEach((node) => rewriteBindings(node, methodMap, lexicalArgs));
  return state;
}

function getLexicalScopeVars(component: MitosisComponent) {
  return ['props', 'state', ...Object.keys(component.refs), ...Object.keys(component.context.get)];
}

function emitImports(file: File, component: MitosisComponent) {
  // <SELF> is used for self-referencing within the file.
  file.import('<SELF>', component.name);
  component.imports?.forEach((i) => {
    Object.keys(i.imports).forEach((key) => {
      const keyValue = i.imports[key]!;
      file.import(i.path.replace('.lite', '').replace('.tsx', ''), keyValue, key);
    });
  });
}

const CODE_PREFIX = '@builder.io/mitosis/';
const FUNCTION = CODE_PREFIX + 'function:';
const METHOD = CODE_PREFIX + 'method:';
const GETTER = CODE_PREFIX + 'method:get ';

function emitStateMethods(
  file: File,
  componentState: JSONObject,
  lexicalArgs: string[],
): StateInit {
  const state: Record<string, any> = {};
  const stateInit: StateInit = [state];
  const methodMap = stateToMethodOrGetter(componentState);
  Object.keys(componentState).forEach((key) => {
    let code = componentState[key]!;
    if (isCode(code)) {
      let prefixIdx = code.indexOf(':') + 1;
      if (isGetter(code)) {
        prefixIdx += 'get '.length;
      } else if (isFunction(code)) {
        prefixIdx += 'function '.length;
      }
      code = code.substring(prefixIdx);
      code = convertMethodToFunction(code, methodMap, lexicalArgs).replace(
        '(',
        `(${lexicalArgs.join(',')},`,
      );
      const functionName = code.split(/\(/)[0];
      stateInit.push(`state.${key}=${functionName}(state, props)`);
      if (!file.options.isTypeScript) {
        // Erase type information
        code = convertTypeScriptToJS(code);
      }
      file.src.emit('function ', code);
    } else {
      state[key] = code;
    }
  });
  return stateInit;
}

function convertTypeScriptToJS(code: string): string {
  // HACK, proper implementation should use Babel
  // return code.replace(/(\w+):\s+[\w\[\]"']+/gm, (_, ident) => ident);
  return babelTransformExpression(code, {});
}

function isGetter(code: any): code is string {
  return typeof code === 'string' && code.startsWith(GETTER);
}

function isCode(code: any): code is string {
  return typeof code === 'string' && code.startsWith(CODE_PREFIX);
}

function isFunction(code: any): code is string {
  return typeof code === 'string' && code.startsWith(FUNCTION);
}

function extractGetterBody(code: string): string {
  const start = code.indexOf('{');
  const end = code.lastIndexOf('}');
  return code.substring(start + 1, end).trim();
}

function stateToMethodOrGetter(state: Record<string, any>): Record<string, 'method' | 'getter'> {
  const methodMap: Record<string, 'method' | 'getter'> = {};
  Object.keys(state).forEach((key) => {
    let code = state[key]!;
    if (typeof code == 'string' && code.startsWith(METHOD)) {
      methodMap[key] = code.startsWith(GETTER) ? 'getter' : 'method';
    }
  });
  return methodMap;
}

function rewriteBindings(
  node: MitosisNode,
  methodMap: Record<string, 'method' | 'getter'>,
  lexicalArgs: string[],
) {
  Object.keys(node.bindings).forEach((key) => {
    const binding = node.bindings[key];
    if (binding?.code) {
      binding.code = convertMethodToFunction(binding.code, methodMap, lexicalArgs);
    }
    if (key.startsWith('on') && binding?.code) {
      const args = binding?.arguments || [];
      binding.code = `(${args.join(',')}) => ${binding.code}`;
      delete node.bindings[key];
      node.bindings[key + '$'] = binding;
    }
  });
  node.children?.forEach((child) => rewriteBindings(child, methodMap, lexicalArgs));
}
