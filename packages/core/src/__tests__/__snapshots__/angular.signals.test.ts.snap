// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Angular signals > jsx > Javascript Test > Advanced 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-for-show-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <main #_root>
      @for (person of names();track i;let i = $index) {
      <div>{{i}} : {{person}}</div>
      } @for (person of names();track i;let i = $index) {
      <span>{{person}}</span>
      } @for (_ of names();track i;let i = $index) {
      <br />
      } @for (_ of Array.from({ length: 10 });track ee;let ee = $index) {
      <pre>{{ee}}</pre>
      } @for (_ of Array.from({ length: 10 });track i;let i = $index) {
      <p>{{index}}</p>
      } @for (person of names();track index;let index = $index) {
      <span>{{person}} {{index}}</span>
      } @for (person of Array.from({ length: 10 });track count;let count =
      $index) {
      <span>{{person}} {{count}}</span>
      } @for (person of names();track i;let i = $index) {
      <span>{{person}} {{i}}</span>
      } @for (person of Array.from({ length: 10 });track index;let index =
      $index) {
      <span>{{person}} {{index}}</span>
      }
    </main>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicForShowComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"PatrickJS\\");
  names = signal([\\"Steve\\", \\"PatrickJS\\"]);

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-for-show-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > AdvancedRef 1`] = `
"--- MITOSIS ERROR ---
    Component input has an event change that uses 'event.target.xxx'. 
        This will cause an error in Angular.
        Please create a new function with the EventTarget and use e.g '(event.target as HTMLInputElement).value'"
`;

exports[`Angular signals > jsx > Javascript Test > Basic 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

export const DEFAULT_VALUES = {
  name: \\"Steve\\",
};

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div class=\\"test div\\" #_root>
      <input
        [attr.value]=\\"DEFAULT_VALUES.name || name()\\"
        (change)=\\"name.set(myEvent.target.value)\\"
      />

      Hello! I can run in React, Vue, Solid, or Liquid! &gt;
    </div>
  \`,
  styles: \`:host { display: contents; }
        .div {
          padding: 10px;
        }
\`,
})
export class MyBasicComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"Steve\\");
  age = signal(1);
  sports = signal([\\"\\"]);

  underscore_fn_name() {
    return \\"bar\\";
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > Basic 2`] = `
"unknown: Unexpected token, expected \\",\\" (2:7)

[0m [90m 1 |[39m [36mlet[39m _ [33m=[39m {[0m
[0m[31m[1m>[22m[39m[90m 2 |[39m   state[33m.[39mname [33m=[39m event[33m.[39mtarget[33m.[39mvalue [33m+[39m [32m' and '[39m [33m+[39m person[33m;[39m[0m
[0m [90m   |[39m        [31m[1m^[22m[39m[0m
[0m [90m 3 |[39m }[0m"
`;

exports[`Angular signals > jsx > Javascript Test > Basic Context 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Injector, MyService, createInjector } from \\"@dummy/injection-js\\";

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      {{myService.method('hello') + name()}} Hello! I can run in React, Vue,
      Solid, or Liquid!

      <input (change)=\\"onChange()\\" />
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"PatrickJS\\");

  onChange() {
    const change = this.myService.method(\\"change\\");
    console.log(change);
  }

  constructor(public myService: MyService) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    const hi = this.myService.method(\\"hi\\");
    console.log(hi);
    const bye = this.myService.method(\\"hi\\");
    console.log(bye);
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > Basic OnMount Update 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-on-mount-update-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>Hello {{name()}}</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicOnMountUpdateComponent implements AfterViewInit {
  bye = input<any>();
  hi = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"PatrickJS\\");
  names = signal([\\"Steve\\", \\"PatrickJS\\"]);

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.name.set(\\"PatrickJS onInit\\" + this.hi());
    this.name.set(\\"PatrickJS onMount\\" + this.bye());
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-on-mount-update-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > Basic Outputs 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  output,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-outputs-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicOutputsComponent implements AfterViewInit {
  message = input<any>();
  messageChange = output();
  event = output();

  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"PatrickJS\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.messageChange.emit(this.name());
    this.event.emit(this.message());
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-outputs-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > Basic Outputs Meta 1`] = `
"/**
          useMetadata:
          {\\"outputs\\":[\\"onMessage\\",\\"onEvent\\"],\\"baz\\":\\"metadata inside component\\"}
          */

import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  output,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-outputs-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicOutputsComponent implements AfterViewInit {
  message = input<any>();
  messageChange = output();
  event = output();

  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"PatrickJS\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.messageChange.emit(this.name());
    this.event.emit(this.message());
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-outputs-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > BasicAttribute 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <input
      autocapitalize=\\"on\\"
      autocomplete=\\"on\\"
      [attr.spellcheck]=\\"true\\"
      #_root
    />
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > BasicBooleanAttribute 1`] = `
"--- MITOSIS ERROR ---
    Show: You can't use children() in a Show block for \`when\` targeting angular.
      Try to invert it like this: \\"<Show when={props.label} else={props.children}>{props.label}</Show>\\""
`;

exports[`Angular signals > jsx > Javascript Test > BasicChildComponent 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import MyBasicOnMountUpdateComponent from \\"./basic-onMount-update.raw\\";
import MyBasicOutputsComponent from \\"./basic-outputs.raw\\";
import MyBasicComponent from \\"./basic.raw\\";

@Component({
  selector: \\"my-basic-child-component\\",
  standalone: true,
  imports: [
    CommonModule,
    MyBasicComponent,
    MyBasicOnMountUpdateComponent,
    MyBasicOutputsComponent,
  ],
  template: \`
    <div #_root>
      <my-basic-component [id]=\\"dev()\\"></my-basic-component>
      <div>
        <my-basic-on-mount-update-component
          [hi]=\\"name()\\"
          [bye]=\\"dev()\\"
        ></my-basic-on-mount-update-component>
        <my-basic-outputs-component
          message=\\"Test\\"
          (messageChange)=\\"name.set($event)\\"
          (event)=\\"log('Test')\\"
        ></my-basic-outputs-component>
      </div>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicChildComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"Steve\\");
  dev = signal(\\"PatrickJS\\");

  log(message) {
    console.log(message);
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-child-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > BasicFor 1`] = `
"unknown: Unexpected token, expected \\",\\" (2:7)

[0m [90m 1 |[39m [36mlet[39m _ [33m=[39m {[0m
[0m[31m[1m>[22m[39m[90m 2 |[39m   state[33m.[39mname [33m=[39m event[33m.[39mtarget[33m.[39mvalue [33m+[39m [32m' and '[39m [33m+[39m person[33m;[39m[0m
[0m [90m   |[39m        [31m[1m^[22m[39m[0m
[0m [90m 3 |[39m }[0m"
`;

exports[`Angular signals > jsx > Javascript Test > BasicRef 1`] = `
"--- MITOSIS ERROR ---
    Component input has an event change that uses 'event.target.xxx'. 
        This will cause an error in Angular.
        Please create a new function with the EventTarget and use e.g '(event.target as HTMLInputElement).value'"
`;

exports[`Angular signals > jsx > Javascript Test > BasicRefAssignment 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-ref-assignment-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      <button (click)=\\"await handlerClick($event)\\">Click</button>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicRefAssignmentComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  handlerClick(event) {
    event.preventDefault();
    console.log(\\"current value\\", this._holdValueRef);
    this._holdValueRef = this._holdValueRef + \\"JS\\";
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-ref-assignment-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > BasicRefPrevious 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

export function usePrevious(value) {
  // The ref object is a generic container whose current property is mutable ...
  // ... and can hold any value, similar to an instance property on a class
  let ref = useRef(null); // Store current value in ref

  onUpdate(() => {
    ref = value;
  }, [value]); // Only re-run if value changes
  // Return previous value (happens before update in useEffect above)

  return ref;
}

@Component({
  selector: \\"my-previous-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      <h1>Now: {{count()}} , before: {{this._prevCount}}</h1>
      <button (click)=\\"count.set(1)\\">Increment</button>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyPreviousComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  count = signal(0);

  constructor() {
    effect(() => {
      // --- Mitosis: Workaround to make sure the effect() is triggered ---

      // ---

      this._prevCount = this.count;
    });
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-previous-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > Button 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"button\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      @if(link()){
      <a
        [attr.href]=\\"link()\\"
        [attr.target]=\\"openLinkInNewTab() ? '_blank' : undefined\\"
      >
        {{text()}}
      </a>
      } @if(!link()){
      <button type=\\"button\\">{{text()}}</button>
      }
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class Button implements AfterViewInit {
  link = input<any>();
  attributes = input<any>();
  openLinkInNewTab = input<any>();
  text = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"button\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > Columns 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"column\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div class=\\"builder-columns div\\" #_root>
      @for (column of columns();track index;let index = $index) {
      <div class=\\"builder-column div-2\\">{{column.content}} {{index}}</div>
      }
    </div>
  \`,
  styles: \`:host { display: contents; }
        .div {
          display: flex;
          flex-direction: column;
          align-items: stretch;
          line-height: normal;
        }
        @media (max-width: 999px) {
          .div {
            flex-direction: row;
          }
        }
        @media (max-width: 639px) {
          .div {
            flex-direction: row-reverse;
          }
        }
        .div-2 {
          flex-grow: 1;
        }
\`,
})
export class Column implements AfterViewInit {
  columns = input<any>();
  space = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  getColumns() {
    return this.columns || [];
  }
  getGutterSize() {
    return typeof this.space === \\"number\\" ? this.space || 0 : 20;
  }
  getWidth(index) {
    const columns = this.getColumns();
    return (columns[index] && columns[index].width) || 100 / columns.length;
  }
  getColumnCssWidth(index) {
    const columns = this.getColumns();
    const gutterSize = this.getGutterSize();
    const subtractWidth = (gutterSize * (columns.length - 1)) / columns.length;
    return \`calc(\${this.getWidth(index)}% - \${subtractWidth}px)\`;
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"column\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > ContentSlotHtml 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"content-slot-code\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      <ng-content select=\\"[testing]\\"></ng-content>
      <div><hr /></div>
      <div><ng-content></ng-content></div>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class ContentSlotCode implements AfterViewInit {
  slotTesting = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"content-slot-code\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > ContentSlotJSX 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

const defaultProps = {
  content: \\"\\",
  slotReference: undefined,
  slotContent: undefined,
};

@Component({
  selector: \\"content-slot-jsx-code\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    @if(slotReference()){
    <div
      [attr.name]=\\"slotContent() ? 'name1' : 'name2'\\"
      [attr.title]=\\"slotContent() ? 'title1' : 'title2'\\"
      (click)=\\"show()\\"
      [class]=\\"cls()\\"
    >
      @if(showContent() && slotContent()){
      <ng-content select=\\"[content]\\">{{content()}}</ng-content>
      }
      <div><hr /></div>
      <div><ng-content></ng-content></div>
    </div>
    }
  \`,
  styles: \`:host { display: contents; }\`,
})
export class ContentSlotJsxCode implements AfterViewInit {
  slotContent = input<any>(defaultProps[\\"slotContent\\"]);
  slotReference = input<any>(defaultProps[\\"slotReference\\"]);
  attributes = input<any>();
  content = input<any>(defaultProps[\\"content\\"]);

  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"king\\");
  showContent = signal(false);

  get cls() {
    return this.slotContent && this.children ? \`\${this.name}-content\` : \\"\\";
  }
  show() {
    this.slotContent ? 1 : \\"\\";
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"content-slot-jsx-code\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > CustomCode 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";
import { DomSanitizer } from \\"@angular/platform-browser\\";

@Component({
  selector: \\"custom-code\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div
      #elem
      [class]=\\"'builder-custom-code' + (replaceNodes() ? ' replace-nodes' : '')\\"
      [innerHTML]=\\"sanitizer.bypassSecurityTrustHtml(code())\\"
      #_root
    ></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class CustomCode implements AfterViewInit {
  replaceNodes = input<any>();
  code = input<any>();

  elem = viewChild<ElementRef>(\\"elem\\");
  _root = viewChild<ElementRef>(\\"_root\\");

  scriptsInserted = signal([]);
  scriptsRun = signal([]);

  findAndRunScripts() {
    // TODO: Move this function to standalone one in '@builder.io/utils'
    if (this.elem()?.nativeElement && typeof window !== \\"undefined\\") {
      /** @type {HTMLScriptElement[]} */
      const scripts = this.elem()?.nativeElement.getElementsByTagName(\\"script\\");

      for (let i = 0; i < scripts.length; i++) {
        const script = scripts[i];

        if (script.src) {
          if (this.scriptsInserted().includes(script.src)) {
            continue;
          }

          this.scriptsInserted().push(script.src);
          const newScript = document.createElement(\\"script\\");
          newScript.async = true;
          newScript.src = script.src;
          document.head.appendChild(newScript);
        } else if (
          !script.type ||
          [
            \\"text/javascript\\",
            \\"application/javascript\\",
            \\"application/ecmascript\\",
          ].includes(script.type)
        ) {
          if (this.scriptsRun().includes(script.innerText)) {
            continue;
          }

          try {
            this.scriptsRun().push(script.innerText);
            new Function(script.innerText)();
          } catch (error) {
            console.warn(\\"\`CustomCode\`: Error running script:\\", error);
          }
        }
      }
    }
  }

  constructor(protected sanitizer: DomSanitizer) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.findAndRunScripts();
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"custom-code\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > Embed 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";
import { DomSanitizer } from \\"@angular/platform-browser\\";

@Component({
  selector: \\"custom-code\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div
      #elem
      [class]=\\"'builder-custom-code' + (replaceNodes() ? ' replace-nodes' : '')\\"
      [innerHTML]=\\"sanitizer.bypassSecurityTrustHtml(code())\\"
      #_root
    ></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class CustomCode implements AfterViewInit {
  replaceNodes = input<any>();
  code = input<any>();

  elem = viewChild<ElementRef>(\\"elem\\");
  _root = viewChild<ElementRef>(\\"_root\\");

  scriptsInserted = signal([]);
  scriptsRun = signal([]);

  findAndRunScripts() {
    // TODO: Move this function to standalone one in '@builder.io/utils'
    if (this.elem()?.nativeElement && typeof window !== \\"undefined\\") {
      /** @type {HTMLScriptElement[]} */
      const scripts = this.elem()?.nativeElement.getElementsByTagName(\\"script\\");

      for (let i = 0; i < scripts.length; i++) {
        const script = scripts[i];

        if (script.src) {
          if (this.scriptsInserted().includes(script.src)) {
            continue;
          }

          this.scriptsInserted().push(script.src);
          const newScript = document.createElement(\\"script\\");
          newScript.async = true;
          newScript.src = script.src;
          document.head.appendChild(newScript);
        } else if (
          !script.type ||
          [
            \\"text/javascript\\",
            \\"application/javascript\\",
            \\"application/ecmascript\\",
          ].includes(script.type)
        ) {
          if (this.scriptsRun().includes(script.innerText)) {
            continue;
          }

          try {
            this.scriptsRun().push(script.innerText);
            new Function(script.innerText)();
          } catch (error) {
            console.warn(\\"\`CustomCode\`: Error running script:\\", error);
          }
        }
      }
    }
  }

  constructor(protected sanitizer: DomSanitizer) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.findAndRunScripts();
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"custom-code\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > Form 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Builder, builder } from \\"@builder.io/sdk\\";
import {
  BuilderBlock as BuilderBlockComponent,
  BuilderBlocks,
  get,
  set,
} from \\"@fake\\";

@Component({
  selector: \\"form-component\\",
  standalone: true,
  imports: [CommonModule, BuilderBlockComponent, BuilderBlocks],
  template: \`
    <form
      [attr.validate]=\\"validate()\\"
      #formRef
      [attr.action]=\\"!sendWithJs() && action()\\"
      [attr.method]=\\"method()\\"
      [attr.name]=\\"name()\\"
      (submit)=\\"onSubmit($event)\\"
      #_root
    >
      @if(builderBlock() && builderBlock().children){ @for (block of
      builderBlock()?.children;track trackByBlock0;let index = $index) {
      <builder-block-component
        [block]=\\"block\\"
        [index]=\\"index\\"
      ></builder-block-component>
      } } @if(submissionState() === 'error'){
      <builder-blocks
        dataPath=\\"errorMessage\\"
        [blocks]=\\"errorMessage()\\"
      ></builder-blocks>
      } @if(submissionState() === 'sending'){
      <builder-blocks
        dataPath=\\"sendingMessage\\"
        [blocks]=\\"sendingMessage()\\"
      ></builder-blocks>
      } @if(submissionState() === 'error' && responseData()){
      <pre class=\\"builder-form-error-text pre\\">
        {{JSON.stringify(responseData, null, 2)}}</pre
      >
      } @if(submissionState() === 'success'){
      <builder-blocks
        dataPath=\\"successMessage\\"
        [blocks]=\\"successMessage()\\"
      ></builder-blocks>
      }
    </form>
  \`,
  styles: \`:host { display: contents; }
        .pre {
          padding: 10px;
          color: red;
          text-align: center;
        }
\`,
})
export class FormComponent implements AfterViewInit {
  previewState = input<any>();
  sendWithJs = input<any>();
  sendSubmissionsTo = input<any>();
  action = input<any>();
  customHeaders = input<any>();
  contentType = input<any>();
  sendSubmissionsToEmail = input<any>();
  name = input<any>();
  method = input<any>();
  errorMessagePath = input<any>();
  resetFormOnSubmit = input<any>();
  successUrl = input<any>();
  validate = input<any>();
  attributes = input<any>();
  builderBlock = input<any>();
  errorMessage = input<any>();
  sendingMessage = input<any>();
  successMessage = input<any>();

  formRef = viewChild<ElementRef>(\\"formRef\\");
  _root = viewChild<ElementRef>(\\"_root\\");

  formState = signal(\\"unsubmitted\\");
  responseData = signal(null);
  formErrorMessage = signal(\\"\\");

  get submissionState() {
    return (Builder.isEditing && this.previewState) || this.formState;
  }
  onSubmit(event) {
    const sendWithJs = this.sendWithJs || this.sendSubmissionsTo() === \\"email\\";

    if (this.sendSubmissionsTo() === \\"zapier\\") {
      event.preventDefault();
    } else if (sendWithJs) {
      if (!(this.action || this.sendSubmissionsTo() === \\"email\\")) {
        event.preventDefault();
        return;
      }

      event.preventDefault();
      const el = event.currentTarget;
      const headers = this.customHeaders || {};
      let body;
      const formData = new FormData(el); // TODO: maybe support null

      const formPairs = Array.from(
        event.currentTarget.querySelectorAll(\\"input,select,textarea\\")
      )
        .filter((el) => !!el.name)
        .map((el) => {
          let value;
          const key = el.name;

          if (el instanceof HTMLInputElement) {
            if (el.type === \\"radio\\") {
              if (el.checked) {
                value = el.name;
                return {
                  key,
                  value,
                };
              }
            } else if (el.type === \\"checkbox\\") {
              value = el.checked;
            } else if (el.type === \\"number\\" || el.type === \\"range\\") {
              const num = el.valueAsNumber;

              if (!isNaN(num)) {
                value = num;
              }
            } else if (el.type === \\"file\\") {
              // TODO: one vs multiple files
              value = el.files;
            } else {
              value = el.value;
            }
          } else {
            value = el.value;
          }

          return {
            key,
            value,
          };
        });
      let contentType = this.contentType;

      if (this.sendSubmissionsTo() === \\"email\\") {
        contentType = \\"multipart/form-data\\";
      }

      Array.from(formPairs).forEach(({ value }) => {
        if (
          value instanceof File ||
          (Array.isArray(value) && value[0] instanceof File) ||
          value instanceof FileList
        ) {
          contentType = \\"multipart/form-data\\";
        }
      }); // TODO: send as urlEncoded or multipart by default
      // because of ease of use and reliability in browser API
      // for encoding the form?

      if (contentType !== \\"application/json\\") {
        body = formData;
      } else {
        // Json
        const json = {};
        Array.from(formPairs).forEach(({ value, key }) => {
          set(json, key, value);
        });
        body = JSON.stringify(json);
      }

      if (contentType && contentType !== \\"multipart/form-data\\") {
        if (
          /* Zapier doesn't allow content-type header to be sent from browsers */
          !(sendWithJs && this.action?.includes(\\"zapier.com\\"))
        ) {
          headers[\\"content-type\\"] = contentType;
        }
      }

      const presubmitEvent = new CustomEvent(\\"presubmit\\", {
        detail: {
          body,
        },
      });

      if (this.formRef()?.nativeElement) {
        this.formRef()?.nativeElement.dispatchEvent(presubmitEvent);

        if (presubmitEvent.defaultPrevented) {
          return;
        }
      }

      this.formState.set(\\"sending\\");
      const formUrl = \`\${
        builder.env === \\"dev\\" ? \\"http://localhost:5000\\" : \\"https://builder.io\\"
      }/api/v1/form-submit?apiKey=\${builder.apiKey}&to=\${btoa(
        this.sendSubmissionsToEmail || \\"\\"
      )}&name=\${encodeURIComponent(this.name || \\"\\")}\`;
      fetch(
        this.sendSubmissionsTo() === \\"email\\" ? formUrl : this.action,
        /* TODO: throw error if no action URL */
        {
          body,
          headers,
          method: this.method || \\"post\\",
        }
      ).then(
        async (res) => {
          let body;
          const contentType = res.headers.get(\\"content-type\\");

          if (contentType && contentType.indexOf(\\"application/json\\") !== -1) {
            body = await res.json();
          } else {
            body = await res.text();
          }

          if (!res.ok && this.errorMessagePath) {
            /* TODO: allow supplying an error formatter function */
            let message = get(body, this.errorMessagePath());

            if (message) {
              if (typeof message !== \\"string\\") {
                /* TODO: ideally convert json to yaml so it woul dbe like
            error: - email has been taken */
                message = JSON.stringify(message);
              }

              this.formErrorMessage.set(message);
            }
          }

          this.responseData.set(body);
          this.formState.set(res.ok ? \\"success\\" : \\"error\\");

          if (res.ok) {
            const submitSuccessEvent = new CustomEvent(\\"submit:success\\", {
              detail: {
                res,
                body,
              },
            });

            if (this.formRef()?.nativeElement) {
              this.formRef()?.nativeElement.dispatchEvent(submitSuccessEvent);

              if (submitSuccessEvent.defaultPrevented) {
                return;
              }
              /* TODO: option to turn this on/off? */

              if (this.resetFormOnSubmit() !== false) {
                this.formRef()?.nativeElement.reset();
              }
            }
            /* TODO: client side route event first that can be preventDefaulted */

            if (this.successUrl) {
              if (this.formRef()?.nativeElement) {
                const event = new CustomEvent(\\"route\\", {
                  detail: {
                    url: this.successUrl,
                  },
                });
                this.formRef()?.nativeElement.dispatchEvent(event);

                if (!event.defaultPrevented) {
                  location.href = this.successUrl;
                }
              } else {
                location.href = this.successUrl;
              }
            }
          }
        },
        (err) => {
          const submitErrorEvent = new CustomEvent(\\"submit:error\\", {
            detail: {
              error: err,
            },
          });

          if (this.formRef()?.nativeElement) {
            this.formRef()?.nativeElement.dispatchEvent(submitErrorEvent);

            if (submitErrorEvent.defaultPrevented) {
              return;
            }
          }

          this.responseData.set(err);
          this.formState.set(\\"error\\");
        }
      );
    }
  }
  trackByBlock0(index: number, block: any) {
    return block.id;
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"form-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > Image 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"image\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      <picture #pictureRef>
        @if(!useLazyLoading() || load()){
        <img
          [attr.alt]=\\"altText()\\"
          [attr.aria-role]=\\"altText() ? 'presentation' : undefined\\"
          [class]=\\"'builder-image' + (_class() ? ' ' + _class() : '') + ' img'\\"
          [attr.src]=\\"image()\\"
          (load)=\\"setLoaded()\\"
          [attr.srcset]=\\"srcset()\\"
          [attr.sizes]=\\"sizes()\\"
        />
        }
        <source [attr.srcset]=\\"srcset()\\" />
      </picture>
      <ng-content></ng-content>
    </div>
  \`,
  styles: \`:host { display: contents; }
        .img {
          opacity: 1;
          transition: opacity 0.2s ease-in-out;
          object-fit: cover;
          object-position: center;
        }
\`,
})
export class Image implements AfterViewInit {
  lazy = input<any>();
  altText = input<any>();
  _class = input<any>();
  image = input<any>();
  srcset = input<any>();
  sizes = input<any>();

  pictureRef = viewChild<ElementRef>(\\"pictureRef\\");
  _root = viewChild<ElementRef>(\\"_root\\");

  scrollListener = signal(null);
  imageLoaded = signal(false);
  load = signal(false);

  setLoaded() {
    this.imageLoaded.set(true);
  }
  useLazyLoading() {
    // TODO: Add more checks here, like testing for real web browsers
    return !!this.lazy && this.isBrowser();
  }
  isBrowser() {
    return (
      typeof window !== \\"undefined\\" && window.navigator.product != \\"ReactNative\\"
    );
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    if (this.useLazyLoading()) {
      // throttled scroll capture listener
      const listener = () => {
        if (this.pictureRef()?.nativeElement) {
          const rect = this.pictureRef()?.nativeElement.getBoundingClientRect();
          const buffer = window.innerHeight / 2;

          if (rect.top < window.innerHeight + buffer) {
            this.load.set(true);
            this.scrollListener.set(null);
            window.removeEventListener(\\"scroll\\", listener);
          }
        }
      };

      this.scrollListener.set(listener);
      window.addEventListener(\\"scroll\\", listener, {
        capture: true,
        passive: true,
      });
      listener();
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"image\\");
  }

  ngOnDestroy() {
    if (this.scrollListener) {
      window.removeEventListener(\\"scroll\\", this.scrollListener());
    }
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > Image State 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"img-state-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      @for (item of images();track itemIndex;let itemIndex = $index) {
      <ng-container>
        <img class=\\"custom-class\\" [attr.src]=\\"item\\" />
      </ng-container>
      }
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class ImgStateComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  canShow = signal(true);
  images = signal([\\"http://example.com/qwik.png\\"]);

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"img-state-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > Img 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Builder } from \\"@builder.io/sdk\\";

@Component({
  selector: \\"img-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <img
      [ngStyle]=\\"{
          objectFit: backgroundSize() || 'cover',
          objectPosition: backgroundPosition() || 'center'
        }\\"
      [attr.alt]=\\"altText()\\"
      [attr.src]=\\"imgSrc()\\"
      #_root
    />
  \`,
  styles: \`:host { display: contents; }\`,
})
export class ImgComponent implements AfterViewInit {
  backgroundSize = input<any>();
  backgroundPosition = input<any>();
  attributes = input<any>();
  imgSrc = input<any>();
  altText = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"img-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > Input 1`] = `
"--- MITOSIS ERROR ---
    Component input has an event change that uses 'event.target.xxx'. 
        This will cause an error in Angular.
        Please create a new function with the EventTarget and use e.g '(event.target as HTMLInputElement).value'"
`;

exports[`Angular signals > jsx > Javascript Test > InputParent 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import FormInputComponent from \\"./input.raw\\";

@Component({
  selector: \\"stepper\\",
  standalone: true,
  imports: [CommonModule, FormInputComponent],
  template: \`
    <form-input-component
      name=\\"kingzez\\"
      type=\\"text\\"
      (change)=\\"handleChange($event)\\"
      #_root
    ></form-input-component>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class Stepper implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  handleChange(value) {
    console.log(value);
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"stepper\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > NestedStore 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"nested-store\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div [attr.id]=\\"_id()\\" #_root>
      Test

      <p [attr.id]=\\"_messageId()\\">Message</p>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class NestedStore implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  _id = signal(\\"abc\\");
  _messageId = signal(this._id() + \\"-message\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"nested-store\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > RawText 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";
import { DomSanitizer } from \\"@angular/platform-browser\\";

@Component({
  selector: \\"raw-text\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <span
      [class]=\\"attributes()?.class || attributes()?.className\\"
      [innerHTML]=\\"sanitizer.bypassSecurityTrustHtml(text() || '')\\"
      #_root
    ></span>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class RawText implements AfterViewInit {
  attributes = input<any>();
  text = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor(protected sanitizer: DomSanitizer) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"raw-text\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > Section 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"section-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <section
      [ngStyle]=\\"maxWidth() && typeof maxWidth() === 'number' ? {
          maxWidth: maxWidth()
        } : undefined\\"
      #_root
    >
      <ng-content></ng-content>
    </section>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class SectionComponent implements AfterViewInit {
  attributes = input<any>();
  maxWidth = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"section-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > Section 2`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"section-state-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    @if(max()){ @for (item of items();track i;let i = $index) {
    <section
      [ngStyle]=\\"{
          maxWidth: item + max()
        }\\"
    >
      <ng-content></ng-content>
    </section>
    } }
  \`,
  styles: \`:host { display: contents; }\`,
})
export class SectionStateComponent implements AfterViewInit {
  attributes = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  max = signal(42);
  items = signal([42]);

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"section-state-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > Select 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Builder } from \\"@builder.io/sdk\\";

@Component({
  selector: \\"select-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <select
      [attr.value]=\\"value()\\"
      [attr.defaultValue]=\\"defaultValue()\\"
      [attr.name]=\\"name()\\"
      #_root
    >
      @for (option of options();track index;let index = $index) {
      <option [attr.value]=\\"option.value\\" [attr.data-index]=\\"index\\">
        {{option.name || option.value}}
      </option>
      }
    </select>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class SelectComponent implements AfterViewInit {
  attributes = input<any>();
  value = input<any>();
  defaultValue = input<any>();
  name = input<any>();
  options = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"select-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > SlotDefault 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"slot-code\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      <ng-content>
        <div class=\\"default-slot\\">Default content</div>
      </ng-content>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class SlotCode implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"slot-code\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > SlotHtml 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import ContentSlotCode from \\"./content-slot-jsx.raw\\";

@Component({
  selector: \\"slot-code\\",
  standalone: true,
  imports: [CommonModule, ContentSlotCode],
  template: \`
    <div #_root>
      <content-slot-code><ng-content></ng-content></content-slot-code>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class SlotCode implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"slot-code\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > SlotJsx 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import ContentSlotCode from \\"./content-slot-jsx.raw\\";

@Component({
  selector: \\"slot-code\\",
  standalone: true,
  imports: [CommonModule, ContentSlotCode],
  template: \`
    <div #_root>
      <content-slot-code [slotTesting]=\\"<div>Hello</div>\\"></content-slot-code>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class SlotCode implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"slot-code\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > SlotNamed 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"slot-code\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      <ng-content select=\\"[my-awesome-slot]\\"></ng-content>
      <ng-content select=\\"[top]\\"></ng-content>
      <ng-content select=\\"[left]\\">Default left</ng-content>
      <ng-content>Default Child</ng-content>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class SlotCode implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"slot-code\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > Stamped.io 1`] = `
"unknown: Unexpected token, expected \\",\\" (2:4)

[0m [90m 1 |[39m [36mlet[39m _ [33m=[39m {[0m
[0m[31m[1m>[22m[39m[90m 2 |[39m   ev[33m.[39mpreventDefault()[33m;[39m[0m
[0m [90m   |[39m     [31m[1m^[22m[39m[0m
[0m [90m 3 |[39m   state[33m.[39mshowReviewPrompt [33m=[39m [36mfalse[39m[33m;[39m[0m
[0m [90m 4 |[39m }[0m"
`;

exports[`Angular signals > jsx > Javascript Test > StoreComment 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"string-literal-store\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <ng-container>{{foo()}}</ng-container>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class StringLiteralStore implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  foo = signal(true);

  bar() {}

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"string-literal-store\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > StoreShadowVars 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <ng-container>{{foo(errors)}}</ng-container>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  errors = signal({});

  foo(errors) {
    return errors;
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > StoreWithState 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <ng-container>{{bar()}}</ng-container>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  foo = signal(false);

  bar() {
    return this.foo;
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > Submit 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"submit-button\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <button type=\\"submit\\" #_root>{{text()}}</button>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class SubmitButton implements AfterViewInit {
  attributes = input<any>();
  text = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"submit-button\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > Text 1`] = `
"unknown: Missing semicolon. (1:70)

[0m[31m[1m>[22m[39m[90m 1 |[39m [36mlet[39m _ [33m=[39m props[33m.[39mtext() [33m||[39m props[33m.[39mcontent() [33m||[39m state[33m.[39mname() [33m||[39m [32m'<p class='[39mtext[33m-[39mlg[32m'>my name</p>'[39m[0m
[0m [90m   |[39m                                                                       [31m[1m^[22m[39m[0m"
`;

exports[`Angular signals > jsx > Javascript Test > Textarea 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"textarea\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <textarea
      [attr.placeholder]=\\"placeholder()\\"
      [attr.name]=\\"name()\\"
      [attr.value]=\\"value()\\"
      [attr.defaultValue]=\\"defaultValue()\\"
      #_root
    ></textarea>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class Textarea implements AfterViewInit {
  attributes = input<any>();
  placeholder = input<any>();
  name = input<any>();
  value = input<any>();
  defaultValue = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"textarea\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > UseValueAndFnFromStore 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  output,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"use-value-and-fn-from-store\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>Test</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class UseValueAndFnFromStore implements AfterViewInit {
  change = output();

  _root = viewChild<ElementRef>(\\"_root\\");

  _id = signal(\\"abc\\");
  _active = signal(false);

  _do(id) {
    this._active.set(!!id);

    if (this.change) {
      this.change.emit(this._active());
    }
  }

  constructor() {
    effect(() => {
      // --- Mitosis: Workaround to make sure the effect() is triggered ---

      // ---

      if (this._do) {
        this._do(this._id());
      }
    });
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"use-value-and-fn-from-store\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > Video 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"video\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <video
      preload=\\"none\\"
      [ngStyle]=\\"{
          width: '100%',
          height: '100%',
          ...attributes()?.style,
          objectFit: fit(),
          objectPosition: position(),
          // Hack to get object fit to work as expected and
          // not have the video overflow
          borderRadius: 1
        }\\"
      [attr.poster]=\\"posterImage()\\"
      [attr.autoplay]=\\"autoPlay()\\"
      [attr.muted]=\\"muted()\\"
      [attr.controls]=\\"controls()\\"
      [attr.loop]=\\"loop()\\"
      #_root
    ></video>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class Video implements AfterViewInit {
  attributes = input<any>();
  fit = input<any>();
  position = input<any>();
  video = input<any>();
  posterImage = input<any>();
  autoPlay = input<any>();
  muted = input<any>();
  controls = input<any>();
  loop = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"video\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > allSpread 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      Hello! I can run natively in React, Vue, Svelte, Qwik, and many more
      frameworks!
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  attributes = input<any>();
  accessHere = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  attrsUsingUseState = signal({
    hello: \\"world\\",
  });
  properties = signal({
    style: \\"color: blue\\",
    onClick: () => console.log(\\"pressed\\"),
  });
  specifics = signal({
    someSpecificState: \\"specific\\",
  });

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > arrowFunctionInUseStore 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>Hello {{name()}}</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"steve\\");

  setName(value) {
    this.name.set(value);
  }
  updateNameWithArrowFn(value) {
    this.name.set(value);
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > basicForFragment 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"basic-for-fragment\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      @for (option of ['a', 'b', 'c'];track trackByOption0;let i = $index) {
      <ng-container>
        <div>{{option}}</div>
      </ng-container>
      } @for (option of ['a', 'b', 'c'];track trackByOption1;let i = $index) {
      <ng-container>
        <div>{{option}}</div>
      </ng-container>
      }

      <select>
        @for (option of ['d', 'e', 'f'];track trackByOption2;let i = $index) {
        <option [attr.value]=\\"option\\">{{option}}</option>
        }
      </select>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class BasicForFragment implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  id = signal(\\"xyz\\");

  trackByOption0(_: number, option: any) {
    return \`key-\${option}\`;
  }
  trackByOption1(_: number, option: any) {
    return \`\${id()}-\${option}\`;
  }
  trackByOption2(_: number, option: any) {
    return \`\${id()}-\${option}\`;
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"basic-for-fragment\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > basicForNoTagReference 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-for-no-tag-ref-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <this.TagNameGetter #_root>
      Hello
      <this.tag>{{name()}}</this.tag>

      @for (action of actions();track i;let i = $index) {
      <this.TagName>
        <action.icon></action.icon>
        <span>{{action.text}}</span>
      </this.TagName>
      }
    </this.TagNameGetter>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicForNoTagRefComponent implements AfterViewInit {
  actions = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"VincentW\\");
  TagName = signal(\\"div\\");
  tag = signal(\\"span\\");

  get TagNameGetter() {
    return \\"span\\";
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-for-no-tag-ref-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > basicForwardRef 1`] = `
"--- MITOSIS ERROR ---
    Component input has an event change that uses 'event.target.xxx'. 
        This will cause an error in Angular.
        Please create a new function with the EventTarget and use e.g '(event.target as HTMLInputElement).value'"
`;

exports[`Angular signals > jsx > Javascript Test > basicForwardRefMetadata 1`] = `
"--- MITOSIS ERROR ---
    Component input has an event change that uses 'event.target.xxx'. 
        This will cause an error in Angular.
        Please create a new function with the EventTarget and use e.g '(event.target as HTMLInputElement).value'"
`;

exports[`Angular signals > jsx > Javascript Test > basicOnUpdateReturn 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-on-update-return-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>Hello! {{name()}}</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicOnUpdateReturnComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"PatrickJS\\");

  constructor() {
    effect(() => {
      // --- Mitosis: Workaround to make sure the effect() is triggered ---

      // ---

      const controller = new AbortController();
      const signal = controller.signal;
      fetch(\\"https://patrickjs.com/api/resource.json\\", {
        signal,
      })
        .then((response) => response.json())
        .then((data) => {
          this.name.set(data.name);
        });
      return () => {
        if (!signal.aborted) {
          controller.abort();
        }
      };
    });
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-on-update-return-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > basicRefAttributePassing 1`] = `
"/**
          useMetadata:
          {\\"attributePassing\\":{\\"enabled\\":true}}
          */

import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"basic-ref-attribute-passing-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <button #buttonRef #_root>Attribute Passing</button>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class BasicRefAttributePassingComponent implements AfterViewInit {
  buttonRef = viewChild<ElementRef>(\\"buttonRef\\");
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(
      element,
      \\"basic-ref-attribute-passing-component\\"
    );
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > basicRefAttributePassingCustomRef 1`] = `
"/**
          useMetadata:
          {\\"attributePassing\\":{\\"enabled\\":true,\\"customRef\\":\\"buttonRef\\"}}
          */

import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"basic-ref-attribute-passing-custom-ref-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div><button #buttonRef>Attribute Passing</button></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class BasicRefAttributePassingCustomRefComponent
  implements AfterViewInit
{
  buttonRef = viewChild<ElementRef>(\\"buttonRef\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this.buttonRef()?.nativeElement;
    this.enableAttributePassing(
      element,
      \\"basic-ref-attribute-passing-custom-ref-component\\"
    );
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > changeDetection 1`] = `
"/**
          useMetadata:
          {\\"angular\\":{\\"changeDetection\\":\\"OnPush\\"}}
          */

import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  ChangeDetectionStrategy,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>{{count()}}</div>
  \`,
  changeDetection: \\"ChangeDetectionStrategy.OnPush\\",
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  count = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > class + ClassName + css 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import MyComp from \\"./my-component.js\\";

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule, MyComp],
  template: \`
    <div #_root>
      <my-comp class=\\"test\\" className=\\"test2\\">
        Hello! I can run in React, Vue, Solid, or Liquid!
      </my-comp>
      <div class=\\"test2 test div\\">
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>
    </div>
  \`,
  styles: \`:host { display: contents; }
        .div {
          padding: 10px;
        }
\`,
})
export class MyBasicComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > class + css 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div class=\\"test div\\" #_root>
      Hello! I can run in React, Vue, Solid, or Liquid!
    </div>
  \`,
  styles: \`:host { display: contents; }
        .div {
          padding: 10px;
        }
\`,
})
export class MyBasicComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > className + css 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div class=\\"test div\\" #_root>
      Hello! I can run in React, Vue, Solid, or Liquid!
    </div>
  \`,
  styles: \`:host { display: contents; }
        .div {
          padding: 10px;
        }
\`,
})
export class MyBasicComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > className 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"class-name-code\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      <div class=\\"no binding\\">Without Binding</div>
      <div [class]=\\"bindings()\\">With binding</div>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class ClassNameCode implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  bindings = signal(\\"a binding\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"class-name-code\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > classState 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div [class]=\\"classState() + ' div'\\" [ngStyle]=\\"styleState()\\" #_root>
      Hello! I can run in React, Vue, Solid, or Liquid!
    </div>
  \`,
  styles: \`:host { display: contents; }
        .div {
          padding: 10px;
        }
\`,
})
export class MyBasicComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  classState = signal(\\"testClassName\\");
  styleState = signal({
    color: \\"red\\",
  });

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > classnameProps 1`] = `
"/**
          useMetadata:
          {\\"stencil\\":{\\"propOptions\\":{\\"className\\":{\\"attribute\\":\\"classname\\",\\"mutable\\":false,\\"reflect\\":false}}}}
          */

import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div [class]=\\"className()\\" #_root>
      <ng-content></ng-content>
      {{type()}} Hello! I can run in React, Vue, Solid, or Liquid!
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicComponent implements AfterViewInit {
  className = input<any>();
  type = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > complexMeta 1`] = `
"/**
          useMetadata:
          {\\"x\\":\\"y\\",\\"asdf\\":{\\"stringValue\\":\\"d\\",\\"booleanValue\\":true,\\"numberValue\\":1,\\"innerObject\\":{\\"stringValue\\":\\"inner\\",\\"numberValue\\":2,\\"booleanValue\\":false},\\"spreadStringValue\\":\\"f\\"}}
          */

import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"complex-meta-raw\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class ComplexMetaRaw implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"complex-meta-raw\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > componentWithContext 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import Context1 from \\"@dummy/1\\";
import Context2 from \\"@dummy/2\\";

@Component({
  selector: \\"component-with-context\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <ng-container>
      <ng-container>{{foo.value}}</ng-container>
    </ng-container>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class ComponentWithContext implements AfterViewInit {
  content = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor(public foo: Context1) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"component-with-context\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > componentWithContextMultiRoot 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import Context1 from \\"@dummy/1\\";
import Context2 from \\"@dummy/2\\";

@Component({
  selector: \\"component-with-context\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <ng-container>
      <ng-container>{{foo.value}}</ng-container>
      <div>other</div>
    </ng-container>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class ComponentWithContext implements AfterViewInit {
  content = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor(public foo: Context1) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"component-with-context\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > contentState 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import BuilderContext from \\"@dummy/context.js\\";

@Component({
  selector: \\"render-content\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>setting context</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class RenderContent implements AfterViewInit {
  content = input<any>();
  customComponents = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"render-content\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > customSelector 1`] = `
"/**
          useMetadata:
          {\\"angular\\":{\\"selector\\":\\"not-my-component\\"}}
          */

import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <span #_root>My selector shouldn't be my-component!</span>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > defaultProps 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  output,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

const defaultProps = {
  text: \\"default text\\",
  link: \\"https://builder.io/\\",
  openLinkInNewTab: false,
  onClick: () => {
    console.log(\\"hi\\");
  },
};

@Component({
  selector: \\"button\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      @if(link()){
      <a
        [attr.href]=\\"link()\\"
        [attr.target]=\\"openLinkInNewTab() ? '_blank' : undefined\\"
      >
        {{text()}}
      </a>
      } @if(!link()){
      <button type=\\"button\\" (click)=\\"click.emit()\\">{{buttonText()}}</button>
      }
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class Button implements AfterViewInit {
  link = input<any>(defaultProps[\\"link\\"]);
  attributes = input<any>();
  openLinkInNewTab = input<any>(defaultProps[\\"openLinkInNewTab\\"]);
  text = input<any>(defaultProps[\\"text\\"]);
  buttonText = input<any>();
  click = output();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"button\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > defaultPropsOutsideComponent 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  output,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

const defaultProps = {
  text: \\"default text\\",
  link: \\"https://builder.io/\\",
  openLinkInNewTab: false,
  onClick: () => {},
};

@Component({
  selector: \\"button\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      @if(link()){
      <a
        [attr.href]=\\"link()\\"
        [attr.target]=\\"openLinkInNewTab() ? '_blank' : undefined\\"
      >
        {{text()}}
      </a>
      } @if(!link()){
      <button type=\\"button\\" (click)=\\"click.emit($event)\\">{{text()}}</button>
      }
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class Button implements AfterViewInit {
  link = input<any>(defaultProps[\\"link\\"]);
  attributes = input<any>();
  openLinkInNewTab = input<any>(defaultProps[\\"openLinkInNewTab\\"]);
  text = input<any>(defaultProps[\\"text\\"]);
  click = output();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"button\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > defaultValsWithTypes 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

const DEFAULT_VALUES = {
  name: \\"Sami\\",
};

@Component({
  selector: \\"component-with-types\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>Hello {{name() || DEFAULT_VALUES.name}}</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class ComponentWithTypes implements AfterViewInit {
  name = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"component-with-types\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > dynamicComponent 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <this.obj.Component hello=\\"world\\" (click)=\\"onClick()\\" #_root>
      hello

      <ng-content></ng-content>
    </this.obj.Component>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  attributes = input<any>();
  something = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  obj = signal({
    name: \\"foo\\",
    Component: FooComponent,
  });

  onClick() {
    console.log(\\"hello\\");
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > dynamicComponentWithEventArg 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <this.Component hello=\\"world\\" (click)=\\"onClick($event)\\" #_root>
      hello
    </this.Component>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  attributes = input<any>();
  something = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  Component = signal(HelloComponent);

  onClick(event) {
    console.log(\\"hello\\", event);
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > eventInputAndChange 1`] = `
"--- MITOSIS ERROR ---
    Component input has an event input that uses 'event.target.xxx'. 
        This will cause an error in Angular.
        Please create a new function with the EventTarget and use e.g '(event.target as HTMLInputElement).value'"
`;

exports[`Angular signals > jsx > Javascript Test > eventProps 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  output,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"event-props-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <button (click)=\\"handleClick()\\" #_root>Test</button>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class EventPropsComponent implements AfterViewInit {
  getVoid = output();
  enter = output();

  _root = viewChild<ElementRef>(\\"_root\\");

  handleClick() {
    if (this.getVoid) {
      this.getVoid.emit();
    }

    if (this.enter) {
      console.log(this.enter.emit());
    }
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"event-props-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > expressionState 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>{{refToUse()}}</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  componentRef = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  refToUse = signal(
    !(this.componentRef() instanceof Function) ? this.componentRef : null
  );

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > figmaMeta 1`] = `
"/**
          useMetadata:
          {\\"figma\\":{\\"name\\":\\"def-button-beta-outlined\\",\\"url\\":\\"https://www.figma.com/xxx\\",\\"props\\":{\\"iconSmall\\":{\\"type\\":\\"instance\\",\\"key\\":\\"📍 Icon Small\\"},\\"iconMedium\\":{\\"type\\":\\"instance\\",\\"key\\":\\"📍 Icon Medium\\"},\\"label\\":{\\"type\\":\\"string\\",\\"key\\":\\"✏️ Label\\"},\\"icon\\":{\\"type\\":\\"boolean\\",\\"key\\":\\"👁️ Icon\\",\\"value\\":{\\"false\\":false,\\"true\\":\\"placeholder\\"}},\\"interactiveState\\":{\\"type\\":\\"enum\\",\\"key\\":\\"Interactive State\\",\\"value\\":{\\"(Def) Enabled\\":false,\\"Hovered\\":false,\\"Pressed\\":false,\\"Focused\\":false,\\"Disabled\\":\\"true\\"}},\\"size\\":{\\"type\\":\\"enum\\",\\"key\\":\\"Size\\",\\"value\\":{\\"(Def) Medium\\":false,\\"Small\\":\\"small\\"}},\\"width\\":{\\"type\\":\\"enum\\",\\"key\\":\\"Width\\",\\"value\\":{\\"(Def) Auto Width\\":false,\\"Full Width\\":\\"full\\"}}}}}
          */

import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"figma-button\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <button
      [attr.data-icon]=\\"icon()\\"
      [attr.data-disabled]=\\"interactiveState()\\"
      [attr.data-width]=\\"width()\\"
      [attr.data-size]=\\"size()\\"
      #_root
    >
      {{label()}}
    </button>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class FigmaButton implements AfterViewInit {
  icon = input<any>();
  interactiveState = input<any>();
  width = input<any>();
  size = input<any>();
  label = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"figma-button\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > functionProps 1`] = `
"unknown: --- MITOSIS ERROR ---
    Component MyBasicComponent has a BlockStatement inside JSX'. 
        This will cause an error in Angular.
        Please create and call a new function instead with this code:
        x => {}"
`;

exports[`Angular signals > jsx > Javascript Test > getterState 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"button\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      <p>{{foo2()}}</p>
      <p>{{bar()}}</p>
      <p>{{baz(1)}}</p>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class Button implements AfterViewInit {
  foo = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  get foo2() {
    return this.foo() + \\"foo\\";
  }
  get bar() {
    return \\"bar\\";
  }
  baz(i) {
    return i + this.foo2.length;
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"button\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > import types 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import RenderBlock from \\"./builder-render-block.raw\\";

@Component({
  selector: \\"render-content\\",
  standalone: true,
  imports: [CommonModule, RenderBlock],
  template: \`
    <render-block #_root></render-block>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class RenderContent implements AfterViewInit {
  renderContentProps = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  getRenderContentProps(block, index) {
    return {
      block: block,
      index: index,
    };
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"render-content\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > importRaw 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-import-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>Testing which imports get excluded!</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyImportComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-import-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > layerName 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-layer-name-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <section #_root>
      <div $name=\\"🌟layer-name\\" class=\\"layer-name\\">
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>
    </section>
  \`,
  styles: \`:host { display: contents; }
        .layer-name {
          padding: 10px;
        }
\`,
})
export class MyLayerNameComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-layer-name-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > multipleOnUpdate 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"multiple-on-update\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MultipleOnUpdate implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {
    effect(() => {
      // --- Mitosis: Workaround to make sure the effect() is triggered ---

      // ---

      console.log(\\"Runs on every update/rerender\\");
    });
    effect(() => {
      // --- Mitosis: Workaround to make sure the effect() is triggered ---

      // ---

      console.log(\\"Runs on every update/rerender as well\\");
    });
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"multiple-on-update\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > multipleOnUpdateWithDeps 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"multiple-on-update-with-deps\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MultipleOnUpdateWithDeps implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  a = signal(\\"a\\");
  b = signal(\\"b\\");
  c = signal(\\"c\\");
  d = signal(\\"d\\");

  constructor() {
    effect(() => {
      // --- Mitosis: Workaround to make sure the effect() is triggered ---

      // ---

      console.log(\\"Runs when a or b changes\\", this.a(), this.b());

      if (this.a() === \\"a\\") {
        this.a.set(\\"b\\");
      }
    });
    effect(() => {
      // --- Mitosis: Workaround to make sure the effect() is triggered ---

      // ---

      console.log(\\"Runs when c or d changes\\", this.c(), this.d());

      if (this.a() === \\"a\\") {
        this.a.set(\\"b\\");
      }
    });
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"multiple-on-update-with-deps\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > multipleSpreads 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <input #_root />
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  attrs = signal({
    hello: \\"world\\",
  });

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > nativeAttributes 1`] = `
"/**
          useMetadata:
          {\\"angular\\":{\\"nativeAttributes\\":[\\"disabled\\"]}}
          */

import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      <input [disabled]=\\"disabled()\\" />

      Hello! If someone passes \\\\\`[disabled]=\\"false\\"\\\\\` to me, disabled shouldn't
      be visible in the DOM.
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  disabled = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > nestedShow 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"nested-show\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    @if(conditionA()){ @if(!conditionB()){
    <div>if condition A and condition B</div>
    }@else{
    <div>else-condition-B</div>
    } }@else{
    <div>else-condition-A</div>
    }
  \`,
  styles: \`:host { display: contents; }\`,
})
export class NestedShow implements AfterViewInit {
  conditionA = input<any>();
  conditionB = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"nested-show\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > nestedStyles 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"nested-styles\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div class=\\"div\\" #_root>Hello world</div>
  \`,
  styles: \`:host { display: contents; }
        .div {
          display: flex;
          --bar: red;
          color: var(--bar);
        }
        @media (max-width: env(--mobile)) {
          .div {
            display: block;
          }
        }
        .div:hover {
          display: flex;
        }
        .div:active {
          display: inline;
        }
        .div .nested-selector {
          display: grid;
        }
        .div .nested-selector:hover {
          display: block;
        }
        .div.nested-selector:active {
          display: inline-block;
        }
\`,
})
export class NestedStyles implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"nested-styles\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > normalizeLayerNames 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-normalized-layer-names-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <section #_root>
      <div $name=\\"🌟layer-name\\">Emoji</div>
      <div $name=\\"---\\">Dashes</div>
      <div $name=\\"CamelCase\\">CamelCase</div>
      <div $name=\\"123my@Class-Name!\\">Special chars</div>
      <div $name=\\"--my--@custom--name--\\">Special chars with dashes</div>
      <div $name=\\"0\\" class=\\"css-0\\">Single Number</div>
      <div $name=\\"123\\" class=\\"css-123\\">Multiple Numbers</div>
      <div $name=\\"name123\\" class=\\"name-123\\">Chars with numbers at end</div>
      <div $name=\\"456name\\" class=\\"name\\">Chars with numbers at start</div>
      <div $name=\\"name-789\\" class=\\"name-789\\">Numnbers separated by dash</div>
      <div $name=\\"🚀\\">Emoji</div>
      <div data-name=\\"1\\" class=\\"div\\">Number</div>
    </section>
  \`,
  styles: \`:host { display: contents; }
        .css-0 {
          margin: 10px;
        }
        .css-123 {
          padding: 10px;
        }
        .name-123 {
          border: 1px solid;
        }
        .name {
          color: red;
        }
        .name-789 {
          background: blue;
        }
        .div {
          background: blue;
        }
\`,
})
export class MyNormalizedLayerNamesComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-normalized-layer-names-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > onEvent 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"embed\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div class=\\"builder-embed\\" #elem #_root><div>Test</div></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class Embed implements AfterViewInit {
  elem = viewChild<ElementRef>(\\"elem\\");
  _root = viewChild<ElementRef>(\\"_root\\");

  foo(event) {
    console.log(\\"test2\\");
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.elem()?.nativeElement.dispatchEvent(
      new CustomEvent(\\"initEditingBldr\\")
    );
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"embed\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > onInit & onMount 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"on-init\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class OnInit implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    console.log(\\"onInit\\");
    console.log(\\"onMount\\");
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"on-init\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > onInit 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

export const defaultValues = {
  name: \\"PatrickJS\\",
};

@Component({
  selector: \\"on-init\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>Default name defined by parent {{name()}}</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class OnInit implements AfterViewInit {
  name = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.name.set(defaultValues.name || this.name);
    console.log(\\"set defaults with props\\");
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"on-init\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > onInitPlain 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"on-init-plain\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class OnInitPlain implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    console.log(\\"onInit\\");
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"on-init-plain\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > onMount 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"comp\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class Comp implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    console.log(\\"Runs on mount\\");
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"comp\\");
  }

  ngOnDestroy() {
    console.log(\\"Runs on unMount\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > onMountMultiple 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"comp\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class Comp implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    const onMountHook_0 = () => {
      console.log(\\"Runs on mount\\");
    };
    onMountHook_0();
    const onMountHook_1 = () => {
      console.log(\\"Another one runs on Mount\\");
    };
    onMountHook_1();
    const onMountHook_2 = () => {
      console.log(\\"SSR runs on Mount\\");
    };
    onMountHook_2();
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"comp\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > onUpdate 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"on-update\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class OnUpdate implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {
    effect(() => {
      // --- Mitosis: Workaround to make sure the effect() is triggered ---

      // ---

      console.log(\\"Runs on every update/rerender\\");
    });
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"on-update\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > onUpdateWithDeps 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"on-update-with-deps\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class OnUpdateWithDeps implements AfterViewInit {
  size = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  a = signal(\\"a\\");
  b = signal(\\"b\\");

  constructor() {
    effect(() => {
      // --- Mitosis: Workaround to make sure the effect() is triggered ---

      // ---

      console.log(
        \\"Runs when a, b or size changes\\",
        this.a(),
        this.b(),
        this.size()
      );
    });
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"on-update-with-deps\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > outputEventBinding 1`] = `
"--- MITOSIS ERROR ---
    Component input has an event change that uses 'event.target.xxx'. 
        This will cause an error in Angular.
        Please create a new function with the EventTarget and use e.g '(event.target as HTMLInputElement).value'"
`;

exports[`Angular signals > jsx > Javascript Test > preserveExportOrLocalStatement 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

const b = 3;
const foo = () => {};
export const a = 3;
export const bar = () => {};
export function run(value) {}

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > preserveTyping 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      Hello! I can run in React, Vue, Solid, or Liquid! {{name()}}
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicComponent implements AfterViewInit {
  name = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > propsDestructure 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      <ng-content></ng-content>
      {{type()}} Hello! I can run in React, Vue, Solid, or Liquid!
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicComponent implements AfterViewInit {
  type = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"Decadef20\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > propsInterface 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      Hello! I can run in React, Vue, Solid, or Liquid! {{name()}}
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicComponent implements AfterViewInit {
  name = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > propsType 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      Hello! I can run in React, Vue, Solid, or Liquid! {{name()}}
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicComponent implements AfterViewInit {
  name = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > referencingFunInsideHook 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"on-update\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class OnUpdate implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  foo(params) {}
  bar() {}
  zoo() {
    const params = {
      cb: this.bar,
    };
  }

  constructor() {
    effect(() => {
      // --- Mitosis: Workaround to make sure the effect() is triggered ---

      // ---

      this.foo({
        someOption: this.bar,
      });
    });
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"on-update\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > renderBlock 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { TARGET } from \\"../../constants/target.js\\";
import { evaluate } from \\"../../functions/evaluate.js\\";
import { extractTextStyles } from \\"../../functions/extract-text-styles.js\\";
import { getBlockActions } from \\"../../functions/get-block-actions.js\\";
import { getBlockComponentOptions } from \\"../../functions/get-block-component-options.js\\";
import { getBlockProperties } from \\"../../functions/get-block-properties.js\\";
import { getBlockTag } from \\"../../functions/get-block-tag.js\\";
import { getProcessedBlock } from \\"../../functions/get-processed-block.js\\";
import { getReactNativeBlockStyles } from \\"../../functions/get-react-native-block-styles.js\\";
import BlockStyles from \\"./block-styles.js\\";
import { isEmptyHtmlElement } from \\"./render-block.helpers.js\\";
import RenderComponentWithContext from \\"./render-component-with-context.js\\";
import RenderComponent from \\"./render-component.js\\";
import RenderRepeatedBlock from \\"./render-repeated-block.js\\";

@Component({
  selector: \\"render-block\\",
  standalone: true,
  imports: [CommonModule, RenderRepeatedBlock, RenderBlock, BlockStyles],
  template: \`
    @if(shouldWrap()){ @if(isEmptyHtmlElement(tag)){
    <this.tag></this.tag>
    } @if(!isEmptyHtmlElement(tag) && repeatItemData()){ @for (data of
    repeatItemData();track trackByData0;let index = $index) {
    <render-repeated-block
      [repeatContext]=\\"data.context\\"
      [block]=\\"data.block\\"
    ></render-repeated-block>
    } } @if(!isEmptyHtmlElement(tag) && !repeatItemData()){
    <this.tag>
      <this.renderComponentTag></this.renderComponentTag>

      @for (child of childrenWithoutParentComponent();track trackByChild1;let i
      = $index) {
      <render-block
        [block]=\\"child\\"
        [context]=\\"childrenContext()\\"
      ></render-block>
      } @for (child of childrenWithoutParentComponent();track trackByChild2;let
      i = $index) {
      <block-styles
        [block]=\\"child\\"
        [context]=\\"childrenContext()\\"
      ></block-styles>
      }
    </this.tag>
    } }@else{
    <this.renderComponentTag></this.renderComponentTag>
    }
  \`,
  styles: \`:host { display: contents; }\`,
})
export class RenderBlock implements AfterViewInit {
  block = input<any>();
  context = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  get component() {
    const componentName = getProcessedBlock({
      block: this.block,
      state: this.context.state,
      context: this.context.context,
      shouldEvaluateBindings: false,
    }).component?.name;

    if (!componentName) {
      return null;
    }

    const ref = this.context.registeredComponents[componentName];

    if (!ref) {
      // TODO: Public doc page with more info about this message
      console.warn(\`
          Could not find a registered component named \\"\${componentName}\\".
          If you registered it, is the file that registered it imported by the file that needs to render it?\`);
      return undefined;
    } else {
      return ref;
    }
  }
  get tag() {
    return getBlockTag(this.useBlock());
  }
  get useBlock() {
    return this.repeatItemData
      ? this.block
      : getProcessedBlock({
          block: this.block,
          state: this.context.state,
          context: this.context.context,
          shouldEvaluateBindings: true,
        });
  }
  get actions() {
    return getBlockActions({
      block: this.useBlock,
      state: this.context.state,
      context: this.context.context,
    });
  }
  get attributes() {
    const blockProperties = getBlockProperties(this.useBlock());
    return {
      ...blockProperties,
      ...(TARGET === \\"reactNative\\"
        ? {
            style: getReactNativeBlockStyles({
              block: this.useBlock,
              context: this.context,
              blockStyles: blockProperties.style,
            }),
          }
        : {}),
    };
  }
  get shouldWrap() {
    return !this.component?.noWrap;
  }
  get renderComponentProps() {
    return {
      blockChildren: this.useChildren,
      componentRef: this.component?.component,
      componentOptions: {
        ...getBlockComponentOptions(this.useBlock()),

        /**
         * These attributes are passed to the wrapper element when there is one. If \`noWrap\` is set to true, then
         * they are provided to the component itself directly.
         */
        ...(this.shouldWrap
          ? {}
          : {
              attributes: { ...this.attributes, ...this.actions },
            }),
        customBreakpoints: this.childrenContext?.content?.meta?.breakpoints,
      },
      context: this.childrenContext,
    };
  }
  get useChildren() {
    // TO-DO: When should \`canHaveChildren\` dictate rendering?
    // This is currently commented out because some Builder components (e.g. Box) do not have \`canHaveChildren: true\`,
    // but still receive and need to render children.
    // return state.componentInfo?.canHaveChildren ? state.useBlock.children : [];
    return this.useBlock.children ?? [];
  }
  get childrenWithoutParentComponent() {
    /**
     * When there is no \`componentRef\`, there might still be children that need to be rendered. In this case,
     * we render them outside of \`componentRef\`.
     * NOTE: We make sure not to render this if \`repeatItemData\` is non-null, because that means we are rendering an array of
     * blocks, and the children will be repeated within those blocks.
     */
    const shouldRenderChildrenOutsideRef =
      !this.component?.component && !this.repeatItemData;
    return shouldRenderChildrenOutsideRef ? this.useChildren : [];
  }
  get repeatItemData() {
    /**
     * we don't use \`state.useBlock\` here because the processing done within its logic includes evaluating the block's bindings,
     * which will not work if there is a repeat.
     */
    const { repeat, ...blockWithoutRepeat } = this.block;

    if (!repeat?.collection) {
      return undefined;
    }

    const itemsArray = evaluate({
      code: repeat.collection,
      state: this.context.state,
      context: this.context.context,
    });

    if (!Array.isArray(itemsArray)) {
      return undefined;
    }

    const collectionName = repeat.collection.split(\\".\\").pop();
    const itemNameToUse =
      repeat.itemName || (collectionName ? collectionName + \\"Item\\" : \\"item\\");
    const repeatArray = itemsArray.map((item, index) => ({
      context: {
        ...this.context,
        state: {
          ...this.context.state,
          $index: index,
          $item: item,
          [itemNameToUse]: item,
          [\`$\${itemNameToUse}Index\`]: index,
        },
      },
      block: blockWithoutRepeat,
    }));
    return repeatArray;
  }
  get inheritedTextStyles() {
    if (TARGET !== \\"reactNative\\") {
      return {};
    }

    const styles = getReactNativeBlockStyles({
      block: this.useBlock,
      context: this.context,
      blockStyles: this.attributes.style,
    });
    return extractTextStyles(styles);
  }
  get childrenContext() {
    return {
      apiKey: this.context.apiKey,
      state: this.context.state,
      content: this.context.content,
      context: this.context.context,
      registeredComponents: this.context.registeredComponents,
      inheritedStyles: this.inheritedTextStyles,
    };
  }
  get renderComponentTag() {
    if (TARGET === \\"reactNative\\") {
      return RenderComponentWithContext;
    } else if (TARGET === \\"vue3\\") {
      // vue3 expects a string for the component tag
      return \\"RenderComponent\\";
    } else {
      return RenderComponent;
    }
  }
  trackByData0(index: number, data: any) {
    return index;
  }
  trackByChild1(_: number, child: any) {
    return \\"render-block-\\" + child.id;
  }
  trackByChild2(_: number, child: any) {
    return \\"block-style-\\" + child.id;
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"render-block\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > renderContentExample 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import BuilderContext from \\"@dummy/context.js\\";
import {
  dispatchNewContentToVisualEditor,
  sendComponentsToVisualEditor,
  trackClick,
} from \\"@dummy/injection-js\\";
import RenderBlocks from \\"@dummy/RenderBlocks.js\\";

@Component({
  selector: \\"render-content\\",
  standalone: true,
  imports: [CommonModule, RenderBlocks],
  template: \`
    <div class=\\"div\\" (click)=\\"trackClick(content().id)\\" #_root>
      <render-blocks [blocks]=\\"content().blocks\\"></render-blocks>
    </div>
  \`,
  styles: \`:host { display: contents; }
        .div {
          display: flex;
          flex-direction: columns;
        }
\`,
})
export class RenderContent implements AfterViewInit {
  customComponents = input<any>();
  content = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {
    effect(() => {
      // --- Mitosis: Workaround to make sure the effect() is triggered ---

      // ---

      dispatchNewContentToVisualEditor(this.content());
    });
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    sendComponentsToVisualEditor(this.customComponents());
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"render-content\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > rootFragmentMultiNode 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"button\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <ng-container>
      @if(link()){
      <a
        [attr.href]=\\"link()\\"
        [attr.target]=\\"openLinkInNewTab() ? '_blank' : undefined\\"
      >
        {{text()}}
      </a>
      } @if(!link()){
      <button type=\\"button\\">{{text()}}</button>
      }
    </ng-container>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class Button implements AfterViewInit {
  link = input<any>();
  attributes = input<any>();
  openLinkInNewTab = input<any>();
  text = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"button\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > rootShow 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"render-styles\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    @if(foo() === 'bar'){
    <div>Bar</div>
    }@else{
    <div>Foo</div>
    }
  \`,
  styles: \`:host { display: contents; }\`,
})
export class RenderStyles implements AfterViewInit {
  foo = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"render-styles\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > sanitizeInnerHTML 1`] = `
"/**
          useMetadata:
          {\\"angular\\":{\\"sanitizeInnerHTML\\":true}}
          */

import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div [innerHTML]=\\"html()\\" #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  html = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > self-referencing component 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule, MyComponent],
  template: \`
    <div #_root>
      {{name()}} @if(name() === 'Batman'){
      <my-component name=\\"Bruce Wayne\\"></my-component>
      }
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  name = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > self-referencing component with children 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule, MyComponent],
  template: \`
    <div #_root>
      {{name()}}
      <ng-content></ng-content>
      @if(name() === 'Batman'){
      <my-component name=\\"Bruce\\"><div>Wayne</div></my-component>
      }
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  name = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > setState 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"set-state\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root><button (click)=\\"someFn()\\">Click me</button></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class SetState implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  n = signal([\\"123\\"]);

  someFn() {
    this.n[0] = \\"123\\";
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"set-state\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > showExpressions 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"show-with-other-values\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      @if(conditionA()){ Content0 }@else{ ContentA } @if(conditionA()){ ContentA
      } @if(conditionA()){ }@else{ ContentA } @if(conditionA()){ ContentB
      }@else{
      {{undefined}} } @if(conditionA()){ {{undefined}} }@else{ ContentB }
      @if(conditionA()){ ContentC } @if(conditionA()){ }@else{ ContentC }
      @if(conditionA()){ ContentD } @if(conditionA()){ }@else{ ContentD }
      @if(conditionA()){ ContentE }@else{ hello } @if(conditionA()){ hello
      }@else{ ContentE } @if(conditionA()){ ContentF }@else{ 123 }
      @if(conditionA()){ 123 }@else{ ContentF } @if(conditionA() === 'Default'){
      4mb }@else{ @if(conditionB() === 'Complete'){ 20mb }@else{ 9mb } }
      @if(conditionA() === 'Default'){ @if(conditionB() === 'Complete'){ 20mb
      }@else{ 9mb } }@else{ 4mb } @if(conditionA() === 'Default'){
      @if(conditionB() === 'Complete'){
      <div>complete</div>
      }@else{ 9mb } }@else{ @if(conditionC() === 'Complete'){ dff }@else{
      <div>complete else</div>
      } }
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class ShowWithOtherValues implements AfterViewInit {
  conditionA = input<any>();
  conditionB = input<any>();
  conditionC = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"show-with-other-values\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > showWithFor 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"nested-show\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    @if(conditionA()){ @for (item of items();track trackByItem0;let idx =
    $index) {
    <div>{{item}}</div>
    } }@else{
    <div>else-condition-A</div>
    }
  \`,
  styles: \`:host { display: contents; }\`,
})
export class NestedShow implements AfterViewInit {
  conditionA = input<any>();
  items = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  trackByItem0(idx: number, item: any) {
    return idx;
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"nested-show\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > showWithOtherValues 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"show-with-other-values\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      @if(conditionA()){ ContentA } @if(conditionA()){ ContentB }@else{
      {{undefined}} } @if(conditionA()){ ContentC } @if(conditionA()){ ContentD
      } @if(conditionA()){ ContentE }@else{ hello } @if(conditionA()){ ContentF
      }@else{ 123 }
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class ShowWithOtherValues implements AfterViewInit {
  conditionA = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"show-with-other-values\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > showWithRootText 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"show-root-text\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    @if(conditionA()){ ContentA }@else{
    <div>else-condition-A</div>
    }
  \`,
  styles: \`:host { display: contents; }\`,
})
export class ShowRootText implements AfterViewInit {
  conditionA = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"show-root-text\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > signals 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  output,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

const defaultProps = { testInput: \\"Test\\", label: \\"Bla\\" };

@Component({
  selector: \\"signals-test-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <button
      [attr.aria-label]=\\"label()\\"
      #buttonRef
      (click)=\\"handleOutput()\\"
      #_root
    >
      {{testInput()}}
    </button>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class SignalsTestComponent implements AfterViewInit {
  testInput = input<any>(defaultProps[\\"testInput\\"]);
  label = input<any>(defaultProps[\\"label\\"]);
  testOutput = output();

  buttonRef = viewChild<ElementRef>(\\"buttonRef\\");
  _root = viewChild<ElementRef>(\\"_root\\");

  _counter = signal(0);
  _innerText = signal(\\"a\\");

  handleOutput() {
    this._counter.update((_counter) => {
      _counter++;
      return _counter;
    });

    this._innerText.set(\\"b\\");

    console.log(this.testInput(), this._counter());

    if (this.testOutput) {
      this.testOutput.emit();
    }
  }

  constructor() {
    effect(() => {
      // --- Mitosis: Workaround to make sure the effect() is triggered ---
      this.buttonRef();
      // ---

      console.log(this._counter(), this.buttonRef()?.nativeElement);
      this.buttonRef()?.nativeElement?.setAttribute(
        \\"data-counter\\",
        this._counter().toString()
      );
    });
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"signals-test-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > signalsOnUpdate 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div class=\\"test div\\" #_root>{{id()}} {{foo().value.bar.baz}}</div>
  \`,
  styles: \`:host { display: contents; }
        .div {
          padding: 10px;
        }
\`,
})
export class MyBasicComponent implements AfterViewInit {
  id = input<any>();
  foo = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {
    effect(() => {
      // --- Mitosis: Workaround to make sure the effect() is triggered ---

      // ---

      console.log(\\"props.id changed\\", this.id());
      console.log(\\"props.foo.value.bar.baz changed\\", this.foo.value.bar.baz);
    });
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > spreadAttrs 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <input #_root />
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > spreadNestedProps 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <input #_root />
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicComponent implements AfterViewInit {
  nested = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > spreadProps 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <input #_root />
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > stateInit 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      <div>{{asfas()}}</div>
      <div>{{someCompute()}}</div>
      <div>{{someOtherVal()}}</div>
      <div>{{sf()}}</div>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  val = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  asfas = signal(\\"asga\\");
  someCompute = signal(this.add(1, 2));
  someOtherVal = signal(this.val);
  sf = signal(this.add(this.val(), 34));

  add(a, b) {
    return a + b;
  }
  subtract() {
    return this.someCompute() - this.someOtherVal();
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > stateInitSequence 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule, Comp],
  template: \`
    <Comp
      [val]=\\"{ ...val()
        }\\"
      #_root
    >
      {{val()}}
    </Comp>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  value = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  val = signal(this.value);

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > store-async-function 1`] = `
"import { Component, AfterViewInit, viewChild, ElementRef, effect } from '@angular/core';
       import { CommonModule } from '@angular/common';












       @Component({
         selector: 'string-literal-store',standalone: true,imports: [CommonModule],template: \`<div #_root></div>
\`,styles: \`:host { display: contents; }\`
       })
       export class StringLiteralStore implements AfterViewInit {



         _root = viewChild<ElementRef>(\\"_root\\")


         async function arrowFunction() {
 return Promise.resolve();
}
async function namedFunction() {
 return Promise.resolve();
}
async function fetchUsers() {
 return Promise.resolve();
}


         constructor() {

         }

         /**
* Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
* @param element  the ref for the component
* @param customElementSelector  the custom element like \`my-component\`
*/
private enableAttributePassing(element: HTMLElement | null, customElementSelector: string) {
 const parent = element?.closest(customElementSelector);
 if (element && parent) {
   const attributes = parent.attributes;
   for (let i = 0; i < attributes.length; i++) {
     const attr = attributes.item(i);
     if (attr && (attr.name.startsWith('data-') || attr.name.startsWith('aria-'))) {
       element.setAttribute(attr.name, attr.value);
       parent.removeAttribute(attr.name);
     }
     if (attr && attr.name === 'class') {
       const isWebComponent = attr.value.includes('hydrated');
       const value = attr.value.replace('hydrated', '').trim();
       const currentClass = element.getAttribute('class');
       element.setAttribute(attr.name, \`\${currentClass ? \`\${currentClass} \` : ''}\${value}\`);
       if (isWebComponent) {
         // Stencil is using this class for lazy loading component
         parent.setAttribute('class', 'hydrated');
       } else {
         parent.removeAttribute(attr.name);
       }
     }
   }
 }
};



         ngAfterViewInit() {

           const element: HTMLElement | null = this._root()?.nativeElement;
           this.enableAttributePassing(element, \\"string-literal-store\\");

             }



       }"
`;

exports[`Angular signals > jsx > Javascript Test > string-literal-store 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"string-literal-store\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>{{foo()}}</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class StringLiteralStore implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  foo = signal(123);

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"string-literal-store\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > string-literal-store-kebab 1`] = `
"import { Component, AfterViewInit, viewChild, ElementRef, effect, signal } from '@angular/core';
       import { CommonModule } from '@angular/common';












       @Component({
         selector: 'string-literal-store',standalone: true,imports: [CommonModule],template: \`<div #_root>{{'foo-bar'}}</div>
\`,styles: \`:host { display: contents; }\`
       })
       export class StringLiteralStore implements AfterViewInit {



         _root = viewChild<ElementRef>(\\"_root\\")

          foo-bar= signal(123)



         constructor() {

         }

         /**
* Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
* @param element  the ref for the component
* @param customElementSelector  the custom element like \`my-component\`
*/
private enableAttributePassing(element: HTMLElement | null, customElementSelector: string) {
 const parent = element?.closest(customElementSelector);
 if (element && parent) {
   const attributes = parent.attributes;
   for (let i = 0; i < attributes.length; i++) {
     const attr = attributes.item(i);
     if (attr && (attr.name.startsWith('data-') || attr.name.startsWith('aria-'))) {
       element.setAttribute(attr.name, attr.value);
       parent.removeAttribute(attr.name);
     }
     if (attr && attr.name === 'class') {
       const isWebComponent = attr.value.includes('hydrated');
       const value = attr.value.replace('hydrated', '').trim();
       const currentClass = element.getAttribute('class');
       element.setAttribute(attr.name, \`\${currentClass ? \`\${currentClass} \` : ''}\${value}\`);
       if (isWebComponent) {
         // Stencil is using this class for lazy loading component
         parent.setAttribute('class', 'hydrated');
       } else {
         parent.removeAttribute(attr.name);
       }
     }
   }
 }
};



         ngAfterViewInit() {

           const element: HTMLElement | null = this._root()?.nativeElement;
           this.enableAttributePassing(element, \\"string-literal-store\\");

             }



       }"
`;

exports[`Angular signals > jsx > Javascript Test > styleClassAndCss 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div
      class=\\"builder-column div\\"
      [ngStyle]=\\"{
          width: '100%'
        }\\"
      #_root
    ></div>
  \`,
  styles: \`:host { display: contents; }
        .div {
          display: flex;
          flex-direction: column;
          align-items: stretch;
        }
\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > stylePropClassAndCss 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"style-prop-class-and-css\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div
      [ngStyle]=\\"attributes().style\\"
      [class]=\\"attributes().class + ' div'\\"
      #_root
    ></div>
  \`,
  styles: \`:host { display: contents; }
        .div {
          display: flex;
          flex-direction: column;
          align-items: stretch;
        }
\`,
})
export class StylePropClassAndCss implements AfterViewInit {
  attributes = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"style-prop-class-and-css\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > subComponent 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import Foo from \\"./foo-sub-component.js\\";

@Component({
  selector: \\"sub-component\\",
  standalone: true,
  imports: [CommonModule, Foo],
  template: \`
    <foo #_root></foo>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class SubComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"sub-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > svgComponent 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"svg-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <svg
      fill=\\"none\\"
      role=\\"img\\"
      [attr.viewBox]=\\"'0 0 ' + 42 + ' ' + 42\\"
      [attr.width]=\\"42\\"
      [attr.height]=\\"42\\"
      #_root
    >
      <defs>
        <filter id=\\"prefix__filter0_f\\" filterUnits=\\"userSpaceOnUse\\">
          <feFlood result=\\"BackgroundImageFix\\"></feFlood>
          <feBlend
            in=\\"SourceGraphic\\"
            in2=\\"BackgroundImageFix\\"
            result=\\"shape\\"
          ></feBlend>
          <feGaussianBlur
            result=\\"effect1_foregroundBlur\\"
            [attr.stdDeviation]=\\"7\\"
          ></feGaussianBlur>
        </filter>
      </defs>
    </svg>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class SvgComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"svg-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > twoForsTrackBy 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      @for (item of items();track trackByItem0;let i = $index) {
      <div>{{item}}</div>
      } @for (item of items();track trackByItem1;let i = $index) {
      <div>{{item}}</div>
      }
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  items = signal([1, 2, 3]);

  trackByItem0(_: number, item: any) {
    return item;
  }
  trackByItem1(_: number, item: any) {
    return item;
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > typeDependency 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"type-dependency\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>{{foo()}}</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class TypeDependency implements AfterViewInit {
  foo = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"type-dependency\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > typeExternalProps 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"type-external-props\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>Hello {{name()}} !</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class TypeExternalProps implements AfterViewInit {
  name = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"type-external-props\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > typeExternalStore 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"type-external-store\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>Hello {{_name()}} !</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class TypeExternalStore implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  _name = signal(\\"test\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"type-external-store\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > typeGetterStore 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"type-getter-store\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>Hello {{name()}} !</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class TypeGetterStore implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"test\\");

  getName() {
    if (this.name() === \\"a\\") {
      return \\"b\\";
    }

    return this.name;
  }
  get test() {
    return \\"test\\";
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"type-getter-store\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > use-style 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <button type=\\"button\\" #_root>Button</button>
  \`,
  styles: \`:host { display: contents; }
        button {
          background: blue;
          color: white;
          font-size: 12px;
          outline: 1px solid black;
        }
\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > use-style-and-css 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <button type=\\"button\\" class=\\"button\\" #_root>Button</button>
  \`,
  styles: \`:host { display: contents; }
        button {
          font-size: 12px;
          outline: 1px solid black;
        }

        .button {
          background: blue;
          color: white;
        }
\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > use-style-outside-component 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <button type=\\"button\\" #_root>Button</button>
  \`,
  styles: \`:host { display: contents; }
        button {
          background: blue;
          color: white;
          font-size: 12px;
          outline: 1px solid black;
        }
\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > useObjectWrapper 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule, Comp],
  template: \`
    <div #_root>
      <Comp
        [val1]=\\"{ ...attributes2()
        }\\"
        [val2]=\\"{ ...attributes(),
          ...attributes2()
        }\\"
        [val3]=\\"{ ...something(),
          anything: 'hello',
          hello: 'world'
        }\\"
        [val4]=\\"{ ...attributes(),
          ...something(),
          anything: [1, 2, 3],
          hello: 'hello',
          ...attributes2()
        }\\"
        [val5]=\\"{ ...attributes(),
          ...something(),
          anything: [1, 2, 3],
          anythingString: ['a', 'b', 'c'],
          hello: 'hello',
          ...spreadAttrs()
        }\\"
        [val6]=\\"{
          anything: [1, 2, 3]
        }\\"
      ></Comp>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  spreadAttrs = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  attributes = signal({
    id: 1,
  });
  attributes2 = signal({
    id2: 1,
  });
  something = signal({
    id3: 1,
  });

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > useTarget 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"use-target-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>{{name()}}</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class UseTargetComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  lastName = signal(\\"bar\\");
  foo = signal(\\"bar\\");

  get name() {
    const prefix = true;
    return prefix + \\"foo\\";
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    console.log(this.foo());
    this.foo.set(\\"bar\\");
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"use-target-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Javascript Test > webComponent 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { register } from \\"swiper/element/bundle\\";

@Component({
  selector: \\"my-basic-web-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <swiper-container
      slides-per-view=\\"3\\"
      navigation=\\"true\\"
      pagination=\\"true\\"
      #_root
    >
      <swiper-slide>Slide 1</swiper-slide>
      <swiper-slide>Slide 2</swiper-slide>
      <swiper-slide>Slide 3</swiper-slide>
    </swiper-container>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicWebComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    register();
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-web-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Remove Internal mitosis package 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      Hello {{name()}} ! I can run in React, Qwik, Vue, Solid, or Liquid!
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"PatrickJS\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > Advanced 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-for-show-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <main #_root>
      @for (person of names();track i;let i = $index) {
      <div>{{i}} : {{person}}</div>
      } @for (person of names();track i;let i = $index) {
      <span>{{person}}</span>
      } @for (_ of names();track i;let i = $index) {
      <br />
      } @for (_ of Array.from({ length: 10 });track ee;let ee = $index) {
      <pre>{{ee}}</pre>
      } @for (_ of Array.from({ length: 10 });track i;let i = $index) {
      <p>{{index}}</p>
      } @for (person of names();track index;let index = $index) {
      <span>{{person}} {{index}}</span>
      } @for (person of Array.from({ length: 10 });track count;let count =
      $index) {
      <span>{{person}} {{count}}</span>
      } @for (person of names();track i;let i = $index) {
      <span>{{person}} {{i}}</span>
      } @for (person of Array.from({ length: 10 });track index;let index =
      $index) {
      <span>{{person}} {{index}}</span>
      }
    </main>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicForShowComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"PatrickJS\\");
  names = signal([\\"Steve\\", \\"PatrickJS\\"]);

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-for-show-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > AdvancedRef 1`] = `
"--- MITOSIS ERROR ---
    Component input has an event change that uses 'event.target.xxx'. 
        This will cause an error in Angular.
        Please create a new function with the EventTarget and use e.g '(event.target as HTMLInputElement).value'"
`;

exports[`Angular signals > jsx > Typescript Test > Basic 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

export interface MyBasicComponentProps {
  id: string;
}

export const DEFAULT_VALUES = {
  name: \\"Steve\\",
};

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div class=\\"test div\\" #_root>
      <input
        [attr.value]=\\"DEFAULT_VALUES.name || name()\\"
        (change)=\\"name.set(myEvent.target.value)\\"
      />

      Hello! I can run in React, Vue, Solid, or Liquid! &gt;
    </div>
  \`,
  styles: \`:host { display: contents; }
        .div {
          padding: 10px;
        }
\`,
})
export class MyBasicComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"Steve\\");
  age = signal<number>(1);
  sports = signal<Array<string>>([\\"\\"]);

  underscore_fn_name() {
    return \\"bar\\";
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > Basic 2`] = `
"unknown: Unexpected token, expected \\",\\" (2:7)

[0m [90m 1 |[39m [36mlet[39m _ [33m=[39m {[0m
[0m[31m[1m>[22m[39m[90m 2 |[39m   state[33m.[39mname [33m=[39m event[33m.[39mtarget[33m.[39mvalue [33m+[39m [32m' and '[39m [33m+[39m person[33m;[39m[0m
[0m [90m   |[39m        [31m[1m^[22m[39m[0m
[0m [90m 3 |[39m }[0m"
`;

exports[`Angular signals > jsx > Typescript Test > Basic Context 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Injector, MyService, createInjector } from \\"@dummy/injection-js\\";

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      {{myService.method('hello') + name()}} Hello! I can run in React, Vue,
      Solid, or Liquid!

      <input (change)=\\"onChange()\\" />
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"PatrickJS\\");

  onChange() {
    const change = this.myService.method(\\"change\\");
    console.log(change);
  }

  constructor(public myService: MyService) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    const hi = this.myService.method(\\"hi\\");
    console.log(hi);
    const bye = this.myService.method(\\"hi\\");
    console.log(bye);
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > Basic OnMount Update 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

export interface Props {
  hi: string;
  bye: string;
}

@Component({
  selector: \\"my-basic-on-mount-update-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>Hello {{name()}}</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicOnMountUpdateComponent implements AfterViewInit {
  bye = input<Props[\\"bye\\"]>();
  hi = input<Props[\\"hi\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"PatrickJS\\");
  names = signal([\\"Steve\\", \\"PatrickJS\\"]);

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.name.set(\\"PatrickJS onInit\\" + this.hi());
    this.name.set(\\"PatrickJS onMount\\" + this.bye());
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-on-mount-update-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > Basic Outputs 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  output,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-outputs-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicOutputsComponent implements AfterViewInit {
  message = input<any>();
  messageChange = output();
  event = output();

  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"PatrickJS\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.messageChange.emit(this.name());
    this.event.emit(this.message());
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-outputs-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > Basic Outputs Meta 1`] = `
"/**
          useMetadata:
          {\\"outputs\\":[\\"onMessage\\",\\"onEvent\\"],\\"baz\\":\\"metadata inside component\\"}
          */

import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  output,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-outputs-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicOutputsComponent implements AfterViewInit {
  message = input<any>();
  messageChange = output();
  event = output();

  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"PatrickJS\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.messageChange.emit(this.name());
    this.event.emit(this.message());
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-outputs-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > BasicAttribute 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <input
      autocapitalize=\\"on\\"
      autocomplete=\\"on\\"
      [attr.spellcheck]=\\"true\\"
      #_root
    />
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > BasicBooleanAttribute 1`] = `
"--- MITOSIS ERROR ---
    Show: You can't use children() in a Show block for \`when\` targeting angular.
      Try to invert it like this: \\"<Show when={props.label} else={props.children}>{props.label}</Show>\\""
`;

exports[`Angular signals > jsx > Typescript Test > BasicChildComponent 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import MyBasicOnMountUpdateComponent from \\"./basic-onMount-update.raw\\";
import MyBasicOutputsComponent from \\"./basic-outputs.raw\\";
import MyBasicComponent from \\"./basic.raw\\";

@Component({
  selector: \\"my-basic-child-component\\",
  standalone: true,
  imports: [
    CommonModule,
    MyBasicComponent,
    MyBasicOnMountUpdateComponent,
    MyBasicOutputsComponent,
  ],
  template: \`
    <div #_root>
      <my-basic-component [id]=\\"dev()\\"></my-basic-component>
      <div>
        <my-basic-on-mount-update-component
          [hi]=\\"name()\\"
          [bye]=\\"dev()\\"
        ></my-basic-on-mount-update-component>
        <my-basic-outputs-component
          message=\\"Test\\"
          (messageChange)=\\"name.set($event)\\"
          (event)=\\"log('Test')\\"
        ></my-basic-outputs-component>
      </div>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicChildComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"Steve\\");
  dev = signal(\\"PatrickJS\\");

  log(message: string) {
    console.log(message);
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-child-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > BasicFor 1`] = `
"unknown: Unexpected token, expected \\",\\" (2:7)

[0m [90m 1 |[39m [36mlet[39m _ [33m=[39m {[0m
[0m[31m[1m>[22m[39m[90m 2 |[39m   state[33m.[39mname [33m=[39m event[33m.[39mtarget[33m.[39mvalue [33m+[39m [32m' and '[39m [33m+[39m person[33m;[39m[0m
[0m [90m   |[39m        [31m[1m^[22m[39m[0m
[0m [90m 3 |[39m }[0m"
`;

exports[`Angular signals > jsx > Typescript Test > BasicRef 1`] = `
"--- MITOSIS ERROR ---
    Component input has an event change that uses 'event.target.xxx'. 
        This will cause an error in Angular.
        Please create a new function with the EventTarget and use e.g '(event.target as HTMLInputElement).value'"
`;

exports[`Angular signals > jsx > Typescript Test > BasicRefAssignment 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

export interface Props {
  showInput: boolean;
}

@Component({
  selector: \\"my-basic-ref-assignment-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      <button (click)=\\"await handlerClick($event)\\">Click</button>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicRefAssignmentComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  handlerClick(event: Event) {
    event.preventDefault();
    console.log(\\"current value\\", this._holdValueRef);
    this._holdValueRef = this._holdValueRef + \\"JS\\";
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-ref-assignment-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > BasicRefPrevious 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

export interface Props {
  showInput: boolean;
}

export function usePrevious<T>(value: T) {
  // The ref object is a generic container whose current property is mutable ...
  // ... and can hold any value, similar to an instance property on a class
  let ref = useRef<T>(null); // Store current value in ref

  onUpdate(() => {
    ref = value;
  }, [value]); // Only re-run if value changes
  // Return previous value (happens before update in useEffect above)

  return ref;
}

@Component({
  selector: \\"my-previous-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      <h1>Now: {{count()}} , before: {{this._prevCount}}</h1>
      <button (click)=\\"count.set(1)\\">Increment</button>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyPreviousComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  count = signal(0);

  constructor() {
    effect(() => {
      // --- Mitosis: Workaround to make sure the effect() is triggered ---

      // ---

      this._prevCount = this.count;
    });
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-previous-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > Button 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

export interface ButtonProps {
  attributes?: any;
  text?: string;
  link?: string;
  openLinkInNewTab?: boolean;
}

@Component({
  selector: \\"button\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      @if(link()){
      <a
        [attr.href]=\\"link()\\"
        [attr.target]=\\"openLinkInNewTab() ? '_blank' : undefined\\"
      >
        {{text()}}
      </a>
      } @if(!link()){
      <button type=\\"button\\">{{text()}}</button>
      }
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class Button implements AfterViewInit {
  link = input<ButtonProps[\\"link\\"]>();
  attributes = input<ButtonProps[\\"attributes\\"]>();
  openLinkInNewTab = input<ButtonProps[\\"openLinkInNewTab\\"]>();
  text = input<ButtonProps[\\"text\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"button\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > Columns 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

type Column = {
  content: any; // TODO: Implement this when support for dynamic CSS lands

  width?: number;
};
export interface ColumnProps {
  columns?: Column[]; // TODO: Implement this when support for dynamic CSS lands

  space?: number; // TODO: Implement this when support for dynamic CSS lands

  stackColumnsAt?: \\"tablet\\" | \\"mobile\\" | \\"never\\"; // TODO: Implement this when support for dynamic CSS lands

  reverseColumnsWhenStacked?: boolean;
}

@Component({
  selector: \\"column\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div class=\\"builder-columns div\\" #_root>
      @for (column of columns();track index;let index = $index) {
      <div class=\\"builder-column div-2\\">{{column.content}} {{index}}</div>
      }
    </div>
  \`,
  styles: \`:host { display: contents; }
        .div {
          display: flex;
          flex-direction: column;
          align-items: stretch;
          line-height: normal;
        }
        @media (max-width: 999px) {
          .div {
            flex-direction: row;
          }
        }
        @media (max-width: 639px) {
          .div {
            flex-direction: row-reverse;
          }
        }
        .div-2 {
          flex-grow: 1;
        }
\`,
})
export class Column implements AfterViewInit {
  columns = input<ColumnProps[\\"columns\\"]>();
  space = input<ColumnProps[\\"space\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  getColumns() {
    return this.columns || [];
  }
  getGutterSize() {
    return typeof this.space === \\"number\\" ? this.space || 0 : 20;
  }
  getWidth(index: number) {
    const columns = this.getColumns();
    return (columns[index] && columns[index].width) || 100 / columns.length;
  }
  getColumnCssWidth(index: number) {
    const columns = this.getColumns();
    const gutterSize = this.getGutterSize();
    const subtractWidth = (gutterSize * (columns.length - 1)) / columns.length;
    return \`calc(\${this.getWidth(index)}% - \${subtractWidth}px)\`;
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"column\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > ContentSlotHtml 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

type Props = {
  [key: string]: string | JSX.Element;
  slotTesting: JSX.Element;
};

import type { JSX } from \\"../../../../jsx-runtime\\";

@Component({
  selector: \\"content-slot-code\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      <ng-content select=\\"[testing]\\"></ng-content>
      <div><hr /></div>
      <div><ng-content></ng-content></div>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class ContentSlotCode implements AfterViewInit {
  slotTesting = input<Props[\\"slotTesting\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"content-slot-code\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > ContentSlotJSX 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

type Props = {
  [key: string]: string | JSX.Element;
};
const defaultProps = {
  content: \\"\\",
  slotReference: undefined,
  slotContent: undefined,
};

import type { JSX } from \\"../../../../jsx-runtime\\";

@Component({
  selector: \\"content-slot-jsx-code\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    @if(slotReference()){
    <div
      [attr.name]=\\"slotContent() ? 'name1' : 'name2'\\"
      [attr.title]=\\"slotContent() ? 'title1' : 'title2'\\"
      (click)=\\"show()\\"
      [class]=\\"cls()\\"
    >
      @if(showContent() && slotContent()){
      <ng-content select=\\"[content]\\">{{content()}}</ng-content>
      }
      <div><hr /></div>
      <div><ng-content></ng-content></div>
    </div>
    }
  \`,
  styles: \`:host { display: contents; }\`,
})
export class ContentSlotJsxCode implements AfterViewInit {
  slotContent = input<Props[\\"slotContent\\"]>(defaultProps[\\"slotContent\\"]);
  slotReference = input<Props[\\"slotReference\\"]>(defaultProps[\\"slotReference\\"]);
  attributes = input<Props[\\"attributes\\"]>();
  content = input<Props[\\"content\\"]>(defaultProps[\\"content\\"]);

  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"king\\");
  showContent = signal(false);

  get cls() {
    return this.slotContent && this.children ? \`\${this.name}-content\` : \\"\\";
  }
  show() {
    this.slotContent ? 1 : \\"\\";
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"content-slot-jsx-code\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > CustomCode 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";
import { DomSanitizer } from \\"@angular/platform-browser\\";

export interface CustomCodeProps {
  code: string;
  replaceNodes?: boolean;
}

@Component({
  selector: \\"custom-code\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div
      #elem
      [class]=\\"'builder-custom-code' + (replaceNodes() ? ' replace-nodes' : '')\\"
      [innerHTML]=\\"sanitizer.bypassSecurityTrustHtml(code())\\"
      #_root
    ></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class CustomCode implements AfterViewInit {
  replaceNodes = input<CustomCodeProps[\\"replaceNodes\\"]>();
  code = input<CustomCodeProps[\\"code\\"]>();

  elem = viewChild<ElementRef>(\\"elem\\");
  _root = viewChild<ElementRef>(\\"_root\\");

  scriptsInserted = signal([]);
  scriptsRun = signal([]);

  findAndRunScripts() {
    // TODO: Move this function to standalone one in '@builder.io/utils'
    if (this.elem()?.nativeElement && typeof window !== \\"undefined\\") {
      /** @type {HTMLScriptElement[]} */
      const scripts = this.elem()?.nativeElement.getElementsByTagName(\\"script\\");

      for (let i = 0; i < scripts.length; i++) {
        const script = scripts[i];

        if (script.src) {
          if (this.scriptsInserted().includes(script.src)) {
            continue;
          }

          this.scriptsInserted().push(script.src);
          const newScript = document.createElement(\\"script\\");
          newScript.async = true;
          newScript.src = script.src;
          document.head.appendChild(newScript);
        } else if (
          !script.type ||
          [
            \\"text/javascript\\",
            \\"application/javascript\\",
            \\"application/ecmascript\\",
          ].includes(script.type)
        ) {
          if (this.scriptsRun().includes(script.innerText)) {
            continue;
          }

          try {
            this.scriptsRun().push(script.innerText);
            new Function(script.innerText)();
          } catch (error) {
            console.warn(\\"\`CustomCode\`: Error running script:\\", error);
          }
        }
      }
    }
  }

  constructor(protected sanitizer: DomSanitizer) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.findAndRunScripts();
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"custom-code\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > Embed 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";
import { DomSanitizer } from \\"@angular/platform-browser\\";

export interface CustomCodeProps {
  code: string;
  replaceNodes?: boolean;
}

@Component({
  selector: \\"custom-code\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div
      #elem
      [class]=\\"'builder-custom-code' + (replaceNodes() ? ' replace-nodes' : '')\\"
      [innerHTML]=\\"sanitizer.bypassSecurityTrustHtml(code())\\"
      #_root
    ></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class CustomCode implements AfterViewInit {
  replaceNodes = input<CustomCodeProps[\\"replaceNodes\\"]>();
  code = input<CustomCodeProps[\\"code\\"]>();

  elem = viewChild<ElementRef>(\\"elem\\");
  _root = viewChild<ElementRef>(\\"_root\\");

  scriptsInserted = signal([]);
  scriptsRun = signal([]);

  findAndRunScripts() {
    // TODO: Move this function to standalone one in '@builder.io/utils'
    if (this.elem()?.nativeElement && typeof window !== \\"undefined\\") {
      /** @type {HTMLScriptElement[]} */
      const scripts = this.elem()?.nativeElement.getElementsByTagName(\\"script\\");

      for (let i = 0; i < scripts.length; i++) {
        const script = scripts[i];

        if (script.src) {
          if (this.scriptsInserted().includes(script.src)) {
            continue;
          }

          this.scriptsInserted().push(script.src);
          const newScript = document.createElement(\\"script\\");
          newScript.async = true;
          newScript.src = script.src;
          document.head.appendChild(newScript);
        } else if (
          !script.type ||
          [
            \\"text/javascript\\",
            \\"application/javascript\\",
            \\"application/ecmascript\\",
          ].includes(script.type)
        ) {
          if (this.scriptsRun().includes(script.innerText)) {
            continue;
          }

          try {
            this.scriptsRun().push(script.innerText);
            new Function(script.innerText)();
          } catch (error) {
            console.warn(\\"\`CustomCode\`: Error running script:\\", error);
          }
        }
      }
    }
  }

  constructor(protected sanitizer: DomSanitizer) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.findAndRunScripts();
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"custom-code\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > Form 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

export interface FormProps {
  attributes?: any;
  name?: string;
  action?: string;
  validate?: boolean;
  method?: string;
  builderBlock?: BuilderElement;
  sendSubmissionsTo?: string;
  sendSubmissionsToEmail?: string;
  sendWithJs?: boolean;
  contentType?: string;
  customHeaders?: {
    [key: string]: string;
  };
  successUrl?: string;
  previewState?: FormState;
  successMessage?: BuilderElement[];
  errorMessage?: BuilderElement[];
  sendingMessage?: BuilderElement[];
  resetFormOnSubmit?: boolean;
  errorMessagePath?: string;
}
export type FormState = \\"unsubmitted\\" | \\"sending\\" | \\"success\\" | \\"error\\";

import { Builder, BuilderElement, builder } from \\"@builder.io/sdk\\";
import {
  BuilderBlock as BuilderBlockComponent,
  BuilderBlocks,
  get,
  set,
} from \\"@fake\\";

@Component({
  selector: \\"form-component\\",
  standalone: true,
  imports: [CommonModule, BuilderBlockComponent, BuilderBlocks],
  template: \`
    <form
      [attr.validate]=\\"validate()\\"
      #formRef
      [attr.action]=\\"!sendWithJs() && action()\\"
      [attr.method]=\\"method()\\"
      [attr.name]=\\"name()\\"
      (submit)=\\"onSubmit($event)\\"
      #_root
    >
      @if(builderBlock() && builderBlock().children){ @for (block of
      builderBlock()?.children;track trackByBlock0;let index = $index) {
      <builder-block-component
        [block]=\\"block\\"
        [index]=\\"index\\"
      ></builder-block-component>
      } } @if(submissionState() === 'error'){
      <builder-blocks
        dataPath=\\"errorMessage\\"
        [blocks]=\\"errorMessage()!\\"
      ></builder-blocks>
      } @if(submissionState() === 'sending'){
      <builder-blocks
        dataPath=\\"sendingMessage\\"
        [blocks]=\\"sendingMessage()!\\"
      ></builder-blocks>
      } @if(submissionState() === 'error' && responseData()){
      <pre class=\\"builder-form-error-text pre\\">
        {{JSON.stringify(responseData, null, 2)}}</pre
      >
      } @if(submissionState() === 'success'){
      <builder-blocks
        dataPath=\\"successMessage\\"
        [blocks]=\\"successMessage()!\\"
      ></builder-blocks>
      }
    </form>
  \`,
  styles: \`:host { display: contents; }
        .pre {
          padding: 10px;
          color: red;
          text-align: center;
        }
\`,
})
export class FormComponent implements AfterViewInit {
  previewState = input<FormProps[\\"previewState\\"]>();
  sendWithJs = input<FormProps[\\"sendWithJs\\"]>();
  sendSubmissionsTo = input<FormProps[\\"sendSubmissionsTo\\"]>();
  action = input<FormProps[\\"action\\"]>();
  customHeaders = input<FormProps[\\"customHeaders\\"]>();
  contentType = input<FormProps[\\"contentType\\"]>();
  sendSubmissionsToEmail = input<FormProps[\\"sendSubmissionsToEmail\\"]>();
  name = input<FormProps[\\"name\\"]>();
  method = input<FormProps[\\"method\\"]>();
  errorMessagePath = input<FormProps[\\"errorMessagePath\\"]>();
  resetFormOnSubmit = input<FormProps[\\"resetFormOnSubmit\\"]>();
  successUrl = input<FormProps[\\"successUrl\\"]>();
  validate = input<FormProps[\\"validate\\"]>();
  attributes = input<FormProps[\\"attributes\\"]>();
  builderBlock = input<FormProps[\\"builderBlock\\"]>();
  errorMessage = input<FormProps[\\"errorMessage\\"]>();
  sendingMessage = input<FormProps[\\"sendingMessage\\"]>();
  successMessage = input<FormProps[\\"successMessage\\"]>();

  formRef = viewChild<ElementRef>(\\"formRef\\");
  _root = viewChild<ElementRef>(\\"_root\\");

  formState = signal(\\"unsubmitted\\");
  responseData = signal(null);
  formErrorMessage = signal(\\"\\");

  get submissionState() {
    return (Builder.isEditing && this.previewState) || this.formState;
  }
  onSubmit(
    event: Event & {
      currentTarget: HTMLFormElement;
    }
  ) {
    const sendWithJs = this.sendWithJs || this.sendSubmissionsTo() === \\"email\\";

    if (this.sendSubmissionsTo() === \\"zapier\\") {
      event.preventDefault();
    } else if (sendWithJs) {
      if (!(this.action || this.sendSubmissionsTo() === \\"email\\")) {
        event.preventDefault();
        return;
      }

      event.preventDefault();
      const el = event.currentTarget;
      const headers = this.customHeaders || {};
      let body: any;
      const formData = new FormData(el); // TODO: maybe support null

      const formPairs: {
        key: string;
        value: File | boolean | number | string | FileList;
      }[] = Array.from(
        event.currentTarget.querySelectorAll(\\"input,select,textarea\\")
      )
        .filter((el) => !!(el as HTMLInputElement).name)
        .map((el) => {
          let value: any;
          const key = (el as HTMLImageElement).name;

          if (el instanceof HTMLInputElement) {
            if (el.type === \\"radio\\") {
              if (el.checked) {
                value = el.name;
                return {
                  key,
                  value,
                };
              }
            } else if (el.type === \\"checkbox\\") {
              value = el.checked;
            } else if (el.type === \\"number\\" || el.type === \\"range\\") {
              const num = el.valueAsNumber;

              if (!isNaN(num)) {
                value = num;
              }
            } else if (el.type === \\"file\\") {
              // TODO: one vs multiple files
              value = el.files;
            } else {
              value = el.value;
            }
          } else {
            value = (el as HTMLInputElement).value;
          }

          return {
            key,
            value,
          };
        });
      let contentType = this.contentType;

      if (this.sendSubmissionsTo() === \\"email\\") {
        contentType = \\"multipart/form-data\\";
      }

      Array.from(formPairs).forEach(({ value }) => {
        if (
          value instanceof File ||
          (Array.isArray(value) && value[0] instanceof File) ||
          value instanceof FileList
        ) {
          contentType = \\"multipart/form-data\\";
        }
      }); // TODO: send as urlEncoded or multipart by default
      // because of ease of use and reliability in browser API
      // for encoding the form?

      if (contentType !== \\"application/json\\") {
        body = formData;
      } else {
        // Json
        const json = {};
        Array.from(formPairs).forEach(({ value, key }) => {
          set(json, key, value);
        });
        body = JSON.stringify(json);
      }

      if (contentType && contentType !== \\"multipart/form-data\\") {
        if (
          /* Zapier doesn't allow content-type header to be sent from browsers */
          !(sendWithJs && this.action?.includes(\\"zapier.com\\"))
        ) {
          headers[\\"content-type\\"] = contentType;
        }
      }

      const presubmitEvent = new CustomEvent(\\"presubmit\\", {
        detail: {
          body,
        },
      });

      if (this.formRef()?.nativeElement) {
        this.formRef()?.nativeElement.dispatchEvent(presubmitEvent);

        if (presubmitEvent.defaultPrevented) {
          return;
        }
      }

      this.formState.set(\\"sending\\");
      const formUrl = \`\${
        builder.env === \\"dev\\" ? \\"http://localhost:5000\\" : \\"https://builder.io\\"
      }/api/v1/form-submit?apiKey=\${builder.apiKey}&to=\${btoa(
        this.sendSubmissionsToEmail || \\"\\"
      )}&name=\${encodeURIComponent(this.name || \\"\\")}\`;
      fetch(
        this.sendSubmissionsTo() === \\"email\\" ? formUrl : this.action!,
        /* TODO: throw error if no action URL */
        {
          body,
          headers,
          method: this.method || \\"post\\",
        }
      ).then(
        async (res) => {
          let body;
          const contentType = res.headers.get(\\"content-type\\");

          if (contentType && contentType.indexOf(\\"application/json\\") !== -1) {
            body = await res.json();
          } else {
            body = await res.text();
          }

          if (!res.ok && this.errorMessagePath) {
            /* TODO: allow supplying an error formatter function */
            let message = get(body, this.errorMessagePath());

            if (message) {
              if (typeof message !== \\"string\\") {
                /* TODO: ideally convert json to yaml so it woul dbe like
            error: - email has been taken */
                message = JSON.stringify(message);
              }

              this.formErrorMessage.set(message);
            }
          }

          this.responseData.set(body);
          this.formState.set(res.ok ? \\"success\\" : \\"error\\");

          if (res.ok) {
            const submitSuccessEvent = new CustomEvent(\\"submit:success\\", {
              detail: {
                res,
                body,
              },
            });

            if (this.formRef()?.nativeElement) {
              this.formRef()?.nativeElement.dispatchEvent(submitSuccessEvent);

              if (submitSuccessEvent.defaultPrevented) {
                return;
              }
              /* TODO: option to turn this on/off? */

              if (this.resetFormOnSubmit() !== false) {
                this.formRef()?.nativeElement.reset();
              }
            }
            /* TODO: client side route event first that can be preventDefaulted */

            if (this.successUrl) {
              if (this.formRef()?.nativeElement) {
                const event = new CustomEvent(\\"route\\", {
                  detail: {
                    url: this.successUrl,
                  },
                });
                this.formRef()?.nativeElement.dispatchEvent(event);

                if (!event.defaultPrevented) {
                  location.href = this.successUrl;
                }
              } else {
                location.href = this.successUrl;
              }
            }
          }
        },
        (err) => {
          const submitErrorEvent = new CustomEvent(\\"submit:error\\", {
            detail: {
              error: err,
            },
          });

          if (this.formRef()?.nativeElement) {
            this.formRef()?.nativeElement.dispatchEvent(submitErrorEvent);

            if (submitErrorEvent.defaultPrevented) {
              return;
            }
          }

          this.responseData.set(err);
          this.formState.set(\\"error\\");
        }
      );
    }
  }
  trackByBlock0(index: number, block: any) {
    return block.id;
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"form-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > Image 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

// TODO: AMP Support?
export interface ImageProps {
  _class?: string;
  image: string;
  sizes?: string;
  lazy?: boolean;
  height?: number;
  width?: number;
  altText?: string;
  backgroundSize?: string;
  backgroundPosition?: string; // TODO: Support generating Builder.io and or Shopify \`srcset\`s when needed

  srcset?: string; // TODO: Implement support for custom aspect ratios

  aspectRatio?: number; // TODO: This might not work as expected in terms of positioning

  children?: any;
}

@Component({
  selector: \\"image\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      <picture #pictureRef>
        @if(!useLazyLoading() || load()){
        <img
          [attr.alt]=\\"altText()\\"
          [attr.aria-role]=\\"altText() ? 'presentation' : undefined\\"
          [class]=\\"'builder-image' + (_class() ? ' ' + _class() : '') + ' img'\\"
          [attr.src]=\\"image()\\"
          (load)=\\"setLoaded()\\"
          [attr.srcset]=\\"srcset()\\"
          [attr.sizes]=\\"sizes()\\"
        />
        }
        <source [attr.srcset]=\\"srcset()\\" />
      </picture>
      <ng-content></ng-content>
    </div>
  \`,
  styles: \`:host { display: contents; }
        .img {
          opacity: 1;
          transition: opacity 0.2s ease-in-out;
          object-fit: cover;
          object-position: center;
        }
\`,
})
export class Image implements AfterViewInit {
  lazy = input<ImageProps[\\"lazy\\"]>();
  altText = input<ImageProps[\\"altText\\"]>();
  _class = input<ImageProps[\\"_class\\"]>();
  image = input<ImageProps[\\"image\\"]>();
  srcset = input<ImageProps[\\"srcset\\"]>();
  sizes = input<ImageProps[\\"sizes\\"]>();

  pictureRef = viewChild<ElementRef>(\\"pictureRef\\");
  _root = viewChild<ElementRef>(\\"_root\\");

  scrollListener = signal(null);
  imageLoaded = signal(false);
  load = signal(false);

  setLoaded() {
    this.imageLoaded.set(true);
  }
  useLazyLoading() {
    // TODO: Add more checks here, like testing for real web browsers
    return !!this.lazy && this.isBrowser();
  }
  isBrowser() {
    return (
      typeof window !== \\"undefined\\" && window.navigator.product != \\"ReactNative\\"
    );
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    if (this.useLazyLoading()) {
      // throttled scroll capture listener
      const listener = () => {
        if (this.pictureRef()?.nativeElement) {
          const rect = this.pictureRef()?.nativeElement.getBoundingClientRect();
          const buffer = window.innerHeight / 2;

          if (rect.top < window.innerHeight + buffer) {
            this.load.set(true);
            this.scrollListener.set(null);
            window.removeEventListener(\\"scroll\\", listener);
          }
        }
      };

      this.scrollListener.set(listener);
      window.addEventListener(\\"scroll\\", listener, {
        capture: true,
        passive: true,
      });
      listener();
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"image\\");
  }

  ngOnDestroy() {
    if (this.scrollListener) {
      window.removeEventListener(\\"scroll\\", this.scrollListener());
    }
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > Image State 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"img-state-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      @for (item of images();track itemIndex;let itemIndex = $index) {
      <ng-container>
        <img class=\\"custom-class\\" [attr.src]=\\"item\\" />
      </ng-container>
      }
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class ImgStateComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  canShow = signal(true);
  images = signal([\\"http://example.com/qwik.png\\"]);

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"img-state-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > Img 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

export interface ImgProps {
  attributes?: any;
  imgSrc?: string;
  altText?: string;
  backgroundSize?: \\"cover\\" | \\"contain\\";
  backgroundPosition?:
    | \\"center\\"
    | \\"top\\"
    | \\"left\\"
    | \\"right\\"
    | \\"bottom\\"
    | \\"top left\\"
    | \\"top right\\"
    | \\"bottom left\\"
    | \\"bottom right\\";
}

import { Builder } from \\"@builder.io/sdk\\";

@Component({
  selector: \\"img-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <img
      [ngStyle]=\\"{
          objectFit: backgroundSize() || 'cover',
          objectPosition: backgroundPosition() || 'center'
        }\\"
      [attr.alt]=\\"altText()\\"
      [attr.src]=\\"imgSrc()\\"
      #_root
    />
  \`,
  styles: \`:host { display: contents; }\`,
})
export class ImgComponent implements AfterViewInit {
  backgroundSize = input<ImgProps[\\"backgroundSize\\"]>();
  backgroundPosition = input<ImgProps[\\"backgroundPosition\\"]>();
  attributes = input<ImgProps[\\"attributes\\"]>();
  imgSrc = input<ImgProps[\\"imgSrc\\"]>();
  altText = input<ImgProps[\\"altText\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"img-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > Input 1`] = `
"--- MITOSIS ERROR ---
    Component input has an event change that uses 'event.target.xxx'. 
        This will cause an error in Angular.
        Please create a new function with the EventTarget and use e.g '(event.target as HTMLInputElement).value'"
`;

exports[`Angular signals > jsx > Typescript Test > InputParent 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import FormInputComponent from \\"./input.raw\\";

@Component({
  selector: \\"stepper\\",
  standalone: true,
  imports: [CommonModule, FormInputComponent],
  template: \`
    <form-input-component
      name=\\"kingzez\\"
      type=\\"text\\"
      (change)=\\"handleChange($event)\\"
      #_root
    ></form-input-component>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class Stepper implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  handleChange(value: string) {
    console.log(value);
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"stepper\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > NestedStore 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

type MyStore = {
  _id?: string;
  _messageId?: string;
};

@Component({
  selector: \\"nested-store\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div [attr.id]=\\"_id()\\" #_root>
      Test

      <p [attr.id]=\\"_messageId()\\">Message</p>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class NestedStore implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  _id = signal<MyStore[\\"_id\\"]>(\\"abc\\");
  _messageId = signal<MyStore[\\"_messageId\\"]>(this._id() + \\"-message\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"nested-store\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > RawText 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";
import { DomSanitizer } from \\"@angular/platform-browser\\";

export interface RawTextProps {
  attributes?: any;
  text?: string; // builderBlock?: any;
}

@Component({
  selector: \\"raw-text\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <span
      [class]=\\"attributes()?.class || attributes()?.className\\"
      [innerHTML]=\\"sanitizer.bypassSecurityTrustHtml(text() || '')\\"
      #_root
    ></span>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class RawText implements AfterViewInit {
  attributes = input<RawTextProps[\\"attributes\\"]>();
  text = input<RawTextProps[\\"text\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor(protected sanitizer: DomSanitizer) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"raw-text\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > Section 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

export interface SectionProps {
  maxWidth?: number;
  attributes?: any;
  children?: any;
}

@Component({
  selector: \\"section-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <section
      [ngStyle]=\\"maxWidth() && typeof maxWidth() === 'number' ? {
          maxWidth: maxWidth()
        } : undefined\\"
      #_root
    >
      <ng-content></ng-content>
    </section>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class SectionComponent implements AfterViewInit {
  attributes = input<SectionProps[\\"attributes\\"]>();
  maxWidth = input<SectionProps[\\"maxWidth\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"section-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > Section 2`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

export interface SectionProps {
  maxWidth?: number;
  attributes?: any;
  children?: any;
}

@Component({
  selector: \\"section-state-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    @if(max()){ @for (item of items();track i;let i = $index) {
    <section
      [ngStyle]=\\"{
          maxWidth: item + max()
        }\\"
    >
      <ng-content></ng-content>
    </section>
    } }
  \`,
  styles: \`:host { display: contents; }\`,
})
export class SectionStateComponent implements AfterViewInit {
  attributes = input<SectionProps[\\"attributes\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  max = signal(42);
  items = signal([42]);

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"section-state-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > Select 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

export interface FormSelectProps {
  options?: {
    name?: string;
    value: string;
  }[];
  attributes?: any;
  name?: string;
  value?: string;
  defaultValue?: string;
}

import { Builder } from \\"@builder.io/sdk\\";

@Component({
  selector: \\"select-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <select
      [attr.value]=\\"value()\\"
      [attr.defaultValue]=\\"defaultValue()\\"
      [attr.name]=\\"name()\\"
      #_root
    >
      @for (option of options();track index;let index = $index) {
      <option [attr.value]=\\"option.value\\" [attr.data-index]=\\"index\\">
        {{option.name || option.value}}
      </option>
      }
    </select>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class SelectComponent implements AfterViewInit {
  attributes = input<FormSelectProps[\\"attributes\\"]>();
  value = input<FormSelectProps[\\"value\\"]>();
  defaultValue = input<FormSelectProps[\\"defaultValue\\"]>();
  name = input<FormSelectProps[\\"name\\"]>();
  options = input<FormSelectProps[\\"options\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"select-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > SlotDefault 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

type Props = {
  [key: string]: string;
};

@Component({
  selector: \\"slot-code\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      <ng-content>
        <div class=\\"default-slot\\">Default content</div>
      </ng-content>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class SlotCode implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"slot-code\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > SlotHtml 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

type Props = {
  [key: string]: string;
};

import ContentSlotCode from \\"./content-slot-jsx.raw\\";

@Component({
  selector: \\"slot-code\\",
  standalone: true,
  imports: [CommonModule, ContentSlotCode],
  template: \`
    <div #_root>
      <content-slot-code><ng-content></ng-content></content-slot-code>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class SlotCode implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"slot-code\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > SlotJsx 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

type Props = {
  [key: string]: string;
};

import ContentSlotCode from \\"./content-slot-jsx.raw\\";

@Component({
  selector: \\"slot-code\\",
  standalone: true,
  imports: [CommonModule, ContentSlotCode],
  template: \`
    <div #_root>
      <content-slot-code [slotTesting]=\\"<div>Hello</div>\\"></content-slot-code>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class SlotCode implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"slot-code\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > SlotNamed 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

type Props = {
  [key: string]: string;
};

@Component({
  selector: \\"slot-code\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      <ng-content select=\\"[my-awesome-slot]\\"></ng-content>
      <ng-content select=\\"[top]\\"></ng-content>
      <ng-content select=\\"[left]\\">Default left</ng-content>
      <ng-content>Default Child</ng-content>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class SlotCode implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"slot-code\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > Stamped.io 1`] = `
"unknown: Unexpected token, expected \\",\\" (2:4)

[0m [90m 1 |[39m [36mlet[39m _ [33m=[39m {[0m
[0m[31m[1m>[22m[39m[90m 2 |[39m   ev[33m.[39mpreventDefault()[33m;[39m[0m
[0m [90m   |[39m     [31m[1m^[22m[39m[0m
[0m [90m 3 |[39m   state[33m.[39mshowReviewPrompt [33m=[39m [36mfalse[39m[33m;[39m[0m
[0m [90m 4 |[39m }[0m"
`;

exports[`Angular signals > jsx > Typescript Test > StoreComment 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"string-literal-store\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <ng-container>{{foo()}}</ng-container>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class StringLiteralStore implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  foo = signal(true);

  bar() {}

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"string-literal-store\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > StoreShadowVars 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <ng-container>{{foo(errors)}}</ng-container>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  errors = signal({});

  foo(errors) {
    return errors;
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > StoreWithState 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <ng-container>{{bar()}}</ng-container>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  foo = signal(false);

  bar() {
    return this.foo;
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > Submit 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

export interface ButtonProps {
  attributes?: any;
  text?: string;
}

@Component({
  selector: \\"submit-button\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <button type=\\"submit\\" #_root>{{text()}}</button>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class SubmitButton implements AfterViewInit {
  attributes = input<ButtonProps[\\"attributes\\"]>();
  text = input<ButtonProps[\\"text\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"submit-button\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > Text 1`] = `
"unknown: Missing semicolon. (1:70)

[0m[31m[1m>[22m[39m[90m 1 |[39m [36mlet[39m _ [33m=[39m props[33m.[39mtext() [33m||[39m props[33m.[39mcontent() [33m||[39m state[33m.[39mname() [33m||[39m [32m'<p class='[39mtext[33m-[39mlg[32m'>my name</p>'[39m[0m
[0m [90m   |[39m                                                                       [31m[1m^[22m[39m[0m"
`;

exports[`Angular signals > jsx > Typescript Test > Textarea 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

export interface TextareaProps {
  attributes?: any;
  name?: string;
  value?: string;
  defaultValue?: string;
  placeholder?: string;
}

@Component({
  selector: \\"textarea\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <textarea
      [attr.placeholder]=\\"placeholder()\\"
      [attr.name]=\\"name()\\"
      [attr.value]=\\"value()\\"
      [attr.defaultValue]=\\"defaultValue()\\"
      #_root
    ></textarea>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class Textarea implements AfterViewInit {
  attributes = input<TextareaProps[\\"attributes\\"]>();
  placeholder = input<TextareaProps[\\"placeholder\\"]>();
  name = input<TextareaProps[\\"name\\"]>();
  value = input<TextareaProps[\\"value\\"]>();
  defaultValue = input<TextareaProps[\\"defaultValue\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"textarea\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > UseValueAndFnFromStore 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  output,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

type MyProps = {
  onChange?: (active: boolean) => void;
};
type MyStore = {
  _id?: string;
  _active?: boolean;
  _do?: (id?: string) => void;
};

@Component({
  selector: \\"use-value-and-fn-from-store\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>Test</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class UseValueAndFnFromStore implements AfterViewInit {
  change = output<Parameters<Required<MyProps>[\\"onChange\\"]>[number] | void>();

  _root = viewChild<ElementRef>(\\"_root\\");

  _id = signal<MyStore[\\"_id\\"]>(\\"abc\\");
  _active = signal<MyStore[\\"_active\\"]>(false);

  _do(id?: string) {
    this._active.set(!!id);

    if (this.change) {
      this.change.emit(this._active());
    }
  }

  constructor() {
    effect(() => {
      // --- Mitosis: Workaround to make sure the effect() is triggered ---

      // ---

      if (this._do) {
        this._do(this._id());
      }
    });
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"use-value-and-fn-from-store\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > Video 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

export interface VideoProps {
  attributes?: any;
  video?: string;
  autoPlay?: boolean;
  controls?: boolean;
  muted?: boolean;
  loop?: boolean;
  playsInline?: boolean;
  aspectRatio?: number;
  width?: number;
  height?: number;
  fit?: \\"contain\\" | \\"cover\\" | \\"fill\\";
  position?:
    | \\"center\\"
    | \\"top\\"
    | \\"left\\"
    | \\"right\\"
    | \\"bottom\\"
    | \\"top left\\"
    | \\"top right\\"
    | \\"bottom left\\"
    | \\"bottom right\\";
  posterImage?: string;
  lazyLoad?: boolean;
}

@Component({
  selector: \\"video\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <video
      preload=\\"none\\"
      [ngStyle]=\\"{
          width: '100%',
          height: '100%',
          ...attributes()?.style,
          objectFit: fit(),
          objectPosition: position(),
          // Hack to get object fit to work as expected and
          // not have the video overflow
          borderRadius: 1
        }\\"
      [attr.poster]=\\"posterImage()\\"
      [attr.autoplay]=\\"autoPlay()\\"
      [attr.muted]=\\"muted()\\"
      [attr.controls]=\\"controls()\\"
      [attr.loop]=\\"loop()\\"
      #_root
    ></video>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class Video implements AfterViewInit {
  attributes = input<VideoProps[\\"attributes\\"]>();
  fit = input<VideoProps[\\"fit\\"]>();
  position = input<VideoProps[\\"position\\"]>();
  video = input<VideoProps[\\"video\\"]>();
  posterImage = input<VideoProps[\\"posterImage\\"]>();
  autoPlay = input<VideoProps[\\"autoPlay\\"]>();
  muted = input<VideoProps[\\"muted\\"]>();
  controls = input<VideoProps[\\"controls\\"]>();
  loop = input<VideoProps[\\"loop\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"video\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > allSpread 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      Hello! I can run natively in React, Vue, Svelte, Qwik, and many more
      frameworks!
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  attributes = input<any>();
  accessHere = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  attrsUsingUseState = signal({
    hello: \\"world\\",
  });
  properties = signal({
    style: \\"color: blue\\",
    onClick: () => console.log(\\"pressed\\"),
  });
  specifics = signal({
    someSpecificState: \\"specific\\",
  });

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > arrowFunctionInUseStore 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>Hello {{name()}}</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"steve\\");

  setName(value) {
    this.name.set(value);
  }
  updateNameWithArrowFn(value) {
    this.name.set(value);
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > basicForFragment 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"basic-for-fragment\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      @for (option of ['a', 'b', 'c'];track trackByOption0;let i = $index) {
      <ng-container>
        <div>{{option}}</div>
      </ng-container>
      } @for (option of ['a', 'b', 'c'];track trackByOption1;let i = $index) {
      <ng-container>
        <div>{{option}}</div>
      </ng-container>
      }

      <select>
        @for (option of ['d', 'e', 'f'];track trackByOption2;let i = $index) {
        <option [attr.value]=\\"option\\">{{option}}</option>
        }
      </select>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class BasicForFragment implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  id = signal(\\"xyz\\");

  trackByOption0(_: number, option: any) {
    return \`key-\${option}\`;
  }
  trackByOption1(_: number, option: any) {
    return \`\${id()}-\${option}\`;
  }
  trackByOption2(_: number, option: any) {
    return \`\${id()}-\${option}\`;
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"basic-for-fragment\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > basicForNoTagReference 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-for-no-tag-ref-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <this.TagNameGetter #_root>
      Hello
      <this.tag>{{name()}}</this.tag>

      @for (action of actions();track i;let i = $index) {
      <this.TagName>
        <action.icon></action.icon>
        <span>{{action.text}}</span>
      </this.TagName>
      }
    </this.TagNameGetter>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicForNoTagRefComponent implements AfterViewInit {
  actions = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"VincentW\\");
  TagName = signal(\\"div\\");
  tag = signal(\\"span\\");

  get TagNameGetter() {
    return \\"span\\";
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-for-no-tag-ref-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > basicForwardRef 1`] = `
"--- MITOSIS ERROR ---
    Component input has an event change that uses 'event.target.xxx'. 
        This will cause an error in Angular.
        Please create a new function with the EventTarget and use e.g '(event.target as HTMLInputElement).value'"
`;

exports[`Angular signals > jsx > Typescript Test > basicForwardRefMetadata 1`] = `
"--- MITOSIS ERROR ---
    Component input has an event change that uses 'event.target.xxx'. 
        This will cause an error in Angular.
        Please create a new function with the EventTarget and use e.g '(event.target as HTMLInputElement).value'"
`;

exports[`Angular signals > jsx > Typescript Test > basicOnUpdateReturn 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-on-update-return-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>Hello! {{name()}}</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicOnUpdateReturnComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"PatrickJS\\");

  constructor() {
    effect(() => {
      // --- Mitosis: Workaround to make sure the effect() is triggered ---

      // ---

      const controller = new AbortController();
      const signal = controller.signal;
      fetch(\\"https://patrickjs.com/api/resource.json\\", {
        signal,
      })
        .then((response) => response.json())
        .then((data) => {
          this.name.set(data.name);
        });
      return () => {
        if (!signal.aborted) {
          controller.abort();
        }
      };
    });
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-on-update-return-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > basicRefAttributePassing 1`] = `
"/**
          useMetadata:
          {\\"attributePassing\\":{\\"enabled\\":true}}
          */

import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"basic-ref-attribute-passing-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <button #buttonRef #_root>Attribute Passing</button>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class BasicRefAttributePassingComponent implements AfterViewInit {
  buttonRef = viewChild<ElementRef>(\\"buttonRef\\");
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(
      element,
      \\"basic-ref-attribute-passing-component\\"
    );
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > basicRefAttributePassingCustomRef 1`] = `
"/**
          useMetadata:
          {\\"attributePassing\\":{\\"enabled\\":true,\\"customRef\\":\\"buttonRef\\"}}
          */

import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"basic-ref-attribute-passing-custom-ref-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div><button #buttonRef>Attribute Passing</button></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class BasicRefAttributePassingCustomRefComponent
  implements AfterViewInit
{
  buttonRef = viewChild<ElementRef>(\\"buttonRef\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this.buttonRef()?.nativeElement;
    this.enableAttributePassing(
      element,
      \\"basic-ref-attribute-passing-custom-ref-component\\"
    );
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > changeDetection 1`] = `
"/**
          useMetadata:
          {\\"angular\\":{\\"changeDetection\\":\\"OnPush\\"}}
          */

import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  ChangeDetectionStrategy,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>{{count()}}</div>
  \`,
  changeDetection: \\"ChangeDetectionStrategy.OnPush\\",
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  count = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > class + ClassName + css 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import MyComp from \\"./my-component.js\\";

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule, MyComp],
  template: \`
    <div #_root>
      <my-comp class=\\"test\\" className=\\"test2\\">
        Hello! I can run in React, Vue, Solid, or Liquid!
      </my-comp>
      <div class=\\"test2 test div\\">
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>
    </div>
  \`,
  styles: \`:host { display: contents; }
        .div {
          padding: 10px;
        }
\`,
})
export class MyBasicComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > class + css 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div class=\\"test div\\" #_root>
      Hello! I can run in React, Vue, Solid, or Liquid!
    </div>
  \`,
  styles: \`:host { display: contents; }
        .div {
          padding: 10px;
        }
\`,
})
export class MyBasicComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > className + css 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div class=\\"test div\\" #_root>
      Hello! I can run in React, Vue, Solid, or Liquid!
    </div>
  \`,
  styles: \`:host { display: contents; }
        .div {
          padding: 10px;
        }
\`,
})
export class MyBasicComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > className 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

type Props = {
  [key: string]: string | JSX.Element;
  slotTesting: JSX.Element;
};

import type { JSX } from \\"../../../../jsx-runtime\\";

@Component({
  selector: \\"class-name-code\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      <div class=\\"no binding\\">Without Binding</div>
      <div [class]=\\"bindings()\\">With binding</div>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class ClassNameCode implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  bindings = signal(\\"a binding\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"class-name-code\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > classState 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div [class]=\\"classState() + ' div'\\" [ngStyle]=\\"styleState()\\" #_root>
      Hello! I can run in React, Vue, Solid, or Liquid!
    </div>
  \`,
  styles: \`:host { display: contents; }
        .div {
          padding: 10px;
        }
\`,
})
export class MyBasicComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  classState = signal(\\"testClassName\\");
  styleState = signal({
    color: \\"red\\",
  });

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > classnameProps 1`] = `
"/**
          useMetadata:
          {\\"stencil\\":{\\"propOptions\\":{\\"className\\":{\\"attribute\\":\\"classname\\",\\"mutable\\":false,\\"reflect\\":false}}}}
          */

import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

type Props = {
  children: any;
  className: string;
  type: string;
};

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div [class]=\\"className()\\" #_root>
      <ng-content></ng-content>
      {{type()}} Hello! I can run in React, Vue, Solid, or Liquid!
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicComponent implements AfterViewInit {
  className = input<Props[\\"className\\"]>();
  type = input<Props[\\"type\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > complexMeta 1`] = `
"/**
          useMetadata:
          {\\"x\\":\\"y\\",\\"asdf\\":{\\"stringValue\\":\\"d\\",\\"booleanValue\\":true,\\"numberValue\\":1,\\"innerObject\\":{\\"stringValue\\":\\"inner\\",\\"numberValue\\":2,\\"booleanValue\\":false},\\"spreadStringValue\\":\\"f\\"}}
          */

import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"complex-meta-raw\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class ComplexMetaRaw implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"complex-meta-raw\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > componentWithContext 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

export interface ComponentWithContextProps {
  content: string;
}

import Context1 from \\"@dummy/1\\";
import Context2 from \\"@dummy/2\\";

@Component({
  selector: \\"component-with-context\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <ng-container>
      <ng-container>{{foo.value}}</ng-container>
    </ng-container>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class ComponentWithContext implements AfterViewInit {
  content = input<ComponentWithContextProps[\\"content\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor(public foo: Context1) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"component-with-context\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > componentWithContextMultiRoot 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

export interface ComponentWithContextProps {
  content: string;
}

import Context1 from \\"@dummy/1\\";
import Context2 from \\"@dummy/2\\";

@Component({
  selector: \\"component-with-context\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <ng-container>
      <ng-container>{{foo.value}}</ng-container>
      <div>other</div>
    </ng-container>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class ComponentWithContext implements AfterViewInit {
  content = input<ComponentWithContextProps[\\"content\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor(public foo: Context1) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"component-with-context\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > contentState 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import BuilderContext from \\"@dummy/context.js\\";

@Component({
  selector: \\"render-content\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>setting context</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class RenderContent implements AfterViewInit {
  content = input<any>();
  customComponents = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"render-content\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > customSelector 1`] = `
"/**
          useMetadata:
          {\\"angular\\":{\\"selector\\":\\"not-my-component\\"}}
          */

import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <span #_root>My selector shouldn't be my-component!</span>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > defaultProps 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  output,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

export interface ButtonProps {
  attributes?: any;
  text?: string;
  buttonText?: string; // no default value

  link?: string;
  openLinkInNewTab?: boolean;
  onClick?: () => void;
}
const defaultProps = {
  text: \\"default text\\",
  link: \\"https://builder.io/\\",
  openLinkInNewTab: false,
  onClick: () => {
    console.log(\\"hi\\");
  },
};

@Component({
  selector: \\"button\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      @if(link()){
      <a
        [attr.href]=\\"link()\\"
        [attr.target]=\\"openLinkInNewTab() ? '_blank' : undefined\\"
      >
        {{text()}}
      </a>
      } @if(!link()){
      <button type=\\"button\\" (click)=\\"click.emit()\\">{{buttonText()}}</button>
      }
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class Button implements AfterViewInit {
  link = input<ButtonProps[\\"link\\"]>(defaultProps[\\"link\\"]);
  attributes = input<ButtonProps[\\"attributes\\"]>();
  openLinkInNewTab = input<ButtonProps[\\"openLinkInNewTab\\"]>(
    defaultProps[\\"openLinkInNewTab\\"]
  );
  text = input<ButtonProps[\\"text\\"]>(defaultProps[\\"text\\"]);
  buttonText = input<ButtonProps[\\"buttonText\\"]>();
  click = output<Parameters<Required<ButtonProps>[\\"onClick\\"]>[number] | void>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"button\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > defaultPropsOutsideComponent 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  output,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

export interface ButtonProps {
  attributes?: any;
  text?: string;
  link?: string;
  openLinkInNewTab?: boolean;
  onClick: () => void;
}
const defaultProps = {
  text: \\"default text\\",
  link: \\"https://builder.io/\\",
  openLinkInNewTab: false,
  onClick: () => {},
};

@Component({
  selector: \\"button\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      @if(link()){
      <a
        [attr.href]=\\"link()\\"
        [attr.target]=\\"openLinkInNewTab() ? '_blank' : undefined\\"
      >
        {{text()}}
      </a>
      } @if(!link()){
      <button type=\\"button\\" (click)=\\"click.emit($event)\\">{{text()}}</button>
      }
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class Button implements AfterViewInit {
  link = input<ButtonProps[\\"link\\"]>(defaultProps[\\"link\\"]);
  attributes = input<ButtonProps[\\"attributes\\"]>();
  openLinkInNewTab = input<ButtonProps[\\"openLinkInNewTab\\"]>(
    defaultProps[\\"openLinkInNewTab\\"]
  );
  text = input<ButtonProps[\\"text\\"]>(defaultProps[\\"text\\"]);
  click = output<Parameters<Required<ButtonProps>[\\"onClick\\"]>[number] | void>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"button\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > defaultValsWithTypes 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

type Props = {
  name: string;
};

const DEFAULT_VALUES: Props = {
  name: \\"Sami\\",
};

@Component({
  selector: \\"component-with-types\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>Hello {{name() || DEFAULT_VALUES.name}}</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class ComponentWithTypes implements AfterViewInit {
  name = input<Props[\\"name\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"component-with-types\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > dynamicComponent 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <this.obj.Component hello=\\"world\\" (click)=\\"onClick()\\" #_root>
      hello

      <ng-content></ng-content>
    </this.obj.Component>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  attributes = input<any>();
  something = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  obj = signal({
    name: \\"foo\\",
    Component: FooComponent,
  });

  onClick() {
    console.log(\\"hello\\");
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > dynamicComponentWithEventArg 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <this.Component hello=\\"world\\" (click)=\\"onClick($event)\\" #_root>
      hello
    </this.Component>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  attributes = input<any>();
  something = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  Component = signal(HelloComponent);

  onClick(event: any) {
    console.log(\\"hello\\", event);
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > eventInputAndChange 1`] = `
"--- MITOSIS ERROR ---
    Component input has an event input that uses 'event.target.xxx'. 
        This will cause an error in Angular.
        Please create a new function with the EventTarget and use e.g '(event.target as HTMLInputElement).value'"
`;

exports[`Angular signals > jsx > Typescript Test > eventProps 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  output,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { EventProps, EventState } from \\"./event-props.type\\";

@Component({
  selector: \\"event-props-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <button (click)=\\"handleClick()\\" #_root>Test</button>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class EventPropsComponent implements AfterViewInit {
  getVoid = output<
    Parameters<Required<EventProps>[\\"onGetVoid\\"]>[number] | void
  >();
  enter = output<Parameters<Required<EventProps>[\\"onEnter\\"]>[number] | void>();

  _root = viewChild<ElementRef>(\\"_root\\");

  handleClick() {
    if (this.getVoid) {
      this.getVoid.emit();
    }

    if (this.enter) {
      console.log(this.enter.emit());
    }
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"event-props-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > expressionState 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>{{refToUse()}}</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  componentRef = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  refToUse = signal(
    !(this.componentRef() instanceof Function) ? this.componentRef : null
  );

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > figmaMeta 1`] = `
"/**
          useMetadata:
          {\\"figma\\":{\\"name\\":\\"def-button-beta-outlined\\",\\"url\\":\\"https://www.figma.com/xxx\\",\\"props\\":{\\"iconSmall\\":{\\"type\\":\\"instance\\",\\"key\\":\\"📍 Icon Small\\"},\\"iconMedium\\":{\\"type\\":\\"instance\\",\\"key\\":\\"📍 Icon Medium\\"},\\"label\\":{\\"type\\":\\"string\\",\\"key\\":\\"✏️ Label\\"},\\"icon\\":{\\"type\\":\\"boolean\\",\\"key\\":\\"👁️ Icon\\",\\"value\\":{\\"false\\":false,\\"true\\":\\"placeholder\\"}},\\"interactiveState\\":{\\"type\\":\\"enum\\",\\"key\\":\\"Interactive State\\",\\"value\\":{\\"(Def) Enabled\\":false,\\"Hovered\\":false,\\"Pressed\\":false,\\"Focused\\":false,\\"Disabled\\":\\"true\\"}},\\"size\\":{\\"type\\":\\"enum\\",\\"key\\":\\"Size\\",\\"value\\":{\\"(Def) Medium\\":false,\\"Small\\":\\"small\\"}},\\"width\\":{\\"type\\":\\"enum\\",\\"key\\":\\"Width\\",\\"value\\":{\\"(Def) Auto Width\\":false,\\"Full Width\\":\\"full\\"}}}}}
          */

import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"figma-button\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <button
      [attr.data-icon]=\\"icon()\\"
      [attr.data-disabled]=\\"interactiveState()\\"
      [attr.data-width]=\\"width()\\"
      [attr.data-size]=\\"size()\\"
      #_root
    >
      {{label()}}
    </button>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class FigmaButton implements AfterViewInit {
  icon = input<any>();
  interactiveState = input<any>();
  width = input<any>();
  size = input<any>();
  label = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"figma-button\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > functionProps 1`] = `
"unknown: --- MITOSIS ERROR ---
    Component MyBasicComponent has a BlockStatement inside JSX'. 
        This will cause an error in Angular.
        Please create and call a new function instead with this code:
        x => {}"
`;

exports[`Angular signals > jsx > Typescript Test > getterState 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

export interface ButtonProps {
  foo: string;
}

@Component({
  selector: \\"button\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      <p>{{foo2()}}</p>
      <p>{{bar()}}</p>
      <p>{{baz(1)}}</p>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class Button implements AfterViewInit {
  foo = input<ButtonProps[\\"foo\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  get foo2() {
    return this.foo() + \\"foo\\";
  }
  get bar() {
    return \\"bar\\";
  }
  baz(i: number) {
    return i + this.foo2.length;
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"button\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > import types 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

type RenderContentProps = {
  options?: GetContentOptions;
  content: BuilderContent;
  renderContentProps: RenderBlockProps;
};

import { BuilderContent, GetContentOptions } from \\"@builder.io/sdk\\";
import RenderBlock, { RenderBlockProps } from \\"./builder-render-block.raw\\";

@Component({
  selector: \\"render-content\\",
  standalone: true,
  imports: [CommonModule, RenderBlock],
  template: \`
    <render-block #_root></render-block>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class RenderContent implements AfterViewInit {
  renderContentProps = input<RenderContentProps[\\"renderContentProps\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  getRenderContentProps(block, index) {
    return {
      block: block,
      index: index,
    };
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"render-content\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > importRaw 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-import-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>Testing which imports get excluded!</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyImportComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-import-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > layerName 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-layer-name-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <section #_root>
      <div $name=\\"🌟layer-name\\" class=\\"layer-name\\">
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>
    </section>
  \`,
  styles: \`:host { display: contents; }
        .layer-name {
          padding: 10px;
        }
\`,
})
export class MyLayerNameComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-layer-name-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > multipleOnUpdate 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"multiple-on-update\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MultipleOnUpdate implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {
    effect(() => {
      // --- Mitosis: Workaround to make sure the effect() is triggered ---

      // ---

      console.log(\\"Runs on every update/rerender\\");
    });
    effect(() => {
      // --- Mitosis: Workaround to make sure the effect() is triggered ---

      // ---

      console.log(\\"Runs on every update/rerender as well\\");
    });
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"multiple-on-update\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > multipleOnUpdateWithDeps 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"multiple-on-update-with-deps\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MultipleOnUpdateWithDeps implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  a = signal(\\"a\\");
  b = signal(\\"b\\");
  c = signal(\\"c\\");
  d = signal(\\"d\\");

  constructor() {
    effect(() => {
      // --- Mitosis: Workaround to make sure the effect() is triggered ---

      // ---

      console.log(\\"Runs when a or b changes\\", this.a(), this.b());

      if (this.a() === \\"a\\") {
        this.a.set(\\"b\\");
      }
    });
    effect(() => {
      // --- Mitosis: Workaround to make sure the effect() is triggered ---

      // ---

      console.log(\\"Runs when c or d changes\\", this.c(), this.d());

      if (this.a() === \\"a\\") {
        this.a.set(\\"b\\");
      }
    });
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"multiple-on-update-with-deps\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > multipleSpreads 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <input #_root />
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  attrs = signal({
    hello: \\"world\\",
  });

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > nativeAttributes 1`] = `
"/**
          useMetadata:
          {\\"angular\\":{\\"nativeAttributes\\":[\\"disabled\\"]}}
          */

import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      <input [disabled]=\\"disabled()\\" />

      Hello! If someone passes \\\\\`[disabled]=\\"false\\"\\\\\` to me, disabled shouldn't
      be visible in the DOM.
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  disabled = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > nestedShow 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

interface Props {
  conditionA: boolean;
  conditionB: boolean;
}

@Component({
  selector: \\"nested-show\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    @if(conditionA()){ @if(!conditionB()){
    <div>if condition A and condition B</div>
    }@else{
    <div>else-condition-B</div>
    } }@else{
    <div>else-condition-A</div>
    }
  \`,
  styles: \`:host { display: contents; }\`,
})
export class NestedShow implements AfterViewInit {
  conditionA = input<Props[\\"conditionA\\"]>();
  conditionB = input<Props[\\"conditionB\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"nested-show\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > nestedStyles 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"nested-styles\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div class=\\"div\\" #_root>Hello world</div>
  \`,
  styles: \`:host { display: contents; }
        .div {
          display: flex;
          --bar: red;
          color: var(--bar);
        }
        @media (max-width: env(--mobile)) {
          .div {
            display: block;
          }
        }
        .div:hover {
          display: flex;
        }
        .div:active {
          display: inline;
        }
        .div .nested-selector {
          display: grid;
        }
        .div .nested-selector:hover {
          display: block;
        }
        .div.nested-selector:active {
          display: inline-block;
        }
\`,
})
export class NestedStyles implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"nested-styles\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > normalizeLayerNames 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

export interface MyNormalizedLayerNamesComponentProps {
  id: string;
}

@Component({
  selector: \\"my-normalized-layer-names-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <section #_root>
      <div $name=\\"🌟layer-name\\">Emoji</div>
      <div $name=\\"---\\">Dashes</div>
      <div $name=\\"CamelCase\\">CamelCase</div>
      <div $name=\\"123my@Class-Name!\\">Special chars</div>
      <div $name=\\"--my--@custom--name--\\">Special chars with dashes</div>
      <div $name=\\"0\\" class=\\"css-0\\">Single Number</div>
      <div $name=\\"123\\" class=\\"css-123\\">Multiple Numbers</div>
      <div $name=\\"name123\\" class=\\"name-123\\">Chars with numbers at end</div>
      <div $name=\\"456name\\" class=\\"name\\">Chars with numbers at start</div>
      <div $name=\\"name-789\\" class=\\"name-789\\">Numnbers separated by dash</div>
      <div $name=\\"🚀\\">Emoji</div>
      <div data-name=\\"1\\" class=\\"div\\">Number</div>
    </section>
  \`,
  styles: \`:host { display: contents; }
        .css-0 {
          margin: 10px;
        }
        .css-123 {
          padding: 10px;
        }
        .name-123 {
          border: 1px solid;
        }
        .name {
          color: red;
        }
        .name-789 {
          background: blue;
        }
        .div {
          background: blue;
        }
\`,
})
export class MyNormalizedLayerNamesComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-normalized-layer-names-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > onEvent 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"embed\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div class=\\"builder-embed\\" #elem #_root><div>Test</div></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class Embed implements AfterViewInit {
  elem = viewChild<ElementRef>(\\"elem\\");
  _root = viewChild<ElementRef>(\\"_root\\");

  foo(event) {
    console.log(\\"test2\\");
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.elem()?.nativeElement.dispatchEvent(
      new CustomEvent(\\"initEditingBldr\\")
    );
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"embed\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > onInit & onMount 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"on-init\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class OnInit implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    console.log(\\"onInit\\");
    console.log(\\"onMount\\");
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"on-init\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > onInit 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

type Props = {
  name: string;
};

export const defaultValues = {
  name: \\"PatrickJS\\",
};

@Component({
  selector: \\"on-init\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>Default name defined by parent {{name()}}</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class OnInit implements AfterViewInit {
  name = input<Props[\\"name\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.name.set(defaultValues.name || this.name);
    console.log(\\"set defaults with props\\");
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"on-init\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > onInitPlain 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"on-init-plain\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class OnInitPlain implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    console.log(\\"onInit\\");
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"on-init-plain\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > onMount 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"comp\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class Comp implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    console.log(\\"Runs on mount\\");
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"comp\\");
  }

  ngOnDestroy() {
    console.log(\\"Runs on unMount\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > onMountMultiple 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"comp\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class Comp implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    const onMountHook_0 = () => {
      console.log(\\"Runs on mount\\");
    };
    onMountHook_0();
    const onMountHook_1 = () => {
      console.log(\\"Another one runs on Mount\\");
    };
    onMountHook_1();
    const onMountHook_2 = () => {
      console.log(\\"SSR runs on Mount\\");
    };
    onMountHook_2();
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"comp\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > onUpdate 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"on-update\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class OnUpdate implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {
    effect(() => {
      // --- Mitosis: Workaround to make sure the effect() is triggered ---

      // ---

      console.log(\\"Runs on every update/rerender\\");
    });
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"on-update\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > onUpdateWithDeps 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

type Props = {
  size: string;
};

@Component({
  selector: \\"on-update-with-deps\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class OnUpdateWithDeps implements AfterViewInit {
  size = input<Props[\\"size\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  a = signal(\\"a\\");
  b = signal(\\"b\\");

  constructor() {
    effect(() => {
      // --- Mitosis: Workaround to make sure the effect() is triggered ---

      // ---

      console.log(
        \\"Runs when a, b or size changes\\",
        this.a(),
        this.b(),
        this.size()
      );
    });
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"on-update-with-deps\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > outputEventBinding 1`] = `
"--- MITOSIS ERROR ---
    Component input has an event change that uses 'event.target.xxx'. 
        This will cause an error in Angular.
        Please create a new function with the EventTarget and use e.g '(event.target as HTMLInputElement).value'"
`;

exports[`Angular signals > jsx > Typescript Test > preserveExportOrLocalStatement 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

type Types = {
  s: any[];
};
interface IPost {
  len: number;
}
export interface MyBasicComponentProps {
  id: string;
}

const b = 3;
const foo = () => {};
export const a = 3;
export const bar = () => {};
export function run<T>(value: T) {}

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > preserveTyping 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

export type A = \\"test\\";
export interface C {
  n: \\"test\\";
}
type B = \\"test2\\";
interface D {
  n: \\"test\\";
}
export interface MyBasicComponentProps {
  name: string;
  age?: number;
}

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      Hello! I can run in React, Vue, Solid, or Liquid! {{name()}}
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicComponent implements AfterViewInit {
  name = input<MyBasicComponentProps[\\"name\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > propsDestructure 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

type Props = {
  children: any;
  type: string;
};

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      <ng-content></ng-content>
      {{type()}} Hello! I can run in React, Vue, Solid, or Liquid!
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicComponent implements AfterViewInit {
  type = input<Props[\\"type\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"Decadef20\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > propsInterface 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

interface Person {
  name: string;
  age?: number;
}

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      Hello! I can run in React, Vue, Solid, or Liquid! {{name()}}
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicComponent implements AfterViewInit {
  name = input<Person | never[\\"name\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > propsType 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

type Person = {
  name: string;
  age?: number;
};

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      Hello! I can run in React, Vue, Solid, or Liquid! {{name()}}
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicComponent implements AfterViewInit {
  name = input<Person[\\"name\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > referencingFunInsideHook 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"on-update\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class OnUpdate implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  foo(params) {}
  bar() {}
  zoo() {
    const params = {
      cb: this.bar,
    };
  }

  constructor() {
    effect(() => {
      // --- Mitosis: Workaround to make sure the effect() is triggered ---

      // ---

      this.foo({
        someOption: this.bar,
      });
    });
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"on-update\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > renderBlock 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

export type RenderBlockProps = {
  block: BuilderBlock;
  context: BuilderContextInterface;
};

import { TARGET } from \\"../../constants/target.js\\";
import type {
  BuilderContextInterface,
  RegisteredComponent,
} from \\"../../context/types.js\\";
import { evaluate } from \\"../../functions/evaluate.js\\";
import { extractTextStyles } from \\"../../functions/extract-text-styles.js\\";
import { getBlockActions } from \\"../../functions/get-block-actions.js\\";
import { getBlockComponentOptions } from \\"../../functions/get-block-component-options.js\\";
import { getBlockProperties } from \\"../../functions/get-block-properties.js\\";
import { getBlockTag } from \\"../../functions/get-block-tag.js\\";
import { getProcessedBlock } from \\"../../functions/get-processed-block.js\\";
import { getReactNativeBlockStyles } from \\"../../functions/get-react-native-block-styles.js\\";
import type { BuilderBlock } from \\"../../types/builder-block.js\\";
import type { Nullable } from \\"../../types/typescript.js\\";
import BlockStyles from \\"./block-styles.js\\";
import { isEmptyHtmlElement } from \\"./render-block.helpers.js\\";
import RenderComponentWithContext from \\"./render-component-with-context.js\\";
import type { RenderComponentProps } from \\"./render-component.js\\";
import RenderComponent from \\"./render-component.js\\";
import RenderRepeatedBlock from \\"./render-repeated-block.js\\";
import type { RepeatData } from \\"./types.js\\";

@Component({
  selector: \\"render-block\\",
  standalone: true,
  imports: [CommonModule, RenderRepeatedBlock, RenderBlock, BlockStyles],
  template: \`
    @if(shouldWrap()){ @if(isEmptyHtmlElement(tag)){
    <this.tag></this.tag>
    } @if(!isEmptyHtmlElement(tag) && repeatItemData()){ @for (data of
    repeatItemData();track trackByData0;let index = $index) {
    <render-repeated-block
      [repeatContext]=\\"data.context\\"
      [block]=\\"data.block\\"
    ></render-repeated-block>
    } } @if(!isEmptyHtmlElement(tag) && !repeatItemData()){
    <this.tag>
      <this.renderComponentTag></this.renderComponentTag>

      @for (child of childrenWithoutParentComponent();track trackByChild1;let i
      = $index) {
      <render-block
        [block]=\\"child\\"
        [context]=\\"childrenContext()\\"
      ></render-block>
      } @for (child of childrenWithoutParentComponent();track trackByChild2;let
      i = $index) {
      <block-styles
        [block]=\\"child\\"
        [context]=\\"childrenContext()\\"
      ></block-styles>
      }
    </this.tag>
    } }@else{
    <this.renderComponentTag></this.renderComponentTag>
    }
  \`,
  styles: \`:host { display: contents; }\`,
})
export class RenderBlock implements AfterViewInit {
  block = input<RenderBlockProps[\\"block\\"]>();
  context = input<RenderBlockProps[\\"context\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  get component() {
    const componentName = getProcessedBlock({
      block: this.block,
      state: this.context.state,
      context: this.context.context,
      shouldEvaluateBindings: false,
    }).component?.name;

    if (!componentName) {
      return null;
    }

    const ref = this.context.registeredComponents[componentName];

    if (!ref) {
      // TODO: Public doc page with more info about this message
      console.warn(\`
          Could not find a registered component named \\"\${componentName}\\".
          If you registered it, is the file that registered it imported by the file that needs to render it?\`);
      return undefined;
    } else {
      return ref;
    }
  }
  get tag() {
    return getBlockTag(this.useBlock());
  }
  get useBlock() {
    return this.repeatItemData
      ? this.block
      : getProcessedBlock({
          block: this.block,
          state: this.context.state,
          context: this.context.context,
          shouldEvaluateBindings: true,
        });
  }
  get actions() {
    return getBlockActions({
      block: this.useBlock,
      state: this.context.state,
      context: this.context.context,
    });
  }
  get attributes() {
    const blockProperties = getBlockProperties(this.useBlock());
    return {
      ...blockProperties,
      ...(TARGET === \\"reactNative\\"
        ? {
            style: getReactNativeBlockStyles({
              block: this.useBlock,
              context: this.context,
              blockStyles: blockProperties.style,
            }),
          }
        : {}),
    };
  }
  get shouldWrap() {
    return !this.component?.noWrap;
  }
  get renderComponentProps() {
    return {
      blockChildren: this.useChildren,
      componentRef: this.component?.component,
      componentOptions: {
        ...getBlockComponentOptions(this.useBlock()),

        /**
         * These attributes are passed to the wrapper element when there is one. If \`noWrap\` is set to true, then
         * they are provided to the component itself directly.
         */
        ...(this.shouldWrap
          ? {}
          : {
              attributes: { ...this.attributes, ...this.actions },
            }),
        customBreakpoints: this.childrenContext?.content?.meta?.breakpoints,
      },
      context: this.childrenContext,
    };
  }
  get useChildren() {
    // TO-DO: When should \`canHaveChildren\` dictate rendering?
    // This is currently commented out because some Builder components (e.g. Box) do not have \`canHaveChildren: true\`,
    // but still receive and need to render children.
    // return state.componentInfo?.canHaveChildren ? state.useBlock.children : [];
    return this.useBlock.children ?? [];
  }
  get childrenWithoutParentComponent() {
    /**
     * When there is no \`componentRef\`, there might still be children that need to be rendered. In this case,
     * we render them outside of \`componentRef\`.
     * NOTE: We make sure not to render this if \`repeatItemData\` is non-null, because that means we are rendering an array of
     * blocks, and the children will be repeated within those blocks.
     */
    const shouldRenderChildrenOutsideRef =
      !this.component?.component && !this.repeatItemData;
    return shouldRenderChildrenOutsideRef ? this.useChildren : [];
  }
  get repeatItemData() {
    /**
     * we don't use \`state.useBlock\` here because the processing done within its logic includes evaluating the block's bindings,
     * which will not work if there is a repeat.
     */
    const { repeat, ...blockWithoutRepeat } = this.block;

    if (!repeat?.collection) {
      return undefined;
    }

    const itemsArray = evaluate({
      code: repeat.collection,
      state: this.context.state,
      context: this.context.context,
    });

    if (!Array.isArray(itemsArray)) {
      return undefined;
    }

    const collectionName = repeat.collection.split(\\".\\").pop();
    const itemNameToUse =
      repeat.itemName || (collectionName ? collectionName + \\"Item\\" : \\"item\\");
    const repeatArray = itemsArray.map<RepeatData>((item, index) => ({
      context: {
        ...this.context,
        state: {
          ...this.context.state,
          $index: index,
          $item: item,
          [itemNameToUse]: item,
          [\`$\${itemNameToUse}Index\`]: index,
        },
      },
      block: blockWithoutRepeat,
    }));
    return repeatArray;
  }
  get inheritedTextStyles() {
    if (TARGET !== \\"reactNative\\") {
      return {};
    }

    const styles = getReactNativeBlockStyles({
      block: this.useBlock,
      context: this.context,
      blockStyles: this.attributes.style,
    });
    return extractTextStyles(styles);
  }
  get childrenContext() {
    return {
      apiKey: this.context.apiKey,
      state: this.context.state,
      content: this.context.content,
      context: this.context.context,
      registeredComponents: this.context.registeredComponents,
      inheritedStyles: this.inheritedTextStyles,
    };
  }
  get renderComponentTag() {
    if (TARGET === \\"reactNative\\") {
      return RenderComponentWithContext;
    } else if (TARGET === \\"vue3\\") {
      // vue3 expects a string for the component tag
      return \\"RenderComponent\\";
    } else {
      return RenderComponent;
    }
  }
  trackByData0(index: number, data: any) {
    return index;
  }
  trackByChild1(_: number, child: any) {
    return \\"render-block-\\" + child.id;
  }
  trackByChild2(_: number, child: any) {
    return \\"block-style-\\" + child.id;
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"render-block\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > renderContentExample 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

type Props = {
  customComponents: string[];
  content: {
    blocks: any[];
    id: string;
  };
};

import BuilderContext from \\"@dummy/context.js\\";
import {
  dispatchNewContentToVisualEditor,
  sendComponentsToVisualEditor,
  trackClick,
} from \\"@dummy/injection-js\\";
import RenderBlocks from \\"@dummy/RenderBlocks.js\\";

@Component({
  selector: \\"render-content\\",
  standalone: true,
  imports: [CommonModule, RenderBlocks],
  template: \`
    <div class=\\"div\\" (click)=\\"trackClick(content().id)\\" #_root>
      <render-blocks [blocks]=\\"content().blocks\\"></render-blocks>
    </div>
  \`,
  styles: \`:host { display: contents; }
        .div {
          display: flex;
          flex-direction: columns;
        }
\`,
})
export class RenderContent implements AfterViewInit {
  customComponents = input<Props[\\"customComponents\\"]>();
  content = input<Props[\\"content\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {
    effect(() => {
      // --- Mitosis: Workaround to make sure the effect() is triggered ---

      // ---

      dispatchNewContentToVisualEditor(this.content());
    });
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    sendComponentsToVisualEditor(this.customComponents());
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"render-content\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > rootFragmentMultiNode 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

export interface ButtonProps {
  attributes?: any;
  text?: string;
  link?: string;
  openLinkInNewTab?: boolean;
}

@Component({
  selector: \\"button\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <ng-container>
      @if(link()){
      <a
        [attr.href]=\\"link()\\"
        [attr.target]=\\"openLinkInNewTab() ? '_blank' : undefined\\"
      >
        {{text()}}
      </a>
      } @if(!link()){
      <button type=\\"button\\">{{text()}}</button>
      }
    </ng-container>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class Button implements AfterViewInit {
  link = input<ButtonProps[\\"link\\"]>();
  attributes = input<ButtonProps[\\"attributes\\"]>();
  openLinkInNewTab = input<ButtonProps[\\"openLinkInNewTab\\"]>();
  text = input<ButtonProps[\\"text\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"button\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > rootShow 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

export interface RenderStylesProps {
  foo: string;
}

@Component({
  selector: \\"render-styles\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    @if(foo() === 'bar'){
    <div>Bar</div>
    }@else{
    <div>Foo</div>
    }
  \`,
  styles: \`:host { display: contents; }\`,
})
export class RenderStyles implements AfterViewInit {
  foo = input<RenderStylesProps[\\"foo\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"render-styles\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > sanitizeInnerHTML 1`] = `
"/**
          useMetadata:
          {\\"angular\\":{\\"sanitizeInnerHTML\\":true}}
          */

import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div [innerHTML]=\\"html()\\" #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  html = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > self-referencing component 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule, MyComponent],
  template: \`
    <div #_root>
      {{name()}} @if(name() === 'Batman'){
      <my-component name=\\"Bruce Wayne\\"></my-component>
      }
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  name = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > self-referencing component with children 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule, MyComponent],
  template: \`
    <div #_root>
      {{name()}}
      <ng-content></ng-content>
      @if(name() === 'Batman'){
      <my-component name=\\"Bruce\\"><div>Wayne</div></my-component>
      }
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  name = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > setState 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"set-state\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root><button (click)=\\"someFn()\\">Click me</button></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class SetState implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  n = signal([\\"123\\"]);

  someFn() {
    this.n[0] = \\"123\\";
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"set-state\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > showExpressions 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

interface Props {
  conditionA: boolean;
  conditionB: boolean;
}

@Component({
  selector: \\"show-with-other-values\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      @if(conditionA()){ Content0 }@else{ ContentA } @if(conditionA()){ ContentA
      } @if(conditionA()){ }@else{ ContentA } @if(conditionA()){ ContentB
      }@else{
      {{undefined}} } @if(conditionA()){ {{undefined}} }@else{ ContentB }
      @if(conditionA()){ ContentC } @if(conditionA()){ }@else{ ContentC }
      @if(conditionA()){ ContentD } @if(conditionA()){ }@else{ ContentD }
      @if(conditionA()){ ContentE }@else{ hello } @if(conditionA()){ hello
      }@else{ ContentE } @if(conditionA()){ ContentF }@else{ 123 }
      @if(conditionA()){ 123 }@else{ ContentF } @if(conditionA() === 'Default'){
      4mb }@else{ @if(conditionB() === 'Complete'){ 20mb }@else{ 9mb } }
      @if(conditionA() === 'Default'){ @if(conditionB() === 'Complete'){ 20mb
      }@else{ 9mb } }@else{ 4mb } @if(conditionA() === 'Default'){
      @if(conditionB() === 'Complete'){
      <div>complete</div>
      }@else{ 9mb } }@else{ @if(conditionC() === 'Complete'){ dff }@else{
      <div>complete else</div>
      } }
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class ShowWithOtherValues implements AfterViewInit {
  conditionA = input<Props[\\"conditionA\\"]>();
  conditionB = input<Props[\\"conditionB\\"]>();
  conditionC = input<Props[\\"conditionC\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"show-with-other-values\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > showWithFor 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

interface Props {
  conditionA: boolean;
  items: string[];
}

@Component({
  selector: \\"nested-show\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    @if(conditionA()){ @for (item of items();track trackByItem0;let idx =
    $index) {
    <div>{{item}}</div>
    } }@else{
    <div>else-condition-A</div>
    }
  \`,
  styles: \`:host { display: contents; }\`,
})
export class NestedShow implements AfterViewInit {
  conditionA = input<Props[\\"conditionA\\"]>();
  items = input<Props[\\"items\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  trackByItem0(idx: number, item: any) {
    return idx;
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"nested-show\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > showWithOtherValues 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

interface Props {
  conditionA: boolean;
}

@Component({
  selector: \\"show-with-other-values\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      @if(conditionA()){ ContentA } @if(conditionA()){ ContentB }@else{
      {{undefined}} } @if(conditionA()){ ContentC } @if(conditionA()){ ContentD
      } @if(conditionA()){ ContentE }@else{ hello } @if(conditionA()){ ContentF
      }@else{ 123 }
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class ShowWithOtherValues implements AfterViewInit {
  conditionA = input<Props[\\"conditionA\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"show-with-other-values\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > showWithRootText 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

interface Props {
  conditionA: boolean;
}

@Component({
  selector: \\"show-root-text\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    @if(conditionA()){ ContentA }@else{
    <div>else-condition-A</div>
    }
  \`,
  styles: \`:host { display: contents; }\`,
})
export class ShowRootText implements AfterViewInit {
  conditionA = input<Props[\\"conditionA\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"show-root-text\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > signals 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  output,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

type Props = {
  label: string;
  testInput: string;
  onTestOutput?: () => void;
};
type Store = {
  _counter: number;
  _innerText: string;
  handleOutput: () => void;
};
const defaultProps = { testInput: \\"Test\\", label: \\"Bla\\" };

@Component({
  selector: \\"signals-test-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <button
      [attr.aria-label]=\\"label()\\"
      #buttonRef
      (click)=\\"handleOutput()\\"
      #_root
    >
      {{testInput()}}
    </button>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class SignalsTestComponent implements AfterViewInit {
  testInput = input<Props[\\"testInput\\"]>(defaultProps[\\"testInput\\"]);
  label = input<Props[\\"label\\"]>(defaultProps[\\"label\\"]);
  testOutput = output<
    Parameters<Required<Props>[\\"onTestOutput\\"]>[number] | void
  >();

  buttonRef = viewChild<ElementRef>(\\"buttonRef\\");
  _root = viewChild<ElementRef>(\\"_root\\");

  _counter = signal<Store[\\"_counter\\"]>(0);
  _innerText = signal<Store[\\"_innerText\\"]>(\\"a\\");

  handleOutput() {
    this._counter.update((_counter) => {
      _counter++;
      return _counter;
    });

    this._innerText.set(\\"b\\");

    console.log(this.testInput(), this._counter());

    if (this.testOutput) {
      this.testOutput.emit();
    }
  }

  constructor() {
    effect(() => {
      // --- Mitosis: Workaround to make sure the effect() is triggered ---
      this.buttonRef();
      // ---

      console.log(this._counter(), this.buttonRef()?.nativeElement);
      this.buttonRef()?.nativeElement?.setAttribute(
        \\"data-counter\\",
        this._counter().toString()
      );
    });
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"signals-test-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > signalsOnUpdate 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

type Props = {
  id: string;
  foo: {
    bar: {
      baz: number;
    };
  };
};

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div class=\\"test div\\" #_root>{{id()}} {{foo().bar.baz}}</div>
  \`,
  styles: \`:host { display: contents; }
        .div {
          padding: 10px;
        }
\`,
})
export class MyBasicComponent implements AfterViewInit {
  id = input<Props[\\"id\\"]>();
  foo = input<Props[\\"foo\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {
    effect(() => {
      // --- Mitosis: Workaround to make sure the effect() is triggered ---

      // ---

      console.log(\\"props.id changed\\", this.id());
      console.log(\\"props.foo.value.bar.baz changed\\", this.foo.bar.baz);
    });
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > spreadAttrs 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <input #_root />
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > spreadNestedProps 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <input #_root />
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicComponent implements AfterViewInit {
  nested = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > spreadProps 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-basic-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <input #_root />
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > stateInit 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      <div>{{asfas()}}</div>
      <div>{{someCompute()}}</div>
      <div>{{someOtherVal()}}</div>
      <div>{{sf()}}</div>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  val = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  asfas = signal(\\"asga\\");
  someCompute = signal(this.add(1, 2));
  someOtherVal = signal(this.val);
  sf = signal(this.add(this.val(), 34));

  add(a, b) {
    return a + b;
  }
  subtract() {
    return this.someCompute() - this.someOtherVal();
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > stateInitSequence 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule, Comp],
  template: \`
    <Comp
      [val]=\\"{ ...val()
        }\\"
      #_root
    >
      {{val()}}
    </Comp>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  value = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  val = signal(this.value);

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > store-async-function 1`] = `
"import { Component, AfterViewInit, viewChild, ElementRef, effect } from '@angular/core';
       import { CommonModule } from '@angular/common';












       @Component({
         selector: 'string-literal-store',standalone: true,imports: [CommonModule],template: \`<div #_root></div>
\`,styles: \`:host { display: contents; }\`
       })
       export class StringLiteralStore implements AfterViewInit {



         _root = viewChild<ElementRef>(\\"_root\\")


         async function arrowFunction() {
 return Promise.resolve();
}
async function namedFunction() {
 return Promise.resolve();
}
async function fetchUsers() {
 return Promise.resolve();
}


         constructor() {

         }

         /**
* Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
* @param element  the ref for the component
* @param customElementSelector  the custom element like \`my-component\`
*/
private enableAttributePassing(element: HTMLElement | null, customElementSelector: string) {
 const parent = element?.closest(customElementSelector);
 if (element && parent) {
   const attributes = parent.attributes;
   for (let i = 0; i < attributes.length; i++) {
     const attr = attributes.item(i);
     if (attr && (attr.name.startsWith('data-') || attr.name.startsWith('aria-'))) {
       element.setAttribute(attr.name, attr.value);
       parent.removeAttribute(attr.name);
     }
     if (attr && attr.name === 'class') {
       const isWebComponent = attr.value.includes('hydrated');
       const value = attr.value.replace('hydrated', '').trim();
       const currentClass = element.getAttribute('class');
       element.setAttribute(attr.name, \`\${currentClass ? \`\${currentClass} \` : ''}\${value}\`);
       if (isWebComponent) {
         // Stencil is using this class for lazy loading component
         parent.setAttribute('class', 'hydrated');
       } else {
         parent.removeAttribute(attr.name);
       }
     }
   }
 }
};



         ngAfterViewInit() {

           const element: HTMLElement | null = this._root()?.nativeElement;
           this.enableAttributePassing(element, \\"string-literal-store\\");

             }



       }"
`;

exports[`Angular signals > jsx > Typescript Test > string-literal-store 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"string-literal-store\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>{{foo()}}</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class StringLiteralStore implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  foo = signal(123);

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"string-literal-store\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > string-literal-store-kebab 1`] = `
"import { Component, AfterViewInit, viewChild, ElementRef, effect, signal } from '@angular/core';
       import { CommonModule } from '@angular/common';












       @Component({
         selector: 'string-literal-store',standalone: true,imports: [CommonModule],template: \`<div #_root>{{'foo-bar'}}</div>
\`,styles: \`:host { display: contents; }\`
       })
       export class StringLiteralStore implements AfterViewInit {



         _root = viewChild<ElementRef>(\\"_root\\")

          foo-bar= signal(123)



         constructor() {

         }

         /**
* Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
* @param element  the ref for the component
* @param customElementSelector  the custom element like \`my-component\`
*/
private enableAttributePassing(element: HTMLElement | null, customElementSelector: string) {
 const parent = element?.closest(customElementSelector);
 if (element && parent) {
   const attributes = parent.attributes;
   for (let i = 0; i < attributes.length; i++) {
     const attr = attributes.item(i);
     if (attr && (attr.name.startsWith('data-') || attr.name.startsWith('aria-'))) {
       element.setAttribute(attr.name, attr.value);
       parent.removeAttribute(attr.name);
     }
     if (attr && attr.name === 'class') {
       const isWebComponent = attr.value.includes('hydrated');
       const value = attr.value.replace('hydrated', '').trim();
       const currentClass = element.getAttribute('class');
       element.setAttribute(attr.name, \`\${currentClass ? \`\${currentClass} \` : ''}\${value}\`);
       if (isWebComponent) {
         // Stencil is using this class for lazy loading component
         parent.setAttribute('class', 'hydrated');
       } else {
         parent.removeAttribute(attr.name);
       }
     }
   }
 }
};



         ngAfterViewInit() {

           const element: HTMLElement | null = this._root()?.nativeElement;
           this.enableAttributePassing(element, \\"string-literal-store\\");

             }



       }"
`;

exports[`Angular signals > jsx > Typescript Test > styleClassAndCss 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div
      class=\\"builder-column div\\"
      [ngStyle]=\\"{
          width: '100%'
        }\\"
      #_root
    ></div>
  \`,
  styles: \`:host { display: contents; }
        .div {
          display: flex;
          flex-direction: column;
          align-items: stretch;
        }
\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > stylePropClassAndCss 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"style-prop-class-and-css\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div
      [ngStyle]=\\"attributes().style\\"
      [class]=\\"attributes().class + ' div'\\"
      #_root
    ></div>
  \`,
  styles: \`:host { display: contents; }
        .div {
          display: flex;
          flex-direction: column;
          align-items: stretch;
        }
\`,
})
export class StylePropClassAndCss implements AfterViewInit {
  attributes = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"style-prop-class-and-css\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > subComponent 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import Foo from \\"./foo-sub-component.js\\";

@Component({
  selector: \\"sub-component\\",
  standalone: true,
  imports: [CommonModule, Foo],
  template: \`
    <foo #_root></foo>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class SubComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"sub-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > svgComponent 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"svg-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <svg
      fill=\\"none\\"
      role=\\"img\\"
      [attr.viewBox]=\\"'0 0 ' + 42 + ' ' + 42\\"
      [attr.width]=\\"42\\"
      [attr.height]=\\"42\\"
      #_root
    >
      <defs>
        <filter id=\\"prefix__filter0_f\\" filterUnits=\\"userSpaceOnUse\\">
          <feFlood result=\\"BackgroundImageFix\\"></feFlood>
          <feBlend
            in=\\"SourceGraphic\\"
            in2=\\"BackgroundImageFix\\"
            result=\\"shape\\"
          ></feBlend>
          <feGaussianBlur
            result=\\"effect1_foregroundBlur\\"
            [attr.stdDeviation]=\\"7\\"
          ></feGaussianBlur>
        </filter>
      </defs>
    </svg>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class SvgComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"svg-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > twoForsTrackBy 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      @for (item of items();track trackByItem0;let i = $index) {
      <div>{{item}}</div>
      } @for (item of items();track trackByItem1;let i = $index) {
      <div>{{item}}</div>
      }
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  items = signal([1, 2, 3]);

  trackByItem0(_: number, item: any) {
    return item;
  }
  trackByItem1(_: number, item: any) {
    return item;
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > typeDependency 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

export type TypeDependencyProps = {
  foo: Foo;
  foo2: Foo2;
};

import type { Foo } from \\"./foo-type\\";
import type { Foo as Foo2 } from \\"./type-export.js\\";

@Component({
  selector: \\"type-dependency\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>{{foo()}}</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class TypeDependency implements AfterViewInit {
  foo = input<TypeDependencyProps[\\"foo\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"type-dependency\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > typeExternalProps 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { FooProps } from \\"./foo-props\\";

@Component({
  selector: \\"type-external-props\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>Hello {{name()}} !</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class TypeExternalProps implements AfterViewInit {
  name = input<FooProps[\\"name\\"]>();

  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"type-external-props\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > typeExternalStore 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { FooStore } from \\"./foo-store\\";

@Component({
  selector: \\"type-external-store\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>Hello {{_name()}} !</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class TypeExternalStore implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  _name = signal<FooStore[\\"_name\\"]>(\\"test\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"type-external-store\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > typeGetterStore 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

type GetterStore = {
  getName: () => string;
  name: string;
  get test(): string;
};

@Component({
  selector: \\"type-getter-store\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>Hello {{name()}} !</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class TypeGetterStore implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal<GetterStore[\\"name\\"]>(\\"test\\");

  getName() {
    if (this.name() === \\"a\\") {
      return \\"b\\";
    }

    return this.name;
  }
  get test() {
    return \\"test\\";
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"type-getter-store\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > use-style 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <button type=\\"button\\" #_root>Button</button>
  \`,
  styles: \`:host { display: contents; }
        button {
          background: blue;
          color: white;
          font-size: 12px;
          outline: 1px solid black;
        }
\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > use-style-and-css 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <button type=\\"button\\" class=\\"button\\" #_root>Button</button>
  \`,
  styles: \`:host { display: contents; }
        button {
          font-size: 12px;
          outline: 1px solid black;
        }

        .button {
          background: blue;
          color: white;
        }
\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > use-style-outside-component 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <button type=\\"button\\" #_root>Button</button>
  \`,
  styles: \`:host { display: contents; }
        button {
          background: blue;
          color: white;
          font-size: 12px;
          outline: 1px solid black;
        }
\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > useObjectWrapper 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule, Comp],
  template: \`
    <div #_root>
      <Comp
        [val1]=\\"{ ...attributes2()
        }\\"
        [val2]=\\"{ ...attributes(),
          ...attributes2()
        }\\"
        [val3]=\\"{ ...something(),
          anything: 'hello',
          hello: 'world'
        }\\"
        [val4]=\\"{ ...attributes(),
          ...something(),
          anything: [1, 2, 3],
          hello: 'hello',
          ...attributes2()
        }\\"
        [val5]=\\"{ ...attributes(),
          ...something(),
          anything: [1, 2, 3],
          anythingString: ['a', 'b', 'c'],
          hello: 'hello',
          ...spreadAttrs()
        }\\"
        [val6]=\\"{
          anything: [1, 2, 3]
        }\\"
      ></Comp>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  spreadAttrs = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  attributes = signal({
    id: 1,
  });
  attributes2 = signal({
    id2: 1,
  });
  something = signal({
    id3: 1,
  });

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > useTarget 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"use-target-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>{{name()}}</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class UseTargetComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  lastName = signal(\\"bar\\");
  foo = signal(\\"bar\\");

  get name() {
    const prefix = true;
    return prefix + \\"foo\\";
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    console.log(this.foo());
    this.foo.set(\\"bar\\");
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"use-target-component\\");
  }
}
"
`;

exports[`Angular signals > jsx > Typescript Test > webComponent 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { register } from \\"swiper/element/bundle\\";

@Component({
  selector: \\"my-basic-web-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <swiper-container
      slides-per-view=\\"3\\"
      navigation=\\"true\\"
      pagination=\\"true\\"
      #_root
    >
      <swiper-slide>Slide 1</swiper-slide>
      <swiper-slide>Slide 2</swiper-slide>
      <swiper-slide>Slide 3</swiper-slide>
    </swiper-container>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyBasicWebComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    register();
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-web-component\\");
  }
}
"
`;

exports[`Angular signals > svelte > Javascript Test > basic 1`] = `
"--- MITOSIS ERROR ---
    Component input has an event change that uses 'event.target.xxx'. 
        This will cause an error in Angular.
        Please create a new function with the EventTarget and use e.g '(event.target as HTMLInputElement).value'"
`;

exports[`Angular signals > svelte > Javascript Test > bindGroup 1`] = `
"--- MITOSIS ERROR ---
    Component input has an event change that uses 'event.target.xxx'. 
        This will cause an error in Angular.
        Please create a new function with the EventTarget and use e.g '(event.target as HTMLInputElement).value'"
`;

exports[`Angular signals > svelte > Javascript Test > bindProperty 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <input [attr.value]=\\"value()\\" #_root />
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  value = signal(\\"hello\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > svelte > Javascript Test > classDirective 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

const defaultProps = {};

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <input
      [class]=\\"\\\\\`form-input \\\\\${disabled() ? 'disabled' : ''} \\\\\${focus() ? 'focus' : ''}\\\\\`\\"
      #_root
    />
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  disabled = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  focus = signal(true);

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > svelte > Javascript Test > context 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>{{activeTab()}}</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  activeTab = signal(0);

  constructor(public disabled: \\"disabled\\") {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > svelte > Javascript Test > each 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <ul #_root>
      @for (num of numbers();track i;let i = $index) {
      <li>{{num}}</li>
      }
    </ul>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  numbers = signal([\\"one\\", \\"two\\", \\"three\\"]);

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > svelte > Javascript Test > eventHandlers 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      <button (click)=\\"log('hi')\\">Log</button>
      <button (click)=\\"log($event)\\">Log</button>
      <button (click)=\\"log($event)\\">Log</button>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  log(msg = \\"hello\\") {
    console.log(msg);
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > svelte > Javascript Test > html 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";
import { DomSanitizer } from \\"@angular/platform-browser\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div [innerHTML]=\\"sanitizer.bypassSecurityTrustHtml(html())\\" #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  html = signal(\\"<b>bold</b>\\");

  constructor(protected sanitizer: DomSanitizer) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > svelte > Javascript Test > ifElse 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    @if(show()){
    <button (click)=\\"toggle($event)\\">Hide</button>
    }@else{
    <button (click)=\\"toggle($event)\\">Show</button>
    }
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  show = signal(true);

  toggle() {
    this.show.set(!this.show);
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > svelte > Javascript Test > imports 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import Button from \\"./Button.js\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule, Button],
  template: \`
    <div #_root>
      <button type=\\"button\\" [disabled]=\\"disabled()\\">
        <ng-content></ng-content>
      </button>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  disabled = signal(false);

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > svelte > Javascript Test > lifecycleHooks 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {
    effect(() => {
      console.log(\\"onAfterUpdate\\");
    });
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    console.log(\\"onMount\\");
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }

  ngOnDestroy() {
    console.log(\\"onDestroy\\");
  }
}
"
`;

exports[`Angular signals > svelte > Javascript Test > reactive 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      <input [attr.value]=\\"name()\\" />

      Lowercase: {{lowercaseName()}}
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"Steve\\");

  get lowercaseName() {
    return this.name().toLowerCase();
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > svelte > Javascript Test > reactiveWithFn 1`] = `
"--- MITOSIS ERROR ---
    Component input has an event change that uses 'event.target.xxx'. 
        This will cause an error in Angular.
        Please create a new function with the EventTarget and use e.g '(event.target as HTMLInputElement).value'"
`;

exports[`Angular signals > svelte > Javascript Test > slots 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      <ng-content>default</ng-content>
      <ng-content select=\\"[test]\\">
        <div>default</div>
      </ng-content>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > svelte > Javascript Test > style 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <input class=\\"form-input\\" #_root />
  \`,
  styles: \`:host { display: contents; }
        input {
          color: red;
          font-size: 12px;
        }

        .form-input:focus {
          outline: 1px solid blue;
        }
\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > svelte > Javascript Test > textExpressions 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      normal: {{a() + b()}}
      <br />

      conditional {{a() > 2 ? 'hello' : 'bye'}}
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  a = signal(5);
  b = signal(12);

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > svelte > Typescript Test > basic 1`] = `
"--- MITOSIS ERROR ---
    Component input has an event change that uses 'event.target.xxx'. 
        This will cause an error in Angular.
        Please create a new function with the EventTarget and use e.g '(event.target as HTMLInputElement).value'"
`;

exports[`Angular signals > svelte > Typescript Test > bindGroup 1`] = `
"--- MITOSIS ERROR ---
    Component input has an event change that uses 'event.target.xxx'. 
        This will cause an error in Angular.
        Please create a new function with the EventTarget and use e.g '(event.target as HTMLInputElement).value'"
`;

exports[`Angular signals > svelte > Typescript Test > bindProperty 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <input [attr.value]=\\"value()\\" #_root />
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  value = signal(\\"hello\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > svelte > Typescript Test > classDirective 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  input,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

const defaultProps = {};

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <input
      [class]=\\"\\\\\`form-input \\\\\${disabled() ? 'disabled' : ''} \\\\\${focus() ? 'focus' : ''}\\\\\`\\"
      #_root
    />
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  disabled = input<any>();

  _root = viewChild<ElementRef>(\\"_root\\");

  focus = signal(true);

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > svelte > Typescript Test > context 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>{{activeTab()}}</div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  activeTab = signal(0);

  constructor(public disabled: \\"disabled\\") {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > svelte > Typescript Test > each 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <ul #_root>
      @for (num of numbers();track i;let i = $index) {
      <li>{{num}}</li>
      }
    </ul>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  numbers = signal([\\"one\\", \\"two\\", \\"three\\"]);

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > svelte > Typescript Test > eventHandlers 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      <button (click)=\\"log('hi')\\">Log</button>
      <button (click)=\\"log($event)\\">Log</button>
      <button (click)=\\"log($event)\\">Log</button>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  log(msg = \\"hello\\") {
    console.log(msg);
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > svelte > Typescript Test > html 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";
import { DomSanitizer } from \\"@angular/platform-browser\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div [innerHTML]=\\"sanitizer.bypassSecurityTrustHtml(html())\\" #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  html = signal(\\"<b>bold</b>\\");

  constructor(protected sanitizer: DomSanitizer) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > svelte > Typescript Test > ifElse 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    @if(show()){
    <button (click)=\\"toggle($event)\\">Hide</button>
    }@else{
    <button (click)=\\"toggle($event)\\">Show</button>
    }
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  show = signal(true);

  toggle() {
    this.show.set(!this.show);
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > svelte > Typescript Test > imports 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import Button from \\"./Button.js\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule, Button],
  template: \`
    <div #_root>
      <button type=\\"button\\" [disabled]=\\"disabled()\\">
        <ng-content></ng-content>
      </button>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  disabled = signal(false);

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > svelte > Typescript Test > lifecycleHooks 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root></div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {
    effect(() => {
      console.log(\\"onAfterUpdate\\");
    });
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    console.log(\\"onMount\\");
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }

  ngOnDestroy() {
    console.log(\\"onDestroy\\");
  }
}
"
`;

exports[`Angular signals > svelte > Typescript Test > reactive 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      <input [attr.value]=\\"name()\\" />

      Lowercase: {{lowercaseName()}}
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  name = signal(\\"Steve\\");

  get lowercaseName() {
    return this.name().toLowerCase();
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > svelte > Typescript Test > reactiveWithFn 1`] = `
"--- MITOSIS ERROR ---
    Component input has an event change that uses 'event.target.xxx'. 
        This will cause an error in Angular.
        Please create a new function with the EventTarget and use e.g '(event.target as HTMLInputElement).value'"
`;

exports[`Angular signals > svelte > Typescript Test > slots 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      <ng-content>default</ng-content>
      <ng-content select=\\"[test]\\">
        <div>default</div>
      </ng-content>
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > svelte > Typescript Test > style 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <input class=\\"form-input\\" #_root />
  \`,
  styles: \`:host { display: contents; }
        input {
          color: red;
          font-size: 12px;
        }

        .form-input:focus {
          outline: 1px solid blue;
        }
\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals > svelte > Typescript Test > textExpressions 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
  signal,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"my-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div #_root>
      normal: {{a() + b()}}
      <br />

      conditional {{a() > 2 ? 'hello' : 'bye'}}
    </div>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class MyComponent implements AfterViewInit {
  _root = viewChild<ElementRef>(\\"_root\\");

  a = signal(5);
  b = signal(12);

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}
"
`;

exports[`Angular signals local > jsx > Only Test > basicRefAttributePassing 1`] = `
"/**
          useMetadata:
          {\\"attributePassing\\":{\\"enabled\\":true}}
          */

import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

@Component({
  selector: \\"basic-ref-attribute-passing-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <button #buttonRef #_root>Attribute Passing</button>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class BasicRefAttributePassingComponent implements AfterViewInit {
  buttonRef = viewChild<ElementRef>(\\"buttonRef\\");
  _root = viewChild<ElementRef>(\\"_root\\");

  constructor() {
    effect(() => {
      // --- Mitosis: Workaround to make sure the effect() is triggered ---
      this.buttonRef();
      // ---

      if (this.buttonRef()?.nativeElement) {
        if (this.buttonRef()?.nativeElement.disabled) {
          console.log(this.buttonRef()?.nativeElement);
        }
      }
    });
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(
      element,
      \\"basic-ref-attribute-passing-component\\"
    );
  }
}
"
`;

exports[`Angular signals local > jsx > Only Test > eventProps 1`] = `
"import {
  Component,
  AfterViewInit,
  viewChild,
  ElementRef,
  output,
  effect,
} from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { EventProps, EventState } from \\"./event-props.type\\";

@Component({
  selector: \\"event-props-component\\",
  standalone: true,
  imports: [CommonModule],
  template: \`
    <button (click)=\\"handleClick()\\" #_root>Test</button>
  \`,
  styles: \`:host { display: contents; }\`,
})
export class EventPropsComponent implements AfterViewInit {
  getVoid = output<
    Parameters<Required<EventProps>[\\"onGetVoid\\"]>[number] | void
  >();
  enter = output<Parameters<Required<EventProps>[\\"onEnter\\"]>[number] | void>();

  _root = viewChild<ElementRef>(\\"_root\\");

  handleClick() {
    if (this.getVoid.emit()) {
      this.getVoid.emit()();
    }

    if (this.enter.emit()) {
      console.log(this.enter.emit()());
    }
  }

  constructor() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root()?.nativeElement;
    this.enableAttributePassing(element, \\"event-props-component\\");
  }
}
"
`;
