// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Vue Basic 1`] = `
"<template>
  <div>
    <input :value=\\"name\\" @change=\\"name = $event.target.value\\" />

    Hello! I can run in React, Vue, Solid, or Liquid!
  </div>
</template>
<script>
  export default {
    data: () => ({ name: \\"Steve\\" }),
  };
</script>
"
`;

exports[`Vue Form block 1`] = `
"<template>
  <form
    v-bind=\\"props.attributes\\"
    :validate=\\"validate\\"
    ref=\\"formRef\\"
    :action=\\"!sendWithJs && action\\"
    :method=\\"method\\"
    :name=\\"name\\"
    @submit=\\"onSubmit(event)\\"
  >
    <template v-if=\\"props.builderBlock && props.builderBlock.children\\">
      <template v-for=\\"block in props.builderBlock.children\\"
        ><BuilderBlockComponent
          :key=\\"block.id\\"
          :block=\\"block\\"
        ></BuilderBlockComponent
      ></template>
    </template>

    <template v-if=\\"state.submissionState === 'error'\\">
      <BuilderBlocks
        dataPath=\\"errorMessage\\"
        :blocks=\\"errorMessage\\"
      ></BuilderBlocks>
    </template>

    <template v-if=\\"state.submissionState === 'sending'\\">
      <BuilderBlocks
        dataPath=\\"sendingMessage\\"
        :blocks=\\"sendingMessage\\"
      ></BuilderBlocks>
    </template>

    <template v-if=\\"state.submissionState === 'error' && state.responseData\\">
      <pre
        className=\\"builder-form-error-text\\"
        :css=\\"{
padding: '10px',
color: 'red',
textAlign: 'center'
}\\"
      >
        
{JSON.stringify(state.responseData, null, 2)}

      </pre>
    </template>

    <template v-if=\\"state.submissionState === 'success'\\">
      <BuilderBlocks
        dataPath=\\"successMessage\\"
        :blocks=\\"successMessage\\"
      ></BuilderBlocks>
    </template>
  </form>
</template>
<script>
  import { BuilderBlockComponent as BuilderBlock } from \\"@fake\\";
  import { Builder, builder } from \\"@builder.io/sdk\\";
  import { BuilderBlocks } from \\"@fake\\";
  import { set } from \\"@fake\\";
  import { get } from \\"@fake\\";

  export interface FormProps {
    attributes?: any;
    name?: string;
    action?: string;
    validate?: boolean;
    method?: string;
    builderBlock?: BuilderElement;
    sendSubmissionsTo?: string;
    sendSubmissionsToEmail?: string;
    sendWithJs?: boolean;
    contentType?: string;
    customHeaders?: {
      [key: string]: string,
    };
    successUrl?: string;
    previewState?: FormState;
    successMessage?: BuilderElement[];
    errorMessage?: BuilderElement[];
    sendingMessage?: BuilderElement[];
    resetFormOnSubmit?: boolean;
    errorMessagePath?: string;
  }
  export type FormState = \\"unsubmitted\\" | \\"sending\\" | \\"success\\" | \\"error\\";

  export default {
    data: () => ({
      state: \\"unsubmitted\\",
      formErrorMessage: \\"\\",
      get submissionState() {
        return (Builder.isEditing && props.previewState) || state.state;
      },
      onSubmit(event) {
        const sendWithJs =
          props.sendWithJs || props.sendSubmissionsTo === \\"email\\";

        if (props.sendSubmissionsTo === \\"zapier\\") {
          event.preventDefault();
        } else if (sendWithJs) {
          if (!(props.action || props.sendSubmissionsTo === \\"email\\")) {
            event.preventDefault();
            return;
          }

          event.preventDefault();
          const el = event.currentTarget;
          const headers = props.customHeaders || {};
          let body;
          const formData = new FormData(el); // TODO: maybe support null

          const formPairs = Array.from(
            event.currentTarget.querySelectorAll(\\"input,select,textarea\\")
          )
            .filter((el) => !!el.name)
            .map((el) => {
              let value;
              const key = el.name;

              if (el instanceof HTMLInputElement) {
                if (el.type === \\"radio\\") {
                  if (el.checked) {
                    value = el.name;
                    return {
                      key,
                      value,
                    };
                  }
                } else if (el.type === \\"checkbox\\") {
                  value = el.checked;
                } else if (el.type === \\"number\\" || el.type === \\"range\\") {
                  const num = el.valueAsNumber;

                  if (!isNaN(num)) {
                    value = num;
                  }
                } else if (el.type === \\"file\\") {
                  // TODO: one vs multiple files
                  value = el.files;
                } else {
                  value = el.value;
                }
              } else {
                value = el.value;
              }

              return {
                key,
                value,
              };
            });
          let contentType = props.contentType;

          if (props.sendSubmissionsTo === \\"email\\") {
            contentType = \\"multipart/form-data\\";
          }

          Array.from(formPairs).forEach(({ value }) => {
            if (
              value instanceof File ||
              (Array.isArray(value) && value[0] instanceof File) ||
              value instanceof FileList
            ) {
              contentType = \\"multipart/form-data\\";
            }
          }); // TODO: send as urlEncoded or multipart by default
          // because of ease of use and reliability in browser API
          // for encoding the form?

          if (contentType !== \\"application/json\\") {
            body = formData;
          } else {
            // Json
            const json = {};
            Array.from(formPairs).forEach(({ value, key }) => {
              set(json, key, value);
            });
            body = JSON.stringify(json);
          }

          if (contentType && contentType !== \\"multipart/form-data\\") {
            if (
              // Zapier doesn't allow content-type header to be sent from browsers
              !(sendWithJs && props.action?.includes(\\"zapier.com\\"))
            ) {
              headers[\\"content-type\\"] = contentType;
            }
          }

          const presubmitEvent = new CustomEvent(\\"presubmit\\", {
            detail: {
              body,
            },
          });

          if (this.$refs.formRef) {
            this.$refs.formRef.dispatchEvent(presubmitEvent);

            if (presubmitEvent.defaultPrevented) {
              return;
            }
          }

          state.state = \\"sending\\";
          const formUrl = \`\${
            builder.env === \\"dev\\"
              ? \\"http://localhost:5000\\"
              : \\"https://builder.io\\"
          }/api/v1/form-submit?apiKey=\${builder.apiKey}&to=\${btoa(
            props.sendSubmissionsToEmail || \\"\\"
          )}&name=\${encodeURIComponent(props.name || \\"\\")}\`;
          fetch(
            props.sendSubmissionsTo === \\"email\\" ? formUrl : props.action, // TODO: throw error if no action URL
            {
              body,
              headers,
              method: props.method || \\"post\\",
            }
          ).then(
            async (res) => {
              let body;
              const contentType = res.headers.get(\\"content-type\\");

              if (
                contentType &&
                contentType.indexOf(\\"application/json\\") !== -1
              ) {
                body = await res.json();
              } else {
                body = await res.text();
              }

              if (!res.ok && props.errorMessagePath) {
                // TODO: allow supplying an error formatter function
                let message = get(body, props.errorMessagePath);

                if (message) {
                  if (typeof message !== \\"string\\") {
                    // TODO: ideally convert json to yaml so it woul dbe like
                    // error: - email has been taken
                    message = JSON.stringify(message);
                  }

                  state.formErrorMessage = message;
                }
              }

              state.responseData = body;
              state.state = res.ok ? \\"success\\" : \\"error\\";

              if (res.ok) {
                const submitSuccessEvent = new CustomEvent(\\"submit:success\\", {
                  detail: {
                    res,
                    body,
                  },
                });

                if (this.$refs.formRef) {
                  this.$refs.formRef.dispatchEvent(submitSuccessEvent);

                  if (submitSuccessEvent.defaultPrevented) {
                    return;
                  } // TODO: option to turn this on/off?

                  if (props.resetFormOnSubmit !== false) {
                    this.$refs.formRef.reset();
                  }
                } // TODO: client side route event first that can be preventDefaulted

                if (props.successUrl) {
                  if (this.$refs.formRef) {
                    const event = new CustomEvent(\\"route\\", {
                      detail: {
                        url: props.successUrl,
                      },
                    });
                    this.$refs.formRef.dispatchEvent(event);

                    if (!event.defaultPrevented) {
                      location.href = props.successUrl;
                    }
                  } else {
                    location.href = props.successUrl;
                  }
                }
              }
            },
            (err) => {
              const submitErrorEvent = new CustomEvent(\\"submit:error\\", {
                detail: {
                  error: err,
                },
              });

              if (this.$refs.formRef) {
                this.$refs.formRef.dispatchEvent(submitErrorEvent);

                if (submitErrorEvent.defaultPrevented) {
                  return;
                }
              }

              state.responseData = err;
              state.state = \\"error\\";
            }
          );
        }
      },
      BuilderBlock,
      Builder,
      builder,
      BuilderBlocks,
      set,
      get,
    }),
  };
</script>
"
`;

exports[`Vue Input block 1`] = `
"<template>
  <input
    v-bind=\\"props.attributes\\"
    :key=\\"Builder.isEditing && defaultValue ? defaultValue : 'default-key'\\"
    :placeholder=\\"placeholder\\"
    :type=\\"type\\"
    :name=\\"name\\"
    :value=\\"value\\"
    :defaultValue=\\"defaultValue\\"
    :required=\\"required\\"
  />
</template>
<script>
  import { Builder } from \\"@builder.io/sdk\\";

  export interface FormInputProps {
    type?: string;
    attributes?: any;
    name?: string;
    value?: string;
    placeholder?: string;
    defaultValue?: string;
    required?: boolean;
  }

  export default {
    data: () => ({ Builder }),
  };
</script>
"
`;

exports[`Vue Select block 1`] = `
"<template>
  <select
    v-bind=\\"props.attributes\\"
    :value=\\"value\\"
    :key=\\"Builder.isEditing && defaultValue ? defaultValue : 'default-key'\\"
    :defaultValue=\\"defaultValue\\"
    :name=\\"name\\"
  >
    <template v-for=\\"option in props.options\\"
      ><option :value=\\"option.value\\">
        {option.name || option.value}
      </option></template
    >
  </select>
</template>
<script>
  import { Builder } from \\"@builder.io/sdk\\";

  export interface FormSelectProps {
    options?: {
      name?: string,
      value: string,
    }[];
    attributes?: any;
    name?: string;
    value?: string;
    defaultValue?: string;
  }

  export default {
    data: () => ({ Builder }),
  };
</script>
"
`;

exports[`Vue Submit button block 1`] = `
"<template>
  <button v-bind=\\"props.attributes\\" type=\\"submit\\">{props.text}</button>
</template>
<script>
  export interface ButtonProps {
    attributes?: any;
    text?: string;
  }

  export default {
    data: () => ({}),
  };
</script>
"
`;
