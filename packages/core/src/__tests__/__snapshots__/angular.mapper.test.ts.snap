// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > Advanced 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-for-show-component\\",
  template: \`
    <main #_root>
      <ng-container *ngFor=\\"let person of names; index as i\\">
        <div>{{i}} : {{person}}</div>
      </ng-container>
      <ng-container *ngFor=\\"let person of names\\">
        <span>{{person}}</span>
      </ng-container>
      <ng-container *ngFor=\\"let _ of names\\"><br /></ng-container>
      <ng-container
        *ngFor=\\"let _ of Array.from({
          length: 10
        }); index as ee\\"
      >
        <pre>{{ee}}</pre>
      </ng-container>
      <ng-container
        *ngFor=\\"let _ of Array.from({
          length: 10
        })\\"
      >
        <p>{{index}}</p>
      </ng-container>
      <ng-container *ngFor=\\"let person of names; index as index\\">
        <span>{{person}} {{index}}</span>
      </ng-container>
      <ng-container
        *ngFor=\\"let person of Array.from({
          length: 10
        }); index as count\\"
      >
        <span>{{person}} {{count}}</span>
      </ng-container>
      <ng-container *ngFor=\\"let person of names; index as i\\">
        <span>{{person}} {{i}}</span>
      </ng-container>
      <ng-container
        *ngFor=\\"let person of Array.from({
          length: 10
        }); index as index\\"
      >
        <span>{{person}} {{index}}</span>
      </ng-container>
    </main>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicForShowComponent {
  @ViewChild(\\"_root\\") _root;

  name = \\"PatrickJS\\";
  names = [\\"Steve\\", \\"PatrickJS\\"];

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-for-show-component\\");
  }
}

@NgModule({
  declarations: [MyBasicForShowComponent],
  imports: [CommonModule],
  exports: [MyBasicForShowComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicForShowComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > AdvancedRef 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-ref-component\\",
  template: \`
    <div #_root>
      <ng-container *ngIf=\\"showInput\\">
        <ng-container>
          <input
            class=\\"input\\"
            #inputRef
            [attr.value]=\\"name\\"
            (blur)=\\"onBlur()\\"
            (change)=\\"name = $event.target.value\\"
          />
          <label for=\\"cars\\" #inputNoArgRef>Choose a car:</label>
          <select name=\\"cars\\" id=\\"cars\\">
            <option value=\\"supra\\">GR Supra</option>
            <option value=\\"86\\">GR 86</option>
          </select>
        </ng-container>
      </ng-container>

      Hello {{lowerCaseName()}} ! I can run in React, Qwik, Vue, Solid, or Web
      Component!
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .input {
        color: red;
      }
    \`,
  ],
})
export default class MyBasicRefComponent {
  @Input() showInput;

  @ViewChild(\\"inputRef\\") inputRef;
  @ViewChild(\\"inputNoArgRef\\") inputNoArgRef;
  @ViewChild(\\"_root\\") _root;

  name = \\"PatrickJS\\";
  onBlur = function onBlur() {
    // Maintain focus
    this.inputRef.nativeElement.focus();
  };
  lowerCaseName = function lowerCaseName() {
    return this.name.toLowerCase();
  };

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-ref-component\\");
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      console.log(\\"Received an update\\");
    }
  }
}

@NgModule({
  declarations: [MyBasicRefComponent],
  imports: [CommonModule],
  exports: [MyBasicRefComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicRefComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > Basic 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

export const DEFAULT_VALUES = {
  name: \\"Steve\\",
};

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <div class=\\"test div\\" #_root>
      <input
        [attr.value]=\\"DEFAULT_VALUES.name || name\\"
        (change)=\\"name = $event.target.value\\"
      />

      Hello! I can run in React, Vue, Solid, or Liquid! &gt;
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .div {
        padding: 10px;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  DEFAULT_VALUES = DEFAULT_VALUES;

  @ViewChild(\\"_root\\") _root;

  name = \\"Steve\\";
  underscore_fn_name() {
    return \\"bar\\";
  }
  age = 1;
  sports = [\\"\\"];

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > Basic 2`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-for-show-component\\",
  template: \`
    <div #_root>
      <ng-container *ngFor=\\"let person of names\\">
        <ng-container *ngIf=\\"person === name\\">
          <input
            [attr.value]=\\"name\\"
            (change)=\\"
          name = $event.target.value + ' and ' + person;
        \\"
          />

          Hello {{person}} ! I can run in Qwik, Web Component, React, Vue,
          Solid, or Liquid!
        </ng-container>
      </ng-container>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicForShowComponent {
  @ViewChild(\\"_root\\") _root;

  name = \\"PatrickJS\\";
  names = [\\"Steve\\", \\"PatrickJS\\"];

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-for-show-component\\");
  }
}

@NgModule({
  declarations: [MyBasicForShowComponent],
  imports: [CommonModule],
  exports: [MyBasicForShowComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicForShowComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > Basic Context 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

import { Injector, MyService, createInjector } from \\"@dummy/injection-js\\";

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <div #_root>
      {{myService.method('hello') + name}} Hello! I can run in React, Vue,
      Solid, or Liquid!

      <input (change)=\\"onChange\\" />
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @ViewChild(\\"_root\\") _root;

  name = \\"PatrickJS\\";
  onChange = function onChange() {
    const change = this.myService.method(\\"change\\");
    console.log(change);
  };

  constructor(public myService: MyService) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    const hi = this.myService.method(\\"hi\\");
    console.log(hi);

    if (typeof window !== \\"undefined\\") {
      const bye = this.myService.method(\\"hi\\");
      console.log(bye);
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > Basic OnMount Update 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-on-mount-update-component\\",
  template: \`
    <div #_root>Hello {{name}}</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicOnMountUpdateComponent {
  @Input() bye;
  @Input() hi;

  @ViewChild(\\"_root\\") _root;

  name = \\"PatrickJS\\";
  names = [\\"Steve\\", \\"PatrickJS\\"];

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.name = \\"PatrickJS onInit\\" + this.hi;

    if (typeof window !== \\"undefined\\") {
      this.name = \\"PatrickJS onMount\\" + this.bye;
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-on-mount-update-component\\");
  }
}

@NgModule({
  declarations: [MyBasicOnMountUpdateComponent],
  imports: [CommonModule],
  exports: [MyBasicOnMountUpdateComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicOnMountUpdateComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > Basic Outputs 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Output,
  EventEmitter,
  Component,
  ViewChild,
  ElementRef,
  Input,
} from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-outputs-component\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicOutputsComponent {
  @Input() message;

  @Output() onMessage = new EventEmitter();
  @Output() onEvent = new EventEmitter();

  @ViewChild(\\"_root\\") _root;

  name = \\"PatrickJS\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    if (typeof window !== \\"undefined\\") {
      this.onMessage.emit(this.name);
      this.onEvent.emit(this.message);
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-outputs-component\\");
  }
}

@NgModule({
  declarations: [MyBasicOutputsComponent],
  imports: [CommonModule],
  exports: [MyBasicOutputsComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicOutputsComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > Basic Outputs Meta 1`] = `
"/**
          useMetadata:
          {\\"outputs\\":[\\"onMessage\\",\\"onEvent\\"],\\"baz\\":\\"metadata inside component\\"}
          */

import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Output,
  EventEmitter,
  Component,
  ViewChild,
  ElementRef,
  Input,
} from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-outputs-component\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicOutputsComponent {
  @Input() message;

  @Output() onMessage = new EventEmitter();
  @Output() onEvent = new EventEmitter();

  @ViewChild(\\"_root\\") _root;

  name = \\"PatrickJS\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    if (typeof window !== \\"undefined\\") {
      this.onMessage.emit(this.name);
      this.onEvent.emit(this.message);
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-outputs-component\\");
  }
}

@NgModule({
  declarations: [MyBasicOutputsComponent],
  imports: [CommonModule],
  exports: [MyBasicOutputsComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicOutputsComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > BasicAttribute 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <input
      autocapitalize=\\"on\\"
      autocomplete=\\"on\\"
      [attr.spellcheck]=\\"true\\"
      #_root
    />
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > BasicBooleanAttribute 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

import MyBooleanAttributeComponentModule from \\"./basic-boolean-attribute-component.raw/angular\\";

@Component({
  selector: \\"my-boolean-attribute\\",
  template: \`
    <div #_root>
      <ng-container *ngIf=\\"children\\">
        <ng-content></ng-content>
        {{type}}
      </ng-container>
      <my-boolean-attribute-component
        [toggle]=\\"true\\"
      ></my-boolean-attribute-component>
      <my-boolean-attribute-component
        [toggle]=\\"true\\"
      ></my-boolean-attribute-component>
      <my-boolean-attribute-component
        [list]=\\"null\\"
      ></my-boolean-attribute-component>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBooleanAttribute {
  @Input() type;

  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-boolean-attribute\\");
  }
}

@NgModule({
  declarations: [MyBooleanAttribute],
  imports: [CommonModule, MyBooleanAttributeComponentModule],
  exports: [MyBooleanAttribute],
  bootstrap: [SomeOtherComponent],
})
export class MyBooleanAttributeModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > BasicChildComponent 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

import MyBasicOnMountUpdateComponentModule from \\"./basic-onMount-update.raw/angular\\";
import MyBasicComponentModule from \\"./basic.raw/angular\\";

@Component({
  selector: \\"my-basic-child-component\\",
  template: \`
    <div #_root>
      <my-basic-component [id]=\\"dev\\"></my-basic-component>
      <div>
        <my-basic-on-mount-update-component
          [hi]=\\"name\\"
          [bye]=\\"dev\\"
        ></my-basic-on-mount-update-component>
      </div>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicChildComponent {
  @ViewChild(\\"_root\\") _root;

  name = \\"Steve\\";
  dev = \\"PatrickJS\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-child-component\\");
  }
}

@NgModule({
  declarations: [MyBasicChildComponent],
  imports: [
    CommonModule,
    MyBasicComponentModule,
    MyBasicOnMountUpdateComponentModule,
  ],
  exports: [MyBasicChildComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicChildComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > BasicFor 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-for-component\\",
  template: \`
    <div #_root>
      <ng-container *ngFor=\\"let person of names\\">
        <ng-container>
          <input
            [attr.value]=\\"name\\"
            (change)=\\"
          name = $event.target.value + ' and ' + person;
        \\"
          />

          Hello {{person}} ! I can run in Qwik, Web Component, React, Vue,
          Solid, or Liquid!
        </ng-container>
      </ng-container>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicForComponent {
  @ViewChild(\\"_root\\") _root;

  name = \\"PatrickJS\\";
  names = [\\"Steve\\", \\"PatrickJS\\"];

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    if (typeof window !== \\"undefined\\") {
      console.log(\\"onMount code\\");
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-for-component\\");
  }
}

@NgModule({
  declarations: [MyBasicForComponent],
  imports: [CommonModule],
  exports: [MyBasicForComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicForComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > BasicRef 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-ref-component\\",
  template: \`
    <div #_root>
      <ng-container *ngIf=\\"showInput\\">
        <ng-container>
          <input
            class=\\"input\\"
            #inputRef
            [attr.value]=\\"name\\"
            (blur)=\\"onBlur()\\"
            (change)=\\"name = $event.target.value\\"
          />
          <label for=\\"cars\\" #inputNoArgRef>Choose a car:</label>
          <select name=\\"cars\\" id=\\"cars\\">
            <option value=\\"supra\\">GR Supra</option>
            <option value=\\"86\\">GR 86</option>
          </select>
        </ng-container>
      </ng-container>

      Hello {{lowerCaseName()}} ! I can run in React, Qwik, Vue, Solid, or Web
      Component!
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .input {
        color: red;
      }
    \`,
  ],
})
export default class MyBasicRefComponent {
  @Input() showInput;

  @ViewChild(\\"inputRef\\") inputRef;
  @ViewChild(\\"inputNoArgRef\\") inputNoArgRef;
  @ViewChild(\\"_root\\") _root;

  name = \\"PatrickJS\\";
  onBlur = function onBlur() {
    // Maintain focus
    this.inputRef.nativeElement?.focus();
  };
  lowerCaseName = function lowerCaseName() {
    return this.name.toLowerCase();
  };

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-ref-component\\");
  }
}

@NgModule({
  declarations: [MyBasicRefComponent],
  imports: [CommonModule],
  exports: [MyBasicRefComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicRefComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > BasicRefAssignment 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-ref-assignment-component\\",
  template: \`
    <div #_root>
      <button (click)=\\"await handlerClick($event)\\">Click</button>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicRefAssignmentComponent {
  @ViewChild(\\"_root\\") _root;

  handlerClick = function handlerClick(event) {
    event.preventDefault();
    console.log(\\"current value\\", this._holdValueRef);
    this._holdValueRef = this._holdValueRef + \\"JS\\";
  };

  private _holdValueRef = \\"Patrick\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-ref-assignment-component\\");
  }
}

@NgModule({
  declarations: [MyBasicRefAssignmentComponent],
  imports: [CommonModule],
  exports: [MyBasicRefAssignmentComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicRefAssignmentComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > BasicRefPrevious 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

export function usePrevious(value) {
  // The ref object is a generic container whose current property is mutable ...
  // ... and can hold any value, similar to an instance property on a class
  let ref = useRef(null); // Store current value in ref

  onUpdate(() => {
    ref = value;
  }, [value]); // Only re-run if value changes
  // Return previous value (happens before update in useEffect above)

  return ref;
}

@Component({
  selector: \\"my-previous-component\\",
  template: \`
    <div #_root>
      <h1>Now: {{count}} , before: {{this._prevCount}}</h1>
      <button (click)=\\"count += 1\\">Increment</button>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyPreviousComponent {
  @ViewChild(\\"_root\\") _root;

  count = 0;

  private _prevCount = this.count;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-previous-component\\");
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      this._prevCount = this.count;
    }
  }
}

@NgModule({
  declarations: [MyPreviousComponent],
  imports: [CommonModule],
  exports: [MyPreviousComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyPreviousComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > Button 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
} from \\"@angular/core\\";

@Component({
  selector: \\"button\\",
  template: \`
    <div #_root>
      <ng-container *ngIf=\\"link\\">
        <a
          [attr.href]=\\"link\\"
          [attr.target]=\\"openLinkInNewTab ? '_blank' : undefined\\"
          #elRef0
        >
          {{text}}
        </a>
      </ng-container>
      <ng-container *ngIf=\\"!link\\">
        <button type=\\"button\\" #elRef1>{{text}}</button>
      </ng-container>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class Button {
  @Input() link;
  @Input() attributes;
  @Input() openLinkInNewTab;
  @Input() text;

  @ViewChild(\\"_root\\") _root;

  @ViewChild(\\"elRef0\\") elRef0;
  @ViewChild(\\"elRef1\\") elRef1;

  _listenerFns = new Map();

  setAttributes(el, value, changes) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"button\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
    this.setAttributes(this.elRef1?.nativeElement, this.attributes);
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
      this.setAttributes(
        this.elRef1?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [Button],
  imports: [CommonModule],
  exports: [Button],
  bootstrap: [SomeOtherComponent],
})
export class ButtonModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > Columns 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"column\\",
  template: \`
    <div class=\\"builder-columns div\\" #_root>
      <ng-container *ngFor=\\"let column of columns; index as index\\">
        <div class=\\"builder-column div-2\\">{{column.content}} {{index}}</div>
      </ng-container>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .div {
        display: flex;
        flex-direction: column;
        align-items: stretch;
        line-height: normal;
      }
      @media (max-width: 999px) {
        .div {
          flex-direction: row;
        }
      }
      @media (max-width: 639px) {
        .div {
          flex-direction: row-reverse;
        }
      }
      .div-2 {
        flex-grow: 1;
      }
    \`,
  ],
})
export default class Column {
  @Input() columns;
  @Input() space;

  @ViewChild(\\"_root\\") _root;

  getColumns() {
    return this.columns || [];
  }
  getGutterSize() {
    return typeof this.space === \\"number\\" ? this.space || 0 : 20;
  }
  getWidth(index) {
    const columns = this.getColumns();
    return (columns[index] && columns[index].width) || 100 / columns.length;
  }
  getColumnCssWidth(index) {
    const columns = this.getColumns();
    const gutterSize = this.getGutterSize();
    const subtractWidth = (gutterSize * (columns.length - 1)) / columns.length;
    return \`calc(\${this.getWidth(index)}% - \${subtractWidth}px)\`;
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"column\\");
  }
}

@NgModule({
  declarations: [Column],
  imports: [CommonModule],
  exports: [Column],
  bootstrap: [SomeOtherComponent],
})
export class ColumnModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > ContentSlotHtml 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"content-slot-code\\",
  template: \`
    <div #_root>
      <ng-content select=\\"[testing]\\"></ng-content>
      <div><hr /></div>
      <div><ng-content></ng-content></div>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class ContentSlotCode {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"content-slot-code\\");
  }
}

@NgModule({
  declarations: [ContentSlotCode],
  imports: [CommonModule],
  exports: [ContentSlotCode],
  bootstrap: [SomeOtherComponent],
})
export class ContentSlotCodeModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > ContentSlotJSX 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
} from \\"@angular/core\\";

const defaultProps = {
  content: \\"\\",
  slotReference: undefined,
  slotContent: undefined,
};

@Component({
  selector: \\"content-slot-jsx-code\\",
  template: \`
    <ng-container *ngIf=\\"slotReference\\">
      <div
        [attr.name]=\\"slotContent ? 'name1' : 'name2'\\"
        [attr.title]=\\"slotContent ? 'title1' : 'title2'\\"
        (click)=\\"show()\\"
        [class]=\\"cls\\"
        #elRef0
      >
        <ng-container *ngIf=\\"showContent && slotContent\\">
          <ng-content select=\\"[content]\\">{{content}}</ng-content>
        </ng-container>
        <div><hr /></div>
        <div><ng-content></ng-content></div>
      </div>
    </ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class ContentSlotJsxCode {
  @Input() attributes;
  @Input() content = defaultProps[\\"content\\"];

  @ViewChild(\\"_root\\") _root;

  @ViewChild(\\"elRef0\\") elRef0;

  _listenerFns = new Map();

  name = \\"king\\";
  showContent = false;
  get cls() {
    return this.slotContent && this.children ? \`\${this.name}-content\` : \\"\\";
  }
  show() {
    this.slotContent ? 1 : \\"\\";
  }
  setAttributes(el, value, changes) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"content-slot-jsx-code\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [ContentSlotJsxCode],
  imports: [CommonModule],
  exports: [ContentSlotJsxCode],
  bootstrap: [SomeOtherComponent],
})
export class ContentSlotJsxCodeModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > CustomCode 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"custom-code\\",
  template: \`
    <div
      #elem
      [class]=\\"'builder-custom-code' + (replaceNodes ? ' replace-nodes' : '')\\"
      [innerHTML]=\\"code\\"
      #_root
    ></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class CustomCode {
  @Input() replaceNodes;
  @Input() code;

  @ViewChild(\\"elem\\") elem;
  @ViewChild(\\"_root\\") _root;

  scriptsInserted = [];
  scriptsRun = [];
  findAndRunScripts() {
    // TODO: Move this function to standalone one in '@builder.io/utils'
    if (this.elem.nativeElement && typeof window !== \\"undefined\\") {
      /** @type {HTMLScriptElement[]} */
      const scripts = this.elem.nativeElement.getElementsByTagName(\\"script\\");

      for (let i = 0; i < scripts.length; i++) {
        const script = scripts[i];

        if (script.src) {
          if (this.scriptsInserted.includes(script.src)) {
            continue;
          }

          this.scriptsInserted.push(script.src);
          const newScript = document.createElement(\\"script\\");
          newScript.async = true;
          newScript.src = script.src;
          document.head.appendChild(newScript);
        } else if (
          !script.type ||
          [
            \\"text/javascript\\",
            \\"application/javascript\\",
            \\"application/ecmascript\\",
          ].includes(script.type)
        ) {
          if (this.scriptsRun.includes(script.innerText)) {
            continue;
          }

          try {
            this.scriptsRun.push(script.innerText);
            new Function(script.innerText)();
          } catch (error) {
            console.warn(\\"\`CustomCode\`: Error running script:\\", error);
          }
        }
      }
    }
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    if (typeof window !== \\"undefined\\") {
      this.findAndRunScripts();
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"custom-code\\");
  }
}

@NgModule({
  declarations: [CustomCode],
  imports: [CommonModule],
  exports: [CustomCode],
  bootstrap: [SomeOtherComponent],
})
export class CustomCodeModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > Embed 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"custom-code\\",
  template: \`
    <div
      #elem
      [class]=\\"'builder-custom-code' + (replaceNodes ? ' replace-nodes' : '')\\"
      [innerHTML]=\\"code\\"
      #_root
    ></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class CustomCode {
  @Input() replaceNodes;
  @Input() code;

  @ViewChild(\\"elem\\") elem;
  @ViewChild(\\"_root\\") _root;

  scriptsInserted = [];
  scriptsRun = [];
  findAndRunScripts() {
    // TODO: Move this function to standalone one in '@builder.io/utils'
    if (this.elem.nativeElement && typeof window !== \\"undefined\\") {
      /** @type {HTMLScriptElement[]} */
      const scripts = this.elem.nativeElement.getElementsByTagName(\\"script\\");

      for (let i = 0; i < scripts.length; i++) {
        const script = scripts[i];

        if (script.src) {
          if (this.scriptsInserted.includes(script.src)) {
            continue;
          }

          this.scriptsInserted.push(script.src);
          const newScript = document.createElement(\\"script\\");
          newScript.async = true;
          newScript.src = script.src;
          document.head.appendChild(newScript);
        } else if (
          !script.type ||
          [
            \\"text/javascript\\",
            \\"application/javascript\\",
            \\"application/ecmascript\\",
          ].includes(script.type)
        ) {
          if (this.scriptsRun.includes(script.innerText)) {
            continue;
          }

          try {
            this.scriptsRun.push(script.innerText);
            new Function(script.innerText)();
          } catch (error) {
            console.warn(\\"\`CustomCode\`: Error running script:\\", error);
          }
        }
      }
    }
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    if (typeof window !== \\"undefined\\") {
      this.findAndRunScripts();
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"custom-code\\");
  }
}

@NgModule({
  declarations: [CustomCode],
  imports: [CommonModule],
  exports: [CustomCode],
  bootstrap: [SomeOtherComponent],
})
export class CustomCodeModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > Form 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
} from \\"@angular/core\\";

import { Builder, builder } from \\"@builder.io/sdk\\";
import {
  BuilderBlock as BuilderBlockComponentModule,
  BuilderBlocks,
  get,
  set,
} from \\"@fake/angular\\";

@Component({
  selector: \\"form-component\\",
  template: \`
    <form
      [attr.validate]=\\"validate\\"
      #formRef
      [attr.action]=\\"!sendWithJs && action\\"
      [attr.method]=\\"method\\"
      [attr.name]=\\"name\\"
      (submit)=\\"onSubmit($event)\\"
      #elRef0
      #_root
    >
      <ng-container *ngIf=\\"builderBlock && builderBlock.children\\">
        <ng-container
          *ngFor=\\"let block of builderBlock?.children; index as index; trackBy: trackByBlock0\\"
        >
          <builder-block-component
            [block]=\\"block\\"
            [index]=\\"index\\"
          ></builder-block-component>
        </ng-container>
      </ng-container>
      <ng-container *ngIf=\\"submissionState === 'error'\\">
        <builder-blocks
          dataPath=\\"errorMessage\\"
          [blocks]=\\"errorMessage\\"
        ></builder-blocks>
      </ng-container>
      <ng-container *ngIf=\\"submissionState === 'sending'\\">
        <builder-blocks
          dataPath=\\"sendingMessage\\"
          [blocks]=\\"sendingMessage\\"
        ></builder-blocks>
      </ng-container>
      <ng-container *ngIf=\\"submissionState === 'error' && responseData\\">
        <pre class=\\"builder-form-error-text pre\\">{{responseData | json}}</pre>
      </ng-container>
      <ng-container *ngIf=\\"submissionState === 'success'\\">
        <builder-blocks
          dataPath=\\"successMessage\\"
          [blocks]=\\"successMessage\\"
        ></builder-blocks>
      </ng-container>
    </form>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .pre {
        padding: 10px;
        color: red;
        text-align: center;
      }
    \`,
  ],
})
export default class FormComponent {
  builder = builder;

  @Input() previewState;
  @Input() sendWithJs;
  @Input() sendSubmissionsTo;
  @Input() action;
  @Input() customHeaders;
  @Input() contentType;
  @Input() sendSubmissionsToEmail;
  @Input() name;
  @Input() method;
  @Input() errorMessagePath;
  @Input() resetFormOnSubmit;
  @Input() successUrl;
  @Input() validate;
  @Input() attributes;
  @Input() builderBlock;
  @Input() errorMessage;
  @Input() sendingMessage;
  @Input() successMessage;

  @ViewChild(\\"formRef\\") formRef;
  @ViewChild(\\"_root\\") _root;

  @ViewChild(\\"elRef0\\") elRef0;

  _listenerFns = new Map();

  formState = \\"unsubmitted\\";
  responseData = null;
  formErrorMessage = \\"\\";
  get submissionState() {
    return (Builder.isEditing && this.previewState) || this.formState;
  }
  onSubmit(event) {
    const sendWithJs = this.sendWithJs || this.sendSubmissionsTo === \\"email\\";

    if (this.sendSubmissionsTo === \\"zapier\\") {
      event.preventDefault();
    } else if (sendWithJs) {
      if (!(this.action || this.sendSubmissionsTo === \\"email\\")) {
        event.preventDefault();
        return;
      }

      event.preventDefault();
      const el = event.currentTarget;
      const headers = this.customHeaders || {};
      let body;
      const formData = new FormData(el); // TODO: maybe support null

      const formPairs = Array.from(
        event.currentTarget.querySelectorAll(\\"input,select,textarea\\")
      )
        .filter((el) => !!el.name)
        .map((el) => {
          let value;
          const key = el.name;

          if (el instanceof HTMLInputElement) {
            if (el.type === \\"radio\\") {
              if (el.checked) {
                value = el.name;
                return {
                  key,
                  value,
                };
              }
            } else if (el.type === \\"checkbox\\") {
              value = el.checked;
            } else if (el.type === \\"number\\" || el.type === \\"range\\") {
              const num = el.valueAsNumber;

              if (!isNaN(num)) {
                value = num;
              }
            } else if (el.type === \\"file\\") {
              // TODO: one vs multiple files
              value = el.files;
            } else {
              value = el.value;
            }
          } else {
            value = el.value;
          }

          return {
            key,
            value,
          };
        });
      let contentType = this.contentType;

      if (this.sendSubmissionsTo === \\"email\\") {
        contentType = \\"multipart/form-data\\";
      }

      Array.from(formPairs).forEach(({ value }) => {
        if (
          value instanceof File ||
          (Array.isArray(value) && value[0] instanceof File) ||
          value instanceof FileList
        ) {
          contentType = \\"multipart/form-data\\";
        }
      }); // TODO: send as urlEncoded or multipart by default
      // because of ease of use and reliability in browser API
      // for encoding the form?

      if (contentType !== \\"application/json\\") {
        body = formData;
      } else {
        // Json
        const json = {};
        Array.from(formPairs).forEach(({ value, key }) => {
          set(json, key, value);
        });
        body = JSON.stringify(json);
      }

      if (contentType && contentType !== \\"multipart/form-data\\") {
        if (
          /* Zapier doesn't allow content-type header to be sent from browsers */
          !(sendWithJs && this.action?.includes(\\"zapier.com\\"))
        ) {
          headers[\\"content-type\\"] = contentType;
        }
      }

      const presubmitEvent = new CustomEvent(\\"presubmit\\", {
        detail: {
          body,
        },
      });

      if (this.formRef.nativeElement) {
        this.formRef.nativeElement.dispatchEvent(presubmitEvent);

        if (presubmitEvent.defaultPrevented) {
          return;
        }
      }

      this.formState = \\"sending\\";
      const formUrl = \`\${
        builder.env === \\"dev\\" ? \\"http://localhost:5000\\" : \\"https://builder.io\\"
      }/api/v1/form-submit?apiKey=\${builder.apiKey}&to=\${btoa(
        this.sendSubmissionsToEmail || \\"\\"
      )}&name=\${encodeURIComponent(this.name || \\"\\")}\`;
      fetch(
        this.sendSubmissionsTo === \\"email\\" ? formUrl : this.action,
        /* TODO: throw error if no action URL */
        {
          body,
          headers,
          method: this.method || \\"post\\",
        }
      ).then(
        async (res) => {
          let body;
          const contentType = res.headers.get(\\"content-type\\");

          if (contentType && contentType.indexOf(\\"application/json\\") !== -1) {
            body = await res.json();
          } else {
            body = await res.text();
          }

          if (!res.ok && this.errorMessagePath) {
            /* TODO: allow supplying an error formatter function */
            let message = get(body, this.errorMessagePath);

            if (message) {
              if (typeof message !== \\"string\\") {
                /* TODO: ideally convert json to yaml so it woul dbe like
            error: - email has been taken */
                message = JSON.stringify(message);
              }

              this.formErrorMessage = message;
            }
          }

          this.responseData = body;
          this.formState = res.ok ? \\"success\\" : \\"error\\";

          if (res.ok) {
            const submitSuccessEvent = new CustomEvent(\\"submit:success\\", {
              detail: {
                res,
                body,
              },
            });

            if (this.formRef.nativeElement) {
              this.formRef.nativeElement.dispatchEvent(submitSuccessEvent);

              if (submitSuccessEvent.defaultPrevented) {
                return;
              }
              /* TODO: option to turn this on/off? */

              if (this.resetFormOnSubmit !== false) {
                this.formRef.nativeElement.reset();
              }
            }
            /* TODO: client side route event first that can be preventDefaulted */

            if (this.successUrl) {
              if (this.formRef.nativeElement) {
                const event = new CustomEvent(\\"route\\", {
                  detail: {
                    url: this.successUrl,
                  },
                });
                this.formRef.nativeElement.dispatchEvent(event);

                if (!event.defaultPrevented) {
                  location.href = this.successUrl;
                }
              } else {
                location.href = this.successUrl;
              }
            }
          }
        },
        (err) => {
          const submitErrorEvent = new CustomEvent(\\"submit:error\\", {
            detail: {
              error: err,
            },
          });

          if (this.formRef.nativeElement) {
            this.formRef.nativeElement.dispatchEvent(submitErrorEvent);

            if (submitErrorEvent.defaultPrevented) {
              return;
            }
          }

          this.responseData = err;
          this.formState = \\"error\\";
        }
      );
    }
  }
  setAttributes(el, value, changes) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }
  trackByBlock0(index, block) {
    return block.id;
  }

  constructor(private renderer) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"form-component\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [FormComponent],
  imports: [CommonModule, BuilderBlockComponentModule, BuilderBlocksModule],
  exports: [FormComponent],
  bootstrap: [SomeOtherComponent],
})
export class FormComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > Image 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"image\\",
  template: \`
    <div #_root>
      <picture #pictureRef>
        <ng-container *ngIf=\\"!useLazyLoading() || load\\">
          <img
            [attr.alt]=\\"altText\\"
            [attr.aria-role]=\\"altText ? 'presentation' : undefined\\"
            [class]=\\"'builder-image' + (_class ? ' ' + _class : '') + ' img'\\"
            [attr.src]=\\"image\\"
            (load)=\\"setLoaded()\\"
            [attr.srcset]=\\"srcset\\"
            [attr.sizes]=\\"sizes\\"
          />
        </ng-container>
        <source [attr.srcset]=\\"srcset\\" />
      </picture>
      <ng-content></ng-content>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .img {
        opacity: 1;
        transition: opacity 0.2s ease-in-out;
        object-fit: cover;
        object-position: center;
      }
    \`,
  ],
})
export default class Image {
  @Input() lazy;
  @Input() altText;
  @Input() _class;
  @Input() image;
  @Input() srcset;
  @Input() sizes;

  @ViewChild(\\"pictureRef\\") pictureRef;
  @ViewChild(\\"_root\\") _root;

  scrollListener = null;
  imageLoaded = false;
  setLoaded() {
    this.imageLoaded = true;
  }
  useLazyLoading() {
    // TODO: Add more checks here, like testing for real web browsers
    return !!this.lazy && this.isBrowser();
  }
  isBrowser = function isBrowser() {
    return (
      typeof window !== \\"undefined\\" && window.navigator.product != \\"ReactNative\\"
    );
  };
  load = false;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    if (typeof window !== \\"undefined\\") {
      if (this.useLazyLoading()) {
        // throttled scroll capture listener
        const listener = () => {
          if (this.pictureRef.nativeElement) {
            const rect = this.pictureRef.nativeElement.getBoundingClientRect();
            const buffer = window.innerHeight / 2;

            if (rect.top < window.innerHeight + buffer) {
              this.load = true;
              this.scrollListener = null;
              window.removeEventListener(\\"scroll\\", listener);
            }
          }
        };

        this.scrollListener = listener;
        window.addEventListener(\\"scroll\\", listener, {
          capture: true,
          passive: true,
        });
        listener();
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"image\\");
  }

  ngOnDestroy() {
    if (this.scrollListener) {
      window.removeEventListener(\\"scroll\\", this.scrollListener);
    }
  }
}

@NgModule({
  declarations: [Image],
  imports: [CommonModule],
  exports: [Image],
  bootstrap: [SomeOtherComponent],
})
export class ImageModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > Image State 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"img-state-component\\",
  template: \`
    <div #_root>
      <ng-container *ngFor=\\"let item of images; index as itemIndex\\">
        <ng-container>
          <img class=\\"custom-class\\" [attr.src]=\\"item\\" />
        </ng-container>
      </ng-container>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class ImgStateComponent {
  @ViewChild(\\"_root\\") _root;

  canShow = true;
  images = [\\"http://example.com/qwik.png\\"];

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"img-state-component\\");
  }
}

@NgModule({
  declarations: [ImgStateComponent],
  imports: [CommonModule],
  exports: [ImgStateComponent],
  bootstrap: [SomeOtherComponent],
})
export class ImgStateComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > Img 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
} from \\"@angular/core\\";

import { Builder } from \\"@builder.io/sdk\\";

@Component({
  selector: \\"img-component\\",
  template: \`
    <img
      [ngStyle]=\\"{
          objectFit: backgroundSize || 'cover',
          objectPosition: backgroundPosition || 'center'
        }\\"
      [attr.alt]=\\"altText\\"
      [attr.src]=\\"imgSrc\\"
      #elRef0
      #_root
    />
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class ImgComponent {
  @Input() backgroundSize;
  @Input() backgroundPosition;
  @Input() attributes;
  @Input() imgSrc;
  @Input() altText;

  @ViewChild(\\"_root\\") _root;

  @ViewChild(\\"elRef0\\") elRef0;

  _listenerFns = new Map();

  setAttributes(el, value, changes) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"img-component\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [ImgComponent],
  imports: [CommonModule],
  exports: [ImgComponent],
  bootstrap: [SomeOtherComponent],
})
export class ImgComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > Input 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
} from \\"@angular/core\\";

import { Builder } from \\"@builder.io/sdk\\";

@Component({
  selector: \\"form-input-component\\",
  template: \`
    <input
      [attr.placeholder]=\\"placeholder\\"
      [attr.type]=\\"type\\"
      [attr.name]=\\"name\\"
      [attr.value]=\\"value\\"
      [attr.defaultValue]=\\"defaultValue\\"
      [attr.required]=\\"required\\"
      (change)=\\"onChange?.($event.target.value)\\"
      #elRef0
      #_root
    />
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class FormInputComponent {
  @Input() attributes;
  @Input() defaultValue;
  @Input() placeholder;
  @Input() type;
  @Input() name;
  @Input() value;
  @Input() required;
  @Input() onChange;

  @ViewChild(\\"_root\\") _root;

  @ViewChild(\\"elRef0\\") elRef0;

  _listenerFns = new Map();

  setAttributes(el, value, changes) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"form-input-component\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [FormInputComponent],
  imports: [CommonModule],
  exports: [FormInputComponent],
  bootstrap: [SomeOtherComponent],
})
export class FormInputComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > InputParent 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

import FormInputComponentModule from \\"./input.raw/angular\\";

@Component({
  selector: \\"stepper\\",
  template: \`
    <form-input-component
      name=\\"kingzez\\"
      type=\\"text\\"
      (change)=\\"handleChange($event)\\"
      #_root
    ></form-input-component>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class Stepper {
  @ViewChild(\\"_root\\") _root;

  handleChange(value) {
    console.log(value);
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"stepper\\");
  }
}

@NgModule({
  declarations: [Stepper],
  imports: [CommonModule, FormInputComponentModule],
  exports: [Stepper],
  bootstrap: [SomeOtherComponent],
})
export class StepperModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > NestedStore 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"nested-store\\",
  template: \`
    <div [attr.id]=\\"_id\\" #_root>
      Test

      <p [attr.id]=\\"_messageId\\">Message</p>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class NestedStore {
  @ViewChild(\\"_root\\") _root;

  _id = \\"abc\\";
  _messageId = null;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this._messageId = this._id + \\"-message\\";
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"nested-store\\");
  }
}

@NgModule({
  declarations: [NestedStore],
  imports: [CommonModule],
  exports: [NestedStore],
  bootstrap: [SomeOtherComponent],
})
export class NestedStoreModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > RawText 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"raw-text\\",
  template: \`
    <span
      [class]=\\"attributes?.class || attributes?.className\\"
      [innerHTML]=\\"text || ''\\"
      #_root
    ></span>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class RawText {
  @Input() attributes;
  @Input() text;

  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"raw-text\\");
  }
}

@NgModule({
  declarations: [RawText],
  imports: [CommonModule],
  exports: [RawText],
  bootstrap: [SomeOtherComponent],
})
export class RawTextModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > Section 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
} from \\"@angular/core\\";

@Component({
  selector: \\"section-component\\",
  template: \`
    <section
      [ngStyle]=\\"maxWidth && typeof maxWidth === 'number' ? {
          maxWidth: maxWidth
        } : undefined\\"
      #elRef0
      #_root
    >
      <ng-content></ng-content>
    </section>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class SectionComponent {
  @Input() attributes;
  @Input() maxWidth;

  @ViewChild(\\"_root\\") _root;

  @ViewChild(\\"elRef0\\") elRef0;

  _listenerFns = new Map();

  setAttributes(el, value, changes) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"section-component\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [SectionComponent],
  imports: [CommonModule],
  exports: [SectionComponent],
  bootstrap: [SomeOtherComponent],
})
export class SectionComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > Section 2`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
} from \\"@angular/core\\";

@Component({
  selector: \\"section-state-component\\",
  template: \`
    <ng-container *ngIf=\\"max\\">
      <ng-container *ngFor=\\"let item of items\\">
        <section
          [ngStyle]=\\"{
          maxWidth: item + max
        }\\"
          #elRef0
        >
          <ng-content></ng-content>
        </section>
      </ng-container>
    </ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class SectionStateComponent {
  @Input() attributes;

  @ViewChild(\\"_root\\") _root;

  @ViewChild(\\"elRef0\\") elRef0;

  _listenerFns = new Map();

  max = 42;
  items = [42];
  setAttributes(el, value, changes) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"section-state-component\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [SectionStateComponent],
  imports: [CommonModule],
  exports: [SectionStateComponent],
  bootstrap: [SomeOtherComponent],
})
export class SectionStateComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > Select 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
} from \\"@angular/core\\";

import { Builder } from \\"@builder.io/sdk\\";

@Component({
  selector: \\"select-component\\",
  template: \`
    <select
      [attr.value]=\\"value\\"
      [attr.defaultValue]=\\"defaultValue\\"
      [attr.name]=\\"name\\"
      #elRef0
      #_root
    >
      <ng-container *ngFor=\\"let option of options; index as index\\">
        <option [attr.value]=\\"option.value\\" [attr.data-index]=\\"index\\">
          {{option.name || option.value}}
        </option>
      </ng-container>
    </select>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class SelectComponent {
  @Input() attributes;
  @Input() value;
  @Input() defaultValue;
  @Input() name;
  @Input() options;

  @ViewChild(\\"_root\\") _root;

  @ViewChild(\\"elRef0\\") elRef0;

  _listenerFns = new Map();

  setAttributes(el, value, changes) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"select-component\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [SelectComponent],
  imports: [CommonModule],
  exports: [SelectComponent],
  bootstrap: [SomeOtherComponent],
})
export class SelectComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > SlotDefault 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"slot-code\\",
  template: \`
    <div #_root>
      <ng-content><div class=\\"default-slot\\">Default content</div></ng-content>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class SlotCode {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"slot-code\\");
  }
}

@NgModule({
  declarations: [SlotCode],
  imports: [CommonModule],
  exports: [SlotCode],
  bootstrap: [SomeOtherComponent],
})
export class SlotCodeModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > SlotHtml 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

import ContentSlotCodeModule from \\"./content-slot-jsx.raw/angular\\";

@Component({
  selector: \\"slot-code\\",
  template: \`
    <div #_root>
      <content-slot-code>
        <ng-content><div>Hello</div></ng-content>
      </content-slot-code>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class SlotCode {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"slot-code\\");
  }
}

@NgModule({
  declarations: [SlotCode],
  imports: [CommonModule, ContentSlotCodeModule],
  exports: [SlotCode],
  bootstrap: [SomeOtherComponent],
})
export class SlotCodeModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > SlotJsx 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

import ContentSlotCodeModule from \\"./content-slot-jsx.raw/angular\\";

@Component({
  selector: \\"slot-code\\",
  template: \`
    <div #_root>
      <content-slot-code [slotTesting]=\\"<div>Hello</div>\\"></content-slot-code>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class SlotCode {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"slot-code\\");
  }
}

@NgModule({
  declarations: [SlotCode],
  imports: [CommonModule, ContentSlotCodeModule],
  exports: [SlotCode],
  bootstrap: [SomeOtherComponent],
})
export class SlotCodeModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > SlotNamed 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"slot-code\\",
  template: \`
    <div #_root>
      <ng-content select=\\"[my-awesome-slot]\\"></ng-content>
      <ng-content select=\\"[top]\\"></ng-content>
      <ng-content select=\\"[left]\\">Default left</ng-content>
      <ng-content>Default Child</ng-content>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class SlotCode {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"slot-code\\");
  }
}

@NgModule({
  declarations: [SlotCode],
  imports: [CommonModule],
  exports: [SlotCode],
  bootstrap: [SomeOtherComponent],
})
export class SlotCodeModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > Stamped.io 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

import { kebabCase, snakeCase } from \\"lodash\\";

@Component({
  selector: \\"smile-reviews\\",
  template: \`
    <div [attr.data-user]=\\"name\\" #_root>
      <button (click)=\\"showReviewPrompt = true\\">Write a review</button>
      <ng-container *ngIf=\\"showReviewPrompt || 'asdf'\\">
        <input placeholder=\\"Email\\" />
        <input placeholder=\\"Title\\" class=\\"input\\" />
        <textarea
          placeholder=\\"How was your experience?\\"
          class=\\"textarea\\"
        ></textarea>
        <button
          class=\\"button\\"
          (click)=\\"
          $event.preventDefault();
          showReviewPrompt = false;
        \\"
        >
          Submit
        </button>
      </ng-container>
      <ng-container
        *ngFor=\\"let review of reviews; index as index; trackBy: trackByReview0\\"
      >
        <div class=\\"review\\">
          <img class=\\"img\\" [attr.src]=\\"review.avatar\\" />
          <div [class]=\\"showReviewPrompt ? 'bg-primary' : 'bg-secondary'\\">
            <div>N: {{index}}</div>
            <div>{{review.author}}</div>
            <div>{{review.reviewMessage}}</div>
          </div>
        </div>
      </ng-container>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .input {
        display: block;
      }
      .textarea {
        display: block;
      }
      .button {
        display: block;
      }
      .review {
        margin: 10px;
        padding: 10px;
        background: white;
        display: flex;
        border-radius: 5px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        -webkit-font-smoothing: antialiased;
      }
      .img {
        height: 30px;
        width: 30px;
        margin-right: 10px;
      }
    \`,
  ],
})
export default class SmileReviews {
  @Input() apiKey;
  @Input() productId;

  @ViewChild(\\"_root\\") _root;

  reviews = [];
  name = \\"test\\";
  showReviewPrompt = false;
  kebabCaseValue() {
    return kebabCase(\\"testThat\\");
  }
  snakeCaseValue() {
    return snakeCase(\\"testThis\\");
  }
  trackByReview0(index, review) {
    return review.id;
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    if (typeof window !== \\"undefined\\") {
      fetch(
        \`https://stamped.io/api/widget/reviews?storeUrl=builder-io.myshopify.com&apiKey=\${
          this.apiKey || \\"pubkey-8bbDq7W6w4sB3OWeM1HUy2s47702hM\\"
        }&productId=\${this.productId || \\"2410511106127\\"}\`
      )
        .then((res) => res.json())
        .then((data) => {
          this.reviews = data.data;
        });
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"smile-reviews\\");
  }
}

@NgModule({
  declarations: [SmileReviews],
  imports: [CommonModule],
  exports: [SmileReviews],
  bootstrap: [SomeOtherComponent],
})
export class SmileReviewsModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > StoreComment 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"string-literal-store\\",
  template: \`
    <ng-container>{{foo}}</ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class StringLiteralStore {
  @ViewChild(\\"_root\\") _root;

  foo = true;
  bar() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"string-literal-store\\");
  }
}

@NgModule({
  declarations: [StringLiteralStore],
  imports: [CommonModule],
  exports: [StringLiteralStore],
  bootstrap: [SomeOtherComponent],
})
export class StringLiteralStoreModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > StoreShadowVars 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <ng-container>{{foo(errors)}}</ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root;

  errors = {};
  foo(errors) {
    return errors;
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > StoreWithState 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <ng-container>{{bar()}}</ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root;

  foo = false;
  bar() {
    return this.foo;
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > Submit 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
} from \\"@angular/core\\";

@Component({
  selector: \\"submit-button\\",
  template: \`
    <button type=\\"submit\\" #elRef0 #_root>{{text}}</button>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class SubmitButton {
  @Input() attributes;
  @Input() text;

  @ViewChild(\\"_root\\") _root;

  @ViewChild(\\"elRef0\\") elRef0;

  _listenerFns = new Map();

  setAttributes(el, value, changes) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"submit-button\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [SubmitButton],
  imports: [CommonModule],
  exports: [SubmitButton],
  bootstrap: [SomeOtherComponent],
})
export class SubmitButtonModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > Text 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

import { Builder } from \\"@builder.io/sdk\\";

@Component({
  selector: \\"text\\",
  template: \`
    <div
      [attr.contentEditable]=\\"allowEditingText || undefined\\"
      [attr.data-name]=\\"{
          test: name || 'any name'
        }\\"
      [innerHTML]=\\"text || content || name || '<p class=&quot;text-lg&quot;>my name</p>'\\"
      #_root
    ></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class Text {
  @Input() text;
  @Input() content;

  @ViewChild(\\"_root\\") _root;

  name = \\"Decadef20\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"text\\");
  }
}

@NgModule({
  declarations: [Text],
  imports: [CommonModule],
  exports: [Text],
  bootstrap: [SomeOtherComponent],
})
export class TextModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > Textarea 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
} from \\"@angular/core\\";

@Component({
  selector: \\"textarea\\",
  template: \`
    <textarea
      [attr.placeholder]=\\"placeholder\\"
      [attr.name]=\\"name\\"
      [attr.value]=\\"value\\"
      [attr.defaultValue]=\\"defaultValue\\"
      #elRef0
      #_root
    ></textarea>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class Textarea {
  @Input() attributes;
  @Input() placeholder;
  @Input() name;
  @Input() value;
  @Input() defaultValue;

  @ViewChild(\\"_root\\") _root;

  @ViewChild(\\"elRef0\\") elRef0;

  _listenerFns = new Map();

  setAttributes(el, value, changes) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"textarea\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [Textarea],
  imports: [CommonModule],
  exports: [Textarea],
  bootstrap: [SomeOtherComponent],
})
export class TextareaModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > UseValueAndFnFromStore 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Output,
  EventEmitter,
  Component,
  ViewChild,
  ElementRef,
} from \\"@angular/core\\";

@Component({
  selector: \\"use-value-and-fn-from-store\\",
  template: \`
    <div #_root>Test</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class UseValueAndFnFromStore {
  @Output() onChange = new EventEmitter();

  @ViewChild(\\"_root\\") _root;

  _id = \\"abc\\";
  _active = false;
  _do(id) {
    this._active = !!id;

    if (this.onChange) {
      this.onChange.emit(this._active);
    }
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"use-value-and-fn-from-store\\");
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      if (this._do) {
        this._do(this._id);
      }
    }
  }
}

@NgModule({
  declarations: [UseValueAndFnFromStore],
  imports: [CommonModule],
  exports: [UseValueAndFnFromStore],
  bootstrap: [SomeOtherComponent],
})
export class UseValueAndFnFromStoreModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > Video 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
} from \\"@angular/core\\";

@Component({
  selector: \\"video\\",
  template: \`
    <video
      preload=\\"none\\"
      [ngStyle]=\\"useObjectWrapper({
          width: '100%' },{
          height: '100%' },
          attributes?.style,{
          objectFit: fit },{
          objectPosition: position },{
              borderRadius: 1 },)\\"
      [attr.poster]=\\"posterImage\\"
      [attr.autoplay]=\\"autoPlay\\"
      [attr.muted]=\\"muted\\"
      [attr.controls]=\\"controls\\"
      [attr.loop]=\\"loop\\"
      #elRef0
      #_root
    ></video>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class Video {
  @Input() attributes;
  @Input() fit;
  @Input() position;
  @Input() video;
  @Input() posterImage;
  @Input() autoPlay;
  @Input() muted;
  @Input() controls;
  @Input() loop;

  @ViewChild(\\"_root\\") _root;

  @ViewChild(\\"elRef0\\") elRef0;

  _listenerFns = new Map();

  setAttributes(el, value, changes) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  useObjectWrapper(...args) {
    let obj = {};
    args.forEach((arg) => {
      obj = { ...obj, ...arg };
    });
    return obj;
  }

  constructor(private renderer) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"video\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [Video],
  imports: [CommonModule],
  exports: [Video],
  bootstrap: [SomeOtherComponent],
})
export class VideoModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > allSpread 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
} from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #elRef0 #_root>
      Hello! I can run natively in React, Vue, Svelte, Qwik, and many more
      frameworks!
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @Input() attributes;
  @Input() accessHere;

  @ViewChild(\\"_root\\") _root;

  @ViewChild(\\"elRef0\\") elRef0;

  _listenerFns = new Map();

  attrsUsingUseState = {
    hello: \\"world\\",
  };
  properties = {
    style: \\"color: blue\\",
    onClick: () => console.log(\\"pressed\\"),
  };
  specifics = {
    someSpecificState: \\"specific\\",
  };
  setAttributes(el, value, changes) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }
  elRef0_state_0 = null;

  constructor(private renderer) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.elRef0_state_0 = {
      someOtherAttrs: this.accessHere,
      someStateAttrs: this.specifics,
    };
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attrsUsingUseState);
    this.setAttributes(this.elRef0?.nativeElement, this.properties);
    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
    this.setAttributes(this.elRef0?.nativeElement, this.elRef0_state_0);
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attrsUsingUseState,
        changes[\\"attrsUsingUseState\\"]?.currentValue
      );
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.properties,
        changes[\\"properties\\"]?.currentValue
      );
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
      this.elRef0_state_0 = {
        someOtherAttrs: this.accessHere,
        someStateAttrs: this.specifics,
      };
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.elRef0_state_0,
        changes[\\"elRef0_state_0\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > arrowFunctionInUseStore 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>Hello {{name}}</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root;

  name = \\"steve\\";
  setName(value) {
    this.name = value;
  }
  updateNameWithArrowFn(value) {
    this.name = value;
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > basicForFragment 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"basic-for-fragment\\",
  template: \`
    <div #_root>
      <ng-container
        *ngFor=\\"let option of ['a', 'b', 'c']; trackBy: trackByOption0\\"
      >
        <ng-container>
          <div>{{option}}</div>
        </ng-container>
      </ng-container>
      <ng-container
        *ngFor=\\"let option of ['a', 'b', 'c']; trackBy: trackByOption1\\"
      >
        <ng-container>
          <div>{{option}}</div>
        </ng-container>
      </ng-container>
      <select>
        <ng-container
          *ngFor=\\"let option of ['d', 'e', 'f']; trackBy: trackByOption2\\"
        >
          <option [attr.value]=\\"option\\">{{option}}</option>
        </ng-container>
      </select>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class BasicForFragment {
  @ViewChild(\\"_root\\") _root;

  id = \\"xyz\\";
  trackByOption0(_, option) {
    return \`key-\${option}\`;
  }
  trackByOption1(_, option) {
    return \`\${this.id}-\${option}\`;
  }
  trackByOption2(_, option) {
    return \`\${this.id}-\${option}\`;
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"basic-for-fragment\\");
  }
}

@NgModule({
  declarations: [BasicForFragment],
  imports: [CommonModule],
  exports: [BasicForFragment],
  bootstrap: [SomeOtherComponent],
})
export class BasicForFragmentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > basicForNoTagReference 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Input,
  ViewContainerRef,
  TemplateRef,
} from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-for-no-tag-ref-component\\",
  template: \`
    <ng-template #iconTemplate></ng-template>
    <ng-container
      *ngComponentOutlet=\\"
              TagNameGetter;
              inputs: {  };
              content: myContent;
              \\"
    ></ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicForNoTagRefComponent {
  @Input() actions;

  @ViewChild(\\"_root\\") _root;

  @ViewChild(\\"tagnamegetterTemplate\\", { static: true })
  tagnamegetterTemplateRef;
  @ViewChild(\\"tagTemplate\\", { static: true }) tagTemplateRef;
  @ViewChild(\\"tagnameTemplate\\", { static: true }) tagnameTemplateRef;
  @ViewChild(\\"iconTemplate\\", { static: true }) iconTemplateRef;

  myContent;

  name = \\"VincentW\\";
  TagName = \\"div\\";
  tag = \\"span\\";
  get TagNameGetter() {
    return \\"span\\";
  }

  constructor(private vcRef) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.myContent = [
      this.vcRef.createEmbeddedView(this.tagnamegetterTemplateRef).rootNodes,
      this.vcRef.createEmbeddedView(this.tagTemplateRef).rootNodes,
      this.vcRef.createEmbeddedView(this.tagnameTemplateRef).rootNodes,
      this.vcRef.createEmbeddedView(this.iconTemplateRef).rootNodes,
    ];
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-for-no-tag-ref-component\\");
  }
}

@NgModule({
  declarations: [MyBasicForNoTagRefComponent],
  imports: [CommonModule],
  exports: [MyBasicForNoTagRefComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicForNoTagRefComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > basicForwardRef 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-forward-ref-component\\",
  template: \`
    <div #_root>
      <input
        class=\\"input\\"
        [attr.value]=\\"name\\"
        (change)=\\"name = $event.target.value\\"
      />
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .input {
        color: red;
      }
    \`,
  ],
})
export default class MyBasicForwardRefComponent {
  @ViewChild(\\"_root\\") _root;

  name = \\"PatrickJS\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-forward-ref-component\\");
  }
}

@NgModule({
  declarations: [MyBasicForwardRefComponent],
  imports: [CommonModule],
  exports: [MyBasicForwardRefComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicForwardRefComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > basicForwardRefMetadata 1`] = `
"/**
          useMetadata:
          {\\"forwardRef\\":\\"inputRef\\"}
          */

import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-forward-ref-component\\",
  template: \`
    <div #_root>
      <input
        class=\\"input\\"
        [attr.value]=\\"name\\"
        (change)=\\"name = $event.target.value\\"
      />
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .input {
        color: red;
      }
    \`,
  ],
})
export default class MyBasicForwardRefComponent {
  @ViewChild(\\"_root\\") _root;

  name = \\"PatrickJS\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-forward-ref-component\\");
  }
}

@NgModule({
  declarations: [MyBasicForwardRefComponent],
  imports: [CommonModule],
  exports: [MyBasicForwardRefComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicForwardRefComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > basicOnUpdateReturn 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-on-update-return-component\\",
  template: \`
    <div #_root>Hello! {{name}}</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicOnUpdateReturnComponent {
  @ViewChild(\\"_root\\") _root;

  name = \\"PatrickJS\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-on-update-return-component\\");
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      const controller = new AbortController();
      const signal = controller.signal;
      fetch(\\"https://patrickjs.com/api/resource.json\\", {
        signal,
      })
        .then((response) => response.json())
        .then((data) => {
          this.name = data.name;
        });
      return () => {
        if (!signal.aborted) {
          controller.abort();
        }
      };
    }
  }
}

@NgModule({
  declarations: [MyBasicOnUpdateReturnComponent],
  imports: [CommonModule],
  exports: [MyBasicOnUpdateReturnComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicOnUpdateReturnComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > basicRefAttributePassing 1`] = `
"/**
          useMetadata:
          {\\"attributePassing\\":{\\"enabled\\":true}}
          */

import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"basic-ref-attribute-passing-component\\",
  template: \`
    <button #buttonRef>Attribute Passing</button>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class BasicRefAttributePassingComponent {
  @ViewChild(\\"buttonRef\\") buttonRef;
}

@NgModule({
  declarations: [BasicRefAttributePassingComponent],
  imports: [CommonModule],
  exports: [BasicRefAttributePassingComponent],
  bootstrap: [SomeOtherComponent],
})
export class BasicRefAttributePassingComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > basicRefAttributePassingCustomRef 1`] = `
"/**
          useMetadata:
          {\\"attributePassing\\":{\\"enabled\\":true,\\"customRef\\":\\"buttonRef\\"}}
          */

import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"basic-ref-attribute-passing-custom-ref-component\\",
  template: \`
    <div><button #buttonRef>Attribute Passing</button></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class BasicRefAttributePassingCustomRefComponent {
  @ViewChild(\\"buttonRef\\") buttonRef;
}

@NgModule({
  declarations: [BasicRefAttributePassingCustomRefComponent],
  imports: [CommonModule],
  exports: [BasicRefAttributePassingCustomRefComponent],
  bootstrap: [SomeOtherComponent],
})
export class BasicRefAttributePassingCustomRefComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > class + ClassName + css 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

import MyCompModule from \\"./my-component.lite/angular\\";

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <div #_root>
      <my-comp class=\\"test\\" className=\\"test2\\">
        Hello! I can run in React, Vue, Solid, or Liquid!
      </my-comp>
      <div class=\\"test2 test div\\">
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .div {
        padding: 10px;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule, MyCompModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > class + css 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <div class=\\"test div\\" #_root>
      Hello! I can run in React, Vue, Solid, or Liquid!
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .div {
        padding: 10px;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > className + css 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <div class=\\"test div\\" #_root>
      Hello! I can run in React, Vue, Solid, or Liquid!
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .div {
        padding: 10px;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > className 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"class-name-code\\",
  template: \`
    <div #_root>
      <div class=\\"no binding\\">Without Binding</div>
      <div [class]=\\"bindings\\">With binding</div>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class ClassNameCode {
  @ViewChild(\\"_root\\") _root;

  bindings = \\"a binding\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"class-name-code\\");
  }
}

@NgModule({
  declarations: [ClassNameCode],
  imports: [CommonModule],
  exports: [ClassNameCode],
  bootstrap: [SomeOtherComponent],
})
export class ClassNameCodeModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > classState 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <div [class]=\\"classState + ' div'\\" [ngStyle]=\\"styleState\\" #_root>
      Hello! I can run in React, Vue, Solid, or Liquid!
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .div {
        padding: 10px;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @ViewChild(\\"_root\\") _root;

  classState = \\"testClassName\\";
  styleState = {
    color: \\"red\\",
  };

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > complexMeta 1`] = `
"/**
          useMetadata:
          {\\"x\\":\\"y\\",\\"asdf\\":{\\"stringValue\\":\\"d\\",\\"booleanValue\\":true,\\"numberValue\\":1,\\"innerObject\\":{\\"stringValue\\":\\"inner\\",\\"numberValue\\":2,\\"booleanValue\\":false},\\"spreadStringValue\\":\\"f\\"}}
          */

import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"complex-meta-raw\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class ComplexMetaRaw {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"complex-meta-raw\\");
  }
}

@NgModule({
  declarations: [ComplexMetaRaw],
  imports: [CommonModule],
  exports: [ComplexMetaRaw],
  bootstrap: [SomeOtherComponent],
})
export class ComplexMetaRawModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > componentWithContext 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

import Context1 from \\"@dummy/1\\";
import Context2 from \\"@dummy/2\\";

@Component({
  selector: \\"component-with-context\\",
  template: \`
    <ng-container>
      <ng-container>{{foo.value}}</ng-container>
    </ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class ComponentWithContext {
  @Input() content;

  @ViewChild(\\"_root\\") _root;

  constructor(public foo: Context1) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"component-with-context\\");
  }
}

@NgModule({
  declarations: [ComponentWithContext],
  imports: [CommonModule],
  exports: [ComponentWithContext],
  bootstrap: [SomeOtherComponent],
})
export class ComponentWithContextModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > componentWithContextMultiRoot 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

import Context1 from \\"@dummy/1\\";
import Context2 from \\"@dummy/2\\";

@Component({
  selector: \\"component-with-context\\",
  template: \`
    <ng-container>
      <ng-container>{{foo.value}}</ng-container>
      <div>other</div>
    </ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class ComponentWithContext {
  @Input() content;

  @ViewChild(\\"_root\\") _root;

  constructor(public foo: Context1) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"component-with-context\\");
  }
}

@NgModule({
  declarations: [ComponentWithContext],
  imports: [CommonModule],
  exports: [ComponentWithContext],
  bootstrap: [SomeOtherComponent],
})
export class ComponentWithContextModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > contentState 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

import BuilderContext from \\"@dummy/context.lite\\";

@Component({
  selector: \\"render-content\\",
  template: \`
    <div #_root>setting context</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class RenderContent {
  @Input() content;
  @Input() customComponents;

  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"render-content\\");
  }
}

@NgModule({
  declarations: [RenderContent],
  imports: [CommonModule],
  exports: [RenderContent],
  bootstrap: [SomeOtherComponent],
})
export class RenderContentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > customSelector 1`] = `
"/**
          useMetadata:
          {\\"angular\\":{\\"selector\\":\\"not-my-component\\"}}
          */

import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"not-my-component\\",
  template: \`
    <span #_root>My selector shouldn't be my-component!</span>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > defaultProps 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Output,
  EventEmitter,
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
} from \\"@angular/core\\";

const defaultProps = {
  text: \\"default text\\",
  link: \\"https://builder.io/\\",
  openLinkInNewTab: false,
  onClick: () => {
    console.log(\\"hi\\");
  },
};

@Component({
  selector: \\"button\\",
  template: \`
    <div #_root>
      <ng-container *ngIf=\\"link\\">
        <a
          [attr.href]=\\"link\\"
          [attr.target]=\\"openLinkInNewTab ? '_blank' : undefined\\"
          #elRef0
        >
          {{text}}
        </a>
      </ng-container>
      <ng-container *ngIf=\\"!link\\">
        <button type=\\"button\\" (click)=\\"this.onClick.emit()\\" #elRef1>
          {{buttonText}}
        </button>
      </ng-container>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class Button {
  @Input() link = defaultProps[\\"link\\"];
  @Input() attributes;
  @Input() openLinkInNewTab = defaultProps[\\"openLinkInNewTab\\"];
  @Input() text = defaultProps[\\"text\\"];
  @Input() buttonText;

  @Output() onClick = new EventEmitter();

  @ViewChild(\\"_root\\") _root;

  @ViewChild(\\"elRef0\\") elRef0;
  @ViewChild(\\"elRef1\\") elRef1;

  _listenerFns = new Map();

  setAttributes(el, value, changes) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"button\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
    this.setAttributes(this.elRef1?.nativeElement, this.attributes);
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
      this.setAttributes(
        this.elRef1?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [Button],
  imports: [CommonModule],
  exports: [Button],
  bootstrap: [SomeOtherComponent],
})
export class ButtonModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > defaultPropsOutsideComponent 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Output,
  EventEmitter,
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
} from \\"@angular/core\\";

const defaultProps = {
  text: \\"default text\\",
  link: \\"https://builder.io/\\",
  openLinkInNewTab: false,
  onClick: () => {},
};

@Component({
  selector: \\"button\\",
  template: \`
    <div #_root>
      <ng-container *ngIf=\\"link\\">
        <a
          [attr.href]=\\"link\\"
          [attr.target]=\\"openLinkInNewTab ? '_blank' : undefined\\"
          #elRef0
        >
          {{text}}
        </a>
      </ng-container>
      <ng-container *ngIf=\\"!link\\">
        <button type=\\"button\\" (click)=\\"this.onClick.emit($event)\\" #elRef1>
          {{text}}
        </button>
      </ng-container>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class Button {
  @Input() link = defaultProps[\\"link\\"];
  @Input() attributes;
  @Input() openLinkInNewTab = defaultProps[\\"openLinkInNewTab\\"];
  @Input() text = defaultProps[\\"text\\"];

  @Output() onClick = new EventEmitter();

  @ViewChild(\\"_root\\") _root;

  @ViewChild(\\"elRef0\\") elRef0;
  @ViewChild(\\"elRef1\\") elRef1;

  _listenerFns = new Map();

  setAttributes(el, value, changes) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"button\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
    this.setAttributes(this.elRef1?.nativeElement, this.attributes);
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
      this.setAttributes(
        this.elRef1?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [Button],
  imports: [CommonModule],
  exports: [Button],
  bootstrap: [SomeOtherComponent],
})
export class ButtonModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > defaultValsWithTypes 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

const DEFAULT_VALUES = {
  name: \\"Sami\\",
};

@Component({
  selector: \\"component-with-types\\",
  template: \`
    <div #_root>Hello {{name || DEFAULT_VALUES.name}}</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class ComponentWithTypes {
  DEFAULT_VALUES = DEFAULT_VALUES;

  @Input() name;

  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"component-with-types\\");
  }
}

@NgModule({
  declarations: [ComponentWithTypes],
  imports: [CommonModule],
  exports: [ComponentWithTypes],
  bootstrap: [SomeOtherComponent],
})
export class ComponentWithTypesModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > dynamicComponent 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <ng-container
      *ngComponentOutlet=\\"
              obj.Component;
              inputs: { hello: 'world', onClick: onClick.bind(this), attributes: attributes, something: something };
              content: myContent;
              \\"
    ></ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @Input() attributes;
  @Input() something;

  @ViewChild(\\"_root\\") _root;

  obj = {
    name: \\"foo\\",
    Component: FooComponent,
  };
  onClick = function onClick() {
    console.log(\\"hello\\");
  };

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > dynamicComponentWithEventArg 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Input,
  ViewContainerRef,
  TemplateRef,
} from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <ng-template #componentTemplate>hello</ng-template>
    <ng-container
      *ngComponentOutlet=\\"
              Component;
              inputs: { hello: 'world', onClick: onClick.bind(this), attributes: attributes, something: something };
              content: myContent;
              \\"
    ></ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @Input() attributes;
  @Input() something;

  @ViewChild(\\"_root\\") _root;

  @ViewChild(\\"componentTemplate\\", { static: true }) componentTemplateRef;

  myContent;

  Component = HelloComponent;
  onClick = function onClick(event) {
    console.log(\\"hello\\", event);
  };

  constructor(private vcRef) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.myContent = [
      this.vcRef.createEmbeddedView(this.componentTemplateRef).rootNodes,
    ];
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > eventInputAndChange 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"event-input-and-change\\",
  template: \`
    <div #_root>
      <input
        class=\\"input\\"
        [attr.value]=\\"name\\"
        (input)=\\"name = $event.target.value\\"
        (change)=\\"name = $event.target.value\\"
      />

      Hello! I can run in React, Vue, Solid, or Liquid!
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .input {
        color: red;
      }
    \`,
  ],
})
export default class EventInputAndChange {
  @ViewChild(\\"_root\\") _root;

  name = \\"Steve\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"event-input-and-change\\");
  }
}

@NgModule({
  declarations: [EventInputAndChange],
  imports: [CommonModule],
  exports: [EventInputAndChange],
  bootstrap: [SomeOtherComponent],
})
export class EventInputAndChangeModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > expressionState 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>{{refToUse}}</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @Input() componentRef;

  @ViewChild(\\"_root\\") _root;

  refToUse = null;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.refToUse = !(this.componentRef instanceof Function)
      ? this.componentRef
      : null;
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > figmaMeta 1`] = `
"/**
          useMetadata:
          {\\"figma\\":{\\"name\\":\\"def-button-beta-outlined\\",\\"url\\":\\"https://www.figma.com/xxx\\",\\"props\\":{\\"iconSmall\\":{\\"type\\":\\"instance\\",\\"key\\":\\"📍 Icon Small\\"},\\"iconMedium\\":{\\"type\\":\\"instance\\",\\"key\\":\\"📍 Icon Medium\\"},\\"label\\":{\\"type\\":\\"string\\",\\"key\\":\\"✏️ Label\\"},\\"icon\\":{\\"type\\":\\"boolean\\",\\"key\\":\\"👁️ Icon\\",\\"value\\":{\\"false\\":false,\\"true\\":\\"placeholder\\"}},\\"interactiveState\\":{\\"type\\":\\"enum\\",\\"key\\":\\"Interactive State\\",\\"value\\":{\\"(Def) Enabled\\":false,\\"Hovered\\":false,\\"Pressed\\":false,\\"Focused\\":false,\\"Disabled\\":\\"true\\"}},\\"size\\":{\\"type\\":\\"enum\\",\\"key\\":\\"Size\\",\\"value\\":{\\"(Def) Medium\\":false,\\"Small\\":\\"small\\"}},\\"width\\":{\\"type\\":\\"enum\\",\\"key\\":\\"Width\\",\\"value\\":{\\"(Def) Auto Width\\":false,\\"Full Width\\":\\"full\\"}}}}}
          */

import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"figma-button\\",
  template: \`
    <button
      [attr.data-icon]=\\"icon\\"
      [attr.data-disabled]=\\"interactiveState\\"
      [attr.data-width]=\\"width\\"
      [attr.data-size]=\\"size\\"
      #_root
    >
      {{label}}
    </button>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class FigmaButton {
  @Input() icon;
  @Input() interactiveState;
  @Input() width;
  @Input() size;
  @Input() label;

  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"figma-button\\");
  }
}

@NgModule({
  declarations: [FigmaButton],
  imports: [CommonModule],
  exports: [FigmaButton],
  bootstrap: [SomeOtherComponent],
})
export class FigmaButtonModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > getterState 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"button\\",
  template: \`
    <div #_root>
      <p>{{foo2}}</p>
      <p>{{bar}}</p>
      <p>{{baz(1)}}</p>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class Button {
  @Input() foo;

  @ViewChild(\\"_root\\") _root;

  get foo2() {
    return this.foo + \\"foo\\";
  }
  get bar() {
    return \\"bar\\";
  }
  baz(i) {
    return i + this.foo2.length;
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"button\\");
  }
}

@NgModule({
  declarations: [Button],
  imports: [CommonModule],
  exports: [Button],
  bootstrap: [SomeOtherComponent],
})
export class ButtonModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > import types 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

import RenderBlockModule from \\"./builder-render-block.raw/angular\\";

@Component({
  selector: \\"render-content\\",
  template: \`
    <render-block #_root></render-block>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class RenderContent {
  @Input() renderContentProps;

  @ViewChild(\\"_root\\") _root;

  getRenderContentProps(block, index) {
    return {
      block: block,
      index: index,
    };
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"render-content\\");
  }
}

@NgModule({
  declarations: [RenderContent],
  imports: [CommonModule, RenderBlockModule],
  exports: [RenderContent],
  bootstrap: [SomeOtherComponent],
})
export class RenderContentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > importRaw 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-import-component\\",
  template: \`
    <div #_root>Testing which imports get excluded!</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyImportComponent {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-import-component\\");
  }
}

@NgModule({
  declarations: [MyImportComponent],
  imports: [CommonModule],
  exports: [MyImportComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyImportComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > multipleOnUpdate 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"multiple-on-update\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MultipleOnUpdate {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"multiple-on-update\\");
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      console.log(\\"Runs on every update/rerender\\");
      console.log(\\"Runs on every update/rerender as well\\");
    }
  }
}

@NgModule({
  declarations: [MultipleOnUpdate],
  imports: [CommonModule],
  exports: [MultipleOnUpdate],
  bootstrap: [SomeOtherComponent],
})
export class MultipleOnUpdateModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > multipleOnUpdateWithDeps 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"multiple-on-update-with-deps\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MultipleOnUpdateWithDeps {
  @ViewChild(\\"_root\\") _root;

  a = \\"a\\";
  b = \\"b\\";
  c = \\"c\\";
  d = \\"d\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"multiple-on-update-with-deps\\");
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      console.log(\\"Runs when a or b changes\\", this.a, this.b);

      if (this.a === \\"a\\") {
        this.a = \\"b\\";
      }
      console.log(\\"Runs when c or d changes\\", this.c, this.d);

      if (this.a === \\"a\\") {
        this.a = \\"b\\";
      }
    }
  }
}

@NgModule({
  declarations: [MultipleOnUpdateWithDeps],
  imports: [CommonModule],
  exports: [MultipleOnUpdateWithDeps],
  bootstrap: [SomeOtherComponent],
})
export class MultipleOnUpdateWithDepsModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > multipleSpreads 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Renderer2 } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <input #elRef0 #_root />
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @ViewChild(\\"_root\\") _root;

  @ViewChild(\\"elRef0\\") elRef0;

  _listenerFns = new Map();

  attrs = {
    hello: \\"world\\",
  };
  setAttributes(el, value, changes) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attrs);
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attrs,
        changes[\\"attrs\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > nativeAttributes 1`] = `
"/**
          useMetadata:
          {\\"angular\\":{\\"nativeAttributes\\":[\\"disabled\\"]}}
          */

import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      <input [disabled]=\\"disabled\\" />

      Hello! If someone passes \\\\\`[disabled]=\\"false\\"\\\\\` to me, disabled shouldn't
      be visible in the DOM.
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @Input() disabled;

  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > nestedShow 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"nested-show\\",
  template: \`
    <ng-container *ngIf=\\"conditionA\\">
      <ng-container *ngIf=\\"!conditionB\\">
        <div>if condition A and condition B</div>
      </ng-container>
      <ng-container *ngIf=\\"!(!conditionB)\\">
        <div>else-condition-B</div>
      </ng-container>
    </ng-container>
    <ng-container *ngIf=\\"!(conditionA)\\">
      <div>else-condition-A</div>
    </ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class NestedShow {
  @Input() conditionA;
  @Input() conditionB;

  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"nested-show\\");
  }
}

@NgModule({
  declarations: [NestedShow],
  imports: [CommonModule],
  exports: [NestedShow],
  bootstrap: [SomeOtherComponent],
})
export class NestedShowModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > nestedStyles 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"nested-styles\\",
  template: \`
    <div class=\\"div\\" #_root>Hello world</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .div {
        display: flex;
        --bar: red;
        color: var(--bar);
      }
      @media (max-width: env(--mobile)) {
        .div {
          display: block;
        }
      }
      .div:hover {
        display: flex;
      }
      .div:active {
        display: inline;
      }
      .div .nested-selector {
        display: grid;
      }
      .div .nested-selector:hover {
        display: block;
      }
      .div.nested-selector:active {
        display: inline-block;
      }
    \`,
  ],
})
export default class NestedStyles {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"nested-styles\\");
  }
}

@NgModule({
  declarations: [NestedStyles],
  imports: [CommonModule],
  exports: [NestedStyles],
  bootstrap: [SomeOtherComponent],
})
export class NestedStylesModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > onEvent 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"embed\\",
  template: \`
    <div class=\\"builder-embed\\" #elem #_root><div>Test</div></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class Embed {
  @ViewChild(\\"elem\\") elem;
  @ViewChild(\\"_root\\") _root;

  foo(event) {
    console.log(\\"test2\\");
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    if (typeof window !== \\"undefined\\") {
      this.elem.nativeElement.dispatchEvent(new CustomEvent(\\"initEditingBldr\\"));
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"embed\\");
  }
}

@NgModule({
  declarations: [Embed],
  imports: [CommonModule],
  exports: [Embed],
  bootstrap: [SomeOtherComponent],
})
export class EmbedModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > onInit & onMount 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"on-init\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class OnInit {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    console.log(\\"onInit\\");

    if (typeof window !== \\"undefined\\") {
      console.log(\\"onMount\\");
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"on-init\\");
  }
}

@NgModule({
  declarations: [OnInit],
  imports: [CommonModule],
  exports: [OnInit],
  bootstrap: [SomeOtherComponent],
})
export class OnInitModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > onInit 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

export const defaultValues = {
  name: \\"PatrickJS\\",
};

@Component({
  selector: \\"on-init\\",
  template: \`
    <div #_root>Default name defined by parent {{name}}</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class OnInit {
  @Input() name;

  @ViewChild(\\"_root\\") _root;

  name = \\"\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.name = defaultValues.name || this.name;
    console.log(\\"set defaults with props\\");
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"on-init\\");
  }
}

@NgModule({
  declarations: [OnInit],
  imports: [CommonModule],
  exports: [OnInit],
  bootstrap: [SomeOtherComponent],
})
export class OnInitModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > onInitPlain 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"on-init-plain\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class OnInitPlain {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    console.log(\\"onInit\\");
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"on-init-plain\\");
  }
}

@NgModule({
  declarations: [OnInitPlain],
  imports: [CommonModule],
  exports: [OnInitPlain],
  bootstrap: [SomeOtherComponent],
})
export class OnInitPlainModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > onMount 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"comp\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class Comp {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    if (typeof window !== \\"undefined\\") {
      console.log(\\"Runs on mount\\");
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"comp\\");
  }

  ngOnDestroy() {
    console.log(\\"Runs on unMount\\");
  }
}

@NgModule({
  declarations: [Comp],
  imports: [CommonModule],
  exports: [Comp],
  bootstrap: [SomeOtherComponent],
})
export class CompModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > onMountMultiple 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"comp\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class Comp {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    if (typeof window !== \\"undefined\\") {
      const onMountHook_0 = () => {
        console.log(\\"Runs on mount\\");
      };
      onMountHook_0();
      const onMountHook_1 = () => {
        console.log(\\"Another one runs on Mount\\");
      };
      onMountHook_1();
      const onMountHook_2 = () => {
        console.log(\\"SSR runs on Mount\\");
      };
      onMountHook_2();
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"comp\\");
  }
}

@NgModule({
  declarations: [Comp],
  imports: [CommonModule],
  exports: [Comp],
  bootstrap: [SomeOtherComponent],
})
export class CompModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > onUpdate 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"on-update\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class OnUpdate {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"on-update\\");
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      console.log(\\"Runs on every update/rerender\\");
    }
  }
}

@NgModule({
  declarations: [OnUpdate],
  imports: [CommonModule],
  exports: [OnUpdate],
  bootstrap: [SomeOtherComponent],
})
export class OnUpdateModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > onUpdateWithDeps 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"on-update-with-deps\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class OnUpdateWithDeps {
  @Input() size;

  @ViewChild(\\"_root\\") _root;

  a = \\"a\\";
  b = \\"b\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"on-update-with-deps\\");
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      console.log(\\"Runs when a, b or size changes\\", this.a, this.b, this.size);
    }
  }
}

@NgModule({
  declarations: [OnUpdateWithDeps],
  imports: [CommonModule],
  exports: [OnUpdateWithDeps],
  bootstrap: [SomeOtherComponent],
})
export class OnUpdateWithDepsModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > outputEventBinding 1`] = `
"/**
          useMetadata:
          {\\"angular\\":{\\"nativeEvents\\":[\\"onFakeNative\\"]}}
          */

import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      <input
        [attr.value]=\\"name\\"
        (change)=\\"name = $event.target.value\\"
        (changeOrSomething)=\\"name = $event.target.value\\"
        (fakenative)=\\"name = $event.target.value\\"
        (animationend)=\\"name = $event.target.value\\"
      />

      Hello! I can run in React, Vue, Solid, or Liquid!
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root;

  name = \\"Steve\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > preserveExportOrLocalStatement 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

const b = 3;
const foo = () => {};
export const a = 3;
export const bar = () => {};
export function run(value) {}

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > preserveTyping 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <div #_root>Hello! I can run in React, Vue, Solid, or Liquid! {{name}}</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @Input() name;

  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > propsDestructure 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <div #_root>
      <ng-content></ng-content>
      {{type}} Hello! I can run in React, Vue, Solid, or Liquid!
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @Input() type;

  @ViewChild(\\"_root\\") _root;

  name = \\"Decadef20\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > propsInterface 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <div #_root>Hello! I can run in React, Vue, Solid, or Liquid! {{name}}</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @Input() name;

  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > propsType 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <div #_root>Hello! I can run in React, Vue, Solid, or Liquid! {{name}}</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @Input() name;

  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > referencingFunInsideHook 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"on-update\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class OnUpdate {
  @ViewChild(\\"_root\\") _root;

  foo = function foo(params) {};
  bar = function bar() {};
  zoo = function zoo() {
    const params = {
      cb: this.bar,
    };
  };

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"on-update\\");
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      this.foo({
        someOption: this.bar,
      });
    }
  }
}

@NgModule({
  declarations: [OnUpdate],
  imports: [CommonModule],
  exports: [OnUpdate],
  bootstrap: [SomeOtherComponent],
})
export class OnUpdateModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > renderBlock 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Input,
  ViewContainerRef,
  TemplateRef,
} from \\"@angular/core\\";

import { TARGET } from \\"../../constants/target.js\\";
import { evaluate } from \\"../../functions/evaluate.js\\";
import { extractTextStyles } from \\"../../functions/extract-text-styles.js\\";
import { getBlockActions } from \\"../../functions/get-block-actions.js\\";
import { getBlockComponentOptions } from \\"../../functions/get-block-component-options.js\\";
import { getBlockProperties } from \\"../../functions/get-block-properties.js\\";
import { getBlockTag } from \\"../../functions/get-block-tag.js\\";
import { getProcessedBlock } from \\"../../functions/get-processed-block.js\\";
import { getReactNativeBlockStylesModule } from \\"../../functions/get-react-native-block-styles.js\\";
import BlockStylesModule from \\"./block-styles.lite/angular\\";
import { isEmptyHtmlElement } from \\"./render-block.helpers.js\\";
import RenderComponentWithContext from \\"./render-component-with-context.lite\\";
import RenderComponent from \\"./render-component.lite\\";
import RenderRepeatedBlockModule from \\"./render-repeated-block.lite/angular\\";

@Component({
  selector: \\"render-block\\",
  template: \`
    <ng-template #rendercomponenttagTemplate></ng-template>
    <ng-container *ngIf=\\"shouldWrap\\">
      <ng-container *ngIf=\\"isEmptyHtmlElement(tag)\\">
        <ng-container
          *ngComponentOutlet=\\"
              tag;
              inputs: { attributes: attributes, actions: actions };
              content: myContent;
              \\"
        ></ng-container>
      </ng-container>
      <ng-container *ngIf=\\"!isEmptyHtmlElement(tag) && repeatItemData\\">
        <ng-container
          *ngFor=\\"let data of repeatItemData; index as index; trackBy: trackByData0\\"
        >
          <render-repeated-block
            [repeatContext]=\\"data.context\\"
            [block]=\\"data.block\\"
          ></render-repeated-block>
        </ng-container>
      </ng-container>
      <ng-container *ngIf=\\"!isEmptyHtmlElement(tag) && !repeatItemData\\">
        <ng-container
          *ngComponentOutlet=\\"
              tag;
              inputs: { attributes: attributes, actions: actions };
              content: myContent;
              \\"
        ></ng-container>
      </ng-container>
    </ng-container>
    <ng-container *ngIf=\\"!(shouldWrap)\\">
      <ng-container
        *ngComponentOutlet=\\"
              renderComponentTag;
              inputs: { renderComponentProps: renderComponentProps };
              content: myContent;
              \\"
      ></ng-container>
    </ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class RenderBlock {
  isEmptyHtmlElement = isEmptyHtmlElement;

  @Input() block;
  @Input() context;

  @ViewChild(\\"_root\\") _root;

  @ViewChild(\\"rendercomponenttagTemplate\\", { static: true })
  rendercomponenttagTemplateRef;
  @ViewChild(\\"tagTemplate\\", { static: true }) tagTemplateRef;

  myContent;

  get component() {
    const componentName = getProcessedBlock({
      block: this.block,
      state: this.context.state,
      context: this.context.context,
      shouldEvaluateBindings: false,
    }).component?.name;

    if (!componentName) {
      return null;
    }

    const ref = this.context.registeredComponents[componentName];

    if (!ref) {
      // TODO: Public doc page with more info about this message
      console.warn(\`
          Could not find a registered component named \\"\${componentName}\\".
          If you registered it, is the file that registered it imported by the file that needs to render it?\`);
      return undefined;
    } else {
      return ref;
    }
  }
  get tag() {
    return getBlockTag(this.useBlock);
  }
  get useBlock() {
    return this.repeatItemData
      ? this.block
      : getProcessedBlock({
          block: this.block,
          state: this.context.state,
          context: this.context.context,
          shouldEvaluateBindings: true,
        });
  }
  get actions() {
    return getBlockActions({
      block: this.useBlock,
      state: this.context.state,
      context: this.context.context,
    });
  }
  get attributes() {
    const blockProperties = getBlockProperties(this.useBlock);
    return {
      ...blockProperties,
      ...(TARGET === \\"reactNative\\"
        ? {
            style: getReactNativeBlockStyles({
              block: this.useBlock,
              context: this.context,
              blockStyles: blockProperties.style,
            }),
          }
        : {}),
    };
  }
  get shouldWrap() {
    return !this.component?.noWrap;
  }
  get renderComponentProps() {
    return {
      blockChildren: this.useChildren,
      componentRef: this.component?.component,
      componentOptions: {
        ...getBlockComponentOptions(this.useBlock),

        /**
         * These attributes are passed to the wrapper element when there is one. If \`noWrap\` is set to true, then
         * they are provided to the component itself directly.
         */
        ...(this.shouldWrap
          ? {}
          : {
              attributes: { ...this.attributes, ...this.actions },
            }),
        customBreakpoints: this.childrenContext?.content?.meta?.breakpoints,
      },
      context: this.childrenContext,
    };
  }
  get useChildren() {
    // TO-DO: When should \`canHaveChildren\` dictate rendering?
    // This is currently commented out because some Builder components (e.g. Box) do not have \`canHaveChildren: true\`,
    // but still receive and need to render children.
    // return state.componentInfo?.canHaveChildren ? state.useBlock.children : [];
    return this.useBlock.children ?? [];
  }
  get childrenWithoutParentComponent() {
    /**
     * When there is no \`componentRef\`, there might still be children that need to be rendered. In this case,
     * we render them outside of \`componentRef\`.
     * NOTE: We make sure not to render this if \`repeatItemData\` is non-null, because that means we are rendering an array of
     * blocks, and the children will be repeated within those blocks.
     */
    const shouldRenderChildrenOutsideRef =
      !this.component?.component && !this.repeatItemData;
    return shouldRenderChildrenOutsideRef ? this.useChildren : [];
  }
  get repeatItemData() {
    /**
     * we don't use \`state.useBlock\` here because the processing done within its logic includes evaluating the block's bindings,
     * which will not work if there is a repeat.
     */
    const { repeat, ...blockWithoutRepeat } = this.block;

    if (!repeat?.collection) {
      return undefined;
    }

    const itemsArray = evaluate({
      code: repeat.collection,
      state: this.context.state,
      context: this.context.context,
    });

    if (!Array.isArray(itemsArray)) {
      return undefined;
    }

    const collectionName = repeat.collection.split(\\".\\").pop();
    const itemNameToUse =
      repeat.itemName || (collectionName ? collectionName + \\"Item\\" : \\"item\\");
    const repeatArray = itemsArray.map((item, index) => ({
      context: {
        ...this.context,
        state: {
          ...this.context.state,
          $index: index,
          $item: item,
          [itemNameToUse]: item,
          [\`$\${itemNameToUse}Index\`]: index,
        },
      },
      block: blockWithoutRepeat,
    }));
    return repeatArray;
  }
  get inheritedTextStyles() {
    if (TARGET !== \\"reactNative\\") {
      return {};
    }

    const styles = getReactNativeBlockStyles({
      block: this.useBlock,
      context: this.context,
      blockStyles: this.attributes.style,
    });
    return extractTextStyles(styles);
  }
  get childrenContext() {
    return {
      apiKey: this.context.apiKey,
      state: this.context.state,
      content: this.context.content,
      context: this.context.context,
      registeredComponents: this.context.registeredComponents,
      inheritedStyles: this.inheritedTextStyles,
    };
  }
  get renderComponentTag() {
    if (TARGET === \\"reactNative\\") {
      return RenderComponentWithContext;
    } else if (TARGET === \\"vue3\\") {
      // vue3 expects a string for the component tag
      return \\"RenderComponent\\";
    } else {
      return RenderComponent;
    }
  }
  trackByData0(index, data) {
    return index;
  }
  trackByChild1(_, child) {
    return \\"render-block-\\" + child.id;
  }
  trackByChild2(_, child) {
    return \\"block-style-\\" + child.id;
  }

  constructor(private vcRef) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.myContent = [
      this.vcRef.createEmbeddedView(this.rendercomponenttagTemplateRef)
        .rootNodes,
      this.vcRef.createEmbeddedView(this.tagTemplateRef).rootNodes,
    ];
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"render-block\\");
  }
}

@NgModule({
  declarations: [RenderBlock],
  imports: [
    CommonModule,
    RenderRepeatedBlockModule,
    RenderBlockModule,
    BlockStylesModule,
  ],
  exports: [RenderBlock],
  bootstrap: [SomeOtherComponent],
})
export class RenderBlockModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > renderContentExample 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

import BuilderContext from \\"@dummy/context.lite\\";
import {
  dispatchNewContentToVisualEditor,
  sendComponentsToVisualEditor,
  trackClick,
} from \\"@dummy/injection-js\\";
import RenderBlocksModule from \\"@dummy/RenderBlocks.lite.tsx/angular\\";

@Component({
  selector: \\"render-content\\",
  template: \`
    <div class=\\"div\\" (click)=\\"trackClick(content.id)\\" #_root>
      <render-blocks [blocks]=\\"content.blocks\\"></render-blocks>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .div {
        display: flex;
        flex-direction: columns;
      }
    \`,
  ],
})
export default class RenderContent {
  trackClick = trackClick;

  @Input() customComponents;
  @Input() content;

  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    if (typeof window !== \\"undefined\\") {
      sendComponentsToVisualEditor(this.customComponents);
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"render-content\\");
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      dispatchNewContentToVisualEditor(this.content);
    }
  }
}

@NgModule({
  declarations: [RenderContent],
  imports: [CommonModule, RenderBlocksModule],
  exports: [RenderContent],
  bootstrap: [SomeOtherComponent],
})
export class RenderContentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > rootFragmentMultiNode 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
} from \\"@angular/core\\";

@Component({
  selector: \\"button\\",
  template: \`
    <ng-container>
      <ng-container *ngIf=\\"link\\">
        <a
          [attr.href]=\\"link\\"
          [attr.target]=\\"openLinkInNewTab ? '_blank' : undefined\\"
          #elRef0
        >
          {{text}}
        </a>
      </ng-container>
      <ng-container *ngIf=\\"!link\\">
        <button type=\\"button\\" #elRef1>{{text}}</button>
      </ng-container>
    </ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class Button {
  @Input() link;
  @Input() attributes;
  @Input() openLinkInNewTab;
  @Input() text;

  @ViewChild(\\"_root\\") _root;

  @ViewChild(\\"elRef0\\") elRef0;
  @ViewChild(\\"elRef1\\") elRef1;

  _listenerFns = new Map();

  setAttributes(el, value, changes) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"button\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
    this.setAttributes(this.elRef1?.nativeElement, this.attributes);
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
      this.setAttributes(
        this.elRef1?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [Button],
  imports: [CommonModule],
  exports: [Button],
  bootstrap: [SomeOtherComponent],
})
export class ButtonModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > rootShow 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"render-styles\\",
  template: \`
    <ng-container *ngIf=\\"foo === 'bar'\\"><div>Bar</div></ng-container>
    <ng-container *ngIf=\\"!(foo === 'bar')\\"><div>Foo</div></ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class RenderStyles {
  @Input() foo;

  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"render-styles\\");
  }
}

@NgModule({
  declarations: [RenderStyles],
  imports: [CommonModule],
  exports: [RenderStyles],
  bootstrap: [SomeOtherComponent],
})
export class RenderStylesModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > self-referencing component 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      {{name}}
      <ng-container *ngIf=\\"name === 'Batman'\\">
        <my-component name=\\"Bruce Wayne\\"></my-component>
      </ng-container>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @Input() name;

  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule, MyComponentModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > self-referencing component with children 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      {{name}}
      <ng-content></ng-content>
      <ng-container *ngIf=\\"name === 'Batman'\\">
        <my-component name=\\"Bruce\\"><div>Wayne</div></my-component>
      </ng-container>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @Input() name;

  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule, MyComponentModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > setState 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"set-state\\",
  template: \`
    <div #_root><button (click)=\\"someFn()\\">Click me</button></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class SetState {
  @ViewChild(\\"_root\\") _root;

  n = [\\"123\\"];
  someFn() {
    this.n[0] = \\"123\\";
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"set-state\\");
  }
}

@NgModule({
  declarations: [SetState],
  imports: [CommonModule],
  exports: [SetState],
  bootstrap: [SomeOtherComponent],
})
export class SetStateModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > showExpressions 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"show-with-other-values\\",
  template: \`
    <div #_root>
      <ng-container *ngIf=\\"conditionA\\">Content0</ng-container>
      <ng-container *ngIf=\\"!(conditionA)\\">ContentA</ng-container>
      <ng-container *ngIf=\\"conditionA\\">ContentA</ng-container>
      <ng-container *ngIf=\\"conditionA\\"></ng-container>
      <ng-container *ngIf=\\"!(conditionA)\\">ContentA</ng-container>
      <ng-container *ngIf=\\"conditionA\\">ContentB</ng-container>
      <ng-container *ngIf=\\"!(conditionA)\\">{{undefined}}</ng-container>
      <ng-container *ngIf=\\"conditionA\\">{{undefined}}</ng-container>
      <ng-container *ngIf=\\"!(conditionA)\\">ContentB</ng-container>
      <ng-container *ngIf=\\"conditionA\\">ContentC</ng-container>
      <ng-container *ngIf=\\"conditionA\\"></ng-container>
      <ng-container *ngIf=\\"!(conditionA)\\">ContentC</ng-container>
      <ng-container *ngIf=\\"conditionA\\">ContentD</ng-container>
      <ng-container *ngIf=\\"conditionA\\"></ng-container>
      <ng-container *ngIf=\\"!(conditionA)\\">ContentD</ng-container>
      <ng-container *ngIf=\\"conditionA\\">ContentE</ng-container>
      <ng-container *ngIf=\\"!(conditionA)\\">hello</ng-container>
      <ng-container *ngIf=\\"conditionA\\">hello</ng-container>
      <ng-container *ngIf=\\"!(conditionA)\\">ContentE</ng-container>
      <ng-container *ngIf=\\"conditionA\\">ContentF</ng-container>
      <ng-container *ngIf=\\"!(conditionA)\\">123</ng-container>
      <ng-container *ngIf=\\"conditionA\\">123</ng-container>
      <ng-container *ngIf=\\"!(conditionA)\\">ContentF</ng-container>
      <ng-container *ngIf=\\"conditionA === 'Default'\\">4mb</ng-container>
      <ng-container *ngIf=\\"!(conditionA === 'Default')\\">
        <ng-container *ngIf=\\"conditionB === 'Complete'\\">20mb</ng-container>
        <ng-container *ngIf=\\"!(conditionB === 'Complete')\\">9mb</ng-container>
      </ng-container>
      <ng-container *ngIf=\\"conditionA === 'Default'\\">
        <ng-container *ngIf=\\"conditionB === 'Complete'\\">20mb</ng-container>
        <ng-container *ngIf=\\"!(conditionB === 'Complete')\\">9mb</ng-container>
      </ng-container>
      <ng-container *ngIf=\\"!(conditionA === 'Default')\\">4mb</ng-container>
      <ng-container *ngIf=\\"conditionA === 'Default'\\">
        <ng-container *ngIf=\\"conditionB === 'Complete'\\">
          <div>complete</div>
        </ng-container>
        <ng-container *ngIf=\\"!(conditionB === 'Complete')\\">9mb</ng-container>
      </ng-container>
      <ng-container *ngIf=\\"!(conditionA === 'Default')\\">
        <ng-container *ngIf=\\"conditionC === 'Complete'\\">dff</ng-container>
        <ng-container *ngIf=\\"!(conditionC === 'Complete')\\">
          <div>complete else</div>
        </ng-container>
      </ng-container>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class ShowWithOtherValues {
  @Input() conditionA;
  @Input() conditionB;
  @Input() conditionC;

  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"show-with-other-values\\");
  }
}

@NgModule({
  declarations: [ShowWithOtherValues],
  imports: [CommonModule],
  exports: [ShowWithOtherValues],
  bootstrap: [SomeOtherComponent],
})
export class ShowWithOtherValuesModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > showWithFor 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"nested-show\\",
  template: \`
    <ng-container *ngIf=\\"conditionA\\">
      <ng-container
        *ngFor=\\"let item of items; index as idx; trackBy: trackByItem0\\"
      >
        <div>{{item}}</div>
      </ng-container>
    </ng-container>
    <ng-container *ngIf=\\"!(conditionA)\\">
      <div>else-condition-A</div>
    </ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class NestedShow {
  @Input() conditionA;
  @Input() items;

  @ViewChild(\\"_root\\") _root;

  trackByItem0(idx, item) {
    return idx;
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"nested-show\\");
  }
}

@NgModule({
  declarations: [NestedShow],
  imports: [CommonModule],
  exports: [NestedShow],
  bootstrap: [SomeOtherComponent],
})
export class NestedShowModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > showWithOtherValues 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"show-with-other-values\\",
  template: \`
    <div #_root>
      <ng-container *ngIf=\\"conditionA\\">ContentA</ng-container>
      <ng-container *ngIf=\\"conditionA\\">ContentB</ng-container>
      <ng-container *ngIf=\\"!(conditionA)\\">{{undefined}}</ng-container>
      <ng-container *ngIf=\\"conditionA\\">ContentC</ng-container>
      <ng-container *ngIf=\\"conditionA\\">ContentD</ng-container>
      <ng-container *ngIf=\\"conditionA\\">ContentE</ng-container>
      <ng-container *ngIf=\\"!(conditionA)\\">hello</ng-container>
      <ng-container *ngIf=\\"conditionA\\">ContentF</ng-container>
      <ng-container *ngIf=\\"!(conditionA)\\">123</ng-container>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class ShowWithOtherValues {
  @Input() conditionA;

  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"show-with-other-values\\");
  }
}

@NgModule({
  declarations: [ShowWithOtherValues],
  imports: [CommonModule],
  exports: [ShowWithOtherValues],
  bootstrap: [SomeOtherComponent],
})
export class ShowWithOtherValuesModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > showWithRootText 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"show-root-text\\",
  template: \`
    <ng-container *ngIf=\\"conditionA\\">ContentA</ng-container>
    <ng-container *ngIf=\\"!(conditionA)\\">
      <div>else-condition-A</div>
    </ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class ShowRootText {
  @Input() conditionA;

  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"show-root-text\\");
  }
}

@NgModule({
  declarations: [ShowRootText],
  imports: [CommonModule],
  exports: [ShowRootText],
  bootstrap: [SomeOtherComponent],
})
export class ShowRootTextModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > signalsOnUpdate 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <div class=\\"test div\\" #_root>{{id}} {{foo.value.bar.baz}}</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .div {
        padding: 10px;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @Input() id;
  @Input() foo;

  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      console.log(\\"props.id changed\\", this.id);
      console.log(\\"props.foo.value.bar.baz changed\\", this.foo.value.bar.baz);
    }
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > spreadAttrs 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Renderer2 } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <input #elRef0 #_root />
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @ViewChild(\\"_root\\") _root;

  @ViewChild(\\"elRef0\\") elRef0;

  _listenerFns = new Map();

  setAttributes(el, value, changes) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");

    this.setAttributes(this.elRef0?.nativeElement, attrs);
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        attrs,
        changes[\\"attrs\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > spreadNestedProps 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
} from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <input #elRef0 #_root />
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @Input() nested;

  @ViewChild(\\"_root\\") _root;

  @ViewChild(\\"elRef0\\") elRef0;

  _listenerFns = new Map();

  setAttributes(el, value, changes) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");

    this.setAttributes(this.elRef0?.nativeElement, this.nested);
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.nested,
        changes[\\"nested\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > spreadProps 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <input #_root />
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > stateInit 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      <div>{{asfas}}</div>
      <div>{{someCompute}}</div>
      <div>{{someOtherVal}}</div>
      <div>{{sf}}</div>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @Input() val;

  @ViewChild(\\"_root\\") _root;

  add = function add(a, b) {
    return a + b;
  };
  asfas = \\"asga\\";
  subtract() {
    return this.someCompute - this.someOtherVal;
  }
  someCompute = null;
  someOtherVal = null;
  sf = null;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.someCompute = this.add(1, 2);

    this.someOtherVal = this.val;

    this.sf = this.add(this.val, 34);
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > stateInitSequence 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <Comp
      [val]=\\"useObjectWrapper( val
        )\\"
      #_root
    >
      {{val}}
    </Comp>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @Input() value;

  @ViewChild(\\"_root\\") _root;

  val = null;

  useObjectWrapper(...args) {
    let obj = {};
    args.forEach((arg) => {
      obj = { ...obj, ...arg };
    });
    return obj;
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.val = this.value;
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule, CompModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > store-async-function 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"string-literal-store\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class StringLiteralStore {
  @ViewChild(\\"_root\\") _root;

  arrowFunction = async function arrowFunction() {
    return Promise.resolve();
  };
  namedFunction = async function namedFunction() {
    return Promise.resolve();
  };
  fetchUsers = async function fetchUsers() {
    return Promise.resolve();
  };

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"string-literal-store\\");
  }
}

@NgModule({
  declarations: [StringLiteralStore],
  imports: [CommonModule],
  exports: [StringLiteralStore],
  bootstrap: [SomeOtherComponent],
})
export class StringLiteralStoreModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > string-literal-store 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"string-literal-store\\",
  template: \`
    <div #_root>{{foo}}</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class StringLiteralStore {
  @ViewChild(\\"_root\\") _root;

  foo = 123;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"string-literal-store\\");
  }
}

@NgModule({
  declarations: [StringLiteralStore],
  imports: [CommonModule],
  exports: [StringLiteralStore],
  bootstrap: [SomeOtherComponent],
})
export class StringLiteralStoreModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > string-literal-store-kebab 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from '@angular/core';










   @Component({
     selector: 'string-literal-store',template: \`

      <div #_root>{{'foo-bar'}}</div>

      \`,styles: [\`:host { display: contents; }\`]
   })
   export default class StringLiteralStore {







     @ViewChild('_root') _root








      foo-bar= 123








     /**
* Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
* @param element  the ref for the component
* @param customElementSelector  the custom element like \`my-component\`
*/
private enableAttributePassing(element, customElementSelector) {
 const parent = element?.closest(customElementSelector);
 if (element && parent) {
   const attributes = parent.attributes;
   for (let i = 0; i < attributes.length; i++) {
     const attr = attributes.item(i);
     if (attr && (attr.name.startsWith('data-') || attr.name.startsWith('aria-'))) {
       element.setAttribute(attr.name, attr.value);
       parent.removeAttribute(attr.name);
     }
     if (attr && attr.name === 'class') {
       const isWebComponent = attr.value.includes('hydrated');
       const value = attr.value.replace('hydrated', '').trim();
       const currentClass = element.getAttribute('class');
       element.setAttribute(attr.name, \`\${currentClass ? \`\${currentClass} \` : ''}\${value}\`);
       if (isWebComponent) {
         // Stencil is using this class for lazy loading component
         parent.setAttribute('class', 'hydrated');
       } else {
         parent.removeAttribute(attr.name);
       }
     }
   }
 }
};



     ngAfterViewInit() {

       const element: HTMLElement | null = this._root?.nativeElement;
       this.enableAttributePassing(element, \\"string-literal-store\\");

         }





   }

@NgModule({
  declarations: [StringLiteralStore],
  imports: [CommonModule],
  exports: [StringLiteralStore],
  bootstrap: [SomeOtherComponent]
})
export class StringLiteralStoreModule {}"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > styleClassAndCss 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div
      class=\\"builder-column div\\"
      [ngStyle]=\\"{
          width: '100%'
        }\\"
      #_root
    ></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .div {
        display: flex;
        flex-direction: column;
        align-items: stretch;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > stylePropClassAndCss 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"style-prop-class-and-css\\",
  template: \`
    <div
      [ngStyle]=\\"attributes.style\\"
      [class]=\\"attributes.class + ' div'\\"
      #_root
    ></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .div {
        display: flex;
        flex-direction: column;
        align-items: stretch;
      }
    \`,
  ],
})
export default class StylePropClassAndCss {
  @Input() attributes;

  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"style-prop-class-and-css\\");
  }
}

@NgModule({
  declarations: [StylePropClassAndCss],
  imports: [CommonModule],
  exports: [StylePropClassAndCss],
  bootstrap: [SomeOtherComponent],
})
export class StylePropClassAndCssModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > subComponent 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

import FooModule from \\"./foo-sub-component.lite/angular\\";

@Component({
  selector: \\"sub-component\\",
  template: \`
    <foo #_root></foo>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class SubComponent {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"sub-component\\");
  }
}

@NgModule({
  declarations: [SubComponent],
  imports: [CommonModule, FooModule],
  exports: [SubComponent],
  bootstrap: [SomeOtherComponent],
})
export class SubComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > svgComponent 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"svg-component\\",
  template: \`
    <svg
      fill=\\"none\\"
      role=\\"img\\"
      [attr.viewBox]=\\"'0 0 ' + 42 + ' ' + 42\\"
      [attr.width]=\\"42\\"
      [attr.height]=\\"42\\"
      #_root
    >
      <defs>
        <filter id=\\"prefix__filter0_f\\" filterUnits=\\"userSpaceOnUse\\">
          <feFlood result=\\"BackgroundImageFix\\"></feFlood>
          <feBlend
            in=\\"SourceGraphic\\"
            in2=\\"BackgroundImageFix\\"
            result=\\"shape\\"
          ></feBlend>
          <feGaussianBlur
            result=\\"effect1_foregroundBlur\\"
            [attr.stdDeviation]=\\"7\\"
          ></feGaussianBlur>
        </filter>
      </defs>
    </svg>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class SvgComponent {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"svg-component\\");
  }
}

@NgModule({
  declarations: [SvgComponent],
  imports: [CommonModule],
  exports: [SvgComponent],
  bootstrap: [SomeOtherComponent],
})
export class SvgComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > twoForsTrackBy 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      <ng-container *ngFor=\\"let item of items; trackBy: trackByItem0\\">
        <div>{{item}}</div>
      </ng-container>
      <ng-container *ngFor=\\"let item of items; trackBy: trackByItem1\\">
        <div>{{item}}</div>
      </ng-container>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root;

  items = [1, 2, 3];
  trackByItem0(_, item) {
    return item;
  }
  trackByItem1(_, item) {
    return item;
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > typeDependency 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"type-dependency\\",
  template: \`
    <div #_root>{{foo}}</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class TypeDependency {
  @Input() foo;

  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"type-dependency\\");
  }
}

@NgModule({
  declarations: [TypeDependency],
  imports: [CommonModule],
  exports: [TypeDependency],
  bootstrap: [SomeOtherComponent],
})
export class TypeDependencyModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > typeExternalStore 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"type-external-store\\",
  template: \`
    <div #_root>Hello {{_name}} !</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class TypeExternalStore {
  @ViewChild(\\"_root\\") _root;

  _name = \\"test\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"type-external-store\\");
  }
}

@NgModule({
  declarations: [TypeExternalStore],
  imports: [CommonModule],
  exports: [TypeExternalStore],
  bootstrap: [SomeOtherComponent],
})
export class TypeExternalStoreModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > typeGetterStore 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"type-getter-store\\",
  template: \`
    <div #_root>Hello {{name}} !</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class TypeGetterStore {
  @ViewChild(\\"_root\\") _root;

  name = \\"test\\";
  getName() {
    if (this.name === \\"a\\") {
      return \\"b\\";
    }

    return this.name;
  }
  get test() {
    return \\"test\\";
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"type-getter-store\\");
  }
}

@NgModule({
  declarations: [TypeGetterStore],
  imports: [CommonModule],
  exports: [TypeGetterStore],
  bootstrap: [SomeOtherComponent],
})
export class TypeGetterStoreModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > use-style 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <button type=\\"button\\" #_root>Button</button>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      button {
        background: blue;
        color: white;
        font-size: 12px;
        outline: 1px solid black;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > use-style-and-css 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <button type=\\"button\\" class=\\"button\\" #_root>Button</button>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      button {
        font-size: 12px;
        outline: 1px solid black;
      }

      .button {
        background: blue;
        color: white;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > use-style-outside-component 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <button type=\\"button\\" #_root>Button</button>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      button {
        background: blue;
        color: white;
        font-size: 12px;
        outline: 1px solid black;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > useObjectWrapper 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      <Comp
        [val1]=\\"useObjectWrapper( attributes2
        )\\"
        [val2]=\\"useObjectWrapper( attributes,
          attributes2
        )\\"
        [val3]=\\"useObjectWrapper( something,{
          anything: 'hello' },{
          hello: 'world' },)\\"
        [val4]=\\"useObjectWrapper( attributes,
          something,{
          anything: [1, 2, 3] },{
          hello: 'hello' },
          attributes2
        )\\"
        [val5]=\\"useObjectWrapper( attributes,
          something,{
          anything: [1, 2, 3] },{
          anythingString: ['a', 'b', 'c'] },{
          hello: 'hello' },
          spreadAttrs
        )\\"
        [val6]=\\"{
          anything: [1, 2, 3]
        }\\"
      ></Comp>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @Input() spreadAttrs;

  @ViewChild(\\"_root\\") _root;

  attributes = {
    id: 1,
  };
  attributes2 = {
    id2: 1,
  };
  something = {
    id3: 1,
  };

  useObjectWrapper(...args) {
    let obj = {};
    args.forEach((arg) => {
      obj = { ...obj, ...arg };
    });
    return obj;
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule, CompModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > useTarget 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"use-target-component\\",
  template: \`
    <div #_root>{{name}}</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class UseTargetComponent {
  @ViewChild(\\"_root\\") _root;

  get name() {
    const prefix = true;
    return prefix + \\"foo\\";
  }
  lastName = \\"bar\\";
  foo = \\"bar\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    if (typeof window !== \\"undefined\\") {
      console.log(this.foo);
      this.foo = \\"bar\\";
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"use-target-component\\");
  }
}

@NgModule({
  declarations: [UseTargetComponent],
  imports: [CommonModule],
  exports: [UseTargetComponent],
  bootstrap: [SomeOtherComponent],
})
export class UseTargetComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Javascript Test > webComponent 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

import { register } from \\"swiper/element/bundle\\";

@Component({
  selector: \\"my-basic-web-component\\",
  template: \`
    <swiper-container
      slides-per-view=\\"3\\"
      navigation=\\"true\\"
      pagination=\\"true\\"
      #_root
    >
      <swiper-slide>Slide 1</swiper-slide>
      <swiper-slide>Slide 2</swiper-slide>
      <swiper-slide>Slide 3</swiper-slide>
    </swiper-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicWebComponent {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    register();
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-web-component\\");
  }
}

@NgModule({
  declarations: [MyBasicWebComponent],
  imports: [CommonModule],
  exports: [MyBasicWebComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicWebComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Remove Internal mitosis package 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <div #_root>
      Hello {{name}} ! I can run in React, Qwik, Vue, Solid, or Liquid!
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @ViewChild(\\"_root\\") _root;

  name = \\"PatrickJS\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > Advanced 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-for-show-component\\",
  template: \`
    <main #_root>
      <ng-container *ngFor=\\"let person of names; index as i\\">
        <div>{{i}} : {{person}}</div>
      </ng-container>
      <ng-container *ngFor=\\"let person of names\\">
        <span>{{person}}</span>
      </ng-container>
      <ng-container *ngFor=\\"let _ of names\\"><br /></ng-container>
      <ng-container
        *ngFor=\\"let _ of Array.from({
          length: 10
        }); index as ee\\"
      >
        <pre>{{ee}}</pre>
      </ng-container>
      <ng-container
        *ngFor=\\"let _ of Array.from({
          length: 10
        })\\"
      >
        <p>{{index}}</p>
      </ng-container>
      <ng-container *ngFor=\\"let person of names; index as index\\">
        <span>{{person}} {{index}}</span>
      </ng-container>
      <ng-container
        *ngFor=\\"let person of Array.from({
          length: 10
        }); index as count\\"
      >
        <span>{{person}} {{count}}</span>
      </ng-container>
      <ng-container *ngFor=\\"let person of names; index as i\\">
        <span>{{person}} {{i}}</span>
      </ng-container>
      <ng-container
        *ngFor=\\"let person of Array.from({
          length: 10
        }); index as index\\"
      >
        <span>{{person}} {{index}}</span>
      </ng-container>
    </main>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicForShowComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  name = \\"PatrickJS\\";
  names = [\\"Steve\\", \\"PatrickJS\\"];

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-for-show-component\\");
  }
}

@NgModule({
  declarations: [MyBasicForShowComponent],
  imports: [CommonModule],
  exports: [MyBasicForShowComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicForShowComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > AdvancedRef 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Input,
  SimpleChanges,
} from \\"@angular/core\\";

export interface Props {
  showInput: boolean;
}

@Component({
  selector: \\"my-basic-ref-component\\",
  template: \`
    <div #_root>
      <ng-container *ngIf=\\"showInput\\">
        <ng-container>
          <input
            class=\\"input\\"
            #inputRef
            [attr.value]=\\"name\\"
            (blur)=\\"onBlur()\\"
            (change)=\\"name = $event.target.value\\"
          />
          <label for=\\"cars\\" #inputNoArgRef>Choose a car:</label>
          <select name=\\"cars\\" id=\\"cars\\">
            <option value=\\"supra\\">GR Supra</option>
            <option value=\\"86\\">GR 86</option>
          </select>
        </ng-container>
      </ng-container>

      Hello {{lowerCaseName()}} ! I can run in React, Qwik, Vue, Solid, or Web
      Component!
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .input {
        color: red;
      }
    \`,
  ],
})
export default class MyBasicRefComponent {
  @Input() showInput!: Props[\\"showInput\\"];

  @ViewChild(\\"inputRef\\") inputRef!: ElementRef;
  @ViewChild(\\"inputNoArgRef\\") inputNoArgRef!: ElementRef;
  @ViewChild(\\"_root\\") _root!: ElementRef;

  name = \\"PatrickJS\\";
  onBlur = function onBlur() {
    // Maintain focus
    this.inputRef.nativeElement.focus();
  };
  lowerCaseName = function lowerCaseName() {
    return this.name.toLowerCase();
  };

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-ref-component\\");
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      console.log(\\"Received an update\\");
    }
  }
}

@NgModule({
  declarations: [MyBasicRefComponent],
  imports: [CommonModule],
  exports: [MyBasicRefComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicRefComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > Basic 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

export interface MyBasicComponentProps {
  id: string;
}

export const DEFAULT_VALUES = {
  name: \\"Steve\\",
};

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <div class=\\"test div\\" #_root>
      <input
        [attr.value]=\\"DEFAULT_VALUES.name || name\\"
        (change)=\\"name = $event.target.value\\"
      />

      Hello! I can run in React, Vue, Solid, or Liquid! &gt;
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .div {
        padding: 10px;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  DEFAULT_VALUES = DEFAULT_VALUES;

  @ViewChild(\\"_root\\") _root!: ElementRef;

  name = \\"Steve\\";
  underscore_fn_name() {
    return \\"bar\\";
  }
  age: number = 1;
  sports: Array<string> = [\\"\\"];

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > Basic 2`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-for-show-component\\",
  template: \`
    <div #_root>
      <ng-container *ngFor=\\"let person of names\\">
        <ng-container *ngIf=\\"person === name\\">
          <input
            [attr.value]=\\"name\\"
            (change)=\\"
          name = $event.target.value + ' and ' + person;
        \\"
          />

          Hello {{person}} ! I can run in Qwik, Web Component, React, Vue,
          Solid, or Liquid!
        </ng-container>
      </ng-container>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicForShowComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  name = \\"PatrickJS\\";
  names = [\\"Steve\\", \\"PatrickJS\\"];

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-for-show-component\\");
  }
}

@NgModule({
  declarations: [MyBasicForShowComponent],
  imports: [CommonModule],
  exports: [MyBasicForShowComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicForShowComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > Basic Context 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

import { Injector, MyService, createInjector } from \\"@dummy/injection-js\\";

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <div #_root>
      {{myService.method('hello') + name}} Hello! I can run in React, Vue,
      Solid, or Liquid!

      <input (change)=\\"onChange\\" />
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  name = \\"PatrickJS\\";
  onChange = function onChange() {
    const change = this.myService.method(\\"change\\");
    console.log(change);
  };

  constructor(public myService: MyService) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    const hi = this.myService.method(\\"hi\\");
    console.log(hi);

    if (typeof window !== \\"undefined\\") {
      const bye = this.myService.method(\\"hi\\");
      console.log(bye);
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > Basic OnMount Update 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

export interface Props {
  hi: string;
  bye: string;
}

@Component({
  selector: \\"my-basic-on-mount-update-component\\",
  template: \`
    <div #_root>Hello {{name}}</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicOnMountUpdateComponent {
  @Input() bye!: Props[\\"bye\\"];
  @Input() hi!: Props[\\"hi\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  name = \\"PatrickJS\\";
  names = [\\"Steve\\", \\"PatrickJS\\"];

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.name = \\"PatrickJS onInit\\" + this.hi;

    if (typeof window !== \\"undefined\\") {
      this.name = \\"PatrickJS onMount\\" + this.bye;
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-on-mount-update-component\\");
  }
}

@NgModule({
  declarations: [MyBasicOnMountUpdateComponent],
  imports: [CommonModule],
  exports: [MyBasicOnMountUpdateComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicOnMountUpdateComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > Basic Outputs 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Output,
  EventEmitter,
  Component,
  ViewChild,
  ElementRef,
  Input,
} from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-outputs-component\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicOutputsComponent {
  @Input() message!: any;

  @Output() onMessage = new EventEmitter();
  @Output() onEvent = new EventEmitter();

  @ViewChild(\\"_root\\") _root!: ElementRef;

  name = \\"PatrickJS\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    if (typeof window !== \\"undefined\\") {
      this.onMessage.emit(this.name);
      this.onEvent.emit(this.message);
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-outputs-component\\");
  }
}

@NgModule({
  declarations: [MyBasicOutputsComponent],
  imports: [CommonModule],
  exports: [MyBasicOutputsComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicOutputsComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > Basic Outputs Meta 1`] = `
"/**
          useMetadata:
          {\\"outputs\\":[\\"onMessage\\",\\"onEvent\\"],\\"baz\\":\\"metadata inside component\\"}
          */

import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Output,
  EventEmitter,
  Component,
  ViewChild,
  ElementRef,
  Input,
} from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-outputs-component\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicOutputsComponent {
  @Input() message!: any;

  @Output() onMessage = new EventEmitter();
  @Output() onEvent = new EventEmitter();

  @ViewChild(\\"_root\\") _root!: ElementRef;

  name = \\"PatrickJS\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    if (typeof window !== \\"undefined\\") {
      this.onMessage.emit(this.name);
      this.onEvent.emit(this.message);
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-outputs-component\\");
  }
}

@NgModule({
  declarations: [MyBasicOutputsComponent],
  imports: [CommonModule],
  exports: [MyBasicOutputsComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicOutputsComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > BasicAttribute 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <input
      autocapitalize=\\"on\\"
      autocomplete=\\"on\\"
      [attr.spellcheck]=\\"true\\"
      #_root
    />
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > BasicBooleanAttribute 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

type Props = {
  children: any;
  type: string;
};

import MyBooleanAttributeComponentModule from \\"./basic-boolean-attribute-component.raw/angular\\";

@Component({
  selector: \\"my-boolean-attribute\\",
  template: \`
    <div #_root>
      <ng-container *ngIf=\\"children\\">
        <ng-content></ng-content>
        {{type}}
      </ng-container>
      <my-boolean-attribute-component
        [toggle]=\\"true\\"
      ></my-boolean-attribute-component>
      <my-boolean-attribute-component
        [toggle]=\\"true\\"
      ></my-boolean-attribute-component>
      <my-boolean-attribute-component
        [list]=\\"null\\"
      ></my-boolean-attribute-component>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBooleanAttribute {
  @Input() type!: Props[\\"type\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-boolean-attribute\\");
  }
}

@NgModule({
  declarations: [MyBooleanAttribute],
  imports: [CommonModule, MyBooleanAttributeComponentModule],
  exports: [MyBooleanAttribute],
  bootstrap: [SomeOtherComponent],
})
export class MyBooleanAttributeModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > BasicChildComponent 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

import MyBasicOnMountUpdateComponentModule from \\"./basic-onMount-update.raw/angular\\";
import MyBasicComponentModule from \\"./basic.raw/angular\\";

@Component({
  selector: \\"my-basic-child-component\\",
  template: \`
    <div #_root>
      <my-basic-component [id]=\\"dev\\"></my-basic-component>
      <div>
        <my-basic-on-mount-update-component
          [hi]=\\"name\\"
          [bye]=\\"dev\\"
        ></my-basic-on-mount-update-component>
      </div>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicChildComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  name = \\"Steve\\";
  dev = \\"PatrickJS\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-child-component\\");
  }
}

@NgModule({
  declarations: [MyBasicChildComponent],
  imports: [
    CommonModule,
    MyBasicComponentModule,
    MyBasicOnMountUpdateComponentModule,
  ],
  exports: [MyBasicChildComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicChildComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > BasicFor 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-for-component\\",
  template: \`
    <div #_root>
      <ng-container *ngFor=\\"let person of names\\">
        <ng-container>
          <input
            [attr.value]=\\"name\\"
            (change)=\\"
          name = $event.target.value + ' and ' + person;
        \\"
          />

          Hello {{person}} ! I can run in Qwik, Web Component, React, Vue,
          Solid, or Liquid!
        </ng-container>
      </ng-container>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicForComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  name = \\"PatrickJS\\";
  names = [\\"Steve\\", \\"PatrickJS\\"];

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    if (typeof window !== \\"undefined\\") {
      console.log(\\"onMount code\\");
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-for-component\\");
  }
}

@NgModule({
  declarations: [MyBasicForComponent],
  imports: [CommonModule],
  exports: [MyBasicForComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicForComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > BasicRef 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

export interface Props {
  showInput: boolean;
}

@Component({
  selector: \\"my-basic-ref-component\\",
  template: \`
    <div #_root>
      <ng-container *ngIf=\\"showInput\\">
        <ng-container>
          <input
            class=\\"input\\"
            #inputRef
            [attr.value]=\\"name\\"
            (blur)=\\"onBlur()\\"
            (change)=\\"name = $event.target.value\\"
          />
          <label for=\\"cars\\" #inputNoArgRef>Choose a car:</label>
          <select name=\\"cars\\" id=\\"cars\\">
            <option value=\\"supra\\">GR Supra</option>
            <option value=\\"86\\">GR 86</option>
          </select>
        </ng-container>
      </ng-container>

      Hello {{lowerCaseName()}} ! I can run in React, Qwik, Vue, Solid, or Web
      Component!
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .input {
        color: red;
      }
    \`,
  ],
})
export default class MyBasicRefComponent {
  @Input() showInput!: Props[\\"showInput\\"];

  @ViewChild(\\"inputRef\\") inputRef!: ElementRef;
  @ViewChild(\\"inputNoArgRef\\") inputNoArgRef!: ElementRef;
  @ViewChild(\\"_root\\") _root!: ElementRef;

  name = \\"PatrickJS\\";
  onBlur = function onBlur() {
    // Maintain focus
    this.inputRef.nativeElement?.focus();
  };
  lowerCaseName = function lowerCaseName() {
    return this.name.toLowerCase();
  };

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-ref-component\\");
  }
}

@NgModule({
  declarations: [MyBasicRefComponent],
  imports: [CommonModule],
  exports: [MyBasicRefComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicRefComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > BasicRefAssignment 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

export interface Props {
  showInput: boolean;
}

@Component({
  selector: \\"my-basic-ref-assignment-component\\",
  template: \`
    <div #_root>
      <button (click)=\\"await handlerClick($event)\\">Click</button>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicRefAssignmentComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  handlerClick = function handlerClick(event: Event) {
    event.preventDefault();
    console.log(\\"current value\\", this._holdValueRef);
    this._holdValueRef = this._holdValueRef + \\"JS\\";
  };

  private _holdValueRef = \\"Patrick\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-ref-assignment-component\\");
  }
}

@NgModule({
  declarations: [MyBasicRefAssignmentComponent],
  imports: [CommonModule],
  exports: [MyBasicRefAssignmentComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicRefAssignmentComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > BasicRefPrevious 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, SimpleChanges } from \\"@angular/core\\";

export interface Props {
  showInput: boolean;
}

export function usePrevious<T>(value: T) {
  // The ref object is a generic container whose current property is mutable ...
  // ... and can hold any value, similar to an instance property on a class
  let ref = useRef<T>(null); // Store current value in ref

  onUpdate(() => {
    ref = value;
  }, [value]); // Only re-run if value changes
  // Return previous value (happens before update in useEffect above)

  return ref;
}

@Component({
  selector: \\"my-previous-component\\",
  template: \`
    <div #_root>
      <h1>Now: {{count}} , before: {{this._prevCount}}</h1>
      <button (click)=\\"count += 1\\">Increment</button>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyPreviousComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  count = 0;

  private _prevCount = this.count;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-previous-component\\");
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      this._prevCount = this.count;
    }
  }
}

@NgModule({
  declarations: [MyPreviousComponent],
  imports: [CommonModule],
  exports: [MyPreviousComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyPreviousComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > Button 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
  SimpleChanges,
} from \\"@angular/core\\";

export interface ButtonProps {
  attributes?: any;
  text?: string;
  link?: string;
  openLinkInNewTab?: boolean;
}

@Component({
  selector: \\"button\\",
  template: \`
    <div #_root>
      <ng-container *ngIf=\\"link\\">
        <a
          [attr.href]=\\"link\\"
          [attr.target]=\\"openLinkInNewTab ? '_blank' : undefined\\"
          #elRef0
        >
          {{text}}
        </a>
      </ng-container>
      <ng-container *ngIf=\\"!link\\">
        <button type=\\"button\\" #elRef1>{{text}}</button>
      </ng-container>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class Button {
  @Input() link!: ButtonProps[\\"link\\"];
  @Input() attributes!: ButtonProps[\\"attributes\\"];
  @Input() openLinkInNewTab!: ButtonProps[\\"openLinkInNewTab\\"];
  @Input() text!: ButtonProps[\\"text\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  @ViewChild(\\"elRef0\\") elRef0!: ElementRef;
  @ViewChild(\\"elRef1\\") elRef1!: ElementRef;

  _listenerFns = new Map<string, () => void>();

  setAttributes(el: HTMLElement, value: any, changes?: any) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)!();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer: Renderer2) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"button\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
    this.setAttributes(this.elRef1?.nativeElement, this.attributes);
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
      this.setAttributes(
        this.elRef1?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [Button],
  imports: [CommonModule],
  exports: [Button],
  bootstrap: [SomeOtherComponent],
})
export class ButtonModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > Columns 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

type Column = {
  content: any; // TODO: Implement this when support for dynamic CSS lands

  width?: number;
};
export interface ColumnProps {
  columns?: Column[]; // TODO: Implement this when support for dynamic CSS lands

  space?: number; // TODO: Implement this when support for dynamic CSS lands

  stackColumnsAt?: \\"tablet\\" | \\"mobile\\" | \\"never\\"; // TODO: Implement this when support for dynamic CSS lands

  reverseColumnsWhenStacked?: boolean;
}

@Component({
  selector: \\"column\\",
  template: \`
    <div class=\\"builder-columns div\\" #_root>
      <ng-container *ngFor=\\"let column of columns; index as index\\">
        <div class=\\"builder-column div-2\\">{{column.content}} {{index}}</div>
      </ng-container>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .div {
        display: flex;
        flex-direction: column;
        align-items: stretch;
        line-height: normal;
      }
      @media (max-width: 999px) {
        .div {
          flex-direction: row;
        }
      }
      @media (max-width: 639px) {
        .div {
          flex-direction: row-reverse;
        }
      }
      .div-2 {
        flex-grow: 1;
      }
    \`,
  ],
})
export default class Column {
  @Input() columns!: ColumnProps[\\"columns\\"];
  @Input() space!: ColumnProps[\\"space\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  getColumns() {
    return this.columns || [];
  }
  getGutterSize() {
    return typeof this.space === \\"number\\" ? this.space || 0 : 20;
  }
  getWidth(index: number) {
    const columns = this.getColumns();
    return (columns[index] && columns[index].width) || 100 / columns.length;
  }
  getColumnCssWidth(index: number) {
    const columns = this.getColumns();
    const gutterSize = this.getGutterSize();
    const subtractWidth = (gutterSize * (columns.length - 1)) / columns.length;
    return \`calc(\${this.getWidth(index)}% - \${subtractWidth}px)\`;
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"column\\");
  }
}

@NgModule({
  declarations: [Column],
  imports: [CommonModule],
  exports: [Column],
  bootstrap: [SomeOtherComponent],
})
export class ColumnModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > ContentSlotHtml 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

type Props = {
  [key: string]: string | JSX.Element;
  slotTesting: JSX.Element;
};

import { JSX } from \\"../../../../jsx-runtime\\";

@Component({
  selector: \\"content-slot-code\\",
  template: \`
    <div #_root>
      <ng-content select=\\"[testing]\\"></ng-content>
      <div><hr /></div>
      <div><ng-content></ng-content></div>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class ContentSlotCode {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"content-slot-code\\");
  }
}

@NgModule({
  declarations: [ContentSlotCode],
  imports: [CommonModule],
  exports: [ContentSlotCode],
  bootstrap: [SomeOtherComponent],
})
export class ContentSlotCodeModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > ContentSlotJSX 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
  SimpleChanges,
} from \\"@angular/core\\";

type Props = {
  [key: string]: string | JSX.Element;
};
const defaultProps = {
  content: \\"\\",
  slotReference: undefined,
  slotContent: undefined,
};

import { JSX } from \\"../../../../jsx-runtime\\";

@Component({
  selector: \\"content-slot-jsx-code\\",
  template: \`
    <ng-container *ngIf=\\"slotReference\\">
      <div
        [attr.name]=\\"slotContent ? 'name1' : 'name2'\\"
        [attr.title]=\\"slotContent ? 'title1' : 'title2'\\"
        (click)=\\"show()\\"
        [class]=\\"cls\\"
        #elRef0
      >
        <ng-container *ngIf=\\"showContent && slotContent\\">
          <ng-content select=\\"[content]\\">{{content}}</ng-content>
        </ng-container>
        <div><hr /></div>
        <div><ng-content></ng-content></div>
      </div>
    </ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class ContentSlotJsxCode {
  @Input() attributes!: Props[\\"attributes\\"];
  @Input() content: Props[\\"content\\"] = defaultProps[\\"content\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  @ViewChild(\\"elRef0\\") elRef0!: ElementRef;

  _listenerFns = new Map<string, () => void>();

  name = \\"king\\";
  showContent = false;
  get cls() {
    return this.slotContent && this.children ? \`\${this.name}-content\` : \\"\\";
  }
  show() {
    this.slotContent ? 1 : \\"\\";
  }
  setAttributes(el: HTMLElement, value: any, changes?: any) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)!();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer: Renderer2) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"content-slot-jsx-code\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [ContentSlotJsxCode],
  imports: [CommonModule],
  exports: [ContentSlotJsxCode],
  bootstrap: [SomeOtherComponent],
})
export class ContentSlotJsxCodeModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > CustomCode 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

export interface CustomCodeProps {
  code: string;
  replaceNodes?: boolean;
}

@Component({
  selector: \\"custom-code\\",
  template: \`
    <div
      #elem
      [class]=\\"'builder-custom-code' + (replaceNodes ? ' replace-nodes' : '')\\"
      [innerHTML]=\\"code\\"
      #_root
    ></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class CustomCode {
  @Input() replaceNodes!: CustomCodeProps[\\"replaceNodes\\"];
  @Input() code!: CustomCodeProps[\\"code\\"];

  @ViewChild(\\"elem\\") elem!: ElementRef;
  @ViewChild(\\"_root\\") _root!: ElementRef;

  scriptsInserted = [];
  scriptsRun = [];
  findAndRunScripts() {
    // TODO: Move this function to standalone one in '@builder.io/utils'
    if (this.elem.nativeElement && typeof window !== \\"undefined\\") {
      /** @type {HTMLScriptElement[]} */
      const scripts = this.elem.nativeElement.getElementsByTagName(\\"script\\");

      for (let i = 0; i < scripts.length; i++) {
        const script = scripts[i];

        if (script.src) {
          if (this.scriptsInserted.includes(script.src)) {
            continue;
          }

          this.scriptsInserted.push(script.src);
          const newScript = document.createElement(\\"script\\");
          newScript.async = true;
          newScript.src = script.src;
          document.head.appendChild(newScript);
        } else if (
          !script.type ||
          [
            \\"text/javascript\\",
            \\"application/javascript\\",
            \\"application/ecmascript\\",
          ].includes(script.type)
        ) {
          if (this.scriptsRun.includes(script.innerText)) {
            continue;
          }

          try {
            this.scriptsRun.push(script.innerText);
            new Function(script.innerText)();
          } catch (error) {
            console.warn(\\"\`CustomCode\`: Error running script:\\", error);
          }
        }
      }
    }
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    if (typeof window !== \\"undefined\\") {
      this.findAndRunScripts();
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"custom-code\\");
  }
}

@NgModule({
  declarations: [CustomCode],
  imports: [CommonModule],
  exports: [CustomCode],
  bootstrap: [SomeOtherComponent],
})
export class CustomCodeModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > Embed 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

export interface CustomCodeProps {
  code: string;
  replaceNodes?: boolean;
}

@Component({
  selector: \\"custom-code\\",
  template: \`
    <div
      #elem
      [class]=\\"'builder-custom-code' + (replaceNodes ? ' replace-nodes' : '')\\"
      [innerHTML]=\\"code\\"
      #_root
    ></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class CustomCode {
  @Input() replaceNodes!: CustomCodeProps[\\"replaceNodes\\"];
  @Input() code!: CustomCodeProps[\\"code\\"];

  @ViewChild(\\"elem\\") elem!: ElementRef;
  @ViewChild(\\"_root\\") _root!: ElementRef;

  scriptsInserted = [];
  scriptsRun = [];
  findAndRunScripts() {
    // TODO: Move this function to standalone one in '@builder.io/utils'
    if (this.elem.nativeElement && typeof window !== \\"undefined\\") {
      /** @type {HTMLScriptElement[]} */
      const scripts = this.elem.nativeElement.getElementsByTagName(\\"script\\");

      for (let i = 0; i < scripts.length; i++) {
        const script = scripts[i];

        if (script.src) {
          if (this.scriptsInserted.includes(script.src)) {
            continue;
          }

          this.scriptsInserted.push(script.src);
          const newScript = document.createElement(\\"script\\");
          newScript.async = true;
          newScript.src = script.src;
          document.head.appendChild(newScript);
        } else if (
          !script.type ||
          [
            \\"text/javascript\\",
            \\"application/javascript\\",
            \\"application/ecmascript\\",
          ].includes(script.type)
        ) {
          if (this.scriptsRun.includes(script.innerText)) {
            continue;
          }

          try {
            this.scriptsRun.push(script.innerText);
            new Function(script.innerText)();
          } catch (error) {
            console.warn(\\"\`CustomCode\`: Error running script:\\", error);
          }
        }
      }
    }
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    if (typeof window !== \\"undefined\\") {
      this.findAndRunScripts();
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"custom-code\\");
  }
}

@NgModule({
  declarations: [CustomCode],
  imports: [CommonModule],
  exports: [CustomCode],
  bootstrap: [SomeOtherComponent],
})
export class CustomCodeModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > Form 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
  SimpleChanges,
} from \\"@angular/core\\";

export interface FormProps {
  attributes?: any;
  name?: string;
  action?: string;
  validate?: boolean;
  method?: string;
  builderBlock?: BuilderElement;
  sendSubmissionsTo?: string;
  sendSubmissionsToEmail?: string;
  sendWithJs?: boolean;
  contentType?: string;
  customHeaders?: {
    [key: string]: string;
  };
  successUrl?: string;
  previewState?: FormState;
  successMessage?: BuilderElement[];
  errorMessage?: BuilderElement[];
  sendingMessage?: BuilderElement[];
  resetFormOnSubmit?: boolean;
  errorMessagePath?: string;
}
export type FormState = \\"unsubmitted\\" | \\"sending\\" | \\"success\\" | \\"error\\";

import { Builder, BuilderElement, builder } from \\"@builder.io/sdk\\";
import {
  BuilderBlock as BuilderBlockComponentModule,
  BuilderBlocks,
  get,
  set,
} from \\"@fake/angular\\";

@Component({
  selector: \\"form-component\\",
  template: \`
    <form
      [attr.validate]=\\"validate\\"
      #formRef
      [attr.action]=\\"!sendWithJs && action\\"
      [attr.method]=\\"method\\"
      [attr.name]=\\"name\\"
      (submit)=\\"onSubmit($event)\\"
      #elRef0
      #_root
    >
      <ng-container *ngIf=\\"builderBlock && builderBlock.children\\">
        <ng-container
          *ngFor=\\"let block of builderBlock?.children; index as index; trackBy: trackByBlock0\\"
        >
          <builder-block-component
            [block]=\\"block\\"
            [index]=\\"index\\"
          ></builder-block-component>
        </ng-container>
      </ng-container>
      <ng-container *ngIf=\\"submissionState === 'error'\\">
        <builder-blocks
          dataPath=\\"errorMessage\\"
          [blocks]=\\"errorMessage!\\"
        ></builder-blocks>
      </ng-container>
      <ng-container *ngIf=\\"submissionState === 'sending'\\">
        <builder-blocks
          dataPath=\\"sendingMessage\\"
          [blocks]=\\"sendingMessage!\\"
        ></builder-blocks>
      </ng-container>
      <ng-container *ngIf=\\"submissionState === 'error' && responseData\\">
        <pre class=\\"builder-form-error-text pre\\">{{responseData | json}}</pre>
      </ng-container>
      <ng-container *ngIf=\\"submissionState === 'success'\\">
        <builder-blocks
          dataPath=\\"successMessage\\"
          [blocks]=\\"successMessage!\\"
        ></builder-blocks>
      </ng-container>
    </form>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .pre {
        padding: 10px;
        color: red;
        text-align: center;
      }
    \`,
  ],
})
export default class FormComponent {
  builder = builder;

  @Input() previewState!: FormProps[\\"previewState\\"];
  @Input() sendWithJs!: FormProps[\\"sendWithJs\\"];
  @Input() sendSubmissionsTo!: FormProps[\\"sendSubmissionsTo\\"];
  @Input() action!: FormProps[\\"action\\"];
  @Input() customHeaders!: FormProps[\\"customHeaders\\"];
  @Input() contentType!: FormProps[\\"contentType\\"];
  @Input() sendSubmissionsToEmail!: FormProps[\\"sendSubmissionsToEmail\\"];
  @Input() name!: FormProps[\\"name\\"];
  @Input() method!: FormProps[\\"method\\"];
  @Input() errorMessagePath!: FormProps[\\"errorMessagePath\\"];
  @Input() resetFormOnSubmit!: FormProps[\\"resetFormOnSubmit\\"];
  @Input() successUrl!: FormProps[\\"successUrl\\"];
  @Input() validate!: FormProps[\\"validate\\"];
  @Input() attributes!: FormProps[\\"attributes\\"];
  @Input() builderBlock!: FormProps[\\"builderBlock\\"];
  @Input() errorMessage!: FormProps[\\"errorMessage\\"];
  @Input() sendingMessage!: FormProps[\\"sendingMessage\\"];
  @Input() successMessage!: FormProps[\\"successMessage\\"];

  @ViewChild(\\"formRef\\") formRef!: ElementRef;
  @ViewChild(\\"_root\\") _root!: ElementRef;

  @ViewChild(\\"elRef0\\") elRef0!: ElementRef;

  _listenerFns = new Map<string, () => void>();

  formState = \\"unsubmitted\\";
  responseData = null;
  formErrorMessage = \\"\\";
  get submissionState() {
    return (Builder.isEditing && this.previewState) || this.formState;
  }
  onSubmit(
    event: Event & {
      currentTarget: HTMLFormElement;
    }
  ) {
    const sendWithJs = this.sendWithJs || this.sendSubmissionsTo === \\"email\\";

    if (this.sendSubmissionsTo === \\"zapier\\") {
      event.preventDefault();
    } else if (sendWithJs) {
      if (!(this.action || this.sendSubmissionsTo === \\"email\\")) {
        event.preventDefault();
        return;
      }

      event.preventDefault();
      const el = event.currentTarget;
      const headers = this.customHeaders || {};
      let body: any;
      const formData = new FormData(el); // TODO: maybe support null

      const formPairs: {
        key: string;
        value: File | boolean | number | string | FileList;
      }[] = Array.from(
        event.currentTarget.querySelectorAll(\\"input,select,textarea\\")
      )
        .filter((el) => !!(el as HTMLInputElement).name)
        .map((el) => {
          let value: any;
          const key = (el as HTMLImageElement).name;

          if (el instanceof HTMLInputElement) {
            if (el.type === \\"radio\\") {
              if (el.checked) {
                value = el.name;
                return {
                  key,
                  value,
                };
              }
            } else if (el.type === \\"checkbox\\") {
              value = el.checked;
            } else if (el.type === \\"number\\" || el.type === \\"range\\") {
              const num = el.valueAsNumber;

              if (!isNaN(num)) {
                value = num;
              }
            } else if (el.type === \\"file\\") {
              // TODO: one vs multiple files
              value = el.files;
            } else {
              value = el.value;
            }
          } else {
            value = (el as HTMLInputElement).value;
          }

          return {
            key,
            value,
          };
        });
      let contentType = this.contentType;

      if (this.sendSubmissionsTo === \\"email\\") {
        contentType = \\"multipart/form-data\\";
      }

      Array.from(formPairs).forEach(({ value }) => {
        if (
          value instanceof File ||
          (Array.isArray(value) && value[0] instanceof File) ||
          value instanceof FileList
        ) {
          contentType = \\"multipart/form-data\\";
        }
      }); // TODO: send as urlEncoded or multipart by default
      // because of ease of use and reliability in browser API
      // for encoding the form?

      if (contentType !== \\"application/json\\") {
        body = formData;
      } else {
        // Json
        const json = {};
        Array.from(formPairs).forEach(({ value, key }) => {
          set(json, key, value);
        });
        body = JSON.stringify(json);
      }

      if (contentType && contentType !== \\"multipart/form-data\\") {
        if (
          /* Zapier doesn't allow content-type header to be sent from browsers */
          !(sendWithJs && this.action?.includes(\\"zapier.com\\"))
        ) {
          headers[\\"content-type\\"] = contentType;
        }
      }

      const presubmitEvent = new CustomEvent(\\"presubmit\\", {
        detail: {
          body,
        },
      });

      if (this.formRef.nativeElement) {
        this.formRef.nativeElement.dispatchEvent(presubmitEvent);

        if (presubmitEvent.defaultPrevented) {
          return;
        }
      }

      this.formState = \\"sending\\";
      const formUrl = \`\${
        builder.env === \\"dev\\" ? \\"http://localhost:5000\\" : \\"https://builder.io\\"
      }/api/v1/form-submit?apiKey=\${builder.apiKey}&to=\${btoa(
        this.sendSubmissionsToEmail || \\"\\"
      )}&name=\${encodeURIComponent(this.name || \\"\\")}\`;
      fetch(
        this.sendSubmissionsTo === \\"email\\" ? formUrl : this.action!,
        /* TODO: throw error if no action URL */
        {
          body,
          headers,
          method: this.method || \\"post\\",
        }
      ).then(
        async (res) => {
          let body;
          const contentType = res.headers.get(\\"content-type\\");

          if (contentType && contentType.indexOf(\\"application/json\\") !== -1) {
            body = await res.json();
          } else {
            body = await res.text();
          }

          if (!res.ok && this.errorMessagePath) {
            /* TODO: allow supplying an error formatter function */
            let message = get(body, this.errorMessagePath);

            if (message) {
              if (typeof message !== \\"string\\") {
                /* TODO: ideally convert json to yaml so it woul dbe like
            error: - email has been taken */
                message = JSON.stringify(message);
              }

              this.formErrorMessage = message;
            }
          }

          this.responseData = body;
          this.formState = res.ok ? \\"success\\" : \\"error\\";

          if (res.ok) {
            const submitSuccessEvent = new CustomEvent(\\"submit:success\\", {
              detail: {
                res,
                body,
              },
            });

            if (this.formRef.nativeElement) {
              this.formRef.nativeElement.dispatchEvent(submitSuccessEvent);

              if (submitSuccessEvent.defaultPrevented) {
                return;
              }
              /* TODO: option to turn this on/off? */

              if (this.resetFormOnSubmit !== false) {
                this.formRef.nativeElement.reset();
              }
            }
            /* TODO: client side route event first that can be preventDefaulted */

            if (this.successUrl) {
              if (this.formRef.nativeElement) {
                const event = new CustomEvent(\\"route\\", {
                  detail: {
                    url: this.successUrl,
                  },
                });
                this.formRef.nativeElement.dispatchEvent(event);

                if (!event.defaultPrevented) {
                  location.href = this.successUrl;
                }
              } else {
                location.href = this.successUrl;
              }
            }
          }
        },
        (err) => {
          const submitErrorEvent = new CustomEvent(\\"submit:error\\", {
            detail: {
              error: err,
            },
          });

          if (this.formRef.nativeElement) {
            this.formRef.nativeElement.dispatchEvent(submitErrorEvent);

            if (submitErrorEvent.defaultPrevented) {
              return;
            }
          }

          this.responseData = err;
          this.formState = \\"error\\";
        }
      );
    }
  }
  setAttributes(el: HTMLElement, value: any, changes?: any) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)!();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }
  trackByBlock0(index, block) {
    return block.id;
  }

  constructor(private renderer: Renderer2) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"form-component\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [FormComponent],
  imports: [CommonModule, BuilderBlockComponentModule, BuilderBlocksModule],
  exports: [FormComponent],
  bootstrap: [SomeOtherComponent],
})
export class FormComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > Image 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

// TODO: AMP Support?
export interface ImageProps {
  _class?: string;
  image: string;
  sizes?: string;
  lazy?: boolean;
  height?: number;
  width?: number;
  altText?: string;
  backgroundSize?: string;
  backgroundPosition?: string; // TODO: Support generating Builder.io and or Shopify \`srcset\`s when needed

  srcset?: string; // TODO: Implement support for custom aspect ratios

  aspectRatio?: number; // TODO: This might not work as expected in terms of positioning

  children?: any;
}

@Component({
  selector: \\"image\\",
  template: \`
    <div #_root>
      <picture #pictureRef>
        <ng-container *ngIf=\\"!useLazyLoading() || load\\">
          <img
            [attr.alt]=\\"altText\\"
            [attr.aria-role]=\\"altText ? 'presentation' : undefined\\"
            [class]=\\"'builder-image' + (_class ? ' ' + _class : '') + ' img'\\"
            [attr.src]=\\"image\\"
            (load)=\\"setLoaded()\\"
            [attr.srcset]=\\"srcset\\"
            [attr.sizes]=\\"sizes\\"
          />
        </ng-container>
        <source [attr.srcset]=\\"srcset\\" />
      </picture>
      <ng-content></ng-content>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .img {
        opacity: 1;
        transition: opacity 0.2s ease-in-out;
        object-fit: cover;
        object-position: center;
      }
    \`,
  ],
})
export default class Image {
  @Input() lazy!: ImageProps[\\"lazy\\"];
  @Input() altText!: ImageProps[\\"altText\\"];
  @Input() _class!: ImageProps[\\"_class\\"];
  @Input() image!: ImageProps[\\"image\\"];
  @Input() srcset!: ImageProps[\\"srcset\\"];
  @Input() sizes!: ImageProps[\\"sizes\\"];

  @ViewChild(\\"pictureRef\\") pictureRef!: ElementRef;
  @ViewChild(\\"_root\\") _root!: ElementRef;

  scrollListener = null;
  imageLoaded = false;
  setLoaded() {
    this.imageLoaded = true;
  }
  useLazyLoading() {
    // TODO: Add more checks here, like testing for real web browsers
    return !!this.lazy && this.isBrowser();
  }
  isBrowser = function isBrowser() {
    return (
      typeof window !== \\"undefined\\" && window.navigator.product != \\"ReactNative\\"
    );
  };
  load = false;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    if (typeof window !== \\"undefined\\") {
      if (this.useLazyLoading()) {
        // throttled scroll capture listener
        const listener = () => {
          if (this.pictureRef.nativeElement) {
            const rect = this.pictureRef.nativeElement.getBoundingClientRect();
            const buffer = window.innerHeight / 2;

            if (rect.top < window.innerHeight + buffer) {
              this.load = true;
              this.scrollListener = null;
              window.removeEventListener(\\"scroll\\", listener);
            }
          }
        };

        this.scrollListener = listener;
        window.addEventListener(\\"scroll\\", listener, {
          capture: true,
          passive: true,
        });
        listener();
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"image\\");
  }

  ngOnDestroy() {
    if (this.scrollListener) {
      window.removeEventListener(\\"scroll\\", this.scrollListener);
    }
  }
}

@NgModule({
  declarations: [Image],
  imports: [CommonModule],
  exports: [Image],
  bootstrap: [SomeOtherComponent],
})
export class ImageModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > Image State 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"img-state-component\\",
  template: \`
    <div #_root>
      <ng-container *ngFor=\\"let item of images; index as itemIndex\\">
        <ng-container>
          <img class=\\"custom-class\\" [attr.src]=\\"item\\" />
        </ng-container>
      </ng-container>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class ImgStateComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  canShow = true;
  images = [\\"http://example.com/qwik.png\\"];

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"img-state-component\\");
  }
}

@NgModule({
  declarations: [ImgStateComponent],
  imports: [CommonModule],
  exports: [ImgStateComponent],
  bootstrap: [SomeOtherComponent],
})
export class ImgStateComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > Img 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
  SimpleChanges,
} from \\"@angular/core\\";

export interface ImgProps {
  attributes?: any;
  imgSrc?: string;
  altText?: string;
  backgroundSize?: \\"cover\\" | \\"contain\\";
  backgroundPosition?:
    | \\"center\\"
    | \\"top\\"
    | \\"left\\"
    | \\"right\\"
    | \\"bottom\\"
    | \\"top left\\"
    | \\"top right\\"
    | \\"bottom left\\"
    | \\"bottom right\\";
}

import { Builder } from \\"@builder.io/sdk\\";

@Component({
  selector: \\"img-component\\",
  template: \`
    <img
      [ngStyle]=\\"{
          objectFit: backgroundSize || 'cover',
          objectPosition: backgroundPosition || 'center'
        }\\"
      [attr.alt]=\\"altText\\"
      [attr.src]=\\"imgSrc\\"
      #elRef0
      #_root
    />
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class ImgComponent {
  @Input() backgroundSize!: ImgProps[\\"backgroundSize\\"];
  @Input() backgroundPosition!: ImgProps[\\"backgroundPosition\\"];
  @Input() attributes!: ImgProps[\\"attributes\\"];
  @Input() imgSrc!: ImgProps[\\"imgSrc\\"];
  @Input() altText!: ImgProps[\\"altText\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  @ViewChild(\\"elRef0\\") elRef0!: ElementRef;

  _listenerFns = new Map<string, () => void>();

  setAttributes(el: HTMLElement, value: any, changes?: any) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)!();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer: Renderer2) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"img-component\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [ImgComponent],
  imports: [CommonModule],
  exports: [ImgComponent],
  bootstrap: [SomeOtherComponent],
})
export class ImgComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > Input 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
  SimpleChanges,
} from \\"@angular/core\\";

export interface FormInputProps {
  type?: string;
  attributes?: any;
  name?: string;
  value?: string;
  placeholder?: string;
  defaultValue?: string;
  required?: boolean;
  onChange?: (value: string) => void;
}

import { Builder } from \\"@builder.io/sdk\\";

@Component({
  selector: \\"form-input-component\\",
  template: \`
    <input
      [attr.placeholder]=\\"placeholder\\"
      [attr.type]=\\"type\\"
      [attr.name]=\\"name\\"
      [attr.value]=\\"value\\"
      [attr.defaultValue]=\\"defaultValue\\"
      [attr.required]=\\"required\\"
      (change)=\\"onChange?.($event.target.value)\\"
      #elRef0
      #_root
    />
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class FormInputComponent {
  @Input() attributes!: FormInputProps[\\"attributes\\"];
  @Input() defaultValue!: FormInputProps[\\"defaultValue\\"];
  @Input() placeholder!: FormInputProps[\\"placeholder\\"];
  @Input() type!: FormInputProps[\\"type\\"];
  @Input() name!: FormInputProps[\\"name\\"];
  @Input() value!: FormInputProps[\\"value\\"];
  @Input() required!: FormInputProps[\\"required\\"];
  @Input() onChange!: FormInputProps[\\"onChange\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  @ViewChild(\\"elRef0\\") elRef0!: ElementRef;

  _listenerFns = new Map<string, () => void>();

  setAttributes(el: HTMLElement, value: any, changes?: any) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)!();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer: Renderer2) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"form-input-component\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [FormInputComponent],
  imports: [CommonModule],
  exports: [FormInputComponent],
  bootstrap: [SomeOtherComponent],
})
export class FormInputComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > InputParent 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

import FormInputComponentModule from \\"./input.raw/angular\\";

@Component({
  selector: \\"stepper\\",
  template: \`
    <form-input-component
      name=\\"kingzez\\"
      type=\\"text\\"
      (change)=\\"handleChange($event)\\"
      #_root
    ></form-input-component>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class Stepper {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  handleChange(value: string) {
    console.log(value);
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"stepper\\");
  }
}

@NgModule({
  declarations: [Stepper],
  imports: [CommonModule, FormInputComponentModule],
  exports: [Stepper],
  bootstrap: [SomeOtherComponent],
})
export class StepperModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > NestedStore 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

type MyStore = {
  _id?: string;
  _messageId?: string;
};

@Component({
  selector: \\"nested-store\\",
  template: \`
    <div [attr.id]=\\"_id\\" #_root>
      Test

      <p [attr.id]=\\"_messageId\\">Message</p>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class NestedStore {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  _id: MyStore[\\"_id\\"] = \\"abc\\";
  _messageId: MyStore[\\"_messageId\\"] = null;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this._messageId = this._id + \\"-message\\";
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"nested-store\\");
  }
}

@NgModule({
  declarations: [NestedStore],
  imports: [CommonModule],
  exports: [NestedStore],
  bootstrap: [SomeOtherComponent],
})
export class NestedStoreModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > RawText 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

export interface RawTextProps {
  attributes?: any;
  text?: string; // builderBlock?: any;
}

@Component({
  selector: \\"raw-text\\",
  template: \`
    <span
      [class]=\\"attributes?.class || attributes?.className\\"
      [innerHTML]=\\"text || ''\\"
      #_root
    ></span>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class RawText {
  @Input() attributes!: RawTextProps[\\"attributes\\"];
  @Input() text!: RawTextProps[\\"text\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"raw-text\\");
  }
}

@NgModule({
  declarations: [RawText],
  imports: [CommonModule],
  exports: [RawText],
  bootstrap: [SomeOtherComponent],
})
export class RawTextModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > Section 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
  SimpleChanges,
} from \\"@angular/core\\";

export interface SectionProps {
  maxWidth?: number;
  attributes?: any;
  children?: any;
}

@Component({
  selector: \\"section-component\\",
  template: \`
    <section
      [ngStyle]=\\"maxWidth && typeof maxWidth === 'number' ? {
          maxWidth: maxWidth
        } : undefined\\"
      #elRef0
      #_root
    >
      <ng-content></ng-content>
    </section>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class SectionComponent {
  @Input() attributes!: SectionProps[\\"attributes\\"];
  @Input() maxWidth!: SectionProps[\\"maxWidth\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  @ViewChild(\\"elRef0\\") elRef0!: ElementRef;

  _listenerFns = new Map<string, () => void>();

  setAttributes(el: HTMLElement, value: any, changes?: any) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)!();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer: Renderer2) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"section-component\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [SectionComponent],
  imports: [CommonModule],
  exports: [SectionComponent],
  bootstrap: [SomeOtherComponent],
})
export class SectionComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > Section 2`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
  SimpleChanges,
} from \\"@angular/core\\";

export interface SectionProps {
  maxWidth?: number;
  attributes?: any;
  children?: any;
}

@Component({
  selector: \\"section-state-component\\",
  template: \`
    <ng-container *ngIf=\\"max\\">
      <ng-container *ngFor=\\"let item of items\\">
        <section
          [ngStyle]=\\"{
          maxWidth: item + max
        }\\"
          #elRef0
        >
          <ng-content></ng-content>
        </section>
      </ng-container>
    </ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class SectionStateComponent {
  @Input() attributes!: SectionProps[\\"attributes\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  @ViewChild(\\"elRef0\\") elRef0!: ElementRef;

  _listenerFns = new Map<string, () => void>();

  max = 42;
  items = [42];
  setAttributes(el: HTMLElement, value: any, changes?: any) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)!();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer: Renderer2) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"section-state-component\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [SectionStateComponent],
  imports: [CommonModule],
  exports: [SectionStateComponent],
  bootstrap: [SomeOtherComponent],
})
export class SectionStateComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > Select 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
  SimpleChanges,
} from \\"@angular/core\\";

export interface FormSelectProps {
  options?: {
    name?: string;
    value: string;
  }[];
  attributes?: any;
  name?: string;
  value?: string;
  defaultValue?: string;
}

import { Builder } from \\"@builder.io/sdk\\";

@Component({
  selector: \\"select-component\\",
  template: \`
    <select
      [attr.value]=\\"value\\"
      [attr.defaultValue]=\\"defaultValue\\"
      [attr.name]=\\"name\\"
      #elRef0
      #_root
    >
      <ng-container *ngFor=\\"let option of options; index as index\\">
        <option [attr.value]=\\"option.value\\" [attr.data-index]=\\"index\\">
          {{option.name || option.value}}
        </option>
      </ng-container>
    </select>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class SelectComponent {
  @Input() attributes!: FormSelectProps[\\"attributes\\"];
  @Input() value!: FormSelectProps[\\"value\\"];
  @Input() defaultValue!: FormSelectProps[\\"defaultValue\\"];
  @Input() name!: FormSelectProps[\\"name\\"];
  @Input() options!: FormSelectProps[\\"options\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  @ViewChild(\\"elRef0\\") elRef0!: ElementRef;

  _listenerFns = new Map<string, () => void>();

  setAttributes(el: HTMLElement, value: any, changes?: any) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)!();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer: Renderer2) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"select-component\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [SelectComponent],
  imports: [CommonModule],
  exports: [SelectComponent],
  bootstrap: [SomeOtherComponent],
})
export class SelectComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > SlotDefault 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

type Props = {
  [key: string]: string;
};

@Component({
  selector: \\"slot-code\\",
  template: \`
    <div #_root>
      <ng-content><div class=\\"default-slot\\">Default content</div></ng-content>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class SlotCode {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"slot-code\\");
  }
}

@NgModule({
  declarations: [SlotCode],
  imports: [CommonModule],
  exports: [SlotCode],
  bootstrap: [SomeOtherComponent],
})
export class SlotCodeModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > SlotHtml 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

type Props = {
  [key: string]: string;
};

import ContentSlotCodeModule from \\"./content-slot-jsx.raw/angular\\";

@Component({
  selector: \\"slot-code\\",
  template: \`
    <div #_root>
      <content-slot-code>
        <ng-content><div>Hello</div></ng-content>
      </content-slot-code>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class SlotCode {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"slot-code\\");
  }
}

@NgModule({
  declarations: [SlotCode],
  imports: [CommonModule, ContentSlotCodeModule],
  exports: [SlotCode],
  bootstrap: [SomeOtherComponent],
})
export class SlotCodeModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > SlotJsx 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

type Props = {
  [key: string]: string;
};

import ContentSlotCodeModule from \\"./content-slot-jsx.raw/angular\\";

@Component({
  selector: \\"slot-code\\",
  template: \`
    <div #_root>
      <content-slot-code [slotTesting]=\\"<div>Hello</div>\\"></content-slot-code>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class SlotCode {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"slot-code\\");
  }
}

@NgModule({
  declarations: [SlotCode],
  imports: [CommonModule, ContentSlotCodeModule],
  exports: [SlotCode],
  bootstrap: [SomeOtherComponent],
})
export class SlotCodeModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > SlotNamed 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

type Props = {
  [key: string]: string;
};

@Component({
  selector: \\"slot-code\\",
  template: \`
    <div #_root>
      <ng-content select=\\"[my-awesome-slot]\\"></ng-content>
      <ng-content select=\\"[top]\\"></ng-content>
      <ng-content select=\\"[left]\\">Default left</ng-content>
      <ng-content>Default Child</ng-content>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class SlotCode {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"slot-code\\");
  }
}

@NgModule({
  declarations: [SlotCode],
  imports: [CommonModule],
  exports: [SlotCode],
  bootstrap: [SomeOtherComponent],
})
export class SlotCodeModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > Stamped.io 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

type SmileReviewsProps = {
  productId: string;
  apiKey: string;
};

import { kebabCase, snakeCase } from \\"lodash\\";

@Component({
  selector: \\"smile-reviews\\",
  template: \`
    <div [attr.data-user]=\\"name\\" #_root>
      <button (click)=\\"showReviewPrompt = true\\">Write a review</button>
      <ng-container *ngIf=\\"showReviewPrompt || 'asdf'\\">
        <input placeholder=\\"Email\\" />
        <input placeholder=\\"Title\\" class=\\"input\\" />
        <textarea
          placeholder=\\"How was your experience?\\"
          class=\\"textarea\\"
        ></textarea>
        <button
          class=\\"button\\"
          (click)=\\"
          $event.preventDefault();
          showReviewPrompt = false;
        \\"
        >
          Submit
        </button>
      </ng-container>
      <ng-container
        *ngFor=\\"let review of reviews; index as index; trackBy: trackByReview0\\"
      >
        <div class=\\"review\\">
          <img class=\\"img\\" [attr.src]=\\"review.avatar\\" />
          <div [class]=\\"showReviewPrompt ? 'bg-primary' : 'bg-secondary'\\">
            <div>N: {{index}}</div>
            <div>{{review.author}}</div>
            <div>{{review.reviewMessage}}</div>
          </div>
        </div>
      </ng-container>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .input {
        display: block;
      }
      .textarea {
        display: block;
      }
      .button {
        display: block;
      }
      .review {
        margin: 10px;
        padding: 10px;
        background: white;
        display: flex;
        border-radius: 5px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        -webkit-font-smoothing: antialiased;
      }
      .img {
        height: 30px;
        width: 30px;
        margin-right: 10px;
      }
    \`,
  ],
})
export default class SmileReviews {
  @Input() apiKey!: SmileReviewsProps[\\"apiKey\\"];
  @Input() productId!: SmileReviewsProps[\\"productId\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  reviews = [];
  name = \\"test\\";
  showReviewPrompt = false;
  kebabCaseValue() {
    return kebabCase(\\"testThat\\");
  }
  snakeCaseValue() {
    return snakeCase(\\"testThis\\");
  }
  trackByReview0(index, review) {
    return review.id;
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    if (typeof window !== \\"undefined\\") {
      fetch(
        \`https://stamped.io/api/widget/reviews?storeUrl=builder-io.myshopify.com&apiKey=\${
          this.apiKey || \\"pubkey-8bbDq7W6w4sB3OWeM1HUy2s47702hM\\"
        }&productId=\${this.productId || \\"2410511106127\\"}\`
      )
        .then((res) => res.json())
        .then((data) => {
          this.reviews = data.data;
        });
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"smile-reviews\\");
  }
}

@NgModule({
  declarations: [SmileReviews],
  imports: [CommonModule],
  exports: [SmileReviews],
  bootstrap: [SomeOtherComponent],
})
export class SmileReviewsModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > StoreComment 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"string-literal-store\\",
  template: \`
    <ng-container>{{foo}}</ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class StringLiteralStore {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  foo = true;
  bar() {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"string-literal-store\\");
  }
}

@NgModule({
  declarations: [StringLiteralStore],
  imports: [CommonModule],
  exports: [StringLiteralStore],
  bootstrap: [SomeOtherComponent],
})
export class StringLiteralStoreModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > StoreShadowVars 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <ng-container>{{foo(errors)}}</ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  errors = {};
  foo(errors) {
    return errors;
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > StoreWithState 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <ng-container>{{bar()}}</ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  foo = false;
  bar() {
    return this.foo;
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > Submit 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
  SimpleChanges,
} from \\"@angular/core\\";

export interface ButtonProps {
  attributes?: any;
  text?: string;
}

@Component({
  selector: \\"submit-button\\",
  template: \`
    <button type=\\"submit\\" #elRef0 #_root>{{text}}</button>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class SubmitButton {
  @Input() attributes!: ButtonProps[\\"attributes\\"];
  @Input() text!: ButtonProps[\\"text\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  @ViewChild(\\"elRef0\\") elRef0!: ElementRef;

  _listenerFns = new Map<string, () => void>();

  setAttributes(el: HTMLElement, value: any, changes?: any) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)!();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer: Renderer2) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"submit-button\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [SubmitButton],
  imports: [CommonModule],
  exports: [SubmitButton],
  bootstrap: [SomeOtherComponent],
})
export class SubmitButtonModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > Text 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

export interface TextProps {
  attributes?: any;
  rtlMode: boolean;
  text?: string;
  content?: string;
  builderBlock?: any;
}

import { Builder } from \\"@builder.io/sdk\\";

@Component({
  selector: \\"text\\",
  template: \`
    <div
      [attr.contentEditable]=\\"allowEditingText || undefined\\"
      [attr.data-name]=\\"{
          test: name || 'any name'
        }\\"
      [innerHTML]=\\"text || content || name || '<p class=&quot;text-lg&quot;>my name</p>'\\"
      #_root
    ></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class Text {
  @Input() text!: TextProps[\\"text\\"];
  @Input() content!: TextProps[\\"content\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  name = \\"Decadef20\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"text\\");
  }
}

@NgModule({
  declarations: [Text],
  imports: [CommonModule],
  exports: [Text],
  bootstrap: [SomeOtherComponent],
})
export class TextModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > Textarea 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
  SimpleChanges,
} from \\"@angular/core\\";

export interface TextareaProps {
  attributes?: any;
  name?: string;
  value?: string;
  defaultValue?: string;
  placeholder?: string;
}

@Component({
  selector: \\"textarea\\",
  template: \`
    <textarea
      [attr.placeholder]=\\"placeholder\\"
      [attr.name]=\\"name\\"
      [attr.value]=\\"value\\"
      [attr.defaultValue]=\\"defaultValue\\"
      #elRef0
      #_root
    ></textarea>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class Textarea {
  @Input() attributes!: TextareaProps[\\"attributes\\"];
  @Input() placeholder!: TextareaProps[\\"placeholder\\"];
  @Input() name!: TextareaProps[\\"name\\"];
  @Input() value!: TextareaProps[\\"value\\"];
  @Input() defaultValue!: TextareaProps[\\"defaultValue\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  @ViewChild(\\"elRef0\\") elRef0!: ElementRef;

  _listenerFns = new Map<string, () => void>();

  setAttributes(el: HTMLElement, value: any, changes?: any) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)!();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer: Renderer2) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"textarea\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [Textarea],
  imports: [CommonModule],
  exports: [Textarea],
  bootstrap: [SomeOtherComponent],
})
export class TextareaModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > UseValueAndFnFromStore 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Output,
  EventEmitter,
  Component,
  ViewChild,
  ElementRef,
  SimpleChanges,
} from \\"@angular/core\\";

type MyProps = {
  onChange?: (active: boolean) => void;
};
type MyStore = {
  _id?: string;
  _active?: boolean;
  _do?: (id?: string) => void;
};

@Component({
  selector: \\"use-value-and-fn-from-store\\",
  template: \`
    <div #_root>Test</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class UseValueAndFnFromStore {
  @Output() onChange = new EventEmitter();

  @ViewChild(\\"_root\\") _root!: ElementRef;

  _id: MyStore[\\"_id\\"] = \\"abc\\";
  _active: MyStore[\\"_active\\"] = false;
  _do(id?: string): ReturnType<MyStore[\\"_do\\"]> {
    this._active = !!id;

    if (this.onChange) {
      this.onChange.emit(this._active);
    }
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"use-value-and-fn-from-store\\");
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      if (this._do) {
        this._do(this._id);
      }
    }
  }
}

@NgModule({
  declarations: [UseValueAndFnFromStore],
  imports: [CommonModule],
  exports: [UseValueAndFnFromStore],
  bootstrap: [SomeOtherComponent],
})
export class UseValueAndFnFromStoreModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > Video 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
  SimpleChanges,
} from \\"@angular/core\\";

export interface VideoProps {
  attributes?: any;
  video?: string;
  autoPlay?: boolean;
  controls?: boolean;
  muted?: boolean;
  loop?: boolean;
  playsInline?: boolean;
  aspectRatio?: number;
  width?: number;
  height?: number;
  fit?: \\"contain\\" | \\"cover\\" | \\"fill\\";
  position?:
    | \\"center\\"
    | \\"top\\"
    | \\"left\\"
    | \\"right\\"
    | \\"bottom\\"
    | \\"top left\\"
    | \\"top right\\"
    | \\"bottom left\\"
    | \\"bottom right\\";
  posterImage?: string;
  lazyLoad?: boolean;
}

@Component({
  selector: \\"video\\",
  template: \`
    <video
      preload=\\"none\\"
      [ngStyle]=\\"useObjectWrapper({
          width: '100%' },{
          height: '100%' },
          attributes?.style,{
          objectFit: fit },{
          objectPosition: position },{
              borderRadius: 1 },)\\"
      [attr.poster]=\\"posterImage\\"
      [attr.autoplay]=\\"autoPlay\\"
      [attr.muted]=\\"muted\\"
      [attr.controls]=\\"controls\\"
      [attr.loop]=\\"loop\\"
      #elRef0
      #_root
    ></video>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class Video {
  @Input() attributes!: VideoProps[\\"attributes\\"];
  @Input() fit!: VideoProps[\\"fit\\"];
  @Input() position!: VideoProps[\\"position\\"];
  @Input() video!: VideoProps[\\"video\\"];
  @Input() posterImage!: VideoProps[\\"posterImage\\"];
  @Input() autoPlay!: VideoProps[\\"autoPlay\\"];
  @Input() muted!: VideoProps[\\"muted\\"];
  @Input() controls!: VideoProps[\\"controls\\"];
  @Input() loop!: VideoProps[\\"loop\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  @ViewChild(\\"elRef0\\") elRef0!: ElementRef;

  _listenerFns = new Map<string, () => void>();

  setAttributes(el: HTMLElement, value: any, changes?: any) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)!();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  useObjectWrapper(...args: any[]) {
    let obj = {};
    args.forEach((arg) => {
      obj = { ...obj, ...arg };
    });
    return obj;
  }

  constructor(private renderer: Renderer2) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"video\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [Video],
  imports: [CommonModule],
  exports: [Video],
  bootstrap: [SomeOtherComponent],
})
export class VideoModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > allSpread 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
  SimpleChanges,
} from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #elRef0 #_root>
      Hello! I can run natively in React, Vue, Svelte, Qwik, and many more
      frameworks!
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @Input() attributes!: any;
  @Input() accessHere!: any;

  @ViewChild(\\"_root\\") _root!: ElementRef;

  @ViewChild(\\"elRef0\\") elRef0!: ElementRef;

  _listenerFns = new Map<string, () => void>();

  attrsUsingUseState = {
    hello: \\"world\\",
  };
  properties = {
    style: \\"color: blue\\",
    onClick: () => console.log(\\"pressed\\"),
  };
  specifics = {
    someSpecificState: \\"specific\\",
  };
  setAttributes(el: HTMLElement, value: any, changes?: any) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)!();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }
  elRef0_state_0 = null;

  constructor(private renderer: Renderer2) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.elRef0_state_0 = {
      someOtherAttrs: this.accessHere,
      someStateAttrs: this.specifics,
    };
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attrsUsingUseState);
    this.setAttributes(this.elRef0?.nativeElement, this.properties);
    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
    this.setAttributes(this.elRef0?.nativeElement, this.elRef0_state_0);
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attrsUsingUseState,
        changes[\\"attrsUsingUseState\\"]?.currentValue
      );
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.properties,
        changes[\\"properties\\"]?.currentValue
      );
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
      this.elRef0_state_0 = {
        someOtherAttrs: this.accessHere,
        someStateAttrs: this.specifics,
      };
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.elRef0_state_0,
        changes[\\"elRef0_state_0\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > arrowFunctionInUseStore 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>Hello {{name}}</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  name = \\"steve\\";
  setName(value) {
    this.name = value;
  }
  updateNameWithArrowFn(value) {
    this.name = value;
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > basicForFragment 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"basic-for-fragment\\",
  template: \`
    <div #_root>
      <ng-container
        *ngFor=\\"let option of ['a', 'b', 'c']; trackBy: trackByOption0\\"
      >
        <ng-container>
          <div>{{option}}</div>
        </ng-container>
      </ng-container>
      <ng-container
        *ngFor=\\"let option of ['a', 'b', 'c']; trackBy: trackByOption1\\"
      >
        <ng-container>
          <div>{{option}}</div>
        </ng-container>
      </ng-container>
      <select>
        <ng-container
          *ngFor=\\"let option of ['d', 'e', 'f']; trackBy: trackByOption2\\"
        >
          <option [attr.value]=\\"option\\">{{option}}</option>
        </ng-container>
      </select>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class BasicForFragment {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  id = \\"xyz\\";
  trackByOption0(_, option) {
    return \`key-\${option}\`;
  }
  trackByOption1(_, option) {
    return \`\${this.id}-\${option}\`;
  }
  trackByOption2(_, option) {
    return \`\${this.id}-\${option}\`;
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"basic-for-fragment\\");
  }
}

@NgModule({
  declarations: [BasicForFragment],
  imports: [CommonModule],
  exports: [BasicForFragment],
  bootstrap: [SomeOtherComponent],
})
export class BasicForFragmentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > basicForNoTagReference 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Input,
  ViewContainerRef,
  TemplateRef,
} from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-for-no-tag-ref-component\\",
  template: \`
    <ng-template #iconTemplate></ng-template>
    <ng-container
      *ngComponentOutlet=\\"
              TagNameGetter;
              inputs: {  };
              content: myContent;
              \\"
    ></ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicForNoTagRefComponent {
  @Input() actions!: any;

  @ViewChild(\\"_root\\") _root!: ElementRef;

  @ViewChild(\\"tagnamegetterTemplate\\", { static: true })
  tagnamegetterTemplateRef!: TemplateRef<any>;
  @ViewChild(\\"tagTemplate\\", { static: true }) tagTemplateRef!: TemplateRef<any>;
  @ViewChild(\\"tagnameTemplate\\", { static: true })
  tagnameTemplateRef!: TemplateRef<any>;
  @ViewChild(\\"iconTemplate\\", { static: true })
  iconTemplateRef!: TemplateRef<any>;

  myContent?: any[][];

  name = \\"VincentW\\";
  TagName = \\"div\\";
  tag = \\"span\\";
  get TagNameGetter() {
    return \\"span\\";
  }

  constructor(private vcRef: ViewContainerRef) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.myContent = [
      this.vcRef.createEmbeddedView(this.tagnamegetterTemplateRef).rootNodes,
      this.vcRef.createEmbeddedView(this.tagTemplateRef).rootNodes,
      this.vcRef.createEmbeddedView(this.tagnameTemplateRef).rootNodes,
      this.vcRef.createEmbeddedView(this.iconTemplateRef).rootNodes,
    ];
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-for-no-tag-ref-component\\");
  }
}

@NgModule({
  declarations: [MyBasicForNoTagRefComponent],
  imports: [CommonModule],
  exports: [MyBasicForNoTagRefComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicForNoTagRefComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > basicForwardRef 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

export interface Props {
  showInput: boolean;
  inputRef: HTMLInputElement;
}

@Component({
  selector: \\"my-basic-forward-ref-component\\",
  template: \`
    <div #_root>
      <input
        class=\\"input\\"
        [attr.value]=\\"name\\"
        (change)=\\"name = $event.target.value\\"
      />
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .input {
        color: red;
      }
    \`,
  ],
})
export default class MyBasicForwardRefComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  name = \\"PatrickJS\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-forward-ref-component\\");
  }
}

@NgModule({
  declarations: [MyBasicForwardRefComponent],
  imports: [CommonModule],
  exports: [MyBasicForwardRefComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicForwardRefComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > basicForwardRefMetadata 1`] = `
"/**
          useMetadata:
          {\\"forwardRef\\":\\"inputRef\\"}
          */

import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

export interface Props {
  showInput: boolean;
  inputRef: HTMLInputElement;
}

@Component({
  selector: \\"my-basic-forward-ref-component\\",
  template: \`
    <div #_root>
      <input
        class=\\"input\\"
        [attr.value]=\\"name\\"
        (change)=\\"name = $event.target.value\\"
      />
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .input {
        color: red;
      }
    \`,
  ],
})
export default class MyBasicForwardRefComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  name = \\"PatrickJS\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-forward-ref-component\\");
  }
}

@NgModule({
  declarations: [MyBasicForwardRefComponent],
  imports: [CommonModule],
  exports: [MyBasicForwardRefComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicForwardRefComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > basicOnUpdateReturn 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, SimpleChanges } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-on-update-return-component\\",
  template: \`
    <div #_root>Hello! {{name}}</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicOnUpdateReturnComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  name = \\"PatrickJS\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-on-update-return-component\\");
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      const controller = new AbortController();
      const signal = controller.signal;
      fetch(\\"https://patrickjs.com/api/resource.json\\", {
        signal,
      })
        .then((response) => response.json())
        .then((data) => {
          this.name = data.name;
        });
      return () => {
        if (!signal.aborted) {
          controller.abort();
        }
      };
    }
  }
}

@NgModule({
  declarations: [MyBasicOnUpdateReturnComponent],
  imports: [CommonModule],
  exports: [MyBasicOnUpdateReturnComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicOnUpdateReturnComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > basicRefAttributePassing 1`] = `
"/**
          useMetadata:
          {\\"attributePassing\\":{\\"enabled\\":true}}
          */

import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"basic-ref-attribute-passing-component\\",
  template: \`
    <button #buttonRef>Attribute Passing</button>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class BasicRefAttributePassingComponent {
  @ViewChild(\\"buttonRef\\") buttonRef!: ElementRef;
}

@NgModule({
  declarations: [BasicRefAttributePassingComponent],
  imports: [CommonModule],
  exports: [BasicRefAttributePassingComponent],
  bootstrap: [SomeOtherComponent],
})
export class BasicRefAttributePassingComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > basicRefAttributePassingCustomRef 1`] = `
"/**
          useMetadata:
          {\\"attributePassing\\":{\\"enabled\\":true,\\"customRef\\":\\"buttonRef\\"}}
          */

import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"basic-ref-attribute-passing-custom-ref-component\\",
  template: \`
    <div><button #buttonRef>Attribute Passing</button></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class BasicRefAttributePassingCustomRefComponent {
  @ViewChild(\\"buttonRef\\") buttonRef!: ElementRef;
}

@NgModule({
  declarations: [BasicRefAttributePassingCustomRefComponent],
  imports: [CommonModule],
  exports: [BasicRefAttributePassingCustomRefComponent],
  bootstrap: [SomeOtherComponent],
})
export class BasicRefAttributePassingCustomRefComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > class + ClassName + css 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

import MyCompModule from \\"./my-component.lite/angular\\";

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <div #_root>
      <my-comp class=\\"test\\" className=\\"test2\\">
        Hello! I can run in React, Vue, Solid, or Liquid!
      </my-comp>
      <div class=\\"test2 test div\\">
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .div {
        padding: 10px;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule, MyCompModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > class + css 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <div class=\\"test div\\" #_root>
      Hello! I can run in React, Vue, Solid, or Liquid!
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .div {
        padding: 10px;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > className + css 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <div class=\\"test div\\" #_root>
      Hello! I can run in React, Vue, Solid, or Liquid!
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .div {
        padding: 10px;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > className 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

type Props = {
  [key: string]: string | JSX.Element;
  slotTesting: JSX.Element;
};

import { JSX } from \\"../../../../jsx-runtime\\";

@Component({
  selector: \\"class-name-code\\",
  template: \`
    <div #_root>
      <div class=\\"no binding\\">Without Binding</div>
      <div [class]=\\"bindings\\">With binding</div>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class ClassNameCode {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  bindings = \\"a binding\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"class-name-code\\");
  }
}

@NgModule({
  declarations: [ClassNameCode],
  imports: [CommonModule],
  exports: [ClassNameCode],
  bootstrap: [SomeOtherComponent],
})
export class ClassNameCodeModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > classState 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <div [class]=\\"classState + ' div'\\" [ngStyle]=\\"styleState\\" #_root>
      Hello! I can run in React, Vue, Solid, or Liquid!
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .div {
        padding: 10px;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  classState = \\"testClassName\\";
  styleState = {
    color: \\"red\\",
  };

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > complexMeta 1`] = `
"/**
          useMetadata:
          {\\"x\\":\\"y\\",\\"asdf\\":{\\"stringValue\\":\\"d\\",\\"booleanValue\\":true,\\"numberValue\\":1,\\"innerObject\\":{\\"stringValue\\":\\"inner\\",\\"numberValue\\":2,\\"booleanValue\\":false},\\"spreadStringValue\\":\\"f\\"}}
          */

import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"complex-meta-raw\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class ComplexMetaRaw {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"complex-meta-raw\\");
  }
}

@NgModule({
  declarations: [ComplexMetaRaw],
  imports: [CommonModule],
  exports: [ComplexMetaRaw],
  bootstrap: [SomeOtherComponent],
})
export class ComplexMetaRawModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > componentWithContext 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

export interface ComponentWithContextProps {
  content: string;
}

import Context1 from \\"@dummy/1\\";
import Context2 from \\"@dummy/2\\";

@Component({
  selector: \\"component-with-context\\",
  template: \`
    <ng-container>
      <ng-container>{{foo.value}}</ng-container>
    </ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class ComponentWithContext {
  @Input() content!: ComponentWithContextProps[\\"content\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  constructor(public foo: Context1) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"component-with-context\\");
  }
}

@NgModule({
  declarations: [ComponentWithContext],
  imports: [CommonModule],
  exports: [ComponentWithContext],
  bootstrap: [SomeOtherComponent],
})
export class ComponentWithContextModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > componentWithContextMultiRoot 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

export interface ComponentWithContextProps {
  content: string;
}

import Context1 from \\"@dummy/1\\";
import Context2 from \\"@dummy/2\\";

@Component({
  selector: \\"component-with-context\\",
  template: \`
    <ng-container>
      <ng-container>{{foo.value}}</ng-container>
      <div>other</div>
    </ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class ComponentWithContext {
  @Input() content!: ComponentWithContextProps[\\"content\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  constructor(public foo: Context1) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"component-with-context\\");
  }
}

@NgModule({
  declarations: [ComponentWithContext],
  imports: [CommonModule],
  exports: [ComponentWithContext],
  bootstrap: [SomeOtherComponent],
})
export class ComponentWithContextModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > contentState 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

import BuilderContext from \\"@dummy/context.lite\\";

@Component({
  selector: \\"render-content\\",
  template: \`
    <div #_root>setting context</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class RenderContent {
  @Input() content!: any;
  @Input() customComponents!: any;

  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"render-content\\");
  }
}

@NgModule({
  declarations: [RenderContent],
  imports: [CommonModule],
  exports: [RenderContent],
  bootstrap: [SomeOtherComponent],
})
export class RenderContentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > customSelector 1`] = `
"/**
          useMetadata:
          {\\"angular\\":{\\"selector\\":\\"not-my-component\\"}}
          */

import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"not-my-component\\",
  template: \`
    <span #_root>My selector shouldn't be my-component!</span>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > defaultProps 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Output,
  EventEmitter,
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
  SimpleChanges,
} from \\"@angular/core\\";

export interface ButtonProps {
  attributes?: any;
  text?: string;
  buttonText?: string; // no default value

  link?: string;
  openLinkInNewTab?: boolean;
  onClick?: () => void;
}
const defaultProps = {
  text: \\"default text\\",
  link: \\"https://builder.io/\\",
  openLinkInNewTab: false,
  onClick: () => {
    console.log(\\"hi\\");
  },
};

@Component({
  selector: \\"button\\",
  template: \`
    <div #_root>
      <ng-container *ngIf=\\"link\\">
        <a
          [attr.href]=\\"link\\"
          [attr.target]=\\"openLinkInNewTab ? '_blank' : undefined\\"
          #elRef0
        >
          {{text}}
        </a>
      </ng-container>
      <ng-container *ngIf=\\"!link\\">
        <button type=\\"button\\" (click)=\\"this.onClick.emit()\\" #elRef1>
          {{buttonText}}
        </button>
      </ng-container>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class Button {
  @Input() link: ButtonProps[\\"link\\"] = defaultProps[\\"link\\"];
  @Input() attributes!: ButtonProps[\\"attributes\\"];
  @Input() openLinkInNewTab: ButtonProps[\\"openLinkInNewTab\\"] =
    defaultProps[\\"openLinkInNewTab\\"];
  @Input() text: ButtonProps[\\"text\\"] = defaultProps[\\"text\\"];
  @Input() buttonText!: ButtonProps[\\"buttonText\\"];

  @Output() onClick = new EventEmitter();

  @ViewChild(\\"_root\\") _root!: ElementRef;

  @ViewChild(\\"elRef0\\") elRef0!: ElementRef;
  @ViewChild(\\"elRef1\\") elRef1!: ElementRef;

  _listenerFns = new Map<string, () => void>();

  setAttributes(el: HTMLElement, value: any, changes?: any) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)!();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer: Renderer2) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"button\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
    this.setAttributes(this.elRef1?.nativeElement, this.attributes);
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
      this.setAttributes(
        this.elRef1?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [Button],
  imports: [CommonModule],
  exports: [Button],
  bootstrap: [SomeOtherComponent],
})
export class ButtonModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > defaultPropsOutsideComponent 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Output,
  EventEmitter,
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
  SimpleChanges,
} from \\"@angular/core\\";

export interface ButtonProps {
  attributes?: any;
  text?: string;
  link?: string;
  openLinkInNewTab?: boolean;
  onClick: () => void;
}
const defaultProps = {
  text: \\"default text\\",
  link: \\"https://builder.io/\\",
  openLinkInNewTab: false,
  onClick: () => {},
};

@Component({
  selector: \\"button\\",
  template: \`
    <div #_root>
      <ng-container *ngIf=\\"link\\">
        <a
          [attr.href]=\\"link\\"
          [attr.target]=\\"openLinkInNewTab ? '_blank' : undefined\\"
          #elRef0
        >
          {{text}}
        </a>
      </ng-container>
      <ng-container *ngIf=\\"!link\\">
        <button type=\\"button\\" (click)=\\"this.onClick.emit($event)\\" #elRef1>
          {{text}}
        </button>
      </ng-container>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class Button {
  @Input() link: ButtonProps[\\"link\\"] = defaultProps[\\"link\\"];
  @Input() attributes!: ButtonProps[\\"attributes\\"];
  @Input() openLinkInNewTab: ButtonProps[\\"openLinkInNewTab\\"] =
    defaultProps[\\"openLinkInNewTab\\"];
  @Input() text: ButtonProps[\\"text\\"] = defaultProps[\\"text\\"];

  @Output() onClick = new EventEmitter();

  @ViewChild(\\"_root\\") _root!: ElementRef;

  @ViewChild(\\"elRef0\\") elRef0!: ElementRef;
  @ViewChild(\\"elRef1\\") elRef1!: ElementRef;

  _listenerFns = new Map<string, () => void>();

  setAttributes(el: HTMLElement, value: any, changes?: any) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)!();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer: Renderer2) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"button\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
    this.setAttributes(this.elRef1?.nativeElement, this.attributes);
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
      this.setAttributes(
        this.elRef1?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [Button],
  imports: [CommonModule],
  exports: [Button],
  bootstrap: [SomeOtherComponent],
})
export class ButtonModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > defaultValsWithTypes 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

type Props = {
  name: string;
};

const DEFAULT_VALUES: Props = {
  name: \\"Sami\\",
};

@Component({
  selector: \\"component-with-types\\",
  template: \`
    <div #_root>Hello {{name || DEFAULT_VALUES.name}}</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class ComponentWithTypes {
  DEFAULT_VALUES = DEFAULT_VALUES;

  @Input() name!: Props[\\"name\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"component-with-types\\");
  }
}

@NgModule({
  declarations: [ComponentWithTypes],
  imports: [CommonModule],
  exports: [ComponentWithTypes],
  bootstrap: [SomeOtherComponent],
})
export class ComponentWithTypesModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > dynamicComponent 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <ng-container
      *ngComponentOutlet=\\"
              obj.Component;
              inputs: { hello: 'world', onClick: onClick.bind(this), attributes: attributes, something: something };
              content: myContent;
              \\"
    ></ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @Input() attributes!: any;
  @Input() something!: any;

  @ViewChild(\\"_root\\") _root!: ElementRef;

  obj = {
    name: \\"foo\\",
    Component: FooComponent,
  };
  onClick = function onClick() {
    console.log(\\"hello\\");
  };

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > dynamicComponentWithEventArg 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Input,
  ViewContainerRef,
  TemplateRef,
} from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <ng-template #componentTemplate>hello</ng-template>
    <ng-container
      *ngComponentOutlet=\\"
              Component;
              inputs: { hello: 'world', onClick: onClick.bind(this), attributes: attributes, something: something };
              content: myContent;
              \\"
    ></ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @Input() attributes!: any;
  @Input() something!: any;

  @ViewChild(\\"_root\\") _root!: ElementRef;

  @ViewChild(\\"componentTemplate\\", { static: true })
  componentTemplateRef!: TemplateRef<any>;

  myContent?: any[][];

  Component = HelloComponent;
  onClick = function onClick(event: any) {
    console.log(\\"hello\\", event);
  };

  constructor(private vcRef: ViewContainerRef) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.myContent = [
      this.vcRef.createEmbeddedView(this.componentTemplateRef).rootNodes,
    ];
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > eventInputAndChange 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"event-input-and-change\\",
  template: \`
    <div #_root>
      <input
        class=\\"input\\"
        [attr.value]=\\"name\\"
        (input)=\\"name = $event.target.value\\"
        (change)=\\"name = $event.target.value\\"
      />

      Hello! I can run in React, Vue, Solid, or Liquid!
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .input {
        color: red;
      }
    \`,
  ],
})
export default class EventInputAndChange {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  name = \\"Steve\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"event-input-and-change\\");
  }
}

@NgModule({
  declarations: [EventInputAndChange],
  imports: [CommonModule],
  exports: [EventInputAndChange],
  bootstrap: [SomeOtherComponent],
})
export class EventInputAndChangeModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > expressionState 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>{{refToUse}}</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @Input() componentRef!: any;

  @ViewChild(\\"_root\\") _root!: ElementRef;

  refToUse = null;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.refToUse = !(this.componentRef instanceof Function)
      ? this.componentRef
      : null;
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > figmaMeta 1`] = `
"/**
          useMetadata:
          {\\"figma\\":{\\"name\\":\\"def-button-beta-outlined\\",\\"url\\":\\"https://www.figma.com/xxx\\",\\"props\\":{\\"iconSmall\\":{\\"type\\":\\"instance\\",\\"key\\":\\"📍 Icon Small\\"},\\"iconMedium\\":{\\"type\\":\\"instance\\",\\"key\\":\\"📍 Icon Medium\\"},\\"label\\":{\\"type\\":\\"string\\",\\"key\\":\\"✏️ Label\\"},\\"icon\\":{\\"type\\":\\"boolean\\",\\"key\\":\\"👁️ Icon\\",\\"value\\":{\\"false\\":false,\\"true\\":\\"placeholder\\"}},\\"interactiveState\\":{\\"type\\":\\"enum\\",\\"key\\":\\"Interactive State\\",\\"value\\":{\\"(Def) Enabled\\":false,\\"Hovered\\":false,\\"Pressed\\":false,\\"Focused\\":false,\\"Disabled\\":\\"true\\"}},\\"size\\":{\\"type\\":\\"enum\\",\\"key\\":\\"Size\\",\\"value\\":{\\"(Def) Medium\\":false,\\"Small\\":\\"small\\"}},\\"width\\":{\\"type\\":\\"enum\\",\\"key\\":\\"Width\\",\\"value\\":{\\"(Def) Auto Width\\":false,\\"Full Width\\":\\"full\\"}}}}}
          */

import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"figma-button\\",
  template: \`
    <button
      [attr.data-icon]=\\"icon\\"
      [attr.data-disabled]=\\"interactiveState\\"
      [attr.data-width]=\\"width\\"
      [attr.data-size]=\\"size\\"
      #_root
    >
      {{label}}
    </button>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class FigmaButton {
  @Input() icon!: any;
  @Input() interactiveState!: any;
  @Input() width!: any;
  @Input() size!: any;
  @Input() label!: any;

  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"figma-button\\");
  }
}

@NgModule({
  declarations: [FigmaButton],
  imports: [CommonModule],
  exports: [FigmaButton],
  bootstrap: [SomeOtherComponent],
})
export class FigmaButtonModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > getterState 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

export interface ButtonProps {
  foo: string;
}

@Component({
  selector: \\"button\\",
  template: \`
    <div #_root>
      <p>{{foo2}}</p>
      <p>{{bar}}</p>
      <p>{{baz(1)}}</p>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class Button {
  @Input() foo!: ButtonProps[\\"foo\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  get foo2() {
    return this.foo + \\"foo\\";
  }
  get bar() {
    return \\"bar\\";
  }
  baz(i: number) {
    return i + this.foo2.length;
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"button\\");
  }
}

@NgModule({
  declarations: [Button],
  imports: [CommonModule],
  exports: [Button],
  bootstrap: [SomeOtherComponent],
})
export class ButtonModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > import types 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

type RenderContentProps = {
  options?: GetContentOptions;
  content: BuilderContent;
  renderContentProps: RenderBlockProps;
};

import { BuilderContent, GetContentOptions } from \\"@builder.io/sdk\\";
import RenderBlockModule, {
  RenderBlockModuleProps,
} from \\"./builder-render-block.raw/angular\\";

@Component({
  selector: \\"render-content\\",
  template: \`
    <render-block #_root></render-block>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class RenderContent {
  @Input() renderContentProps!: RenderContentProps[\\"renderContentProps\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  getRenderContentProps(block, index) {
    return {
      block: block,
      index: index,
    };
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"render-content\\");
  }
}

@NgModule({
  declarations: [RenderContent],
  imports: [CommonModule, RenderBlockModule],
  exports: [RenderContent],
  bootstrap: [SomeOtherComponent],
})
export class RenderContentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > importRaw 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-import-component\\",
  template: \`
    <div #_root>Testing which imports get excluded!</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyImportComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-import-component\\");
  }
}

@NgModule({
  declarations: [MyImportComponent],
  imports: [CommonModule],
  exports: [MyImportComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyImportComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > multipleOnUpdate 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, SimpleChanges } from \\"@angular/core\\";

@Component({
  selector: \\"multiple-on-update\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MultipleOnUpdate {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"multiple-on-update\\");
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      console.log(\\"Runs on every update/rerender\\");
      console.log(\\"Runs on every update/rerender as well\\");
    }
  }
}

@NgModule({
  declarations: [MultipleOnUpdate],
  imports: [CommonModule],
  exports: [MultipleOnUpdate],
  bootstrap: [SomeOtherComponent],
})
export class MultipleOnUpdateModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > multipleOnUpdateWithDeps 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, SimpleChanges } from \\"@angular/core\\";

@Component({
  selector: \\"multiple-on-update-with-deps\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MultipleOnUpdateWithDeps {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  a = \\"a\\";
  b = \\"b\\";
  c = \\"c\\";
  d = \\"d\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"multiple-on-update-with-deps\\");
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      console.log(\\"Runs when a or b changes\\", this.a, this.b);

      if (this.a === \\"a\\") {
        this.a = \\"b\\";
      }
      console.log(\\"Runs when c or d changes\\", this.c, this.d);

      if (this.a === \\"a\\") {
        this.a = \\"b\\";
      }
    }
  }
}

@NgModule({
  declarations: [MultipleOnUpdateWithDeps],
  imports: [CommonModule],
  exports: [MultipleOnUpdateWithDeps],
  bootstrap: [SomeOtherComponent],
})
export class MultipleOnUpdateWithDepsModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > multipleSpreads 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  SimpleChanges,
} from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <input #elRef0 #_root />
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  @ViewChild(\\"elRef0\\") elRef0!: ElementRef;

  _listenerFns = new Map<string, () => void>();

  attrs = {
    hello: \\"world\\",
  };
  setAttributes(el: HTMLElement, value: any, changes?: any) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)!();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer: Renderer2) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attrs);
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attrs,
        changes[\\"attrs\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > nativeAttributes 1`] = `
"/**
          useMetadata:
          {\\"angular\\":{\\"nativeAttributes\\":[\\"disabled\\"]}}
          */

import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      <input [disabled]=\\"disabled\\" />

      Hello! If someone passes \\\\\`[disabled]=\\"false\\"\\\\\` to me, disabled shouldn't
      be visible in the DOM.
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @Input() disabled!: any;

  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > nestedShow 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

interface Props {
  conditionA: boolean;
  conditionB: boolean;
}

@Component({
  selector: \\"nested-show\\",
  template: \`
    <ng-container *ngIf=\\"conditionA\\">
      <ng-container *ngIf=\\"!conditionB\\">
        <div>if condition A and condition B</div>
      </ng-container>
      <ng-container *ngIf=\\"!(!conditionB)\\">
        <div>else-condition-B</div>
      </ng-container>
    </ng-container>
    <ng-container *ngIf=\\"!(conditionA)\\">
      <div>else-condition-A</div>
    </ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class NestedShow {
  @Input() conditionA!: Props[\\"conditionA\\"];
  @Input() conditionB!: Props[\\"conditionB\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"nested-show\\");
  }
}

@NgModule({
  declarations: [NestedShow],
  imports: [CommonModule],
  exports: [NestedShow],
  bootstrap: [SomeOtherComponent],
})
export class NestedShowModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > nestedStyles 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"nested-styles\\",
  template: \`
    <div class=\\"div\\" #_root>Hello world</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .div {
        display: flex;
        --bar: red;
        color: var(--bar);
      }
      @media (max-width: env(--mobile)) {
        .div {
          display: block;
        }
      }
      .div:hover {
        display: flex;
      }
      .div:active {
        display: inline;
      }
      .div .nested-selector {
        display: grid;
      }
      .div .nested-selector:hover {
        display: block;
      }
      .div.nested-selector:active {
        display: inline-block;
      }
    \`,
  ],
})
export default class NestedStyles {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"nested-styles\\");
  }
}

@NgModule({
  declarations: [NestedStyles],
  imports: [CommonModule],
  exports: [NestedStyles],
  bootstrap: [SomeOtherComponent],
})
export class NestedStylesModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > onEvent 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"embed\\",
  template: \`
    <div class=\\"builder-embed\\" #elem #_root><div>Test</div></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class Embed {
  @ViewChild(\\"elem\\") elem!: ElementRef;
  @ViewChild(\\"_root\\") _root!: ElementRef;

  foo(event) {
    console.log(\\"test2\\");
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    if (typeof window !== \\"undefined\\") {
      this.elem.nativeElement.dispatchEvent(new CustomEvent(\\"initEditingBldr\\"));
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"embed\\");
  }
}

@NgModule({
  declarations: [Embed],
  imports: [CommonModule],
  exports: [Embed],
  bootstrap: [SomeOtherComponent],
})
export class EmbedModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > onInit & onMount 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"on-init\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class OnInit {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    console.log(\\"onInit\\");

    if (typeof window !== \\"undefined\\") {
      console.log(\\"onMount\\");
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"on-init\\");
  }
}

@NgModule({
  declarations: [OnInit],
  imports: [CommonModule],
  exports: [OnInit],
  bootstrap: [SomeOtherComponent],
})
export class OnInitModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > onInit 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

type Props = {
  name: string;
};

export const defaultValues = {
  name: \\"PatrickJS\\",
};

@Component({
  selector: \\"on-init\\",
  template: \`
    <div #_root>Default name defined by parent {{name}}</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class OnInit {
  @Input() name!: Props[\\"name\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  name = \\"\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.name = defaultValues.name || this.name;
    console.log(\\"set defaults with props\\");
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"on-init\\");
  }
}

@NgModule({
  declarations: [OnInit],
  imports: [CommonModule],
  exports: [OnInit],
  bootstrap: [SomeOtherComponent],
})
export class OnInitModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > onInitPlain 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"on-init-plain\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class OnInitPlain {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    console.log(\\"onInit\\");
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"on-init-plain\\");
  }
}

@NgModule({
  declarations: [OnInitPlain],
  imports: [CommonModule],
  exports: [OnInitPlain],
  bootstrap: [SomeOtherComponent],
})
export class OnInitPlainModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > onMount 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"comp\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class Comp {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    if (typeof window !== \\"undefined\\") {
      console.log(\\"Runs on mount\\");
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"comp\\");
  }

  ngOnDestroy() {
    console.log(\\"Runs on unMount\\");
  }
}

@NgModule({
  declarations: [Comp],
  imports: [CommonModule],
  exports: [Comp],
  bootstrap: [SomeOtherComponent],
})
export class CompModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > onMountMultiple 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"comp\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class Comp {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    if (typeof window !== \\"undefined\\") {
      const onMountHook_0 = () => {
        console.log(\\"Runs on mount\\");
      };
      onMountHook_0();
      const onMountHook_1 = () => {
        console.log(\\"Another one runs on Mount\\");
      };
      onMountHook_1();
      const onMountHook_2 = () => {
        console.log(\\"SSR runs on Mount\\");
      };
      onMountHook_2();
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"comp\\");
  }
}

@NgModule({
  declarations: [Comp],
  imports: [CommonModule],
  exports: [Comp],
  bootstrap: [SomeOtherComponent],
})
export class CompModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > onUpdate 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, SimpleChanges } from \\"@angular/core\\";

@Component({
  selector: \\"on-update\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class OnUpdate {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"on-update\\");
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      console.log(\\"Runs on every update/rerender\\");
    }
  }
}

@NgModule({
  declarations: [OnUpdate],
  imports: [CommonModule],
  exports: [OnUpdate],
  bootstrap: [SomeOtherComponent],
})
export class OnUpdateModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > onUpdateWithDeps 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Input,
  SimpleChanges,
} from \\"@angular/core\\";

type Props = {
  size: string;
};

@Component({
  selector: \\"on-update-with-deps\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class OnUpdateWithDeps {
  @Input() size!: Props[\\"size\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  a = \\"a\\";
  b = \\"b\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"on-update-with-deps\\");
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      console.log(\\"Runs when a, b or size changes\\", this.a, this.b, this.size);
    }
  }
}

@NgModule({
  declarations: [OnUpdateWithDeps],
  imports: [CommonModule],
  exports: [OnUpdateWithDeps],
  bootstrap: [SomeOtherComponent],
})
export class OnUpdateWithDepsModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > outputEventBinding 1`] = `
"/**
          useMetadata:
          {\\"angular\\":{\\"nativeEvents\\":[\\"onFakeNative\\"]}}
          */

import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      <input
        [attr.value]=\\"name\\"
        (change)=\\"name = $event.target.value\\"
        (changeOrSomething)=\\"name = $event.target.value\\"
        (fakenative)=\\"name = $event.target.value\\"
        (animationend)=\\"name = $event.target.value\\"
      />

      Hello! I can run in React, Vue, Solid, or Liquid!
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  name = \\"Steve\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > preserveExportOrLocalStatement 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

type Types = {
  s: any[];
};
interface IPost {
  len: number;
}
export interface MyBasicComponentProps {
  id: string;
}

const b = 3;
const foo = () => {};
export const a = 3;
export const bar = () => {};
export function run<T>(value: T) {}

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > preserveTyping 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

export type A = \\"test\\";
export interface C {
  n: \\"test\\";
}
type B = \\"test2\\";
interface D {
  n: \\"test\\";
}
export interface MyBasicComponentProps {
  name: string;
  age?: number;
}

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <div #_root>Hello! I can run in React, Vue, Solid, or Liquid! {{name}}</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @Input() name!: MyBasicComponentProps[\\"name\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > propsDestructure 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

type Props = {
  children: any;
  type: string;
};

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <div #_root>
      <ng-content></ng-content>
      {{type}} Hello! I can run in React, Vue, Solid, or Liquid!
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @Input() type!: Props[\\"type\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  name = \\"Decadef20\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > propsInterface 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

interface Person {
  name: string;
  age?: number;
}

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <div #_root>Hello! I can run in React, Vue, Solid, or Liquid! {{name}}</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @Input() name!: Person | never[\\"name\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > propsType 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

type Person = {
  name: string;
  age?: number;
};

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <div #_root>Hello! I can run in React, Vue, Solid, or Liquid! {{name}}</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @Input() name!: Person[\\"name\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > referencingFunInsideHook 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, SimpleChanges } from \\"@angular/core\\";

@Component({
  selector: \\"on-update\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class OnUpdate {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  foo = function foo(params) {};
  bar = function bar() {};
  zoo = function zoo() {
    const params = {
      cb: this.bar,
    };
  };

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"on-update\\");
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      this.foo({
        someOption: this.bar,
      });
    }
  }
}

@NgModule({
  declarations: [OnUpdate],
  imports: [CommonModule],
  exports: [OnUpdate],
  bootstrap: [SomeOtherComponent],
})
export class OnUpdateModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > renderBlock 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Input,
  ViewContainerRef,
  TemplateRef,
} from \\"@angular/core\\";

export type RenderBlockProps = {
  block: BuilderBlock;
  context: BuilderContextInterface;
};

import { TARGET } from \\"../../constants/target.js\\";
import {
  BuilderContextInterface,
  RegisteredComponent,
} from \\"../../context/types.js\\";
import { evaluate } from \\"../../functions/evaluate.js\\";
import { extractTextStyles } from \\"../../functions/extract-text-styles.js\\";
import { getBlockActions } from \\"../../functions/get-block-actions.js\\";
import { getBlockComponentOptions } from \\"../../functions/get-block-component-options.js\\";
import { getBlockProperties } from \\"../../functions/get-block-properties.js\\";
import { getBlockTag } from \\"../../functions/get-block-tag.js\\";
import { getProcessedBlock } from \\"../../functions/get-processed-block.js\\";
import { getReactNativeBlockStylesModule } from \\"../../functions/get-react-native-block-styles.js\\";
import { BuilderBlock } from \\"../../types/builder-block.js\\";
import { Nullable } from \\"../../types/typescript.js\\";
import BlockStylesModule from \\"./block-styles.lite/angular\\";
import { isEmptyHtmlElement } from \\"./render-block.helpers.js\\";
import RenderComponentWithContext from \\"./render-component-with-context.lite\\";
import { RenderComponentProps } from \\"./render-component.lite\\";
import RenderComponent from \\"./render-component.lite\\";
import RenderRepeatedBlockModule from \\"./render-repeated-block.lite/angular\\";
import { RepeatData } from \\"./types.js\\";

@Component({
  selector: \\"render-block\\",
  template: \`
    <ng-template #rendercomponenttagTemplate></ng-template>
    <ng-container *ngIf=\\"shouldWrap\\">
      <ng-container *ngIf=\\"isEmptyHtmlElement(tag)\\">
        <ng-container
          *ngComponentOutlet=\\"
              tag;
              inputs: { attributes: attributes, actions: actions };
              content: myContent;
              \\"
        ></ng-container>
      </ng-container>
      <ng-container *ngIf=\\"!isEmptyHtmlElement(tag) && repeatItemData\\">
        <ng-container
          *ngFor=\\"let data of repeatItemData; index as index; trackBy: trackByData0\\"
        >
          <render-repeated-block
            [repeatContext]=\\"data.context\\"
            [block]=\\"data.block\\"
          ></render-repeated-block>
        </ng-container>
      </ng-container>
      <ng-container *ngIf=\\"!isEmptyHtmlElement(tag) && !repeatItemData\\">
        <ng-container
          *ngComponentOutlet=\\"
              tag;
              inputs: { attributes: attributes, actions: actions };
              content: myContent;
              \\"
        ></ng-container>
      </ng-container>
    </ng-container>
    <ng-container *ngIf=\\"!(shouldWrap)\\">
      <ng-container
        *ngComponentOutlet=\\"
              renderComponentTag;
              inputs: { renderComponentProps: renderComponentProps };
              content: myContent;
              \\"
      ></ng-container>
    </ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class RenderBlock {
  isEmptyHtmlElement = isEmptyHtmlElement;

  @Input() block!: RenderBlockProps[\\"block\\"];
  @Input() context!: RenderBlockProps[\\"context\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  @ViewChild(\\"rendercomponenttagTemplate\\", { static: true })
  rendercomponenttagTemplateRef!: TemplateRef<any>;
  @ViewChild(\\"tagTemplate\\", { static: true }) tagTemplateRef!: TemplateRef<any>;

  myContent?: any[][];

  get component() {
    const componentName = getProcessedBlock({
      block: this.block,
      state: this.context.state,
      context: this.context.context,
      shouldEvaluateBindings: false,
    }).component?.name;

    if (!componentName) {
      return null;
    }

    const ref = this.context.registeredComponents[componentName];

    if (!ref) {
      // TODO: Public doc page with more info about this message
      console.warn(\`
          Could not find a registered component named \\"\${componentName}\\".
          If you registered it, is the file that registered it imported by the file that needs to render it?\`);
      return undefined;
    } else {
      return ref;
    }
  }
  get tag() {
    return getBlockTag(this.useBlock);
  }
  get useBlock() {
    return this.repeatItemData
      ? this.block
      : getProcessedBlock({
          block: this.block,
          state: this.context.state,
          context: this.context.context,
          shouldEvaluateBindings: true,
        });
  }
  get actions() {
    return getBlockActions({
      block: this.useBlock,
      state: this.context.state,
      context: this.context.context,
    });
  }
  get attributes() {
    const blockProperties = getBlockProperties(this.useBlock);
    return {
      ...blockProperties,
      ...(TARGET === \\"reactNative\\"
        ? {
            style: getReactNativeBlockStyles({
              block: this.useBlock,
              context: this.context,
              blockStyles: blockProperties.style,
            }),
          }
        : {}),
    };
  }
  get shouldWrap() {
    return !this.component?.noWrap;
  }
  get renderComponentProps() {
    return {
      blockChildren: this.useChildren,
      componentRef: this.component?.component,
      componentOptions: {
        ...getBlockComponentOptions(this.useBlock),

        /**
         * These attributes are passed to the wrapper element when there is one. If \`noWrap\` is set to true, then
         * they are provided to the component itself directly.
         */
        ...(this.shouldWrap
          ? {}
          : {
              attributes: { ...this.attributes, ...this.actions },
            }),
        customBreakpoints: this.childrenContext?.content?.meta?.breakpoints,
      },
      context: this.childrenContext,
    };
  }
  get useChildren() {
    // TO-DO: When should \`canHaveChildren\` dictate rendering?
    // This is currently commented out because some Builder components (e.g. Box) do not have \`canHaveChildren: true\`,
    // but still receive and need to render children.
    // return state.componentInfo?.canHaveChildren ? state.useBlock.children : [];
    return this.useBlock.children ?? [];
  }
  get childrenWithoutParentComponent() {
    /**
     * When there is no \`componentRef\`, there might still be children that need to be rendered. In this case,
     * we render them outside of \`componentRef\`.
     * NOTE: We make sure not to render this if \`repeatItemData\` is non-null, because that means we are rendering an array of
     * blocks, and the children will be repeated within those blocks.
     */
    const shouldRenderChildrenOutsideRef =
      !this.component?.component && !this.repeatItemData;
    return shouldRenderChildrenOutsideRef ? this.useChildren : [];
  }
  get repeatItemData() {
    /**
     * we don't use \`state.useBlock\` here because the processing done within its logic includes evaluating the block's bindings,
     * which will not work if there is a repeat.
     */
    const { repeat, ...blockWithoutRepeat } = this.block;

    if (!repeat?.collection) {
      return undefined;
    }

    const itemsArray = evaluate({
      code: repeat.collection,
      state: this.context.state,
      context: this.context.context,
    });

    if (!Array.isArray(itemsArray)) {
      return undefined;
    }

    const collectionName = repeat.collection.split(\\".\\").pop();
    const itemNameToUse =
      repeat.itemName || (collectionName ? collectionName + \\"Item\\" : \\"item\\");
    const repeatArray = itemsArray.map<RepeatData>((item, index) => ({
      context: {
        ...this.context,
        state: {
          ...this.context.state,
          $index: index,
          $item: item,
          [itemNameToUse]: item,
          [\`$\${itemNameToUse}Index\`]: index,
        },
      },
      block: blockWithoutRepeat,
    }));
    return repeatArray;
  }
  get inheritedTextStyles() {
    if (TARGET !== \\"reactNative\\") {
      return {};
    }

    const styles = getReactNativeBlockStyles({
      block: this.useBlock,
      context: this.context,
      blockStyles: this.attributes.style,
    });
    return extractTextStyles(styles);
  }
  get childrenContext() {
    return {
      apiKey: this.context.apiKey,
      state: this.context.state,
      content: this.context.content,
      context: this.context.context,
      registeredComponents: this.context.registeredComponents,
      inheritedStyles: this.inheritedTextStyles,
    };
  }
  get renderComponentTag() {
    if (TARGET === \\"reactNative\\") {
      return RenderComponentWithContext;
    } else if (TARGET === \\"vue3\\") {
      // vue3 expects a string for the component tag
      return \\"RenderComponent\\";
    } else {
      return RenderComponent;
    }
  }
  trackByData0(index, data) {
    return index;
  }
  trackByChild1(_, child) {
    return \\"render-block-\\" + child.id;
  }
  trackByChild2(_, child) {
    return \\"block-style-\\" + child.id;
  }

  constructor(private vcRef: ViewContainerRef) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.myContent = [
      this.vcRef.createEmbeddedView(this.rendercomponenttagTemplateRef)
        .rootNodes,
      this.vcRef.createEmbeddedView(this.tagTemplateRef).rootNodes,
    ];
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"render-block\\");
  }
}

@NgModule({
  declarations: [RenderBlock],
  imports: [
    CommonModule,
    RenderRepeatedBlockModule,
    RenderBlockModule,
    BlockStylesModule,
  ],
  exports: [RenderBlock],
  bootstrap: [SomeOtherComponent],
})
export class RenderBlockModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > renderContentExample 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Input,
  SimpleChanges,
} from \\"@angular/core\\";

type Props = {
  customComponents: string[];
  content: {
    blocks: any[];
    id: string;
  };
};

import BuilderContext from \\"@dummy/context.lite\\";
import {
  dispatchNewContentToVisualEditor,
  sendComponentsToVisualEditor,
  trackClick,
} from \\"@dummy/injection-js\\";
import RenderBlocksModule from \\"@dummy/RenderBlocks.lite.tsx/angular\\";

@Component({
  selector: \\"render-content\\",
  template: \`
    <div class=\\"div\\" (click)=\\"trackClick(content.id)\\" #_root>
      <render-blocks [blocks]=\\"content.blocks\\"></render-blocks>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .div {
        display: flex;
        flex-direction: columns;
      }
    \`,
  ],
})
export default class RenderContent {
  trackClick = trackClick;

  @Input() customComponents!: Props[\\"customComponents\\"];
  @Input() content!: Props[\\"content\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    if (typeof window !== \\"undefined\\") {
      sendComponentsToVisualEditor(this.customComponents);
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"render-content\\");
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      dispatchNewContentToVisualEditor(this.content);
    }
  }
}

@NgModule({
  declarations: [RenderContent],
  imports: [CommonModule, RenderBlocksModule],
  exports: [RenderContent],
  bootstrap: [SomeOtherComponent],
})
export class RenderContentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > rootFragmentMultiNode 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
  SimpleChanges,
} from \\"@angular/core\\";

export interface ButtonProps {
  attributes?: any;
  text?: string;
  link?: string;
  openLinkInNewTab?: boolean;
}

@Component({
  selector: \\"button\\",
  template: \`
    <ng-container>
      <ng-container *ngIf=\\"link\\">
        <a
          [attr.href]=\\"link\\"
          [attr.target]=\\"openLinkInNewTab ? '_blank' : undefined\\"
          #elRef0
        >
          {{text}}
        </a>
      </ng-container>
      <ng-container *ngIf=\\"!link\\">
        <button type=\\"button\\" #elRef1>{{text}}</button>
      </ng-container>
    </ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class Button {
  @Input() link!: ButtonProps[\\"link\\"];
  @Input() attributes!: ButtonProps[\\"attributes\\"];
  @Input() openLinkInNewTab!: ButtonProps[\\"openLinkInNewTab\\"];
  @Input() text!: ButtonProps[\\"text\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  @ViewChild(\\"elRef0\\") elRef0!: ElementRef;
  @ViewChild(\\"elRef1\\") elRef1!: ElementRef;

  _listenerFns = new Map<string, () => void>();

  setAttributes(el: HTMLElement, value: any, changes?: any) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)!();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer: Renderer2) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"button\\");

    this.setAttributes(this.elRef0?.nativeElement, this.attributes);
    this.setAttributes(this.elRef1?.nativeElement, this.attributes);
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
      this.setAttributes(
        this.elRef1?.nativeElement,
        this.attributes,
        changes[\\"attributes\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [Button],
  imports: [CommonModule],
  exports: [Button],
  bootstrap: [SomeOtherComponent],
})
export class ButtonModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > rootShow 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

export interface RenderStylesProps {
  foo: string;
}

@Component({
  selector: \\"render-styles\\",
  template: \`
    <ng-container *ngIf=\\"foo === 'bar'\\"><div>Bar</div></ng-container>
    <ng-container *ngIf=\\"!(foo === 'bar')\\"><div>Foo</div></ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class RenderStyles {
  @Input() foo!: RenderStylesProps[\\"foo\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"render-styles\\");
  }
}

@NgModule({
  declarations: [RenderStyles],
  imports: [CommonModule],
  exports: [RenderStyles],
  bootstrap: [SomeOtherComponent],
})
export class RenderStylesModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > self-referencing component 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      {{name}}
      <ng-container *ngIf=\\"name === 'Batman'\\">
        <my-component name=\\"Bruce Wayne\\"></my-component>
      </ng-container>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @Input() name!: any;

  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule, MyComponentModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > self-referencing component with children 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      {{name}}
      <ng-content></ng-content>
      <ng-container *ngIf=\\"name === 'Batman'\\">
        <my-component name=\\"Bruce\\"><div>Wayne</div></my-component>
      </ng-container>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @Input() name!: any;

  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule, MyComponentModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > setState 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"set-state\\",
  template: \`
    <div #_root><button (click)=\\"someFn()\\">Click me</button></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class SetState {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  n = [\\"123\\"];
  someFn() {
    this.n[0] = \\"123\\";
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"set-state\\");
  }
}

@NgModule({
  declarations: [SetState],
  imports: [CommonModule],
  exports: [SetState],
  bootstrap: [SomeOtherComponent],
})
export class SetStateModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > showExpressions 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

interface Props {
  conditionA: boolean;
  conditionB: boolean;
}

@Component({
  selector: \\"show-with-other-values\\",
  template: \`
    <div #_root>
      <ng-container *ngIf=\\"conditionA\\">Content0</ng-container>
      <ng-container *ngIf=\\"!(conditionA)\\">ContentA</ng-container>
      <ng-container *ngIf=\\"conditionA\\">ContentA</ng-container>
      <ng-container *ngIf=\\"conditionA\\"></ng-container>
      <ng-container *ngIf=\\"!(conditionA)\\">ContentA</ng-container>
      <ng-container *ngIf=\\"conditionA\\">ContentB</ng-container>
      <ng-container *ngIf=\\"!(conditionA)\\">{{undefined}}</ng-container>
      <ng-container *ngIf=\\"conditionA\\">{{undefined}}</ng-container>
      <ng-container *ngIf=\\"!(conditionA)\\">ContentB</ng-container>
      <ng-container *ngIf=\\"conditionA\\">ContentC</ng-container>
      <ng-container *ngIf=\\"conditionA\\"></ng-container>
      <ng-container *ngIf=\\"!(conditionA)\\">ContentC</ng-container>
      <ng-container *ngIf=\\"conditionA\\">ContentD</ng-container>
      <ng-container *ngIf=\\"conditionA\\"></ng-container>
      <ng-container *ngIf=\\"!(conditionA)\\">ContentD</ng-container>
      <ng-container *ngIf=\\"conditionA\\">ContentE</ng-container>
      <ng-container *ngIf=\\"!(conditionA)\\">hello</ng-container>
      <ng-container *ngIf=\\"conditionA\\">hello</ng-container>
      <ng-container *ngIf=\\"!(conditionA)\\">ContentE</ng-container>
      <ng-container *ngIf=\\"conditionA\\">ContentF</ng-container>
      <ng-container *ngIf=\\"!(conditionA)\\">123</ng-container>
      <ng-container *ngIf=\\"conditionA\\">123</ng-container>
      <ng-container *ngIf=\\"!(conditionA)\\">ContentF</ng-container>
      <ng-container *ngIf=\\"conditionA === 'Default'\\">4mb</ng-container>
      <ng-container *ngIf=\\"!(conditionA === 'Default')\\">
        <ng-container *ngIf=\\"conditionB === 'Complete'\\">20mb</ng-container>
        <ng-container *ngIf=\\"!(conditionB === 'Complete')\\">9mb</ng-container>
      </ng-container>
      <ng-container *ngIf=\\"conditionA === 'Default'\\">
        <ng-container *ngIf=\\"conditionB === 'Complete'\\">20mb</ng-container>
        <ng-container *ngIf=\\"!(conditionB === 'Complete')\\">9mb</ng-container>
      </ng-container>
      <ng-container *ngIf=\\"!(conditionA === 'Default')\\">4mb</ng-container>
      <ng-container *ngIf=\\"conditionA === 'Default'\\">
        <ng-container *ngIf=\\"conditionB === 'Complete'\\">
          <div>complete</div>
        </ng-container>
        <ng-container *ngIf=\\"!(conditionB === 'Complete')\\">9mb</ng-container>
      </ng-container>
      <ng-container *ngIf=\\"!(conditionA === 'Default')\\">
        <ng-container *ngIf=\\"conditionC === 'Complete'\\">dff</ng-container>
        <ng-container *ngIf=\\"!(conditionC === 'Complete')\\">
          <div>complete else</div>
        </ng-container>
      </ng-container>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class ShowWithOtherValues {
  @Input() conditionA!: Props[\\"conditionA\\"];
  @Input() conditionB!: Props[\\"conditionB\\"];
  @Input() conditionC!: Props[\\"conditionC\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"show-with-other-values\\");
  }
}

@NgModule({
  declarations: [ShowWithOtherValues],
  imports: [CommonModule],
  exports: [ShowWithOtherValues],
  bootstrap: [SomeOtherComponent],
})
export class ShowWithOtherValuesModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > showWithFor 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

interface Props {
  conditionA: boolean;
  items: string[];
}

@Component({
  selector: \\"nested-show\\",
  template: \`
    <ng-container *ngIf=\\"conditionA\\">
      <ng-container
        *ngFor=\\"let item of items; index as idx; trackBy: trackByItem0\\"
      >
        <div>{{item}}</div>
      </ng-container>
    </ng-container>
    <ng-container *ngIf=\\"!(conditionA)\\">
      <div>else-condition-A</div>
    </ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class NestedShow {
  @Input() conditionA!: Props[\\"conditionA\\"];
  @Input() items!: Props[\\"items\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  trackByItem0(idx, item) {
    return idx;
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"nested-show\\");
  }
}

@NgModule({
  declarations: [NestedShow],
  imports: [CommonModule],
  exports: [NestedShow],
  bootstrap: [SomeOtherComponent],
})
export class NestedShowModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > showWithOtherValues 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

interface Props {
  conditionA: boolean;
}

@Component({
  selector: \\"show-with-other-values\\",
  template: \`
    <div #_root>
      <ng-container *ngIf=\\"conditionA\\">ContentA</ng-container>
      <ng-container *ngIf=\\"conditionA\\">ContentB</ng-container>
      <ng-container *ngIf=\\"!(conditionA)\\">{{undefined}}</ng-container>
      <ng-container *ngIf=\\"conditionA\\">ContentC</ng-container>
      <ng-container *ngIf=\\"conditionA\\">ContentD</ng-container>
      <ng-container *ngIf=\\"conditionA\\">ContentE</ng-container>
      <ng-container *ngIf=\\"!(conditionA)\\">hello</ng-container>
      <ng-container *ngIf=\\"conditionA\\">ContentF</ng-container>
      <ng-container *ngIf=\\"!(conditionA)\\">123</ng-container>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class ShowWithOtherValues {
  @Input() conditionA!: Props[\\"conditionA\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"show-with-other-values\\");
  }
}

@NgModule({
  declarations: [ShowWithOtherValues],
  imports: [CommonModule],
  exports: [ShowWithOtherValues],
  bootstrap: [SomeOtherComponent],
})
export class ShowWithOtherValuesModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > showWithRootText 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

interface Props {
  conditionA: boolean;
}

@Component({
  selector: \\"show-root-text\\",
  template: \`
    <ng-container *ngIf=\\"conditionA\\">ContentA</ng-container>
    <ng-container *ngIf=\\"!(conditionA)\\">
      <div>else-condition-A</div>
    </ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class ShowRootText {
  @Input() conditionA!: Props[\\"conditionA\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"show-root-text\\");
  }
}

@NgModule({
  declarations: [ShowRootText],
  imports: [CommonModule],
  exports: [ShowRootText],
  bootstrap: [SomeOtherComponent],
})
export class ShowRootTextModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > signalsOnUpdate 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Input,
  SimpleChanges,
} from \\"@angular/core\\";

type Props = {
  id: string;
  foo: {
    bar: {
      baz: number;
    };
  };
};

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <div class=\\"test div\\" #_root>{{id}} {{foo.value.bar.baz}}</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .div {
        padding: 10px;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @Input() id!: Props[\\"id\\"];
  @Input() foo!: Props[\\"foo\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      console.log(\\"props.id changed\\", this.id);
      console.log(\\"props.foo.value.bar.baz changed\\", this.foo.value.bar.baz);
    }
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > spreadAttrs 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  SimpleChanges,
} from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <input #elRef0 #_root />
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  @ViewChild(\\"elRef0\\") elRef0!: ElementRef;

  _listenerFns = new Map<string, () => void>();

  setAttributes(el: HTMLElement, value: any, changes?: any) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)!();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer: Renderer2) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");

    this.setAttributes(this.elRef0?.nativeElement, attrs);
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        attrs,
        changes[\\"attrs\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > spreadNestedProps 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import {
  Component,
  ViewChild,
  ElementRef,
  Renderer2,
  Input,
  SimpleChanges,
} from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <input #elRef0 #_root />
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @Input() nested!: any;

  @ViewChild(\\"_root\\") _root!: ElementRef;

  @ViewChild(\\"elRef0\\") elRef0!: ElementRef;

  _listenerFns = new Map<string, () => void>();

  setAttributes(el: HTMLElement, value: any, changes?: any) {
    if (!el) {
      return;
    }

    const target = typeof changes === \\"undefined\\" ? value : changes;
    Object.keys(target).forEach((key) => {
      if (key.startsWith(\\"on\\")) {
        if (this._listenerFns.has(key)) {
          this._listenerFns.get(key)!();
        }

        this._listenerFns.set(
          key,
          this.renderer.listen(
            el,
            key.replace(\\"on\\", \\"\\").toLowerCase(),
            target[key]
          )
        );
      } else {
        this.renderer.setAttribute(el, key.toLowerCase(), target[key] ?? \\"\\");
      }
    });
  }

  constructor(private renderer: Renderer2) {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");

    this.setAttributes(this.elRef0?.nativeElement, this.nested);
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      this.setAttributes(
        this.elRef0?.nativeElement,
        this.nested,
        changes[\\"nested\\"]?.currentValue
      );
    }
  }

  ngOnDestroy() {
    for (const fn of this._listenerFns.values()) {
      fn();
    }
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > spreadProps 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-basic-component\\",
  template: \`
    <input #_root />
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-component\\");
  }
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > stateInit 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      <div>{{asfas}}</div>
      <div>{{someCompute}}</div>
      <div>{{someOtherVal}}</div>
      <div>{{sf}}</div>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @Input() val!: any;

  @ViewChild(\\"_root\\") _root!: ElementRef;

  add = function add(a, b) {
    return a + b;
  };
  asfas = \\"asga\\";
  subtract() {
    return this.someCompute - this.someOtherVal;
  }
  someCompute = null;
  someOtherVal = null;
  sf = null;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.someCompute = this.add(1, 2);

    this.someOtherVal = this.val;

    this.sf = this.add(this.val, 34);
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > stateInitSequence 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <Comp
      [val]=\\"useObjectWrapper( val
        )\\"
      #_root
    >
      {{val}}
    </Comp>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @Input() value!: any;

  @ViewChild(\\"_root\\") _root!: ElementRef;

  val = null;

  useObjectWrapper(...args: any[]) {
    let obj = {};
    args.forEach((arg) => {
      obj = { ...obj, ...arg };
    });
    return obj;
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    this.val = this.value;
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule, CompModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > store-async-function 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"string-literal-store\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class StringLiteralStore {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  arrowFunction = async function arrowFunction() {
    return Promise.resolve();
  };
  namedFunction = async function namedFunction() {
    return Promise.resolve();
  };
  fetchUsers = async function fetchUsers() {
    return Promise.resolve();
  };

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"string-literal-store\\");
  }
}

@NgModule({
  declarations: [StringLiteralStore],
  imports: [CommonModule],
  exports: [StringLiteralStore],
  bootstrap: [SomeOtherComponent],
})
export class StringLiteralStoreModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > string-literal-store 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"string-literal-store\\",
  template: \`
    <div #_root>{{foo}}</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class StringLiteralStore {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  foo = 123;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"string-literal-store\\");
  }
}

@NgModule({
  declarations: [StringLiteralStore],
  imports: [CommonModule],
  exports: [StringLiteralStore],
  bootstrap: [SomeOtherComponent],
})
export class StringLiteralStoreModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > string-literal-store-kebab 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from '@angular/core';










   @Component({
     selector: 'string-literal-store',template: \`

      <div #_root>{{'foo-bar'}}</div>

      \`,styles: [\`:host { display: contents; }\`]
   })
   export default class StringLiteralStore {







     @ViewChild('_root') _root!: ElementRef








      foo-bar= 123








     /**
* Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
* @param element  the ref for the component
* @param customElementSelector  the custom element like \`my-component\`
*/
private enableAttributePassing(element: HTMLElement | null, customElementSelector: string) {
 const parent = element?.closest(customElementSelector);
 if (element && parent) {
   const attributes = parent.attributes;
   for (let i = 0; i < attributes.length; i++) {
     const attr = attributes.item(i);
     if (attr && (attr.name.startsWith('data-') || attr.name.startsWith('aria-'))) {
       element.setAttribute(attr.name, attr.value);
       parent.removeAttribute(attr.name);
     }
     if (attr && attr.name === 'class') {
       const isWebComponent = attr.value.includes('hydrated');
       const value = attr.value.replace('hydrated', '').trim();
       const currentClass = element.getAttribute('class');
       element.setAttribute(attr.name, \`\${currentClass ? \`\${currentClass} \` : ''}\${value}\`);
       if (isWebComponent) {
         // Stencil is using this class for lazy loading component
         parent.setAttribute('class', 'hydrated');
       } else {
         parent.removeAttribute(attr.name);
       }
     }
   }
 }
};



     ngAfterViewInit() {

       const element: HTMLElement | null = this._root?.nativeElement;
       this.enableAttributePassing(element, \\"string-literal-store\\");

         }





   }

@NgModule({
  declarations: [StringLiteralStore],
  imports: [CommonModule],
  exports: [StringLiteralStore],
  bootstrap: [SomeOtherComponent]
})
export class StringLiteralStoreModule {}"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > styleClassAndCss 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div
      class=\\"builder-column div\\"
      [ngStyle]=\\"{
          width: '100%'
        }\\"
      #_root
    ></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .div {
        display: flex;
        flex-direction: column;
        align-items: stretch;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > stylePropClassAndCss 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"style-prop-class-and-css\\",
  template: \`
    <div
      [ngStyle]=\\"attributes.style\\"
      [class]=\\"attributes.class + ' div'\\"
      #_root
    ></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      .div {
        display: flex;
        flex-direction: column;
        align-items: stretch;
      }
    \`,
  ],
})
export default class StylePropClassAndCss {
  @Input() attributes!: any;

  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"style-prop-class-and-css\\");
  }
}

@NgModule({
  declarations: [StylePropClassAndCss],
  imports: [CommonModule],
  exports: [StylePropClassAndCss],
  bootstrap: [SomeOtherComponent],
})
export class StylePropClassAndCssModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > subComponent 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

import FooModule from \\"./foo-sub-component.lite/angular\\";

@Component({
  selector: \\"sub-component\\",
  template: \`
    <foo #_root></foo>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class SubComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"sub-component\\");
  }
}

@NgModule({
  declarations: [SubComponent],
  imports: [CommonModule, FooModule],
  exports: [SubComponent],
  bootstrap: [SomeOtherComponent],
})
export class SubComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > svgComponent 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"svg-component\\",
  template: \`
    <svg
      fill=\\"none\\"
      role=\\"img\\"
      [attr.viewBox]=\\"'0 0 ' + 42 + ' ' + 42\\"
      [attr.width]=\\"42\\"
      [attr.height]=\\"42\\"
      #_root
    >
      <defs>
        <filter id=\\"prefix__filter0_f\\" filterUnits=\\"userSpaceOnUse\\">
          <feFlood result=\\"BackgroundImageFix\\"></feFlood>
          <feBlend
            in=\\"SourceGraphic\\"
            in2=\\"BackgroundImageFix\\"
            result=\\"shape\\"
          ></feBlend>
          <feGaussianBlur
            result=\\"effect1_foregroundBlur\\"
            [attr.stdDeviation]=\\"7\\"
          ></feGaussianBlur>
        </filter>
      </defs>
    </svg>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class SvgComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"svg-component\\");
  }
}

@NgModule({
  declarations: [SvgComponent],
  imports: [CommonModule],
  exports: [SvgComponent],
  bootstrap: [SomeOtherComponent],
})
export class SvgComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > twoForsTrackBy 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      <ng-container *ngFor=\\"let item of items; trackBy: trackByItem0\\">
        <div>{{item}}</div>
      </ng-container>
      <ng-container *ngFor=\\"let item of items; trackBy: trackByItem1\\">
        <div>{{item}}</div>
      </ng-container>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  items = [1, 2, 3];
  trackByItem0(_, item) {
    return item;
  }
  trackByItem1(_, item) {
    return item;
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > typeDependency 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

export type TypeDependencyProps = {
  foo: Foo;
  foo2: Foo2;
};

import { Foo } from \\"./foo-type\\";
import { Foo as Foo2 } from \\"./type-export.lite\\";

@Component({
  selector: \\"type-dependency\\",
  template: \`
    <div #_root>{{foo}}</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class TypeDependency {
  @Input() foo!: TypeDependencyProps[\\"foo\\"];

  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"type-dependency\\");
  }
}

@NgModule({
  declarations: [TypeDependency],
  imports: [CommonModule],
  exports: [TypeDependency],
  bootstrap: [SomeOtherComponent],
})
export class TypeDependencyModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > typeExternalStore 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

import { FooStore } from \\"./foo-store\\";

@Component({
  selector: \\"type-external-store\\",
  template: \`
    <div #_root>Hello {{_name}} !</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class TypeExternalStore {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  _name: FooStore[\\"_name\\"] = \\"test\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"type-external-store\\");
  }
}

@NgModule({
  declarations: [TypeExternalStore],
  imports: [CommonModule],
  exports: [TypeExternalStore],
  bootstrap: [SomeOtherComponent],
})
export class TypeExternalStoreModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > typeGetterStore 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

type GetterStore = {
  getName: () => string;
  name: string;
  get test(): string;
};

@Component({
  selector: \\"type-getter-store\\",
  template: \`
    <div #_root>Hello {{name}} !</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class TypeGetterStore {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  name: GetterStore[\\"name\\"] = \\"test\\";
  getName(): ReturnType<GetterStore[\\"getName\\"]> {
    if (this.name === \\"a\\") {
      return \\"b\\";
    }

    return this.name;
  }
  get test(): ReturnType<GetterStore[\\"test\\"]> {
    return \\"test\\";
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"type-getter-store\\");
  }
}

@NgModule({
  declarations: [TypeGetterStore],
  imports: [CommonModule],
  exports: [TypeGetterStore],
  bootstrap: [SomeOtherComponent],
})
export class TypeGetterStoreModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > use-style 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <button type=\\"button\\" #_root>Button</button>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      button {
        background: blue;
        color: white;
        font-size: 12px;
        outline: 1px solid black;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > use-style-and-css 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <button type=\\"button\\" class=\\"button\\" #_root>Button</button>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      button {
        font-size: 12px;
        outline: 1px solid black;
      }

      .button {
        background: blue;
        color: white;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > use-style-outside-component 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <button type=\\"button\\" #_root>Button</button>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      button {
        background: blue;
        color: white;
        font-size: 12px;
        outline: 1px solid black;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > useObjectWrapper 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      <Comp
        [val1]=\\"useObjectWrapper( attributes2
        )\\"
        [val2]=\\"useObjectWrapper( attributes,
          attributes2
        )\\"
        [val3]=\\"useObjectWrapper( something,{
          anything: 'hello' },{
          hello: 'world' },)\\"
        [val4]=\\"useObjectWrapper( attributes,
          something,{
          anything: [1, 2, 3] },{
          hello: 'hello' },
          attributes2
        )\\"
        [val5]=\\"useObjectWrapper( attributes,
          something,{
          anything: [1, 2, 3] },{
          anythingString: ['a', 'b', 'c'] },{
          hello: 'hello' },
          spreadAttrs
        )\\"
        [val6]=\\"{
          anything: [1, 2, 3]
        }\\"
      ></Comp>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @Input() spreadAttrs!: any;

  @ViewChild(\\"_root\\") _root!: ElementRef;

  attributes = {
    id: 1,
  };
  attributes2 = {
    id2: 1,
  };
  something = {
    id3: 1,
  };

  useObjectWrapper(...args: any[]) {
    let obj = {};
    args.forEach((arg) => {
      obj = { ...obj, ...arg };
    });
    return obj;
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule, CompModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > useTarget 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"use-target-component\\",
  template: \`
    <div #_root>{{name}}</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class UseTargetComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  get name() {
    const prefix = true;
    return prefix + \\"foo\\";
  }
  lastName = \\"bar\\";
  foo = \\"bar\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    if (typeof window !== \\"undefined\\") {
      console.log(this.foo);
      this.foo = \\"bar\\";
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"use-target-component\\");
  }
}

@NgModule({
  declarations: [UseTargetComponent],
  imports: [CommonModule],
  exports: [UseTargetComponent],
  bootstrap: [SomeOtherComponent],
})
export class UseTargetComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > jsx > Typescript Test > webComponent 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

import { register } from \\"swiper/element/bundle\\";

@Component({
  selector: \\"my-basic-web-component\\",
  template: \`
    <swiper-container
      slides-per-view=\\"3\\"
      navigation=\\"true\\"
      pagination=\\"true\\"
      #_root
    >
      <swiper-slide>Slide 1</swiper-slide>
      <swiper-slide>Slide 2</swiper-slide>
      <swiper-slide>Slide 3</swiper-slide>
    </swiper-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyBasicWebComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    register();
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-basic-web-component\\");
  }
}

@NgModule({
  declarations: [MyBasicWebComponent],
  imports: [CommonModule],
  exports: [MyBasicWebComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyBasicWebComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Javascript Test > basic 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      <input (change)=\\"name = $event.target.value\\" [attr.value]=\\"name\\" />

      Hello! I can run in React, Vue, Solid, or Liquid!
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root;

  name = \\"Steve\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Javascript Test > bindGroup 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      <input
        type=\\"radio\\"
        value=\\"Plain\\"
        [attr.checked]=\\"tortilla === 'Plain'\\"
        (change)=\\"tortilla = $event.target.value\\"
      />
      <input
        type=\\"radio\\"
        value=\\"Whole wheat\\"
        [attr.checked]=\\"tortilla === 'Whole wheat'\\"
        (change)=\\"tortilla = $event.target.value\\"
      />
      <input
        type=\\"radio\\"
        value=\\"Spinach\\"
        [attr.checked]=\\"tortilla === 'Spinach'\\"
        (change)=\\"tortilla = $event.target.value\\"
      />
      <br />
      <br />
      <input
        type=\\"checkbox\\"
        value=\\"Rice\\"
        [attr.checked]=\\"fillings === 'Rice'\\"
        (change)=\\"fillings = $event.target.value\\"
      />
      <input
        type=\\"checkbox\\"
        value=\\"Beans\\"
        [attr.checked]=\\"fillings === 'Beans'\\"
        (change)=\\"fillings = $event.target.value\\"
      />
      <input
        type=\\"checkbox\\"
        value=\\"Cheese\\"
        [attr.checked]=\\"fillings === 'Cheese'\\"
        (change)=\\"fillings = $event.target.value\\"
      />
      <input
        type=\\"checkbox\\"
        value=\\"Guac (extra)\\"
        [attr.checked]=\\"fillings === 'Guac (extra)'\\"
        (change)=\\"fillings = $event.target.value\\"
      />
      <p>Tortilla: {{tortilla}}</p>
      <p>Fillings: {{fillings}}</p>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root;

  tortilla = \\"Plain\\";
  fillings = [];

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Javascript Test > bindProperty 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <input [attr.value]=\\"value\\" #_root />
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root;

  value = \\"hello\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Javascript Test > classDirective 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

const defaultProps = {};

@Component({
  selector: \\"my-component\\",
  template: \`
    <input
      [class]=\\"\\\\\`form-input \\\\\${disabled ? 'disabled' : ''} \\\\\${focus ? 'focus' : ''}\\\\\`\\"
      #_root
    />
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @Input() disabled;

  @ViewChild(\\"_root\\") _root;

  focus = true;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Javascript Test > context 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>{{activeTab}}</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root;

  activeTab = 0;

  constructor(public disabled: \\"disabled\\") {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Javascript Test > each 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <ul #_root>
      <ng-container *ngFor=\\"let num of numbers\\">
        <li>{{num}}</li>
      </ng-container>
    </ul>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root;

  numbers = [\\"one\\", \\"two\\", \\"three\\"];

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Javascript Test > eventHandlers 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      <button (click)=\\"log('hi')\\">Log</button>
      <button (click)=\\"log($event)\\">Log</button>
      <button (click)=\\"log($event)\\">Log</button>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root;

  log = function log(msg = \\"hello\\") {
    console.log(msg);
  };

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Javascript Test > html 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div [innerHTML]=\\"html\\" #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root;

  html = \\"<b>bold</b>\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Javascript Test > ifElse 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <ng-container *ngIf=\\"show\\">
      <button (click)=\\"toggle($event)\\">Hide</button>
    </ng-container>
    <ng-container *ngIf=\\"!(show)\\">
      <button (click)=\\"toggle($event)\\">Show</button>
    </ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root;

  show = true;
  toggle = function toggle() {
    this.show = !this.show;
  };

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Javascript Test > imports 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

import ButtonModule from \\"./Button.lite/angular\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      <button type=\\"button\\" [disabled]=\\"disabled\\">
        <ng-content></ng-content>
      </button>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root;

  disabled = false;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule, ButtonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Javascript Test > lifecycleHooks 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    if (typeof window !== \\"undefined\\") {
      console.log(\\"onMount\\");
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      console.log(\\"onAfterUpdate\\");
    }
  }

  ngOnDestroy() {
    console.log(\\"onDestroy\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Javascript Test > reactive 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      <input [attr.value]=\\"name\\" />

      Lowercase: {{lowercaseName}}
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root;

  name = \\"Steve\\";
  get lowercaseName() {
    return this.name.toLowerCase();
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Javascript Test > reactiveWithFn 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      <input
        type=\\"number\\"
        (change)=\\"a = $event.target.value\\"
        [attr.value]=\\"a\\"
      />
      <input
        type=\\"number\\"
        (change)=\\"b = $event.target.value\\"
        [attr.value]=\\"b\\"
      />

      Result: {{result}}
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root;

  a = 2;
  b = 5;
  result = null;
  calculateResult = function calculateResult(a_, b_) {
    this.result = a_ * b_;
  };

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }

  ngOnChanges(changes) {
    if (typeof window !== \\"undefined\\") {
      this.calculateResult(this.a, this.b);
    }
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Javascript Test > slots 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      <ng-content>default</ng-content>
      <ng-content select=\\"[test]\\"><div>default</div></ng-content>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Javascript Test > style 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <input class=\\"form-input\\" #_root />
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      input {
        color: red;
        font-size: 12px;
      }

      .form-input:focus {
        outline: 1px solid blue;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Javascript Test > textExpressions 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      normal: {{a + b}}
      <br />

      conditional {{a > 2 ? 'hello' : 'bye'}}
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root;

  a = 5;
  b = 12;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(element, customElementSelector) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Typescript Test > basic 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      <input (change)=\\"name = $event.target.value\\" [attr.value]=\\"name\\" />

      Hello! I can run in React, Vue, Solid, or Liquid!
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  name = \\"Steve\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Typescript Test > bindGroup 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      <input
        type=\\"radio\\"
        value=\\"Plain\\"
        [attr.checked]=\\"tortilla === 'Plain'\\"
        (change)=\\"tortilla = $event.target.value\\"
      />
      <input
        type=\\"radio\\"
        value=\\"Whole wheat\\"
        [attr.checked]=\\"tortilla === 'Whole wheat'\\"
        (change)=\\"tortilla = $event.target.value\\"
      />
      <input
        type=\\"radio\\"
        value=\\"Spinach\\"
        [attr.checked]=\\"tortilla === 'Spinach'\\"
        (change)=\\"tortilla = $event.target.value\\"
      />
      <br />
      <br />
      <input
        type=\\"checkbox\\"
        value=\\"Rice\\"
        [attr.checked]=\\"fillings === 'Rice'\\"
        (change)=\\"fillings = $event.target.value\\"
      />
      <input
        type=\\"checkbox\\"
        value=\\"Beans\\"
        [attr.checked]=\\"fillings === 'Beans'\\"
        (change)=\\"fillings = $event.target.value\\"
      />
      <input
        type=\\"checkbox\\"
        value=\\"Cheese\\"
        [attr.checked]=\\"fillings === 'Cheese'\\"
        (change)=\\"fillings = $event.target.value\\"
      />
      <input
        type=\\"checkbox\\"
        value=\\"Guac (extra)\\"
        [attr.checked]=\\"fillings === 'Guac (extra)'\\"
        (change)=\\"fillings = $event.target.value\\"
      />
      <p>Tortilla: {{tortilla}}</p>
      <p>Fillings: {{fillings}}</p>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  tortilla = \\"Plain\\";
  fillings = [];

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Typescript Test > bindProperty 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <input [attr.value]=\\"value\\" #_root />
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  value = \\"hello\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Typescript Test > classDirective 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, Input } from \\"@angular/core\\";

const defaultProps = {};

@Component({
  selector: \\"my-component\\",
  template: \`
    <input
      [class]=\\"\\\\\`form-input \\\\\${disabled ? 'disabled' : ''} \\\\\${focus ? 'focus' : ''}\\\\\`\\"
      #_root
    />
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @Input() disabled!: any;

  @ViewChild(\\"_root\\") _root!: ElementRef;

  focus = true;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Typescript Test > context 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>{{activeTab}}</div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  activeTab = 0;

  constructor(public disabled: \\"disabled\\") {}

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Typescript Test > each 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <ul #_root>
      <ng-container *ngFor=\\"let num of numbers\\">
        <li>{{num}}</li>
      </ng-container>
    </ul>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  numbers = [\\"one\\", \\"two\\", \\"three\\"];

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Typescript Test > eventHandlers 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      <button (click)=\\"log('hi')\\">Log</button>
      <button (click)=\\"log($event)\\">Log</button>
      <button (click)=\\"log($event)\\">Log</button>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  log = function log(msg = \\"hello\\") {
    console.log(msg);
  };

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Typescript Test > html 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div [innerHTML]=\\"html\\" #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  html = \\"<b>bold</b>\\";

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Typescript Test > ifElse 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <ng-container *ngIf=\\"show\\">
      <button (click)=\\"toggle($event)\\">Hide</button>
    </ng-container>
    <ng-container *ngIf=\\"!(show)\\">
      <button (click)=\\"toggle($event)\\">Show</button>
    </ng-container>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  show = true;
  toggle = function toggle() {
    this.show = !this.show;
  };

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Typescript Test > imports 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

import ButtonModule from \\"./Button.lite/angular\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      <button type=\\"button\\" [disabled]=\\"disabled\\">
        <ng-content></ng-content>
      </button>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  disabled = false;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule, ButtonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Typescript Test > lifecycleHooks 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, SimpleChanges } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root></div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngOnInit() {
    if (typeof window !== \\"undefined\\") {
      console.log(\\"onMount\\");
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      console.log(\\"onAfterUpdate\\");
    }
  }

  ngOnDestroy() {
    console.log(\\"onDestroy\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Typescript Test > reactive 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      <input [attr.value]=\\"name\\" />

      Lowercase: {{lowercaseName}}
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  name = \\"Steve\\";
  get lowercaseName() {
    return this.name.toLowerCase();
  }

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Typescript Test > reactiveWithFn 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef, SimpleChanges } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      <input
        type=\\"number\\"
        (change)=\\"a = $event.target.value\\"
        [attr.value]=\\"a\\"
      />
      <input
        type=\\"number\\"
        (change)=\\"b = $event.target.value\\"
        [attr.value]=\\"b\\"
      />

      Result: {{result}}
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  a = 2;
  b = 5;
  result = null;
  calculateResult = function calculateResult(a_, b_) {
    this.result = a_ * b_;
  };

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }

  ngOnChanges(changes: SimpleChanges) {
    if (typeof window !== \\"undefined\\") {
      this.calculateResult(this.a, this.b);
    }
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Typescript Test > slots 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      <ng-content>default</ng-content>
      <ng-content select=\\"[test]\\"><div>default</div></ng-content>
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Typescript Test > style 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <input class=\\"form-input\\" #_root />
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
      input {
        color: red;
        font-size: 12px;
      }

      .form-input:focus {
        outline: 1px solid blue;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;

exports[`Angular with Import Mapper Tests > svelte > Typescript Test > textExpressions 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, ViewChild, ElementRef } from \\"@angular/core\\";

@Component({
  selector: \\"my-component\\",
  template: \`
    <div #_root>
      normal: {{a + b}}
      <br />

      conditional {{a > 2 ? 'hello' : 'bye'}}
    </div>
  \`,
  styles: [
    \`
      :host {
        display: contents;
      }
    \`,
  ],
})
export default class MyComponent {
  @ViewChild(\\"_root\\") _root!: ElementRef;

  a = 5;
  b = 12;

  /**
   * Passes \`aria-*\`, \`data-*\` & \`class\` attributes to correct child. Used in angular and stencil.
   * @param element  the ref for the component
   * @param customElementSelector  the custom element like \`my-component\`
   */
  private enableAttributePassing(
    element: HTMLElement | null,
    customElementSelector: string
  ) {
    const parent = element?.closest(customElementSelector);
    if (element && parent) {
      const attributes = parent.attributes;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes.item(i);
        if (
          attr &&
          (attr.name.startsWith(\\"data-\\") || attr.name.startsWith(\\"aria-\\"))
        ) {
          element.setAttribute(attr.name, attr.value);
          parent.removeAttribute(attr.name);
        }
        if (attr && attr.name === \\"class\\") {
          const isWebComponent = attr.value.includes(\\"hydrated\\");
          const value = attr.value.replace(\\"hydrated\\", \\"\\").trim();
          const currentClass = element.getAttribute(\\"class\\");
          element.setAttribute(
            attr.name,
            \`\${currentClass ? \`\${currentClass} \` : \\"\\"}\${value}\`
          );
          if (isWebComponent) {
            // Stencil is using this class for lazy loading component
            parent.setAttribute(\\"class\\", \\"hydrated\\");
          } else {
            parent.removeAttribute(attr.name);
          }
        }
      }
    }
  }

  ngAfterViewInit() {
    const element: HTMLElement | null = this._root?.nativeElement;
    this.enableAttributePassing(element, \\"my-component\\");
  }
}

@NgModule({
  declarations: [MyComponent],
  imports: [CommonModule],
  exports: [MyComponent],
  bootstrap: [SomeOtherComponent],
})
export class MyComponentModule {}
"
`;
