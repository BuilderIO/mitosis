// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Html Basic 1`] = `
"<div>
  <input data-name=\\"input-1\\" />

  Hello! I can run in React, Vue, Solid, or Liquid!
</div>
<script>
  (() => {
    const state = { name: \\"Steve\\" };

    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-name='input-1']\\").forEach((el) => {
        el.value = state.name;
        if (el.props) {
          el.props.value = state.name;
          el.update();
        }

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      state.name = event.target.value;
      update();
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html BasicFor 1`] = `
"<div>
  <template data-name=\\"for\\">
    <input data-name=\\"input-1\\" />

    Hello
    <template data-name=\\"div-1\\"><!-- person --></template>
    ! I can run in Qwik, Web Component, React, Vue, Solid, or Liquid!
  </template>
</div>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };

    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-name='for']\\").forEach((el) => {
        let array = state.names;
        renderLoop(el, array, \\"person\\");
      });

      document.querySelectorAll(\\"[data-name='input-1']\\").forEach((el) => {
        el.value = state.name;
        if (el.props) {
          el.props.value = state.name;
          el.update();
        }

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      document.querySelectorAll(\\"[data-name='div-1']\\").forEach((el) => {
        const person = getContext(el, \\"person\\");
        renderTextNode(el, person);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      const person = getContext(event.currentTarget, \\"person\\");

      state.name = event.target.value + \\" and \\" + person;
      update();
    }

    // Update with initial state on first load
    update();

    // onMount
    console.log(\\"onMount code\\");

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        Array.from(elementFragment.childNodes).reversrEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          this.nodesToDestroy.push(child);
          template.after(child);
        });
      }
    }

    function getContext(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Button 1`] = `
"<template data-name=\\"show\\">
  <a data-name=\\"a-1\\">
    <template data-name=\\"div-1\\"><!-- props.text --></template>
  </a>
</template>

<template data-name=\\"show-2\\">
  <button type=\\"button\\" data-name=\\"button-1\\">
    <template data-name=\\"div-2\\"><!-- props.text --></template>
  </button>
</template>

<script>
  (() => {
    const state = {};
    let props = {};
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-name='show']\\").forEach((el) => {
        const whenCondition = props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-name='a-1']\\").forEach((el) => {
        el.href = props.link;
        if (el.props) {
          el.props.href = props.link;
          el.update();
        }

        el.target = props.openLinkInNewTab ? \\"_blank\\" : undefined;
        if (el.props) {
          el.props.target = props.openLinkInNewTab ? \\"_blank\\" : undefined;
          el.update();
        }
      });

      document.querySelectorAll(\\"[data-name='div-1']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      document.querySelectorAll(\\"[data-name='show-2']\\").forEach((el) => {
        const whenCondition = !props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-name='div-2']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Columns 1`] = `
"<div class=\\"builder-columns div\\">
  <template data-name=\\"for\\">
    <div class=\\"builder-column div-2\\">
      <template data-name=\\"div-1\\"><!-- column.content --></template>

      <template data-name=\\"div-2\\"><!-- index --></template>
    </div>
  </template>
</div>
<style>
  .div {
    display: flex;
    flex-direction: column;
    align-items: stretch;
    line-height: normal;
  }
  @media (max-width: 999px) {
    .div {
      flex-direction: row;
    }
  }
  @media (max-width: 639px) {
    .div {
      flex-direction: row-reverse;
    }
  }
  .div-2 {
    flex-grow: 1;
  }
</style>
<script>
  (() => {
    const state = {
      getColumns() {
        return props.columns || [];
      },
      getGutterSize() {
        return typeof props.space === \\"number\\" ? props.space || 0 : 20;
      },
      getWidth(index) {
        const columns = this.getColumns();
        return (columns[index] && columns[index].width) || 100 / columns.length;
      },
      getColumnCssWidth(index) {
        const columns = this.getColumns();
        const gutterSize = this.getGutterSize();
        const subtractWidth =
          (gutterSize * (columns.length - 1)) / columns.length;
        return \`calc(\${this.getWidth(index)}% - \${subtractWidth}px)\`;
      },
    };
    let props = {};
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-name='for']\\").forEach((el) => {
        let array = props.columns;
        renderLoop(el, array, \\"column\\", \\"index\\");
      });

      document.querySelectorAll(\\"[data-name='div-1']\\").forEach((el) => {
        const column = getContext(el, \\"column\\");
        renderTextNode(el, column.content);
      });

      document.querySelectorAll(\\"[data-name='div-2']\\").forEach((el) => {
        const index = getContext(el, \\"index\\");
        renderTextNode(el, index);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        Array.from(elementFragment.childNodes).reversrEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          this.nodesToDestroy.push(child);
          template.after(child);
        });
      }
    }

    function getContext(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Image 1`] = `
"<picture data-name=\\"picture-1\\">
  <template data-name=\\"show\\">
    <img class=\\"img\\" data-name=\\"img-1\\" />
  </template>

  <source data-name=\\"source-1\\" />
</picture>

<slot></slot>

<style>
  .img {
    opacity: 1;
    transition: opacity 0.2s ease-in-out;
    object-fit: cover;
    object-position: center;
  }
</style>
<script>
  (() => {
    const state = {
      scrollListener: null,
      imageLoaded: false,
      load: false,
      setLoaded() {
        state.imageLoaded = true;
        update();
      },
      isBrowser() {
        return (
          typeof window !== \\"undefined\\" &&
          window.navigator.product != \\"ReactNative\\"
        );
      },
      useLazyLoading() {
        // TODO: Add more checks here, like testing for real web browsers
        return !!props.lazy && state.isBrowser();
      },
    };
    let props = {};
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-name='show']\\").forEach((el) => {
        const whenCondition = !state.useLazyLoading() || state.load;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-name='img-1']\\").forEach((el) => {
        el.alt = props.altText;
        if (el.props) {
          el.props.alt = props.altText;
          el.update();
        }

        el.setAttribute(
          \\"aria-role\\",
          props.altText ? \\"presentation\\" : undefined
        );
        if (el.props) {
          el.props.ariaRole = props.altText ? \\"presentation\\" : undefined;
          el.update();
        }

        el.className = \\"builder-image\\" + (props.class ? \\" \\" + props.class : \\"\\");
        if (el.props) {
          el.props.class =
            \\"builder-image\\" + (props.class ? \\" \\" + props.class : \\"\\");
          el.update();
        }

        el.src = props.image;
        if (el.props) {
          el.props.src = props.image;
          el.update();
        }

        el.removeEventListener(\\"load\\", onImg1Load);
        el.addEventListener(\\"load\\", onImg1Load);

        el.srcset = props.srcset;
        if (el.props) {
          el.props.srcset = props.srcset;
          el.update();
        }

        el.sizes = props.sizes;
        if (el.props) {
          el.props.sizes = props.sizes;
          el.update();
        }
      });

      document.querySelectorAll(\\"[data-name='source-1']\\").forEach((el) => {
        el.srcset = props.srcset;
        if (el.props) {
          el.props.srcset = props.srcset;
          el.update();
        }
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'load' event on img-1
    function onImg1Load(event) {
      state.setLoaded();
    }

    // Update with initial state on first load
    update();

    // onMount
    if (state.useLazyLoading()) {
      // throttled scroll capture listener
      const listener = () => {
        if (pictureRef) {
          const rect = pictureRef.getBoundingClientRect();
          const buffer = window.innerHeight / 2;

          if (rect.top < window.innerHeight + buffer) {
            state.load = true;
            update();
            state.scrollListener = null;
            update();
            window.removeEventListener(\\"scroll\\", listener);
          }
        }
      };

      state.scrollListener = listener;
      update();
      window.addEventListener(\\"scroll\\", listener, {
        capture: true,
        passive: true,
      });
      listener();
    }

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html ImageState 1`] = `
"<div>
  <template data-name=\\"for\\">
    <img data-name=\\"img-1\\" />
  </template>
</div>
<script>
  (() => {
    const state = { canShow: true, images: [\\"http://example.com/qwik.png\\"] };

    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-name='for']\\").forEach((el) => {
        let array = state.images;
        renderLoop(el, array, \\"item\\", \\"itemIndex\\");
      });

      document.querySelectorAll(\\"[data-name='img-1']\\").forEach((el) => {
        const item = getContext(el, \\"item\\");
        const itemIndex = getContext(el, \\"itemIndex\\");

        el.className = \\"custom-class\\";
        if (el.props) {
          el.props.class = \\"custom-class\\";
          el.update();
        }

        el.src = item;
        if (el.props) {
          el.props.src = item;
          el.update();
        }

        el.key = itemIndex;
        if (el.props) {
          el.props.key = itemIndex;
          el.update();
        }
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        Array.from(elementFragment.childNodes).reversrEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          this.nodesToDestroy.push(child);
          template.after(child);
        });
      }
    }

    function getContext(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Img 1`] = `
"<img data-name=\\"img-1\\" />
<script>
  (() => {
    const state = {};
    let props = {};
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-name='img-1']\\").forEach((el) => {
        Object.assign(el.style, {
          objectFit: props.backgroundSize || \\"cover\\",
          objectPosition: props.backgroundPosition || \\"center\\",
        });

        el.key = (Builder.isEditing && props.imgSrc) || \\"default-key\\";
        if (el.props) {
          el.props.key = (Builder.isEditing && props.imgSrc) || \\"default-key\\";
          el.update();
        }

        el.alt = props.altText;
        if (el.props) {
          el.props.alt = props.altText;
          el.update();
        }

        el.src = props.imgSrc;
        if (el.props) {
          el.props.src = props.imgSrc;
          el.update();
        }
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Input block 1`] = `
"<input data-name=\\"input-1\\" />
<script>
  (() => {
    const state = {};
    let props = {};
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-name='input-1']\\").forEach((el) => {
        el.key =
          Builder.isEditing && props.defaultValue
            ? props.defaultValue
            : \\"default-key\\";
        if (el.props) {
          el.props.key =
            Builder.isEditing && props.defaultValue
              ? props.defaultValue
              : \\"default-key\\";
          el.update();
        }

        el.placeholder = props.placeholder;
        if (el.props) {
          el.props.placeholder = props.placeholder;
          el.update();
        }

        el.type = props.type;
        if (el.props) {
          el.props.type = props.type;
          el.update();
        }

        el.name = props.name;
        if (el.props) {
          el.props.name = props.name;
          el.update();
        }

        el.value = props.value;
        if (el.props) {
          el.props.value = props.value;
          el.update();
        }

        el.defaultValue = props.defaultValue;
        if (el.props) {
          el.props.defaultValue = props.defaultValue;
          el.update();
        }

        el.required = props.required;
        if (el.props) {
          el.props.required = props.required;
          el.update();
        }
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Section 1`] = `
"<section data-name=\\"section-1\\">
  <slot></slot>
</section>
<script>
  (() => {
    const state = {};
    let props = {};
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-name='section-1']\\").forEach((el) => {
        Object.assign(
          el.style,
          props.maxWidth && typeof props.maxWidth === \\"number\\"
            ? {
                maxWidth: props.maxWidth,
              }
            : undefined
        );
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html SectionState 1`] = `
"<template data-name=\\"show\\">
  <template data-name=\\"for\\">
    <section data-name=\\"section-1\\">
      <slot></slot>
    </section>
  </template>
</template>
<script>
  (() => {
    const state = { max: 42, items: [42] };
    let props = {};
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-name='show']\\").forEach((el) => {
        const whenCondition = state.max;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-name='for']\\").forEach((el) => {
        let array = state.items;
        renderLoop(el, array, \\"item\\");
      });

      document.querySelectorAll(\\"[data-name='section-1']\\").forEach((el) => {
        const item = getContext(el, \\"item\\");
        Object.assign(el.style, {
          maxWidth: item + state.max,
        });
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        Array.from(elementFragment.childNodes).reversrEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          this.nodesToDestroy.push(child);
          template.after(child);
        });
      }
    }

    function getContext(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Select block 1`] = `
"<select data-name=\\"select-1\\">
  <template data-name=\\"for\\">
    <option data-name=\\"option-1\\">
      <template data-name=\\"div-1\\">
        <!-- option.name || option.value -->
      </template>
    </option>
  </template>
</select>
<script>
  (() => {
    const state = {};
    let props = {};
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-name='select-1']\\").forEach((el) => {
        el.value = props.value;
        if (el.props) {
          el.props.value = props.value;
          el.update();
        }

        el.key =
          Builder.isEditing && props.defaultValue
            ? props.defaultValue
            : \\"default-key\\";
        if (el.props) {
          el.props.key =
            Builder.isEditing && props.defaultValue
              ? props.defaultValue
              : \\"default-key\\";
          el.update();
        }

        el.defaultValue = props.defaultValue;
        if (el.props) {
          el.props.defaultValue = props.defaultValue;
          el.update();
        }

        el.name = props.name;
        if (el.props) {
          el.props.name = props.name;
          el.update();
        }
      });

      document.querySelectorAll(\\"[data-name='for']\\").forEach((el) => {
        let array = props.options;
        renderLoop(el, array, \\"option\\", \\"index\\");
      });

      document.querySelectorAll(\\"[data-name='option-1']\\").forEach((el) => {
        const option = getContext(el, \\"option\\");
        const index = getContext(el, \\"index\\");

        el.value = option.value;
        if (el.props) {
          el.props.value = option.value;
          el.update();
        }

        el.setAttribute(\\"data-index\\", index);
        if (el.props) {
          el.props.dataIndex = index;
          el.update();
        }
      });

      document.querySelectorAll(\\"[data-name='div-1']\\").forEach((el) => {
        const option = getContext(el, \\"option\\");
        renderTextNode(el, option.name || option.value);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        Array.from(elementFragment.childNodes).reversrEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          this.nodesToDestroy.push(child);
          template.after(child);
        });
      }
    }

    function getContext(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Shadow DOM 1`] = `
"<div data-name=\\"div-1\\">
  <button data-name=\\"button-1\\">Write a review</button>

  <template data-name=\\"show\\">
    <input placeholder=\\"Email\\" />

    <input placeholder=\\"Title\\" class=\\"input\\" />

    <textarea
      placeholder=\\"How was your experience?\\"
      class=\\"textarea\\"
    ></textarea>

    <button class=\\"button\\" data-name=\\"button-2\\">Submit</button>
  </template>

  <template data-name=\\"for\\">
    <div class=\\"review\\" data-name=\\"review\\">
      <img class=\\"img\\" data-name=\\"img-1\\" />

      <div data-name=\\"div-2\\">
        <div>
          N:
          <template data-name=\\"div-3\\"><!-- index --></template>
        </div>

        <div>
          <template data-name=\\"div-4\\"><!-- review.author --></template>
        </div>

        <div>
          <template data-name=\\"div-5\\"><!-- review.reviewMessage --></template>
        </div>
      </div>
    </div>
  </template>
</div>
<style>
  .input {
    display: block;
  }
  .textarea {
    display: block;
  }
  .button {
    display: block;
  }
  .review {
    margin: 10px;
    padding: 10px;
    background: white;
    display: flex;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  }
  .img {
    height: 30px;
    width: 30px;
    margin-right: 10px;
  }
</style>
<script>
  (() => {
    const state = { reviews: [], name: \\"test\\", showReviewPrompt: false };
    let props = {};
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-name='div-1']\\").forEach((el) => {
        el.setAttribute(\\"data-user\\", state.name);
        if (el.props) {
          el.props.dataUser = state.name;
          el.update();
        }
      });

      document.querySelectorAll(\\"[data-name='button-1']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton1Click);
        el.addEventListener(\\"click\\", onButton1Click);
      });

      document.querySelectorAll(\\"[data-name='show']\\").forEach((el) => {
        const whenCondition = state.showReviewPrompt;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-name='button-2']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton2Click);
        el.addEventListener(\\"click\\", onButton2Click);
      });

      document.querySelectorAll(\\"[data-name='for']\\").forEach((el) => {
        let array = state.reviews;
        renderLoop(el, array, \\"review\\", \\"index\\");
      });

      document.querySelectorAll(\\"[data-name='review']\\").forEach((el) => {
        const review = getContext(el, \\"review\\");

        el.key = review.id;
        if (el.props) {
          el.props.key = review.id;
          el.update();
        }
      });

      document.querySelectorAll(\\"[data-name='img-1']\\").forEach((el) => {
        const review = getContext(el, \\"review\\");

        el.src = review.avatar;
        if (el.props) {
          el.props.src = review.avatar;
          el.update();
        }
      });

      document.querySelectorAll(\\"[data-name='div-2']\\").forEach((el) => {
        el.className = state.showReviewPrompt ? \\"bg-primary\\" : \\"bg-secondary\\";
        if (el.props) {
          el.props.class = state.showReviewPrompt
            ? \\"bg-primary\\"
            : \\"bg-secondary\\";
          el.update();
        }
      });

      document.querySelectorAll(\\"[data-name='div-3']\\").forEach((el) => {
        const index = getContext(el, \\"index\\");
        renderTextNode(el, index);
      });

      document.querySelectorAll(\\"[data-name='div-4']\\").forEach((el) => {
        const review = getContext(el, \\"review\\");
        renderTextNode(el, review.author);
      });

      document.querySelectorAll(\\"[data-name='div-5']\\").forEach((el) => {
        const review = getContext(el, \\"review\\");
        renderTextNode(el, review.reviewMessage);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'click' event on button-1
    function onButton1Click(event) {
      state.showReviewPrompt = true;
      update();
    }

    // Event handler for 'click' event on button-2
    function onButton2Click(event) {
      state.showReviewPrompt = false;
      update();
    }

    // Update with initial state on first load
    update();

    // onMount
    fetch(
      \`https://stamped.io/api/widget/reviews?storeUrl=builder-io.myshopify.com&apiKey=\${
        props.apiKey || \\"pubkey-8bbDq7W6w4sB3OWeM1HUy2s47702hM\\"
      }&productId=\${props.productId || \\"2410511106127\\"}\`
    )
      .then((res) => res.json())
      .then((data) => {
        state.reviews = data.data;
        update();
      });

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        Array.from(elementFragment.childNodes).reversrEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          this.nodesToDestroy.push(child);
          template.after(child);
        });
      }
    }

    function getContext(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Stamped 1`] = `
"<div data-name=\\"div-1\\">
  <button data-name=\\"button-1\\">Write a review</button>

  <template data-name=\\"show\\">
    <input placeholder=\\"Email\\" />

    <input placeholder=\\"Title\\" class=\\"input\\" />

    <textarea
      placeholder=\\"How was your experience?\\"
      class=\\"textarea\\"
    ></textarea>

    <button class=\\"button\\" data-name=\\"button-2\\">Submit</button>
  </template>

  <template data-name=\\"for\\">
    <div class=\\"review\\" data-name=\\"review\\">
      <img class=\\"img\\" data-name=\\"img-1\\" />

      <div data-name=\\"div-2\\">
        <div>
          N:
          <template data-name=\\"div-3\\"><!-- index --></template>
        </div>

        <div>
          <template data-name=\\"div-4\\"><!-- review.author --></template>
        </div>

        <div>
          <template data-name=\\"div-5\\"><!-- review.reviewMessage --></template>
        </div>
      </div>
    </div>
  </template>
</div>
<style>
  .input {
    display: block;
  }
  .textarea {
    display: block;
  }
  .button {
    display: block;
  }
  .review {
    margin: 10px;
    padding: 10px;
    background: white;
    display: flex;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  }
  .img {
    height: 30px;
    width: 30px;
    margin-right: 10px;
  }
</style>
<script>
  (() => {
    const state = {
      reviews: [],
      name: \\"test\\",
      showReviewPrompt: false,
      kebabCaseValue() {
        return kebabCase(\\"testThat\\");
      },
      snakeCaseValue() {
        return snakeCase(\\"testThis\\");
      },
    };
    let props = {};
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-name='div-1']\\").forEach((el) => {
        el.setAttribute(\\"data-user\\", state.name);
        if (el.props) {
          el.props.dataUser = state.name;
          el.update();
        }
      });

      document.querySelectorAll(\\"[data-name='button-1']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton1Click);
        el.addEventListener(\\"click\\", onButton1Click);
      });

      document.querySelectorAll(\\"[data-name='show']\\").forEach((el) => {
        const whenCondition = state.showReviewPrompt;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-name='button-2']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton2Click);
        el.addEventListener(\\"click\\", onButton2Click);
      });

      document.querySelectorAll(\\"[data-name='for']\\").forEach((el) => {
        let array = state.reviews;
        renderLoop(el, array, \\"review\\", \\"index\\");
      });

      document.querySelectorAll(\\"[data-name='review']\\").forEach((el) => {
        const review = getContext(el, \\"review\\");

        el.key = review.id;
        if (el.props) {
          el.props.key = review.id;
          el.update();
        }
      });

      document.querySelectorAll(\\"[data-name='img-1']\\").forEach((el) => {
        const review = getContext(el, \\"review\\");

        el.src = review.avatar;
        if (el.props) {
          el.props.src = review.avatar;
          el.update();
        }
      });

      document.querySelectorAll(\\"[data-name='div-2']\\").forEach((el) => {
        el.className = state.showReviewPrompt ? \\"bg-primary\\" : \\"bg-secondary\\";
        if (el.props) {
          el.props.class = state.showReviewPrompt
            ? \\"bg-primary\\"
            : \\"bg-secondary\\";
          el.update();
        }
      });

      document.querySelectorAll(\\"[data-name='div-3']\\").forEach((el) => {
        const index = getContext(el, \\"index\\");
        renderTextNode(el, index);
      });

      document.querySelectorAll(\\"[data-name='div-4']\\").forEach((el) => {
        const review = getContext(el, \\"review\\");
        renderTextNode(el, review.author);
      });

      document.querySelectorAll(\\"[data-name='div-5']\\").forEach((el) => {
        const review = getContext(el, \\"review\\");
        renderTextNode(el, review.reviewMessage);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'click' event on button-1
    function onButton1Click(event) {
      state.showReviewPrompt = true;
      update();
    }

    // Event handler for 'click' event on button-2
    function onButton2Click(event) {
      state.showReviewPrompt = false;
      update();
    }

    // Update with initial state on first load
    update();

    // onMount
    fetch(
      \`https://stamped.io/api/widget/reviews?storeUrl=builder-io.myshopify.com&apiKey=\${
        props.apiKey || \\"pubkey-8bbDq7W6w4sB3OWeM1HUy2s47702hM\\"
      }&productId=\${props.productId || \\"2410511106127\\"}\`
    )
      .then((res) => res.json())
      .then((data) => {
        state.reviews = data.data;
        update();
      });

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        Array.from(elementFragment.childNodes).reversrEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          this.nodesToDestroy.push(child);
          template.after(child);
        });
      }
    }

    function getContext(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Submit button block 1`] = `
"<button type=\\"submit\\" data-name=\\"button-1\\">
  <template data-name=\\"div-1\\"><!-- props.text --></template>
</button>
<script>
  (() => {
    const state = {};
    let props = {};
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-name='div-1']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Text 1`] = `
"<div data-name=\\"div-1\\"></div>
<script>
  (() => {
    const state = {};
    let props = {};
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-name='div-1']\\").forEach((el) => {
        el.contentEditable = allowEditingText || undefined;
        if (el.props) {
          el.props.contentEditable = allowEditingText || undefined;
          el.update();
        }

        el.innerHTML = props.text || props.content || \\"\\";
        if (el.props) {
          el.props.innerHtml = props.text || props.content || \\"\\";
          el.update();
        }
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Textarea 1`] = `
"<textarea data-name=\\"textarea-1\\"></textarea>
<script>
  (() => {
    const state = {};
    let props = {};
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-name='textarea-1']\\").forEach((el) => {
        el.placeholder = props.placeholder;
        if (el.props) {
          el.props.placeholder = props.placeholder;
          el.update();
        }

        el.name = props.name;
        if (el.props) {
          el.props.name = props.name;
          el.update();
        }

        el.value = props.value;
        if (el.props) {
          el.props.value = props.value;
          el.update();
        }

        el.defaultValue = props.defaultValue;
        if (el.props) {
          el.props.defaultValue = props.defaultValue;
          el.update();
        }
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Video 1`] = `
"<video preload=\\"none\\" data-name=\\"video-1\\"></video>
<script>
  (() => {
    const state = {};
    let props = {};
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-name='video-1']\\").forEach((el) => {
        Object.assign(el.style, {
          width: \\"100%\\",
          height: \\"100%\\",
          ...props.attributes?.style,
          objectFit: props.fit,
          objectPosition: props.position,
          // Hack to get object fit to work as expected and
          // not have the video overflow
          borderRadius: 1,
        });

        el.key = props.video || \\"no-src\\";
        if (el.props) {
          el.props.key = props.video || \\"no-src\\";
          el.update();
        }

        el.poster = props.posterImage;
        if (el.props) {
          el.props.poster = props.posterImage;
          el.update();
        }

        el.autoPlay = props.autoPlay;
        if (el.props) {
          el.props.autoPlay = props.autoPlay;
          el.update();
        }

        el.muted = props.muted;
        if (el.props) {
          el.props.muted = props.muted;
          el.update();
        }

        el.controls = props.controls;
        if (el.props) {
          el.props.controls = props.controls;
          el.update();
        }

        el.loop = props.loop;
        if (el.props) {
          el.props.loop = props.loop;
          el.update();
        }
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html multipleOnUpdate 1`] = `
"<div></div>
"
`;

exports[`Html multipleOnnUpdateWithDeps 1`] = `
"<div></div>
"
`;

exports[`Html onMount & onUnMount 1`] = `
"<div></div>
<script>
  (() => {
    const state = {};

    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // onMount
    console.log(\\"Runs on mount\\");

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html onUpdate 1`] = `
"<div></div>
"
`;

exports[`Html onUpdateWithDeps 1`] = `
"<div></div>
"
`;
