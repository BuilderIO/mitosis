// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Html > jsx > Javascript Test > AdvancedRef 1`] = `
"<div>
  <template data-el=\\"show\\">
    <input
      class=\\"input\\"
      data-el=\\"input-1\\"
      data-dom-state=\\"input-2\\"
      data-ref=\\"undefined-inputRef\\"
    />
    <label for=\\"cars\\" data-el=\\"label-1\\" data-ref=\\"undefined-inputNoArgRef\\">
      Choose a car:
    </label>
    <select name=\\"cars\\" id=\\"cars\\" data-dom-state=\\"select-1\\">
      <option value=\\"supra\\">GR Supra</option>
      <option value=\\"86\\">GR 86</option>
    </select>
  </template>

  Hello

  <template data-el=\\"div-1\\"><!-- state.lowerCaseName() --></template>
  ! I can run in React, Qwik, Vue, Solid, or Web Component!
</div>
<style>
  .input {
    color: red;
  }
</style>
<script>
  (() => {
    const state = {
      name: \\"PatrickJS\\",
      onBlur: function onBlur() {
        // Maintain focus
        inputRef.focus();
      },
      lowerCaseName: function lowerCaseName() {
        return state.name.toLowerCase();
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.showInput;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = state.name;

        el.removeEventListener(\\"blur\\", onInput1Blur);
        el.addEventListener(\\"blur\\", onInput1Blur);

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.lowerCaseName());
      });

      destroyAnyNodes();

      console.log(\\"Received an update\\");

      pendingUpdate = false;
    }

    // Event handler for 'blur' event on input-1
    function onInput1Blur(event) {
      state.onBlur();
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      state.name = event.target.value;
      update();
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > Basic 1`] = `
"<div class=\\"test div\\">
  <input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />

  Hello! I can run in React, Vue, Solid, or Liquid!
</div>
<style>
  .div {
    padding: 10px;
  }
</style>
<script>
  (() => {
    const state = {
      name: \\"Steve\\",
      underscore_fn_name() {
        return \\"bar\\";
      },
      age: 1,
      sports: [\\"\\"],
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = DEFAULT_VALUES.name || state.name;

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(myEvent) {
      state.name = myEvent.target.value;
      update();
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > Basic 2`] = `
"<div>
  <template data-el=\\"for\\">
    <template data-el=\\"show\\">
      <input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />

      Hello
      <template data-el=\\"div-1\\"><!-- person --></template>
      ! I can run in Qwik, Web Component, React, Vue, Solid, or Liquid!
    </template>
  </template>
</div>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = state.names;
        renderLoop(el, array, \\"person\\");
      });

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const person = getScope(el, \\"person\\");
        const whenCondition = person === state.name;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = state.name;

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        const person = getScope(el, \\"person\\");
        renderTextNode(el, person);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      const person = getScope(event.currentTarget, \\"person\\");

      state.name = event.target.value + \\" and \\" + person;
      update();
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > Basic Context 1`] = `
"<div>
  <template data-el=\\"div-1\\">
    <!-- myService.method('hello') + state.name -->
  </template>

  Hello! I can run in React, Vue, Solid, or Liquid!

  <input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
</div>
<script>
  (() => {
    const state = {
      name: \\"PatrickJS\\",
      onChange: function onChange() {
        const change = myService.method(\\"change\\");
        console.log(change);
      },
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;
    let onInitOnce = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, myService.method(\\"hello\\") + state.name);
      });

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      state.onChange;
    }

    // Update with initial state on first load
    update();

    if (!onInitOnce) {
      const hi = myService.method(\\"hi\\");
      console.log(hi);
      onInitOnce = true;
    }

    // onMount
    const bye = myService.method(\\"hi\\");
    console.log(bye);

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > Basic OnMount Update 1`] = `
"<div>
  Hello
  <template data-el=\\"div-1\\"><!-- state.name --></template>
</div>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;
    let onInitOnce = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    if (!onInitOnce) {
      state.name = \\"PatrickJS onInit\\" + props.hi;
      update();
      onInitOnce = true;
    }

    // onMount
    state.name = \\"PatrickJS onMount\\" + props.bye;
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > Basic Outputs 1`] = `
"<div></div>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\" };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // onMount
    props.onMessage(state.name);
    props.onEvent(props.message);
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > Basic Outputs Meta 1`] = `
"<div></div>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\" };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // onMount
    props.onMessage(state.name);
    props.onEvent(props.message);
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > BasicAttribute 1`] = `
"<input
  autocapitalize=\\"on\\"
  autocomplete=\\"on\\"
  data-el=\\"input-1\\"
  data-dom-state=\\"input-2\\"
/>
<script>
  (() => {
    const state = {};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.setAttribute(\\"spellcheck\\", true);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > BasicBooleanAttribute 1`] = `
"<div>
  <template data-el=\\"show\\">
    <slot></slot>
    <template data-el=\\"div-2\\"><!-- props.type --></template>
  </template>
  <MyBooleanAttributeComponent
    data-el=\\"my-boolean-attribute-component\\"
  ></MyBooleanAttributeComponent>
  <MyBooleanAttributeComponent
    data-el=\\"my-boolean-attribute-component-2\\"
  ></MyBooleanAttributeComponent>
  <MyBooleanAttributeComponent
    data-el=\\"my-boolean-attribute-component-3\\"
  ></MyBooleanAttributeComponent>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.children;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, props.type);
      });

      document
        .querySelectorAll(\\"[data-el='my-boolean-attribute-component']\\")
        .forEach((el) => {
          el.setAttribute(\\"toggle\\", true);
        });

      document
        .querySelectorAll(\\"[data-el='my-boolean-attribute-component-2']\\")
        .forEach((el) => {
          el.setAttribute(\\"toggle\\", true);
        });

      document
        .querySelectorAll(\\"[data-el='my-boolean-attribute-component-3']\\")
        .forEach((el) => {
          el.setAttribute(\\"list\\", null);
        });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > BasicChildComponent 1`] = `
"<div>
  <MyBasicComponent data-el=\\"my-basic-component\\"></MyBasicComponent>
  <div>
    <MyBasicOnMountUpdateComponent
      data-el=\\"my-basic-on-mount-update-component\\"
    ></MyBasicOnMountUpdateComponent>
  </div>
</div>
<script>
  (() => {
    const state = { name: \\"Steve\\", dev: \\"PatrickJS\\" };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document
        .querySelectorAll(\\"[data-el='my-basic-component']\\")
        .forEach((el) => {
          el.setAttribute(\\"id\\", state.dev);
        });

      document
        .querySelectorAll(\\"[data-el='my-basic-on-mount-update-component']\\")
        .forEach((el) => {
          el.setAttribute(\\"hi\\", state.name);

          el.setAttribute(\\"bye\\", state.dev);
        });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > BasicFor 1`] = `
"<div>
  <template data-el=\\"for\\">
    <input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />

    Hello
    <template data-el=\\"div-1\\"><!-- person --></template>
    ! I can run in Qwik, Web Component, React, Vue, Solid, or Liquid!
  </template>
</div>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = state.names;
        renderLoop(el, array, \\"person\\");
      });

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = state.name;

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        const person = getScope(el, \\"person\\");
        renderTextNode(el, person);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      const person = getScope(event.currentTarget, \\"person\\");

      state.name = event.target.value + \\" and \\" + person;
      update();
    }

    // Update with initial state on first load
    update();

    // onMount
    console.log(\\"onMount code\\");

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > BasicRef 1`] = `
"<div>
  <template data-el=\\"show\\">
    <input
      class=\\"input\\"
      data-el=\\"input-1\\"
      data-dom-state=\\"input-2\\"
      data-ref=\\"undefined-inputRef\\"
    />
    <label for=\\"cars\\" data-el=\\"label-1\\" data-ref=\\"undefined-inputNoArgRef\\">
      Choose a car:
    </label>
    <select name=\\"cars\\" id=\\"cars\\" data-dom-state=\\"select-1\\">
      <option value=\\"supra\\">GR Supra</option>
      <option value=\\"86\\">GR 86</option>
    </select>
  </template>

  Hello

  <template data-el=\\"div-1\\"><!-- state.lowerCaseName() --></template>
  ! I can run in React, Qwik, Vue, Solid, or Web Component!
</div>
<style>
  .input {
    color: red;
  }
</style>
<script>
  (() => {
    const state = {
      name: \\"PatrickJS\\",
      onBlur: function onBlur() {
        // Maintain focus
        inputRef.focus();
      },
      lowerCaseName: function lowerCaseName() {
        return state.name.toLowerCase();
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.showInput;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = state.name;

        el.removeEventListener(\\"blur\\", onInput1Blur);
        el.addEventListener(\\"blur\\", onInput1Blur);

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.lowerCaseName());
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'blur' event on input-1
    function onInput1Blur(event) {
      state.onBlur();
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      state.name = event.target.value;
      update();
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > BasicRefAssignment 1`] = `
"<div><button data-el=\\"button-1\\">Click</button></div>
<script>
  (() => {
    const state = {
      handlerClick: function handlerClick(event) {
        event.preventDefault();
        console.log(\\"current value\\", holdValueRef);
        holdValueRef = holdValueRef + \\"JS\\";
      },
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='button-1']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton1Click);
        el.addEventListener(\\"click\\", onButton1Click);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'click' event on button-1
    function onButton1Click(evt) {
      state.handlerClick(evt);
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > BasicRefPrevious 1`] = `
"<div>
  <h1>
    Now:
    <template data-el=\\"div-1\\"><!-- state.count --></template>
    , before:
    <template data-el=\\"div-2\\"><!-- prevCount --></template>
  </h1>
  <button data-el=\\"button-1\\">Increment</button>
</div>
<script>
  (() => {
    const state = { count: 0 };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.count);
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, prevCount);
      });

      document.querySelectorAll(\\"[data-el='button-1']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton1Click);
        el.addEventListener(\\"click\\", onButton1Click);
      });

      destroyAnyNodes();

      prevCount = state.count;

      pendingUpdate = false;
    }

    // Event handler for 'click' event on button-1
    function onButton1Click(event) {
      state.count += 1;
      update();
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > Button 1`] = `
"<div>
  <template data-el=\\"show\\">
    <a data-el=\\"a-1\\">
      <template data-el=\\"div-1\\"><!-- props.text --></template>
    </a>
  </template>
  <template data-el=\\"show-2\\">
    <button type=\\"button\\" data-el=\\"button-1\\">
      <template data-el=\\"div-2\\"><!-- props.text --></template>
    </button>
  </template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='a-1']\\").forEach((el) => {
        el.setAttribute(\\"href\\", props.link);

        el.setAttribute(
          \\"target\\",
          props.openLinkInNewTab ? \\"_blank\\" : undefined
        );
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      document.querySelectorAll(\\"[data-el='show-2']\\").forEach((el) => {
        const whenCondition = !props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > Columns 1`] = `
"<div class=\\"builder-columns div\\">
  <template data-el=\\"for\\">
    <div class=\\"builder-column div-2\\">
      <template data-el=\\"div-1\\"><!-- column.content --></template>
      <template data-el=\\"div-2\\"><!-- index --></template>
    </div>
  </template>
</div>
<style>
  .div {
    display: flex;
    flex-direction: column;
    align-items: stretch;
    line-height: normal;
  }
  @media (max-width: 999px) {
    .div {
      flex-direction: row;
    }
  }
  @media (max-width: 639px) {
    .div {
      flex-direction: row-reverse;
    }
  }
  .div-2 {
    flex-grow: 1;
  }
</style>
<script>
  (() => {
    const state = {
      getColumns() {
        return props.columns || [];
      },
      getGutterSize() {
        return typeof props.space === \\"number\\" ? props.space || 0 : 20;
      },
      getWidth(index) {
        const columns = state.getColumns();
        return (columns[index] && columns[index].width) || 100 / columns.length;
      },
      getColumnCssWidth(index) {
        const columns = state.getColumns();
        const gutterSize = state.getGutterSize();
        const subtractWidth =
          (gutterSize * (columns.length - 1)) / columns.length;
        return \`calc(\${state.getWidth(index)}% - \${subtractWidth}px)\`;
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = props.columns;
        renderLoop(el, array, \\"column\\", \\"index\\");
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        const column = getScope(el, \\"column\\");
        renderTextNode(el, column.content);
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        const index = getScope(el, \\"index\\");
        renderTextNode(el, index);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > ContentSlotHtml 1`] = `
"<div>
  <slot data-el=\\"slot\\"></slot>
  <div><hr /></div>
  <div><slot></slot></div>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='slot']\\").forEach((el) => {
        el.setAttribute(\\"name\\", props.slotTesting);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > ContentSlotJSX 1`] = `
"<template data-el=\\"show\\">
  <div data-el=\\"div-1\\">
    <template data-el=\\"show-2\\">
      <slot name=\\"content\\">
        <template data-el=\\"div-2\\"><!-- props.content --></template>
      </slot>
    </template>
    <div><hr /></div>
    <div><slot></slot></div>
  </div>
</template>
<script>
  (() => {
    const state = {
      name: \\"king\\",
      showContent: false,
      get cls() {
        return props.slotContent && props.children
          ? \`\${state.name}-content\`
          : \\"\\";
      },
      show() {
        props.slotContent ? 1 : \\"\\";
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.slotReference;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.setAttribute(\\"name\\", props.slotContent ? \\"name1\\" : \\"name2\\");

        el.setAttribute(\\"title\\", props.slotContent ? \\"title1\\" : \\"title2\\");

        el.removeEventListener(\\"click\\", onDiv1Click);
        el.addEventListener(\\"click\\", onDiv1Click);

        el.className = state.cls;
      });

      document.querySelectorAll(\\"[data-el='show-2']\\").forEach((el) => {
        const whenCondition = state.showContent && props.slotContent;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, props.content);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'click' event on div-1
    function onDiv1Click(event) {
      state.show();
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > CustomCode 1`] = `
"<div data-el=\\"div-1\\" data-ref=\\"undefined-elem\\"></div>
<script>
  (() => {
    const state = {
      scriptsInserted: [],
      scriptsRun: [],
      findAndRunScripts() {
        // TODO: Move this function to standalone one in '@builder.io/utils'
        if (elem && typeof window !== \\"undefined\\") {
          /** @type {HTMLScriptElement[]} */
          const scripts = elem.getElementsByTagName(\\"script\\");
          for (let i = 0; i < scripts.length; i++) {
            const script = scripts[i];
            if (script.src) {
              if (state.scriptsInserted.includes(script.src)) {
                continue;
              }
              state.scriptsInserted.push(script.src);
              const newScript = document.createElement(\\"script\\");
              newScript.async = true;
              newScript.src = script.src;
              document.head.appendChild(newScript);
            } else if (
              !script.type ||
              [
                \\"text/javascript\\",
                \\"application/javascript\\",
                \\"application/ecmascript\\",
              ].includes(script.type)
            ) {
              if (state.scriptsRun.includes(script.innerText)) {
                continue;
              }
              try {
                state.scriptsRun.push(script.innerText);
                new Function(script.innerText)();
              } catch (error) {
                console.warn(\\"\`CustomCode\`: Error running script:\\", error);
              }
            }
          }
        }
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.className =
          \\"builder-custom-code\\" + (props.replaceNodes ? \\" replace-nodes\\" : \\"\\");

        el.innerHTML = props.code;
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // onMount
    state.findAndRunScripts();
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > Embed 1`] = `
"<div data-el=\\"div-1\\" data-ref=\\"undefined-elem\\"></div>
<script>
  (() => {
    const state = {
      scriptsInserted: [],
      scriptsRun: [],
      findAndRunScripts() {
        // TODO: Move this function to standalone one in '@builder.io/utils'
        if (elem && typeof window !== \\"undefined\\") {
          /** @type {HTMLScriptElement[]} */
          const scripts = elem.getElementsByTagName(\\"script\\");
          for (let i = 0; i < scripts.length; i++) {
            const script = scripts[i];
            if (script.src) {
              if (state.scriptsInserted.includes(script.src)) {
                continue;
              }
              state.scriptsInserted.push(script.src);
              const newScript = document.createElement(\\"script\\");
              newScript.async = true;
              newScript.src = script.src;
              document.head.appendChild(newScript);
            } else if (
              !script.type ||
              [
                \\"text/javascript\\",
                \\"application/javascript\\",
                \\"application/ecmascript\\",
              ].includes(script.type)
            ) {
              if (state.scriptsRun.includes(script.innerText)) {
                continue;
              }
              try {
                state.scriptsRun.push(script.innerText);
                new Function(script.innerText)();
              } catch (error) {
                console.warn(\\"\`CustomCode\`: Error running script:\\", error);
              }
            }
          }
        }
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.className =
          \\"builder-custom-code\\" + (props.replaceNodes ? \\" replace-nodes\\" : \\"\\");

        el.innerHTML = props.code;
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // onMount
    state.findAndRunScripts();
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > Image 1`] = `
"<div>
  <picture data-el=\\"picture-1\\" data-ref=\\"undefined-pictureRef\\">
    <template data-el=\\"show\\"><img data-el=\\"img-1\\" /></template>
    <source data-el=\\"source-1\\" />
  </picture>
  <slot></slot>
</div>
<style>
  .img {
    opacity: 1;
    transition: opacity 0.2s ease-in-out;
    object-fit: cover;
    object-position: center;
  }
</style>
<script>
  (() => {
    const state = {
      scrollListener: null,
      imageLoaded: false,
      setLoaded() {
        state.imageLoaded = true;
        update();
      },
      useLazyLoading() {
        // TODO: Add more checks here, like testing for real web browsers
        return !!props.lazy && state.isBrowser();
      },
      isBrowser: function isBrowser() {
        return (
          typeof window !== \\"undefined\\" &&
          window.navigator.product != \\"ReactNative\\"
        );
      },
      load: false,
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = !state.useLazyLoading() || state.load;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='img-1']\\").forEach((el) => {
        el.setAttribute(\\"alt\\", props.altText);

        el.setAttribute(
          \\"aria-role\\",
          props.altText ? \\"presentation\\" : undefined
        );

        el.className =
          \\"builder-image\\" + (props._class ? \\" \\" + props._class : \\"\\") + \\" img\\";

        el.setAttribute(\\"src\\", props.image);

        el.removeEventListener(\\"load\\", onImg1Load);
        el.addEventListener(\\"load\\", onImg1Load);

        el.setAttribute(\\"srcset\\", props.srcset);

        el.setAttribute(\\"sizes\\", props.sizes);
      });

      document.querySelectorAll(\\"[data-el='source-1']\\").forEach((el) => {
        el.setAttribute(\\"srcset\\", props.srcset);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'load' event on img-1
    function onImg1Load(event) {
      state.setLoaded();
    }

    // Update with initial state on first load
    update();

    // onMount
    if (state.useLazyLoading()) {
      // throttled scroll capture listener
      const listener = () => {
        if (pictureRef) {
          const rect = pictureRef.getBoundingClientRect();
          const buffer = window.innerHeight / 2;
          if (rect.top < window.innerHeight + buffer) {
            state.load = true;
            update();
            state.scrollListener = null;
            update();
            window.removeEventListener(\\"scroll\\", listener);
          }
        }
      };
      state.scrollListener = listener;
      update();
      window.addEventListener(\\"scroll\\", listener, {
        capture: true,
        passive: true,
      });
      listener();
    }

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > Image State 1`] = `
"<div>
  <template data-el=\\"for\\">
    <img class=\\"custom-class\\" data-el=\\"img-1\\" />
  </template>
</div>
<script>
  (() => {
    const state = { canShow: true, images: [\\"http://example.com/qwik.png\\"] };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = state.images;
        renderLoop(el, array, \\"item\\", \\"itemIndex\\");
      });

      document.querySelectorAll(\\"[data-el='img-1']\\").forEach((el) => {
        const item = getScope(el, \\"item\\");
        const itemIndex = getScope(el, \\"itemIndex\\");

        el.setAttribute(\\"src\\", item);

        el.key = itemIndex;
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > Img 1`] = `
"<img data-el=\\"img-1\\" />
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='img-1']\\").forEach((el) => {
        Object.assign(el.style, {
          objectFit: props.backgroundSize || \\"cover\\",
          objectPosition: props.backgroundPosition || \\"center\\",
        });

        el.key = (Builder.isEditing && props.imgSrc) || \\"default-key\\";

        el.setAttribute(\\"alt\\", props.altText);

        el.setAttribute(\\"src\\", props.imgSrc);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > Input 1`] = `
"<input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.key =
          Builder.isEditing && props.defaultValue
            ? props.defaultValue
            : \\"default-key\\";

        el.setAttribute(\\"placeholder\\", props.placeholder);

        el.setAttribute(\\"type\\", props.type);

        el.setAttribute(\\"name\\", props.name);

        el.value = props.value;

        el.setAttribute(\\"defaultValue\\", props.defaultValue);

        el.setAttribute(\\"required\\", props.required);

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      props.onChange?.(event.target.value);
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > InputParent 1`] = `
"<FormInputComponent
  name=\\"kingzez\\"
  type=\\"text\\"
  data-el=\\"form-input-component\\"
></FormInputComponent>
<script>
  (() => {
    const state = {
      handleChange(value) {
        console.log(value);
      },
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document
        .querySelectorAll(\\"[data-el='form-input-component']\\")
        .forEach((el) => {
          el.removeEventListener(\\"change\\", onFormInputComponentChange);
          el.addEventListener(\\"change\\", onFormInputComponentChange);
        });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'change' event on form-input-component
    function onFormInputComponentChange(value) {
      state.handleChange(value);
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > RawText 1`] = `
"<span data-el=\\"span-1\\"></span>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='span-1']\\").forEach((el) => {
        el.className = props.attributes?.class || props.attributes?.className;

        el.innerHTML = props.text || \\"\\";
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > Section 1`] = `
"<section data-el=\\"section-1\\"><slot></slot></section>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='section-1']\\").forEach((el) => {
        Object.assign(
          el.style,
          props.maxWidth && typeof props.maxWidth === \\"number\\"
            ? {
                maxWidth: props.maxWidth,
              }
            : undefined
        );
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > Section 2`] = `
"<template data-el=\\"show\\">
  <template data-el=\\"for\\">
    <section data-el=\\"section-1\\"><slot></slot></section>
  </template>
</template>
<script>
  (() => {
    const state = { max: 42, items: [42] };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = state.max;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = state.items;
        renderLoop(el, array, \\"item\\");
      });

      document.querySelectorAll(\\"[data-el='section-1']\\").forEach((el) => {
        const item = getScope(el, \\"item\\");
        Object.assign(el.style, {
          maxWidth: item + state.max,
        });
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > Select 1`] = `
"<select data-el=\\"select-1\\" data-dom-state=\\"select-2\\">
  <template data-el=\\"for\\">
    <option data-el=\\"option-1\\">
      <template data-el=\\"div-1\\"><!-- option.name || option.value --></template>
    </option>
  </template>
</select>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='select-1']\\").forEach((el) => {
        el.value = props.value;

        el.key =
          Builder.isEditing && props.defaultValue
            ? props.defaultValue
            : \\"default-key\\";

        el.setAttribute(\\"defaultValue\\", props.defaultValue);

        el.setAttribute(\\"name\\", props.name);
      });

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = props.options;
        renderLoop(el, array, \\"option\\", \\"index\\");
      });

      document.querySelectorAll(\\"[data-el='option-1']\\").forEach((el) => {
        const option = getScope(el, \\"option\\");
        const index = getScope(el, \\"index\\");

        el.value = option.value;

        el.setAttribute(\\"data-index\\", index);
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        const option = getScope(el, \\"option\\");
        renderTextNode(el, option.name || option.value);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > SlotDefault 1`] = `
"<div>
  <slot><div class=\\"default-slot\\">Default content</div></slot>
</div>
"
`;

exports[`Html > jsx > Javascript Test > SlotHtml 1`] = `
"<div>
  <ContentSlotCode><slot data-el=\\"slot\\"></slot></ContentSlotCode>
</div>
<script>
  (() => {
    const state = {};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='slot']\\").forEach((el) => {
        el.setAttribute(\\"testing\\", <div>Hello</div>);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > SlotJsx 1`] = `
"<div><ContentSlotCode data-el=\\"content-slot-code\\"></ContentSlotCode></div>
<script>
  (() => {
    const state = {};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document
        .querySelectorAll(\\"[data-el='content-slot-code']\\")
        .forEach((el) => {
          el.setAttribute(\\"slotTesting\\", <div>Hello</div>);
        });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > SlotNamed 1`] = `
"<div>
  <slot name=\\"myAwesomeSlot\\"></slot>
  <slot name=\\"top\\"></slot>
  <slot name=\\"left\\">Default left</slot>
  <slot>Default Child</slot>
</div>
"
`;

exports[`Html > jsx > Javascript Test > Stamped.io 1`] = `
"<div data-el=\\"div-1\\">
  <button data-el=\\"button-1\\">Write a review</button>
  <template data-el=\\"show\\">
    <input placeholder=\\"Email\\" data-dom-state=\\"input-1\\" />
    <input placeholder=\\"Title\\" class=\\"input\\" data-dom-state=\\"input-2\\" />
    <textarea
      placeholder=\\"How was your experience?\\"
      class=\\"textarea\\"
      data-dom-state=\\"textarea-1\\"
    ></textarea>
    <button class=\\"button\\" data-el=\\"button-2\\">Submit</button>
  </template>

  <template data-el=\\"for\\">
    <div class=\\"review\\" data-el=\\"review\\">
      <img class=\\"img\\" data-el=\\"img-1\\" />
      <div data-el=\\"div-2\\">
        <div>
          N:
          <template data-el=\\"div-3\\"><!-- index --></template>
        </div>
        <div>
          <template data-el=\\"div-4\\"><!-- review.author --></template>
        </div>
        <div>
          <template data-el=\\"div-5\\"><!-- review.reviewMessage --></template>
        </div>
      </div>
    </div>
  </template>
</div>
<style>
  .input {
    display: block;
  }
  .textarea {
    display: block;
  }
  .button {
    display: block;
  }
  .review {
    margin: 10px;
    padding: 10px;
    background: white;
    display: flex;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    -webkit-font-smoothing: antialiased;
  }
  .img {
    height: 30px;
    width: 30px;
    margin-right: 10px;
  }
</style>
<script>
  (() => {
    const state = {
      reviews: [],
      name: \\"test\\",
      showReviewPrompt: false,
      kebabCaseValue() {
        return kebabCase(\\"testThat\\");
      },
      snakeCaseValue() {
        return snakeCase(\\"testThis\\");
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.setAttribute(\\"data-user\\", state.name);
      });

      document.querySelectorAll(\\"[data-el='button-1']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton1Click);
        el.addEventListener(\\"click\\", onButton1Click);
      });

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = state.showReviewPrompt || \\"asdf\\";
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='button-2']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton2Click);
        el.addEventListener(\\"click\\", onButton2Click);
      });

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = state.reviews;
        renderLoop(el, array, \\"review\\", \\"index\\");
      });

      document.querySelectorAll(\\"[data-el='review']\\").forEach((el) => {
        const review = getScope(el, \\"review\\");

        el.key = review.id;
      });

      document.querySelectorAll(\\"[data-el='img-1']\\").forEach((el) => {
        const review = getScope(el, \\"review\\");

        el.setAttribute(\\"src\\", review.avatar);
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        el.className = state.showReviewPrompt ? \\"bg-primary\\" : \\"bg-secondary\\";
      });

      document.querySelectorAll(\\"[data-el='div-3']\\").forEach((el) => {
        const index = getScope(el, \\"index\\");
        renderTextNode(el, index);
      });

      document.querySelectorAll(\\"[data-el='div-4']\\").forEach((el) => {
        const review = getScope(el, \\"review\\");
        renderTextNode(el, review.author);
      });

      document.querySelectorAll(\\"[data-el='div-5']\\").forEach((el) => {
        const review = getScope(el, \\"review\\");
        renderTextNode(el, review.reviewMessage);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'click' event on button-1
    function onButton1Click(event) {
      state.showReviewPrompt = true;
      update();
    }

    // Event handler for 'click' event on button-2
    function onButton2Click(event) {
      event.preventDefault();
      state.showReviewPrompt = false;
      update();
    }

    // Update with initial state on first load
    update();

    // onMount
    fetch(
      \`https://stamped.io/api/widget/reviews?storeUrl=builder-io.myshopify.com&apiKey=\${
        props.apiKey || \\"pubkey-8bbDq7W6w4sB3OWeM1HUy2s47702hM\\"
      }&productId=\${props.productId || \\"2410511106127\\"}\`
    )
      .then((res) => res.json())
      .then((data) => {
        state.reviews = data.data;
        update();
      });

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > Submit 1`] = `
"<button type=\\"submit\\" data-el=\\"button-1\\">
  <template data-el=\\"div-1\\"><!-- props.text --></template>
</button>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > Text 1`] = `
"<div data-el=\\"div-1\\"></div>
<script>
  (() => {
    const state = { name: \\"Decadef20\\" };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.setAttribute(\\"contentEditable\\", allowEditingText || undefined);

        el.setAttribute(\\"data-name\\", {
          test: state.name || \\"any name\\",
        });

        el.innerHTML =
          props.text ||
          props.content ||
          state.name ||
          '<p class=\\"text-lg\\">my name</p>';
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > Textarea 1`] = `
"<textarea data-el=\\"textarea-1\\" data-dom-state=\\"textarea-2\\"></textarea>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='textarea-1']\\").forEach((el) => {
        el.setAttribute(\\"placeholder\\", props.placeholder);

        el.setAttribute(\\"name\\", props.name);

        el.value = props.value;

        el.setAttribute(\\"defaultValue\\", props.defaultValue);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > Video 1`] = `
"<video preload=\\"none\\" data-el=\\"video-1\\"></video>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='video-1']\\").forEach((el) => {
        Object.assign(el.style, {
          width: \\"100%\\",
          height: \\"100%\\",
          ...props.attributes?.style,
          objectFit: props.fit,
          objectPosition: props.position,
          // Hack to get object fit to work as expected and
          // not have the video overflow
          borderRadius: 1,
        });

        el.key = props.video || \\"no-src\\";

        el.setAttribute(\\"poster\\", props.posterImage);

        el.setAttribute(\\"autoplay\\", props.autoPlay);

        el.setAttribute(\\"muted\\", props.muted);

        el.setAttribute(\\"controls\\", props.controls);

        el.setAttribute(\\"loop\\", props.loop);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > arrowFunctionInUseStore 1`] = `
"<div>
  Hello
  <template data-el=\\"div-1\\"><!-- state.name --></template>
</div>
<script>
  (() => {
    const state = {
      name: \\"steve\\",
      setName(value) {
        state.name = value;
        update();
      },
      updateNameWithArrowFn(value) {
        state.name = value;
        update();
      },
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > basicForNoTagReference 1`] = `
"<state.TagNameGetter>
  Hello
  <state.tag>
    <template data-el=\\"div-1\\"><!-- state.name --></template>
  </state.tag>

  <template data-el=\\"for\\">
    <state.TagName>
      <action.icon></action.icon>
      <span>
        <template data-el=\\"div-2\\"><!-- action.text --></template>
      </span>
    </state.TagName>
  </template>
</state.TagNameGetter>
<script>
  (() => {
    const state = {
      name: \\"VincentW\\",
      TagName: \\"div\\",
      tag: \\"span\\",
      get TagNameGetter() {
        return \\"span\\";
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.name);
      });

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = props.actions;
        renderLoop(el, array, \\"action\\");
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        const action = getScope(el, \\"action\\");
        renderTextNode(el, action.text);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > basicForwardRef 1`] = `
"<div>
  <input
    class=\\"input\\"
    data-el=\\"input-1\\"
    data-dom-state=\\"input-2\\"
    data-ref=\\"undefined-props.inputRef\\"
  />
</div>
<style>
  .input {
    color: red;
  }
</style>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\" };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = state.name;

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      state.name = event.target.value;
      update();
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > basicForwardRefMetadata 1`] = `
"<div>
  <input
    class=\\"input\\"
    data-el=\\"input-1\\"
    data-dom-state=\\"input-2\\"
    data-ref=\\"undefined-props.inputRef\\"
  />
</div>
<style>
  .input {
    color: red;
  }
</style>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\" };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = state.name;

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      state.name = event.target.value;
      update();
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > basicOnUpdateReturn 1`] = `
"<div>
  Hello!
  <template data-el=\\"div-1\\"><!-- state.name --></template>
</div>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\" };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.name);
      });

      destroyAnyNodes();

      const controller = new AbortController();
      const signal = controller.signal;
      fetch(\\"https://patrickjs.com/api/resource.json\\", {
        signal,
      })
        .then((response) => response.json())
        .then((data) => {
          state.name = data.name;
          update();
        });
      return () => {
        if (!signal.aborted) {
          controller.abort();
        }
      };

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > class + ClassName + css 1`] = `
"<div class=\\"test2 test div\\">
  Hello! I can run in React, Vue, Solid, or Liquid!
</div>
<style>
  .div {
    padding: 10px;
  }
</style>
"
`;

exports[`Html > jsx > Javascript Test > class + css 1`] = `
"<div class=\\"test div\\">Hello! I can run in React, Vue, Solid, or Liquid!</div>
<style>
  .div {
    padding: 10px;
  }
</style>
"
`;

exports[`Html > jsx > Javascript Test > className + css 1`] = `
"<div class=\\"test div\\">Hello! I can run in React, Vue, Solid, or Liquid!</div>
<style>
  .div {
    padding: 10px;
  }
</style>
"
`;

exports[`Html > jsx > Javascript Test > className 1`] = `
"<div>
  <div class=\\"no binding\\">Without Binding</div>
  <div data-el=\\"div-1\\">With binding</div>
</div>
<script>
  (() => {
    const state = { bindings: \\"a binding\\" };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.className = state.bindings;
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > classState 1`] = `
"<div data-el=\\"div-1\\">Hello! I can run in React, Vue, Solid, or Liquid!</div>
<style>
  .div {
    padding: 10px;
  }
</style>
<script>
  (() => {
    const state = {
      classState: \\"testClassName\\",
      styleState: {
        color: \\"red\\",
      },
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.className = state.classState + \\" div\\";

        Object.assign(el.style, state.styleState);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > componentWithContext 1`] = `
"<template data-el=\\"div-1\\"><!-- foo.value --></template>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, foo.value);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > componentWithContextMultiRoot 1`] = `
"<template data-el=\\"div-1\\"><!-- foo.value --></template>
<div>other</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, foo.value);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > contentState 1`] = `
"<div>setting context</div>
"
`;

exports[`Html > jsx > Javascript Test > defaultProps 1`] = `
"<div>
  <template data-el=\\"show\\">
    <a data-el=\\"a-1\\">
      <template data-el=\\"div-1\\"><!-- props.text --></template>
    </a>
  </template>
  <template data-el=\\"show-2\\">
    <button type=\\"button\\" data-el=\\"button-1\\">
      <template data-el=\\"div-2\\"><!-- props.buttonText --></template>
    </button>
  </template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='a-1']\\").forEach((el) => {
        el.setAttribute(\\"href\\", props.link);

        el.setAttribute(
          \\"target\\",
          props.openLinkInNewTab ? \\"_blank\\" : undefined
        );
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      document.querySelectorAll(\\"[data-el='show-2']\\").forEach((el) => {
        const whenCondition = !props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='button-1']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton1Click);
        el.addEventListener(\\"click\\", onButton1Click);
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, props.buttonText);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'click' event on button-1
    function onButton1Click(event) {
      props.onClick(event);
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > defaultPropsOutsideComponent 1`] = `
"<div>
  <template data-el=\\"show\\">
    <a data-el=\\"a-1\\">
      <template data-el=\\"div-1\\"><!-- props.text --></template>
    </a>
  </template>
  <template data-el=\\"show-2\\">
    <button type=\\"button\\" data-el=\\"button-1\\">
      <template data-el=\\"div-2\\"><!-- props.text --></template>
    </button>
  </template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='a-1']\\").forEach((el) => {
        el.setAttribute(\\"href\\", props.link);

        el.setAttribute(
          \\"target\\",
          props.openLinkInNewTab ? \\"_blank\\" : undefined
        );
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      document.querySelectorAll(\\"[data-el='show-2']\\").forEach((el) => {
        const whenCondition = !props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='button-1']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton1Click);
        el.addEventListener(\\"click\\", onButton1Click);
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'click' event on button-1
    function onButton1Click(event) {
      props.onClick(event);
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > defaultValsWithTypes 1`] = `
"<div>
  Hello
  <template data-el=\\"div-1\\">
    <!-- props.name || DEFAULT_VALUES.name -->
  </template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.name || DEFAULT_VALUES.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > expressionState 1`] = `
"<div>
  <template data-el=\\"div-1\\"><!-- state.refToUse --></template>
</div>
<script>
  (() => {
    const state = {
      refToUse: !(props.componentRef instanceof Function)
        ? props.componentRef
        : null,
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.refToUse);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > getterState 1`] = `
"<div>
  <p>
    <template data-el=\\"div-1\\"><!-- state.foo2 --></template>
  </p>
  <p>
    <template data-el=\\"div-2\\"><!-- state.bar --></template>
  </p>
  <p>
    <template data-el=\\"div-3\\"><!-- state.baz(1) --></template>
  </p>
</div>
<script>
  (() => {
    const state = {
      get foo2() {
        return props.foo + \\"foo\\";
      },
      get bar() {
        return \\"bar\\";
      },
      baz(i) {
        return i + state.foo2.length;
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.foo2);
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, state.bar);
      });

      document.querySelectorAll(\\"[data-el='div-3']\\").forEach((el) => {
        renderTextNode(el, state.baz(1));
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > import types 1`] = `
"<RenderBlock data-el=\\"render-block\\"></RenderBlock>
"
`;

exports[`Html > jsx > Javascript Test > multipleOnUpdate 1`] = `
"<div></div>
"
`;

exports[`Html > jsx > Javascript Test > multipleOnUpdateWithDeps 1`] = `
"<div></div>
"
`;

exports[`Html > jsx > Javascript Test > multipleSpreads 1`] = `
"<input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
"
`;

exports[`Html > jsx > Javascript Test > nestedShow 1`] = `
"<template data-el=\\"show\\">
  <template data-el=\\"show-2\\">
    <div>if condition A and condition B</div>
  </template>
</template>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-2']\\").forEach((el) => {
        const whenCondition = !props.conditionB;
        if (whenCondition) {
          showContent(el);
        }
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > nestedStyles 1`] = `
"<div class=\\"div\\">Hello world</div>
<style>
  .div {
    display: flex;
    --bar: red;
    color: var(--bar);
  }
  @media (max-width: env(--mobile)) {
    .div {
      display: block;
    }
  }
  .div:hover {
    display: flex;
  }
  .div:active {
    display: inline;
  }
  .div .nested-selector {
    display: grid;
  }
  .div .nested-selector:hover {
    display: block;
  }
  .div.nested-selector:active {
    display: inline-block;
  }
</style>
"
`;

exports[`Html > jsx > Javascript Test > onEvent 1`] = `
"<div class=\\"builder-embed\\" data-el=\\"div-1\\" data-ref=\\"undefined-elem\\">
  <div>Test</div>
</div>
<script>
  (() => {
    const state = {
      foo(event) {
        console.log(\\"test2\\");
      },
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // onMount
    elem.dispatchEvent(new CustomEvent(\\"initEditingBldr\\"));
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > onInit & onMount 1`] = `
"<div></div>
<script>
  (() => {
    const state = {};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;
    let onInitOnce = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    if (!onInitOnce) {
      console.log(\\"onInit\\");
      onInitOnce = true;
    }

    // onMount
    console.log(\\"onMount\\");
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > onInit 1`] = `
"<div>
  Default name defined by parent
  <template data-el=\\"div-1\\"><!-- state.name --></template>
</div>
<script>
  (() => {
    const state = { name: \\"\\" };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;
    let onInitOnce = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    if (!onInitOnce) {
      state.name = defaultValues.name || props.name;
      update();
      console.log(\\"set defaults with props\\");
      onInitOnce = true;
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > onMount 1`] = `
"<div></div>
<script>
  (() => {
    const state = {};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // onMount
    console.log(\\"Runs on mount\\");
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > onMountMultiple 1`] = `
"<div></div>
<script>
  (() => {
    const state = {};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // onMount
    const onMountHook_0 = () => {
      console.log(\\"Runs on mount\\");
    };
    onMountHook_0();
    const onMountHook_1 = () => {
      console.log(\\"Another one runs on Mount\\");
    };
    onMountHook_1();
    const onMountHook_2 = () => {
      console.log(\\"SSR runs on Mount\\");
    };
    onMountHook_2();
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > onUpdate 1`] = `
"<div></div>
"
`;

exports[`Html > jsx > Javascript Test > onUpdateWithDeps 1`] = `
"<div></div>
"
`;

exports[`Html > jsx > Javascript Test > preserveExportOrLocalStatement 1`] = `
"<div></div>
"
`;

exports[`Html > jsx > Javascript Test > preserveTyping 1`] = `
"<div>
  Hello! I can run in React, Vue, Solid, or Liquid!
  <template data-el=\\"div-1\\"><!-- props.name --></template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > propsDestructure 1`] = `
"<div>
  <slot></slot>
  <template data-el=\\"div-2\\"><!-- props.type --></template>

  Hello! I can run in React, Vue, Solid, or Liquid!
</div>
<script>
  (() => {
    const state = { name: \\"Decadef20\\" };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, props.type);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > propsInterface 1`] = `
"<div>
  Hello! I can run in React, Vue, Solid, or Liquid!
  <template data-el=\\"div-1\\"><!-- props.name --></template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > propsType 1`] = `
"<div>
  Hello! I can run in React, Vue, Solid, or Liquid!
  <template data-el=\\"div-1\\"><!-- props.name --></template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > referencingFunInsideHook 1`] = `
"<div></div>
"
`;

exports[`Html > jsx > Javascript Test > renderBlock 1`] = `
"<template data-el=\\"show\\">
  <template data-el=\\"show-2\\">
    <state.tag data-el=\\"state-tag\\"></state.tag>
  </template>
  <template data-el=\\"show-3\\">
    <template data-el=\\"for\\">
      <RenderRepeatedBlock
        data-el=\\"render-repeated-block\\"
      ></RenderRepeatedBlock>
    </template>
  </template>
  <template data-el=\\"show-4\\">
    <state.tag data-el=\\"state-tag-2\\">
      <state.renderComponentTag
        data-el=\\"state-render-component-tag\\"
      ></state.renderComponentTag>

      <template data-el=\\"for-2\\">
        <RenderBlock data-el=\\"render-block\\"></RenderBlock>
      </template>

      <template data-el=\\"for-3\\">
        <BlockStyles data-el=\\"block-styles\\"></BlockStyles>
      </template>
    </state.tag>
  </template>
</template>
<script>
  (() => {
    const state = {
      get component() {
        const componentName = getProcessedBlock({
          block: props.block,
          state: props.context.state,
          context: props.context.context,
          shouldEvaluateBindings: false,
        }).component?.name;
        if (!componentName) {
          return null;
        }
        const ref = props.context.registeredComponents[componentName];
        if (!ref) {
          // TODO: Public doc page with more info about this message
          console.warn(\`
          Could not find a registered component named \\"\${componentName}\\". 
          If you registered it, is the file that registered it imported by the file that needs to render it?\`);
          return undefined;
        } else {
          return ref;
        }
      },
      get tag() {
        return getBlockTag(state.useBlock);
      },
      get useBlock() {
        return state.repeatItemData
          ? props.block
          : getProcessedBlock({
              block: props.block,
              state: props.context.state,
              context: props.context.context,
              shouldEvaluateBindings: true,
            });
      },
      get actions() {
        return getBlockActions({
          block: state.useBlock,
          state: props.context.state,
          context: props.context.context,
        });
      },
      get attributes() {
        const blockProperties = getBlockProperties(state.useBlock);
        return {
          ...blockProperties,
          ...(TARGET === \\"reactNative\\"
            ? {
                style: getReactNativeBlockStyles({
                  block: state.useBlock,
                  context: props.context,
                  blockStyles: blockProperties.style,
                }),
              }
            : {}),
        };
      },
      get shouldWrap() {
        return !state.component?.noWrap;
      },
      get renderComponentProps() {
        return {
          blockChildren: state.useChildren,
          componentRef: state.component?.component,
          componentOptions: {
            ...getBlockComponentOptions(state.useBlock),
            /**
             * These attributes are passed to the wrapper element when there is one. If \`noWrap\` is set to true, then
             * they are provided to the component itself directly.
             */
            ...(state.shouldWrap
              ? {}
              : {
                  attributes: {
                    ...state.attributes,
                    ...state.actions,
                  },
                }),
            customBreakpoints:
              state.childrenContext?.content?.meta?.breakpoints,
          },
          context: state.childrenContext,
        };
      },
      get useChildren() {
        // TO-DO: When should \`canHaveChildren\` dictate rendering?
        // This is currently commented out because some Builder components (e.g. Box) do not have \`canHaveChildren: true\`,
        // but still receive and need to render children.
        // return state.componentInfo?.canHaveChildren ? state.useBlock.children : [];
        return state.useBlock.children ?? [];
      },
      get childrenWithoutParentComponent() {
        /**
         * When there is no \`componentRef\`, there might still be children that need to be rendered. In this case,
         * we render them outside of \`componentRef\`.
         * NOTE: We make sure not to render this if \`repeatItemData\` is non-null, because that means we are rendering an array of
         * blocks, and the children will be repeated within those blocks.
         */
        const shouldRenderChildrenOutsideRef =
          !state.component?.component && !state.repeatItemData;
        return shouldRenderChildrenOutsideRef ? state.useChildren : [];
      },
      get repeatItemData() {
        /**
         * we don't use \`state.useBlock\` here because the processing done within its logic includes evaluating the block's bindings,
         * which will not work if there is a repeat.
         */
        const { repeat, ...blockWithoutRepeat } = props.block;
        if (!repeat?.collection) {
          return undefined;
        }
        const itemsArray = evaluate({
          code: repeat.collection,
          state: props.context.state,
          context: props.context.context,
        });
        if (!Array.isArray(itemsArray)) {
          return undefined;
        }
        const collectionName = repeat.collection.split(\\".\\").pop();
        const itemNameToUse =
          repeat.itemName ||
          (collectionName ? collectionName + \\"Item\\" : \\"item\\");
        const repeatArray = itemsArray.map((item, index) => ({
          context: {
            ...props.context,
            state: {
              ...props.context.state,
              $index: index,
              $item: item,
              [itemNameToUse]: item,
              [\`$\${itemNameToUse}Index\`]: index,
            },
          },
          block: blockWithoutRepeat,
        }));
        return repeatArray;
      },
      get inheritedTextStyles() {
        if (TARGET !== \\"reactNative\\") {
          return {};
        }
        const styles = getReactNativeBlockStyles({
          block: state.useBlock,
          context: props.context,
          blockStyles: state.attributes.style,
        });
        return extractTextStyles(styles);
      },
      get childrenContext() {
        return {
          apiKey: props.context.apiKey,
          state: props.context.state,
          content: props.context.content,
          context: props.context.context,
          registeredComponents: props.context.registeredComponents,
          inheritedStyles: state.inheritedTextStyles,
        };
      },
      get renderComponentTag() {
        if (TARGET === \\"reactNative\\") {
          return RenderComponentWithContext;
        } else if (TARGET === \\"vue3\\") {
          // vue3 expects a string for the component tag
          return \\"RenderComponent\\";
        } else {
          return RenderComponent;
        }
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = state.shouldWrap;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-2']\\").forEach((el) => {
        const whenCondition = isEmptyHtmlElement(state.tag);
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-3']\\").forEach((el) => {
        const whenCondition =
          !isEmptyHtmlElement(state.tag) && state.repeatItemData;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = state.repeatItemData;
        renderLoop(el, array, \\"data\\", \\"index\\");
      });

      document
        .querySelectorAll(\\"[data-el='render-repeated-block']\\")
        .forEach((el) => {
          const index = getScope(el, \\"index\\");
          const data = getScope(el, \\"data\\");

          el.key = index;

          el.setAttribute(\\"repeatContext\\", data.context);

          el.setAttribute(\\"block\\", data.block);
        });

      document.querySelectorAll(\\"[data-el='show-4']\\").forEach((el) => {
        const whenCondition =
          !isEmptyHtmlElement(state.tag) && !state.repeatItemData;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='for-2']\\").forEach((el) => {
        let array = state.childrenWithoutParentComponent;
        renderLoop(el, array, \\"child\\");
      });

      document.querySelectorAll(\\"[data-el='render-block']\\").forEach((el) => {
        const child = getScope(el, \\"child\\");

        el.key = \\"render-block-\\" + child.id;

        el.setAttribute(\\"block\\", child);

        el.setAttribute(\\"context\\", state.childrenContext);
      });

      document.querySelectorAll(\\"[data-el='for-3']\\").forEach((el) => {
        let array = state.childrenWithoutParentComponent;
        renderLoop(el, array, \\"child\\");
      });

      document.querySelectorAll(\\"[data-el='block-styles']\\").forEach((el) => {
        const child = getScope(el, \\"child\\");

        el.key = \\"block-style-\\" + child.id;

        el.setAttribute(\\"block\\", child);

        el.setAttribute(\\"context\\", state.childrenContext);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > renderContentExample 1`] = `
"<div class=\\"div\\" data-el=\\"div-1\\">
  <RenderBlocks data-el=\\"render-blocks\\"></RenderBlocks>
</div>
<style>
  .div {
    display: flex;
    flex-direction: columns;
  }
</style>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onDiv1Click);
        el.addEventListener(\\"click\\", onDiv1Click);
      });

      document.querySelectorAll(\\"[data-el='render-blocks']\\").forEach((el) => {
        el.setAttribute(\\"blocks\\", props.content.blocks);
      });

      destroyAnyNodes();

      dispatchNewContentToVisualEditor(props.content);

      pendingUpdate = false;
    }

    // Event handler for 'click' event on div-1
    function onDiv1Click(event) {
      trackClick(props.content.id);
    }

    // Update with initial state on first load
    update();

    // onMount
    sendComponentsToVisualEditor(props.customComponents);
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > rootFragmentMultiNode 1`] = `
"<template data-el=\\"show\\">
  <a data-el=\\"a-1\\">
    <template data-el=\\"div-1\\"><!-- props.text --></template>
  </a>
</template>
<template data-el=\\"show-2\\">
  <button type=\\"button\\" data-el=\\"button-1\\">
    <template data-el=\\"div-2\\"><!-- props.text --></template>
  </button>
</template>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='a-1']\\").forEach((el) => {
        el.setAttribute(\\"href\\", props.link);

        el.setAttribute(
          \\"target\\",
          props.openLinkInNewTab ? \\"_blank\\" : undefined
        );
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      document.querySelectorAll(\\"[data-el='show-2']\\").forEach((el) => {
        const whenCondition = !props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > rootShow 1`] = `
"<template data-el=\\"show\\"><div>Bar</div></template>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.foo === \\"bar\\";
        if (whenCondition) {
          showContent(el);
        }
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > self-referencing component 1`] = `
"<div>
  <template data-el=\\"div-1\\"><!-- props.name --></template>
  <template data-el=\\"show\\">
    <MyComponent name=\\"Bruce Wayne\\"></MyComponent>
  </template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.name);
      });

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.name === \\"Batman\\";
        if (whenCondition) {
          showContent(el);
        }
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > self-referencing component with children 1`] = `
"<div>
  <template data-el=\\"div-1\\"><!-- props.name --></template>
  <slot></slot>
  <template data-el=\\"show\\">
    <MyComponent name=\\"Bruce\\"><div>Wayne</div></MyComponent>
  </template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.name);
      });

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.name === \\"Batman\\";
        if (whenCondition) {
          showContent(el);
        }
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > showExpressions 1`] = `
"<div>
  <template data-el=\\"show\\">Content0</template>
  <template data-el=\\"show-2\\">ContentA</template>
  <template data-el=\\"show-3\\"></template>
  <template data-el=\\"show-4\\">ContentB</template>
  <template data-el=\\"show-5\\">
    <template data-el=\\"div-1\\"><!-- undefined --></template>
  </template>
  <template data-el=\\"show-6\\">ContentC</template>
  <template data-el=\\"show-7\\"></template>
  <template data-el=\\"show-8\\">ContentD</template>
  <template data-el=\\"show-9\\"></template>
  <template data-el=\\"show-10\\">ContentE</template>
  <template data-el=\\"show-11\\">hello</template>
  <template data-el=\\"show-12\\">ContentF</template>
  <template data-el=\\"show-13\\">123</template>
  <template data-el=\\"show-14\\">4mb</template>
  <template data-el=\\"show-15\\">
    <template data-el=\\"show-16\\">20mb</template>
  </template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-2']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-3']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-4']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-5']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, undefined);
      });

      document.querySelectorAll(\\"[data-el='show-6']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-7']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-8']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-9']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-10']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-11']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-12']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-13']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-14']\\").forEach((el) => {
        const whenCondition = props.conditionA === \\"Default\\";
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-15']\\").forEach((el) => {
        const whenCondition = props.conditionA === \\"Default\\";
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-16']\\").forEach((el) => {
        const whenCondition = props.conditionB === \\"Complete\\";
        if (whenCondition) {
          showContent(el);
        }
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > showWithFor 1`] = `
"<template data-el=\\"show\\">
  <template data-el=\\"for\\">
    <div data-el=\\"div-1\\">
      <template data-el=\\"div-2\\"><!-- item --></template>
    </div>
  </template>
</template>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = props.items;
        renderLoop(el, array, \\"item\\", \\"idx\\");
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        const idx = getScope(el, \\"idx\\");

        el.key = idx;
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        const item = getScope(el, \\"item\\");
        renderTextNode(el, item);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > showWithOtherValues 1`] = `
"<div>
  <template data-el=\\"show\\">ContentA</template>
  <template data-el=\\"show-2\\">ContentB</template>
  <template data-el=\\"show-3\\">ContentC</template>
  <template data-el=\\"show-4\\">ContentD</template>
  <template data-el=\\"show-5\\">ContentE</template>
  <template data-el=\\"show-6\\">ContentF</template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-2']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-3']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-4']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-5']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-6']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > showWithRootText 1`] = `
"<template data-el=\\"show\\">ContentA</template>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > signalsOnUpdate 1`] = `
"<div class=\\"test div\\">
  <template data-el=\\"div-1\\"><!-- props.id --></template>
  <template data-el=\\"div-2\\"><!-- props.foo.value.bar.baz --></template>
</div>
<style>
  .div {
    padding: 10px;
  }
</style>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.id);
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, props.foo.value.bar.baz);
      });

      destroyAnyNodes();

      console.log(\\"props.id changed\\", props.id);
      console.log(\\"props.foo.value.bar.baz changed\\", props.foo.value.bar.baz);

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > spreadAttrs 1`] = `
"<input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
"
`;

exports[`Html > jsx > Javascript Test > spreadNestedProps 1`] = `
"<input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
"
`;

exports[`Html > jsx > Javascript Test > spreadProps 1`] = `
"<input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
"
`;

exports[`Html > jsx > Javascript Test > string-literal-store 1`] = `
"<div>
  <template data-el=\\"div-1\\"><!-- state.foo --></template>
</div>
<script>
  (() => {
    const state = { foo: 123 };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.foo);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > string-literal-store-kebab 1`] = `
"<div>
  <template data-el=\\"div-1\\"><!-- state['foo-bar'] --></template>
</div>
<script>
  (() => {
    const state = { foo-bar: 123,};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;


    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach(el => el.remove());
      nodesToDestroy = [];
    }


    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

          document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {


  renderTextNode(el, state['foo-bar']);
          });


      destroyAnyNodes();



      pendingUpdate = false;
    }



    // Update with initial state on first load
    update();








      // Helper text DOM nodes
      function renderTextNode(el, text) {
        const textNode = document.createTextNode(text);
        if (el?.scope) {
          textNode.scope = el.scope
        }
        if (el?.context) {
          child.context = el.context;
        }
        el.after(textNode);
        nodesToDestroy.push(el.nextSibling);
      }


  })()
</script>
"
`;

exports[`Html > jsx > Javascript Test > styleClassAndCss 1`] = `
"<div class=\\"builder-column div\\" data-el=\\"div-1\\"></div>
<style>
  .div {
    display: flex;
    flex-direction: column;
    align-items: stretch;
  }
</style>
<script>
  (() => {
    const state = {};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        Object.assign(el.style, {
          width: \\"100%\\",
        });
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > stylePropClassAndCss 1`] = `
"<div data-el=\\"div-1\\"></div>
<style>
  .div {
    display: flex;
    flex-direction: column;
    align-items: stretch;
  }
</style>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        Object.assign(el.style, props.attributes.style);

        el.className = props.attributes.class + \\" div\\";
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > subComponent 1`] = `
"<Foo></Foo>
"
`;

exports[`Html > jsx > Javascript Test > svgComponent 1`] = `
"<svg fill=\\"none\\" role=\\"img\\" data-el=\\"svg-1\\">
  <defs>
    <filter id=\\"prefix__filter0_f\\" filterUnits=\\"userSpaceOnUse\\">
      <feFlood result=\\"BackgroundImageFix\\"></feFlood>
      <feBlend
        in=\\"SourceGraphic\\"
        in2=\\"BackgroundImageFix\\"
        result=\\"shape\\"
      ></feBlend>
      <feGaussianBlur
        result=\\"effect1_foregroundBlur\\"
        data-el=\\"fe-gaussian-blur\\"
      ></feGaussianBlur>
    </filter>
  </defs>
</svg>
<script>
  (() => {
    const state = {};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='svg-1']\\").forEach((el) => {
        el.setAttribute(\\"viewBox\\", \\"0 0 \\" + 42 + \\" \\" + 42);

        el.setAttribute(\\"width\\", 42);

        el.setAttribute(\\"height\\", 42);
      });

      document
        .querySelectorAll(\\"[data-el='fe-gaussian-blur']\\")
        .forEach((el) => {
          el.setAttribute(\\"stdDeviation\\", 7);
        });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > typeDependency 1`] = `
"<div>
  <template data-el=\\"div-1\\"><!-- props.foo --></template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.foo);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > use-style 1`] = `
"<button type=\\"button\\">Button</button>
<style>
  button {
    background: blue;
    color: white;
    font-size: 12px;
    outline: 1px solid black;
  }
</style>
"
`;

exports[`Html > jsx > Javascript Test > use-style-and-css 1`] = `
"<button type=\\"button\\" class=\\"button\\">Button</button>
<style>
  button {
    font-size: 12px;
    outline: 1px solid black;
  }

  .button {
    background: blue;
    color: white;
  }
</style>
"
`;

exports[`Html > jsx > Javascript Test > use-style-outside-component 1`] = `
"<button type=\\"button\\">Button</button>
<style>
  button {
    background: blue;
    color: white;
    font-size: 12px;
    outline: 1px solid black;
  }
</style>
"
`;

exports[`Html > jsx > Javascript Test > useTarget 1`] = `
"<div>
  <template data-el=\\"div-1\\"><!-- state.name --></template>
</div>
<script>
  (() => {
    const state = {
      get name() {
        const prefix = \\"h\\";
        return prefix + \\"foo\\";
      },
      lastName: \\"bar\\",
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // onMount

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Javascript Test > webComponent 1`] = `
"<swiper-container slides-per-view=\\"3\\" navigation=\\"true\\" pagination=\\"true\\">
  <swiper-slide>Slide 1</swiper-slide>
  <swiper-slide>Slide 2</swiper-slide>
  <swiper-slide>Slide 3</swiper-slide>
</swiper-container>
"
`;

exports[`Html > jsx > Remove Internal mitosis package 1`] = `
"<div>
  Hello
  <template data-el=\\"div-1\\"><!-- state.name --></template>
  ! I can run in React, Qwik, Vue, Solid, or Liquid!
</div>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\" };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > AdvancedRef 1`] = `
"<div>
  <template data-el=\\"show\\">
    <input
      class=\\"input\\"
      data-el=\\"input-1\\"
      data-dom-state=\\"input-2\\"
      data-ref=\\"undefined-inputRef\\"
    />
    <label for=\\"cars\\" data-el=\\"label-1\\" data-ref=\\"undefined-inputNoArgRef\\">
      Choose a car:
    </label>
    <select name=\\"cars\\" id=\\"cars\\" data-dom-state=\\"select-1\\">
      <option value=\\"supra\\">GR Supra</option>
      <option value=\\"86\\">GR 86</option>
    </select>
  </template>

  Hello

  <template data-el=\\"div-1\\"><!-- state.lowerCaseName() --></template>
  ! I can run in React, Qwik, Vue, Solid, or Web Component!
</div>
<style>
  .input {
    color: red;
  }
</style>
<script>
  (() => {
    const state = {
      name: \\"PatrickJS\\",
      onBlur: function onBlur() {
        // Maintain focus
        inputRef.focus();
      },
      lowerCaseName: function lowerCaseName() {
        return state.name.toLowerCase();
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.showInput;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = state.name;

        el.removeEventListener(\\"blur\\", onInput1Blur);
        el.addEventListener(\\"blur\\", onInput1Blur);

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.lowerCaseName());
      });

      destroyAnyNodes();

      console.log(\\"Received an update\\");

      pendingUpdate = false;
    }

    // Event handler for 'blur' event on input-1
    function onInput1Blur(event) {
      state.onBlur();
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      state.name = event.target.value;
      update();
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > Basic 1`] = `
"<div class=\\"test div\\">
  <input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />

  Hello! I can run in React, Vue, Solid, or Liquid!
</div>
<style>
  .div {
    padding: 10px;
  }
</style>
<script>
  (() => {
    const state = {
      name: \\"Steve\\",
      underscore_fn_name() {
        return \\"bar\\";
      },
      age: 1,
      sports: [\\"\\"],
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = DEFAULT_VALUES.name || state.name;

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(myEvent) {
      state.name = myEvent.target.value;
      update();
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > Basic 2`] = `
"<div>
  <template data-el=\\"for\\">
    <template data-el=\\"show\\">
      <input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />

      Hello
      <template data-el=\\"div-1\\"><!-- person --></template>
      ! I can run in Qwik, Web Component, React, Vue, Solid, or Liquid!
    </template>
  </template>
</div>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = state.names;
        renderLoop(el, array, \\"person\\");
      });

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const person = getScope(el, \\"person\\");
        const whenCondition = person === state.name;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = state.name;

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        const person = getScope(el, \\"person\\");
        renderTextNode(el, person);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      const person = getScope(event.currentTarget, \\"person\\");

      state.name = event.target.value + \\" and \\" + person;
      update();
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > Basic Context 1`] = `
"<div>
  <template data-el=\\"div-1\\">
    <!-- myService.method('hello') + state.name -->
  </template>

  Hello! I can run in React, Vue, Solid, or Liquid!

  <input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
</div>
<script>
  (() => {
    const state = {
      name: \\"PatrickJS\\",
      onChange: function onChange() {
        const change = myService.method(\\"change\\");
        console.log(change);
      },
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;
    let onInitOnce = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, myService.method(\\"hello\\") + state.name);
      });

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      state.onChange;
    }

    // Update with initial state on first load
    update();

    if (!onInitOnce) {
      const hi = myService.method(\\"hi\\");
      console.log(hi);
      onInitOnce = true;
    }

    // onMount
    const bye = myService.method(\\"hi\\");
    console.log(bye);

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > Basic OnMount Update 1`] = `
"<div>
  Hello
  <template data-el=\\"div-1\\"><!-- state.name --></template>
</div>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;
    let onInitOnce = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    if (!onInitOnce) {
      state.name = \\"PatrickJS onInit\\" + props.hi;
      update();
      onInitOnce = true;
    }

    // onMount
    state.name = \\"PatrickJS onMount\\" + props.bye;
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > Basic Outputs 1`] = `
"<div></div>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\" };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // onMount
    props.onMessage(state.name);
    props.onEvent(props.message);
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > Basic Outputs Meta 1`] = `
"<div></div>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\" };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // onMount
    props.onMessage(state.name);
    props.onEvent(props.message);
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > BasicAttribute 1`] = `
"<input
  autocapitalize=\\"on\\"
  autocomplete=\\"on\\"
  data-el=\\"input-1\\"
  data-dom-state=\\"input-2\\"
/>
<script>
  (() => {
    const state = {};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.setAttribute(\\"spellcheck\\", true);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > BasicBooleanAttribute 1`] = `
"<div>
  <template data-el=\\"show\\">
    <slot></slot>
    <template data-el=\\"div-2\\"><!-- props.type --></template>
  </template>
  <MyBooleanAttributeComponent
    data-el=\\"my-boolean-attribute-component\\"
  ></MyBooleanAttributeComponent>
  <MyBooleanAttributeComponent
    data-el=\\"my-boolean-attribute-component-2\\"
  ></MyBooleanAttributeComponent>
  <MyBooleanAttributeComponent
    data-el=\\"my-boolean-attribute-component-3\\"
  ></MyBooleanAttributeComponent>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.children;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, props.type);
      });

      document
        .querySelectorAll(\\"[data-el='my-boolean-attribute-component']\\")
        .forEach((el) => {
          el.setAttribute(\\"toggle\\", true);
        });

      document
        .querySelectorAll(\\"[data-el='my-boolean-attribute-component-2']\\")
        .forEach((el) => {
          el.setAttribute(\\"toggle\\", true);
        });

      document
        .querySelectorAll(\\"[data-el='my-boolean-attribute-component-3']\\")
        .forEach((el) => {
          el.setAttribute(\\"list\\", null);
        });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > BasicChildComponent 1`] = `
"<div>
  <MyBasicComponent data-el=\\"my-basic-component\\"></MyBasicComponent>
  <div>
    <MyBasicOnMountUpdateComponent
      data-el=\\"my-basic-on-mount-update-component\\"
    ></MyBasicOnMountUpdateComponent>
  </div>
</div>
<script>
  (() => {
    const state = { name: \\"Steve\\", dev: \\"PatrickJS\\" };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document
        .querySelectorAll(\\"[data-el='my-basic-component']\\")
        .forEach((el) => {
          el.setAttribute(\\"id\\", state.dev);
        });

      document
        .querySelectorAll(\\"[data-el='my-basic-on-mount-update-component']\\")
        .forEach((el) => {
          el.setAttribute(\\"hi\\", state.name);

          el.setAttribute(\\"bye\\", state.dev);
        });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > BasicFor 1`] = `
"<div>
  <template data-el=\\"for\\">
    <input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />

    Hello
    <template data-el=\\"div-1\\"><!-- person --></template>
    ! I can run in Qwik, Web Component, React, Vue, Solid, or Liquid!
  </template>
</div>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = state.names;
        renderLoop(el, array, \\"person\\");
      });

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = state.name;

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        const person = getScope(el, \\"person\\");
        renderTextNode(el, person);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      const person = getScope(event.currentTarget, \\"person\\");

      state.name = event.target.value + \\" and \\" + person;
      update();
    }

    // Update with initial state on first load
    update();

    // onMount
    console.log(\\"onMount code\\");

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > BasicRef 1`] = `
"<div>
  <template data-el=\\"show\\">
    <input
      class=\\"input\\"
      data-el=\\"input-1\\"
      data-dom-state=\\"input-2\\"
      data-ref=\\"undefined-inputRef\\"
    />
    <label for=\\"cars\\" data-el=\\"label-1\\" data-ref=\\"undefined-inputNoArgRef\\">
      Choose a car:
    </label>
    <select name=\\"cars\\" id=\\"cars\\" data-dom-state=\\"select-1\\">
      <option value=\\"supra\\">GR Supra</option>
      <option value=\\"86\\">GR 86</option>
    </select>
  </template>

  Hello

  <template data-el=\\"div-1\\"><!-- state.lowerCaseName() --></template>
  ! I can run in React, Qwik, Vue, Solid, or Web Component!
</div>
<style>
  .input {
    color: red;
  }
</style>
<script>
  (() => {
    const state = {
      name: \\"PatrickJS\\",
      onBlur: function onBlur() {
        // Maintain focus
        inputRef.focus();
      },
      lowerCaseName: function lowerCaseName() {
        return state.name.toLowerCase();
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.showInput;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = state.name;

        el.removeEventListener(\\"blur\\", onInput1Blur);
        el.addEventListener(\\"blur\\", onInput1Blur);

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.lowerCaseName());
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'blur' event on input-1
    function onInput1Blur(event) {
      state.onBlur();
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      state.name = event.target.value;
      update();
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > BasicRefAssignment 1`] = `
"<div><button data-el=\\"button-1\\">Click</button></div>
<script>
  (() => {
    const state = {
      handlerClick: function handlerClick(event: Event) {
        event.preventDefault();
        console.log(\\"current value\\", holdValueRef);
        holdValueRef = holdValueRef + \\"JS\\";
      },
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='button-1']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton1Click);
        el.addEventListener(\\"click\\", onButton1Click);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'click' event on button-1
    function onButton1Click(evt) {
      state.handlerClick(evt);
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > BasicRefPrevious 1`] = `
"<div>
  <h1>
    Now:
    <template data-el=\\"div-1\\"><!-- state.count --></template>
    , before:
    <template data-el=\\"div-2\\"><!-- prevCount --></template>
  </h1>
  <button data-el=\\"button-1\\">Increment</button>
</div>
<script>
  (() => {
    const state = { count: 0 };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.count);
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, prevCount);
      });

      document.querySelectorAll(\\"[data-el='button-1']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton1Click);
        el.addEventListener(\\"click\\", onButton1Click);
      });

      destroyAnyNodes();

      prevCount = state.count;

      pendingUpdate = false;
    }

    // Event handler for 'click' event on button-1
    function onButton1Click(event) {
      state.count += 1;
      update();
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > Button 1`] = `
"<div>
  <template data-el=\\"show\\">
    <a data-el=\\"a-1\\">
      <template data-el=\\"div-1\\"><!-- props.text --></template>
    </a>
  </template>
  <template data-el=\\"show-2\\">
    <button type=\\"button\\" data-el=\\"button-1\\">
      <template data-el=\\"div-2\\"><!-- props.text --></template>
    </button>
  </template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='a-1']\\").forEach((el) => {
        el.setAttribute(\\"href\\", props.link);

        el.setAttribute(
          \\"target\\",
          props.openLinkInNewTab ? \\"_blank\\" : undefined
        );
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      document.querySelectorAll(\\"[data-el='show-2']\\").forEach((el) => {
        const whenCondition = !props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > Columns 1`] = `
"<div class=\\"builder-columns div\\">
  <template data-el=\\"for\\">
    <div class=\\"builder-column div-2\\">
      <template data-el=\\"div-1\\"><!-- column.content --></template>
      <template data-el=\\"div-2\\"><!-- index --></template>
    </div>
  </template>
</div>
<style>
  .div {
    display: flex;
    flex-direction: column;
    align-items: stretch;
    line-height: normal;
  }
  @media (max-width: 999px) {
    .div {
      flex-direction: row;
    }
  }
  @media (max-width: 639px) {
    .div {
      flex-direction: row-reverse;
    }
  }
  .div-2 {
    flex-grow: 1;
  }
</style>
<script>
  (() => {
    const state = {
      getColumns() {
        return props.columns || [];
      },
      getGutterSize() {
        return typeof props.space === \\"number\\" ? props.space || 0 : 20;
      },
      getWidth(index: number) {
        const columns = state.getColumns();
        return (columns[index] && columns[index].width) || 100 / columns.length;
      },
      getColumnCssWidth(index: number) {
        const columns = state.getColumns();
        const gutterSize = state.getGutterSize();
        const subtractWidth =
          (gutterSize * (columns.length - 1)) / columns.length;
        return \`calc(\${state.getWidth(index)}% - \${subtractWidth}px)\`;
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = props.columns;
        renderLoop(el, array, \\"column\\", \\"index\\");
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        const column = getScope(el, \\"column\\");
        renderTextNode(el, column.content);
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        const index = getScope(el, \\"index\\");
        renderTextNode(el, index);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > ContentSlotHtml 1`] = `
"<div>
  <slot data-el=\\"slot\\"></slot>
  <div><hr /></div>
  <div><slot></slot></div>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='slot']\\").forEach((el) => {
        el.setAttribute(\\"name\\", props.slotTesting);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > ContentSlotJSX 1`] = `
"<template data-el=\\"show\\">
  <div data-el=\\"div-1\\">
    <template data-el=\\"show-2\\">
      <slot name=\\"content\\">
        <template data-el=\\"div-2\\"><!-- props.content --></template>
      </slot>
    </template>
    <div><hr /></div>
    <div><slot></slot></div>
  </div>
</template>
<script>
  (() => {
    const state = {
      name: \\"king\\",
      showContent: false,
      get cls() {
        return props.slotContent && props.children
          ? \`\${state.name}-content\`
          : \\"\\";
      },
      show() {
        props.slotContent ? 1 : \\"\\";
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.slotReference;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.setAttribute(\\"name\\", props.slotContent ? \\"name1\\" : \\"name2\\");

        el.setAttribute(\\"title\\", props.slotContent ? \\"title1\\" : \\"title2\\");

        el.removeEventListener(\\"click\\", onDiv1Click);
        el.addEventListener(\\"click\\", onDiv1Click);

        el.className = state.cls;
      });

      document.querySelectorAll(\\"[data-el='show-2']\\").forEach((el) => {
        const whenCondition = state.showContent && props.slotContent;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, props.content);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'click' event on div-1
    function onDiv1Click(event) {
      state.show();
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > CustomCode 1`] = `
"<div data-el=\\"div-1\\" data-ref=\\"undefined-elem\\"></div>
<script>
  (() => {
    const state = {
      scriptsInserted: [],
      scriptsRun: [],
      findAndRunScripts() {
        // TODO: Move this function to standalone one in '@builder.io/utils'
        if (elem && typeof window !== \\"undefined\\") {
          /** @type {HTMLScriptElement[]} */
          const scripts = elem.getElementsByTagName(\\"script\\");
          for (let i = 0; i < scripts.length; i++) {
            const script = scripts[i];
            if (script.src) {
              if (state.scriptsInserted.includes(script.src)) {
                continue;
              }
              state.scriptsInserted.push(script.src);
              const newScript = document.createElement(\\"script\\");
              newScript.async = true;
              newScript.src = script.src;
              document.head.appendChild(newScript);
            } else if (
              !script.type ||
              [
                \\"text/javascript\\",
                \\"application/javascript\\",
                \\"application/ecmascript\\",
              ].includes(script.type)
            ) {
              if (state.scriptsRun.includes(script.innerText)) {
                continue;
              }
              try {
                state.scriptsRun.push(script.innerText);
                new Function(script.innerText)();
              } catch (error) {
                console.warn(\\"\`CustomCode\`: Error running script:\\", error);
              }
            }
          }
        }
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.className =
          \\"builder-custom-code\\" + (props.replaceNodes ? \\" replace-nodes\\" : \\"\\");

        el.innerHTML = props.code;
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // onMount
    state.findAndRunScripts();
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > Embed 1`] = `
"<div data-el=\\"div-1\\" data-ref=\\"undefined-elem\\"></div>
<script>
  (() => {
    const state = {
      scriptsInserted: [],
      scriptsRun: [],
      findAndRunScripts() {
        // TODO: Move this function to standalone one in '@builder.io/utils'
        if (elem && typeof window !== \\"undefined\\") {
          /** @type {HTMLScriptElement[]} */
          const scripts = elem.getElementsByTagName(\\"script\\");
          for (let i = 0; i < scripts.length; i++) {
            const script = scripts[i];
            if (script.src) {
              if (state.scriptsInserted.includes(script.src)) {
                continue;
              }
              state.scriptsInserted.push(script.src);
              const newScript = document.createElement(\\"script\\");
              newScript.async = true;
              newScript.src = script.src;
              document.head.appendChild(newScript);
            } else if (
              !script.type ||
              [
                \\"text/javascript\\",
                \\"application/javascript\\",
                \\"application/ecmascript\\",
              ].includes(script.type)
            ) {
              if (state.scriptsRun.includes(script.innerText)) {
                continue;
              }
              try {
                state.scriptsRun.push(script.innerText);
                new Function(script.innerText)();
              } catch (error) {
                console.warn(\\"\`CustomCode\`: Error running script:\\", error);
              }
            }
          }
        }
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.className =
          \\"builder-custom-code\\" + (props.replaceNodes ? \\" replace-nodes\\" : \\"\\");

        el.innerHTML = props.code;
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // onMount
    state.findAndRunScripts();
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > Image 1`] = `
"<div>
  <picture data-el=\\"picture-1\\" data-ref=\\"undefined-pictureRef\\">
    <template data-el=\\"show\\"><img data-el=\\"img-1\\" /></template>
    <source data-el=\\"source-1\\" />
  </picture>
  <slot></slot>
</div>
<style>
  .img {
    opacity: 1;
    transition: opacity 0.2s ease-in-out;
    object-fit: cover;
    object-position: center;
  }
</style>
<script>
  (() => {
    const state = {
      scrollListener: null,
      imageLoaded: false,
      setLoaded() {
        state.imageLoaded = true;
        update();
      },
      useLazyLoading() {
        // TODO: Add more checks here, like testing for real web browsers
        return !!props.lazy && state.isBrowser();
      },
      isBrowser: function isBrowser() {
        return (
          typeof window !== \\"undefined\\" &&
          window.navigator.product != \\"ReactNative\\"
        );
      },
      load: false,
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = !state.useLazyLoading() || state.load;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='img-1']\\").forEach((el) => {
        el.setAttribute(\\"alt\\", props.altText);

        el.setAttribute(
          \\"aria-role\\",
          props.altText ? \\"presentation\\" : undefined
        );

        el.className =
          \\"builder-image\\" + (props._class ? \\" \\" + props._class : \\"\\") + \\" img\\";

        el.setAttribute(\\"src\\", props.image);

        el.removeEventListener(\\"load\\", onImg1Load);
        el.addEventListener(\\"load\\", onImg1Load);

        el.setAttribute(\\"srcset\\", props.srcset);

        el.setAttribute(\\"sizes\\", props.sizes);
      });

      document.querySelectorAll(\\"[data-el='source-1']\\").forEach((el) => {
        el.setAttribute(\\"srcset\\", props.srcset);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'load' event on img-1
    function onImg1Load(event) {
      state.setLoaded();
    }

    // Update with initial state on first load
    update();

    // onMount
    if (state.useLazyLoading()) {
      // throttled scroll capture listener
      const listener = () => {
        if (pictureRef) {
          const rect = pictureRef.getBoundingClientRect();
          const buffer = window.innerHeight / 2;
          if (rect.top < window.innerHeight + buffer) {
            state.load = true;
            update();
            state.scrollListener = null;
            update();
            window.removeEventListener(\\"scroll\\", listener);
          }
        }
      };
      state.scrollListener = listener;
      update();
      window.addEventListener(\\"scroll\\", listener, {
        capture: true,
        passive: true,
      });
      listener();
    }

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > Image State 1`] = `
"<div>
  <template data-el=\\"for\\">
    <img class=\\"custom-class\\" data-el=\\"img-1\\" />
  </template>
</div>
<script>
  (() => {
    const state = { canShow: true, images: [\\"http://example.com/qwik.png\\"] };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = state.images;
        renderLoop(el, array, \\"item\\", \\"itemIndex\\");
      });

      document.querySelectorAll(\\"[data-el='img-1']\\").forEach((el) => {
        const item = getScope(el, \\"item\\");
        const itemIndex = getScope(el, \\"itemIndex\\");

        el.setAttribute(\\"src\\", item);

        el.key = itemIndex;
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > Img 1`] = `
"<img data-el=\\"img-1\\" />
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='img-1']\\").forEach((el) => {
        Object.assign(el.style, {
          objectFit: props.backgroundSize || \\"cover\\",
          objectPosition: props.backgroundPosition || \\"center\\",
        });

        el.key = (Builder.isEditing && props.imgSrc) || \\"default-key\\";

        el.setAttribute(\\"alt\\", props.altText);

        el.setAttribute(\\"src\\", props.imgSrc);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > Input 1`] = `
"<input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.key =
          Builder.isEditing && props.defaultValue
            ? props.defaultValue
            : \\"default-key\\";

        el.setAttribute(\\"placeholder\\", props.placeholder);

        el.setAttribute(\\"type\\", props.type);

        el.setAttribute(\\"name\\", props.name);

        el.value = props.value;

        el.setAttribute(\\"defaultValue\\", props.defaultValue);

        el.setAttribute(\\"required\\", props.required);

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      props.onChange?.(event.target.value);
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > InputParent 1`] = `
"<FormInputComponent
  name=\\"kingzez\\"
  type=\\"text\\"
  data-el=\\"form-input-component\\"
></FormInputComponent>
<script>
  (() => {
    const state = {
      handleChange(value: string) {
        console.log(value);
      },
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document
        .querySelectorAll(\\"[data-el='form-input-component']\\")
        .forEach((el) => {
          el.removeEventListener(\\"change\\", onFormInputComponentChange);
          el.addEventListener(\\"change\\", onFormInputComponentChange);
        });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'change' event on form-input-component
    function onFormInputComponentChange(value) {
      state.handleChange(value);
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > RawText 1`] = `
"<span data-el=\\"span-1\\"></span>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='span-1']\\").forEach((el) => {
        el.className = props.attributes?.class || props.attributes?.className;

        el.innerHTML = props.text || \\"\\";
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > Section 1`] = `
"<section data-el=\\"section-1\\"><slot></slot></section>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='section-1']\\").forEach((el) => {
        Object.assign(
          el.style,
          props.maxWidth && typeof props.maxWidth === \\"number\\"
            ? {
                maxWidth: props.maxWidth,
              }
            : undefined
        );
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > Section 2`] = `
"<template data-el=\\"show\\">
  <template data-el=\\"for\\">
    <section data-el=\\"section-1\\"><slot></slot></section>
  </template>
</template>
<script>
  (() => {
    const state = { max: 42, items: [42] };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = state.max;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = state.items;
        renderLoop(el, array, \\"item\\");
      });

      document.querySelectorAll(\\"[data-el='section-1']\\").forEach((el) => {
        const item = getScope(el, \\"item\\");
        Object.assign(el.style, {
          maxWidth: item + state.max,
        });
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > Select 1`] = `
"<select data-el=\\"select-1\\" data-dom-state=\\"select-2\\">
  <template data-el=\\"for\\">
    <option data-el=\\"option-1\\">
      <template data-el=\\"div-1\\"><!-- option.name || option.value --></template>
    </option>
  </template>
</select>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='select-1']\\").forEach((el) => {
        el.value = props.value;

        el.key =
          Builder.isEditing && props.defaultValue
            ? props.defaultValue
            : \\"default-key\\";

        el.setAttribute(\\"defaultValue\\", props.defaultValue);

        el.setAttribute(\\"name\\", props.name);
      });

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = props.options;
        renderLoop(el, array, \\"option\\", \\"index\\");
      });

      document.querySelectorAll(\\"[data-el='option-1']\\").forEach((el) => {
        const option = getScope(el, \\"option\\");
        const index = getScope(el, \\"index\\");

        el.value = option.value;

        el.setAttribute(\\"data-index\\", index);
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        const option = getScope(el, \\"option\\");
        renderTextNode(el, option.name || option.value);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > SlotDefault 1`] = `
"<div>
  <slot><div class=\\"default-slot\\">Default content</div></slot>
</div>
"
`;

exports[`Html > jsx > Typescript Test > SlotHtml 1`] = `
"<div>
  <ContentSlotCode><slot data-el=\\"slot\\"></slot></ContentSlotCode>
</div>
<script>
  (() => {
    const state = {};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='slot']\\").forEach((el) => {
        el.setAttribute(\\"testing\\", <div>Hello</div>);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > SlotJsx 1`] = `
"<div><ContentSlotCode data-el=\\"content-slot-code\\"></ContentSlotCode></div>
<script>
  (() => {
    const state = {};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document
        .querySelectorAll(\\"[data-el='content-slot-code']\\")
        .forEach((el) => {
          el.setAttribute(\\"slotTesting\\", <div>Hello</div>);
        });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > SlotNamed 1`] = `
"<div>
  <slot name=\\"myAwesomeSlot\\"></slot>
  <slot name=\\"top\\"></slot>
  <slot name=\\"left\\">Default left</slot>
  <slot>Default Child</slot>
</div>
"
`;

exports[`Html > jsx > Typescript Test > Stamped.io 1`] = `
"<div data-el=\\"div-1\\">
  <button data-el=\\"button-1\\">Write a review</button>
  <template data-el=\\"show\\">
    <input placeholder=\\"Email\\" data-dom-state=\\"input-1\\" />
    <input placeholder=\\"Title\\" class=\\"input\\" data-dom-state=\\"input-2\\" />
    <textarea
      placeholder=\\"How was your experience?\\"
      class=\\"textarea\\"
      data-dom-state=\\"textarea-1\\"
    ></textarea>
    <button class=\\"button\\" data-el=\\"button-2\\">Submit</button>
  </template>

  <template data-el=\\"for\\">
    <div class=\\"review\\" data-el=\\"review\\">
      <img class=\\"img\\" data-el=\\"img-1\\" />
      <div data-el=\\"div-2\\">
        <div>
          N:
          <template data-el=\\"div-3\\"><!-- index --></template>
        </div>
        <div>
          <template data-el=\\"div-4\\"><!-- review.author --></template>
        </div>
        <div>
          <template data-el=\\"div-5\\"><!-- review.reviewMessage --></template>
        </div>
      </div>
    </div>
  </template>
</div>
<style>
  .input {
    display: block;
  }
  .textarea {
    display: block;
  }
  .button {
    display: block;
  }
  .review {
    margin: 10px;
    padding: 10px;
    background: white;
    display: flex;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    -webkit-font-smoothing: antialiased;
  }
  .img {
    height: 30px;
    width: 30px;
    margin-right: 10px;
  }
</style>
<script>
  (() => {
    const state = {
      reviews: [],
      name: \\"test\\",
      showReviewPrompt: false,
      kebabCaseValue() {
        return kebabCase(\\"testThat\\");
      },
      snakeCaseValue() {
        return snakeCase(\\"testThis\\");
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.setAttribute(\\"data-user\\", state.name);
      });

      document.querySelectorAll(\\"[data-el='button-1']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton1Click);
        el.addEventListener(\\"click\\", onButton1Click);
      });

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = state.showReviewPrompt || \\"asdf\\";
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='button-2']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton2Click);
        el.addEventListener(\\"click\\", onButton2Click);
      });

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = state.reviews;
        renderLoop(el, array, \\"review\\", \\"index\\");
      });

      document.querySelectorAll(\\"[data-el='review']\\").forEach((el) => {
        const review = getScope(el, \\"review\\");

        el.key = review.id;
      });

      document.querySelectorAll(\\"[data-el='img-1']\\").forEach((el) => {
        const review = getScope(el, \\"review\\");

        el.setAttribute(\\"src\\", review.avatar);
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        el.className = state.showReviewPrompt ? \\"bg-primary\\" : \\"bg-secondary\\";
      });

      document.querySelectorAll(\\"[data-el='div-3']\\").forEach((el) => {
        const index = getScope(el, \\"index\\");
        renderTextNode(el, index);
      });

      document.querySelectorAll(\\"[data-el='div-4']\\").forEach((el) => {
        const review = getScope(el, \\"review\\");
        renderTextNode(el, review.author);
      });

      document.querySelectorAll(\\"[data-el='div-5']\\").forEach((el) => {
        const review = getScope(el, \\"review\\");
        renderTextNode(el, review.reviewMessage);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'click' event on button-1
    function onButton1Click(event) {
      state.showReviewPrompt = true;
      update();
    }

    // Event handler for 'click' event on button-2
    function onButton2Click(event) {
      event.preventDefault();
      state.showReviewPrompt = false;
      update();
    }

    // Update with initial state on first load
    update();

    // onMount
    fetch(
      \`https://stamped.io/api/widget/reviews?storeUrl=builder-io.myshopify.com&apiKey=\${
        props.apiKey || \\"pubkey-8bbDq7W6w4sB3OWeM1HUy2s47702hM\\"
      }&productId=\${props.productId || \\"2410511106127\\"}\`
    )
      .then((res) => res.json())
      .then((data) => {
        state.reviews = data.data;
        update();
      });

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > Submit 1`] = `
"<button type=\\"submit\\" data-el=\\"button-1\\">
  <template data-el=\\"div-1\\"><!-- props.text --></template>
</button>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > Text 1`] = `
"<div data-el=\\"div-1\\"></div>
<script>
  (() => {
    const state = { name: \\"Decadef20\\" };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.setAttribute(\\"contentEditable\\", allowEditingText || undefined);

        el.setAttribute(\\"data-name\\", {
          test: state.name || \\"any name\\",
        });

        el.innerHTML =
          props.text ||
          props.content ||
          state.name ||
          '<p class=\\"text-lg\\">my name</p>';
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > Textarea 1`] = `
"<textarea data-el=\\"textarea-1\\" data-dom-state=\\"textarea-2\\"></textarea>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='textarea-1']\\").forEach((el) => {
        el.setAttribute(\\"placeholder\\", props.placeholder);

        el.setAttribute(\\"name\\", props.name);

        el.value = props.value;

        el.setAttribute(\\"defaultValue\\", props.defaultValue);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > Video 1`] = `
"<video preload=\\"none\\" data-el=\\"video-1\\"></video>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='video-1']\\").forEach((el) => {
        Object.assign(el.style, {
          width: \\"100%\\",
          height: \\"100%\\",
          ...props.attributes?.style,
          objectFit: props.fit,
          objectPosition: props.position,
          // Hack to get object fit to work as expected and
          // not have the video overflow
          borderRadius: 1,
        });

        el.key = props.video || \\"no-src\\";

        el.setAttribute(\\"poster\\", props.posterImage);

        el.setAttribute(\\"autoplay\\", props.autoPlay);

        el.setAttribute(\\"muted\\", props.muted);

        el.setAttribute(\\"controls\\", props.controls);

        el.setAttribute(\\"loop\\", props.loop);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > arrowFunctionInUseStore 1`] = `
"<div>
  Hello
  <template data-el=\\"div-1\\"><!-- state.name --></template>
</div>
<script>
  (() => {
    const state = {
      name: \\"steve\\",
      setName(value) {
        state.name = value;
        update();
      },
      updateNameWithArrowFn(value) {
        state.name = value;
        update();
      },
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > basicForNoTagReference 1`] = `
"<state.TagNameGetter>
  Hello
  <state.tag>
    <template data-el=\\"div-1\\"><!-- state.name --></template>
  </state.tag>

  <template data-el=\\"for\\">
    <state.TagName>
      <action.icon></action.icon>
      <span>
        <template data-el=\\"div-2\\"><!-- action.text --></template>
      </span>
    </state.TagName>
  </template>
</state.TagNameGetter>
<script>
  (() => {
    const state = {
      name: \\"VincentW\\",
      TagName: \\"div\\",
      tag: \\"span\\",
      get TagNameGetter() {
        return \\"span\\";
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.name);
      });

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = props.actions;
        renderLoop(el, array, \\"action\\");
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        const action = getScope(el, \\"action\\");
        renderTextNode(el, action.text);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > basicForwardRef 1`] = `
"<div>
  <input
    class=\\"input\\"
    data-el=\\"input-1\\"
    data-dom-state=\\"input-2\\"
    data-ref=\\"undefined-props.inputRef\\"
  />
</div>
<style>
  .input {
    color: red;
  }
</style>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\" };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = state.name;

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      state.name = event.target.value;
      update();
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > basicForwardRefMetadata 1`] = `
"<div>
  <input
    class=\\"input\\"
    data-el=\\"input-1\\"
    data-dom-state=\\"input-2\\"
    data-ref=\\"undefined-props.inputRef\\"
  />
</div>
<style>
  .input {
    color: red;
  }
</style>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\" };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = state.name;

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      state.name = event.target.value;
      update();
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > basicOnUpdateReturn 1`] = `
"<div>
  Hello!
  <template data-el=\\"div-1\\"><!-- state.name --></template>
</div>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\" };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.name);
      });

      destroyAnyNodes();

      const controller = new AbortController();
      const signal = controller.signal;
      fetch(\\"https://patrickjs.com/api/resource.json\\", {
        signal,
      })
        .then((response) => response.json())
        .then((data) => {
          state.name = data.name;
          update();
        });
      return () => {
        if (!signal.aborted) {
          controller.abort();
        }
      };

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > class + ClassName + css 1`] = `
"<div class=\\"test2 test div\\">
  Hello! I can run in React, Vue, Solid, or Liquid!
</div>
<style>
  .div {
    padding: 10px;
  }
</style>
"
`;

exports[`Html > jsx > Typescript Test > class + css 1`] = `
"<div class=\\"test div\\">Hello! I can run in React, Vue, Solid, or Liquid!</div>
<style>
  .div {
    padding: 10px;
  }
</style>
"
`;

exports[`Html > jsx > Typescript Test > className + css 1`] = `
"<div class=\\"test div\\">Hello! I can run in React, Vue, Solid, or Liquid!</div>
<style>
  .div {
    padding: 10px;
  }
</style>
"
`;

exports[`Html > jsx > Typescript Test > className 1`] = `
"<div>
  <div class=\\"no binding\\">Without Binding</div>
  <div data-el=\\"div-1\\">With binding</div>
</div>
<script>
  (() => {
    const state = { bindings: \\"a binding\\" };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.className = state.bindings;
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > classState 1`] = `
"<div data-el=\\"div-1\\">Hello! I can run in React, Vue, Solid, or Liquid!</div>
<style>
  .div {
    padding: 10px;
  }
</style>
<script>
  (() => {
    const state = {
      classState: \\"testClassName\\",
      styleState: {
        color: \\"red\\",
      },
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.className = state.classState + \\" div\\";

        Object.assign(el.style, state.styleState);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > componentWithContext 1`] = `
"<template data-el=\\"div-1\\"><!-- foo.value --></template>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, foo.value);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > componentWithContextMultiRoot 1`] = `
"<template data-el=\\"div-1\\"><!-- foo.value --></template>
<div>other</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, foo.value);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > contentState 1`] = `
"<div>setting context</div>
"
`;

exports[`Html > jsx > Typescript Test > defaultProps 1`] = `
"<div>
  <template data-el=\\"show\\">
    <a data-el=\\"a-1\\">
      <template data-el=\\"div-1\\"><!-- props.text --></template>
    </a>
  </template>
  <template data-el=\\"show-2\\">
    <button type=\\"button\\" data-el=\\"button-1\\">
      <template data-el=\\"div-2\\"><!-- props.buttonText --></template>
    </button>
  </template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='a-1']\\").forEach((el) => {
        el.setAttribute(\\"href\\", props.link);

        el.setAttribute(
          \\"target\\",
          props.openLinkInNewTab ? \\"_blank\\" : undefined
        );
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      document.querySelectorAll(\\"[data-el='show-2']\\").forEach((el) => {
        const whenCondition = !props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='button-1']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton1Click);
        el.addEventListener(\\"click\\", onButton1Click);
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, props.buttonText);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'click' event on button-1
    function onButton1Click(event) {
      props.onClick(event);
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > defaultPropsOutsideComponent 1`] = `
"<div>
  <template data-el=\\"show\\">
    <a data-el=\\"a-1\\">
      <template data-el=\\"div-1\\"><!-- props.text --></template>
    </a>
  </template>
  <template data-el=\\"show-2\\">
    <button type=\\"button\\" data-el=\\"button-1\\">
      <template data-el=\\"div-2\\"><!-- props.text --></template>
    </button>
  </template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='a-1']\\").forEach((el) => {
        el.setAttribute(\\"href\\", props.link);

        el.setAttribute(
          \\"target\\",
          props.openLinkInNewTab ? \\"_blank\\" : undefined
        );
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      document.querySelectorAll(\\"[data-el='show-2']\\").forEach((el) => {
        const whenCondition = !props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='button-1']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton1Click);
        el.addEventListener(\\"click\\", onButton1Click);
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'click' event on button-1
    function onButton1Click(event) {
      props.onClick(event);
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > defaultValsWithTypes 1`] = `
"<div>
  Hello
  <template data-el=\\"div-1\\">
    <!-- props.name || DEFAULT_VALUES.name -->
  </template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.name || DEFAULT_VALUES.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > expressionState 1`] = `
"<div>
  <template data-el=\\"div-1\\"><!-- state.refToUse --></template>
</div>
<script>
  (() => {
    const state = {
      refToUse: !(props.componentRef instanceof Function)
        ? props.componentRef
        : null,
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.refToUse);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > getterState 1`] = `
"<div>
  <p>
    <template data-el=\\"div-1\\"><!-- state.foo2 --></template>
  </p>
  <p>
    <template data-el=\\"div-2\\"><!-- state.bar --></template>
  </p>
  <p>
    <template data-el=\\"div-3\\"><!-- state.baz(1) --></template>
  </p>
</div>
<script>
  (() => {
    const state = {
      get foo2() {
        return props.foo + \\"foo\\";
      },
      get bar() {
        return \\"bar\\";
      },
      baz(i: number) {
        return i + state.foo2.length;
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.foo2);
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, state.bar);
      });

      document.querySelectorAll(\\"[data-el='div-3']\\").forEach((el) => {
        renderTextNode(el, state.baz(1));
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > import types 1`] = `
"<RenderBlock data-el=\\"render-block\\"></RenderBlock>
"
`;

exports[`Html > jsx > Typescript Test > multipleOnUpdate 1`] = `
"<div></div>
"
`;

exports[`Html > jsx > Typescript Test > multipleOnUpdateWithDeps 1`] = `
"<div></div>
"
`;

exports[`Html > jsx > Typescript Test > multipleSpreads 1`] = `
"<input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
"
`;

exports[`Html > jsx > Typescript Test > nestedShow 1`] = `
"<template data-el=\\"show\\">
  <template data-el=\\"show-2\\">
    <div>if condition A and condition B</div>
  </template>
</template>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-2']\\").forEach((el) => {
        const whenCondition = !props.conditionB;
        if (whenCondition) {
          showContent(el);
        }
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > nestedStyles 1`] = `
"<div class=\\"div\\">Hello world</div>
<style>
  .div {
    display: flex;
    --bar: red;
    color: var(--bar);
  }
  @media (max-width: env(--mobile)) {
    .div {
      display: block;
    }
  }
  .div:hover {
    display: flex;
  }
  .div:active {
    display: inline;
  }
  .div .nested-selector {
    display: grid;
  }
  .div .nested-selector:hover {
    display: block;
  }
  .div.nested-selector:active {
    display: inline-block;
  }
</style>
"
`;

exports[`Html > jsx > Typescript Test > onEvent 1`] = `
"<div class=\\"builder-embed\\" data-el=\\"div-1\\" data-ref=\\"undefined-elem\\">
  <div>Test</div>
</div>
<script>
  (() => {
    const state = {
      foo(event) {
        console.log(\\"test2\\");
      },
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // onMount
    elem.dispatchEvent(new CustomEvent(\\"initEditingBldr\\"));
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > onInit & onMount 1`] = `
"<div></div>
<script>
  (() => {
    const state = {};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;
    let onInitOnce = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    if (!onInitOnce) {
      console.log(\\"onInit\\");
      onInitOnce = true;
    }

    // onMount
    console.log(\\"onMount\\");
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > onInit 1`] = `
"<div>
  Default name defined by parent
  <template data-el=\\"div-1\\"><!-- state.name --></template>
</div>
<script>
  (() => {
    const state = { name: \\"\\" };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;
    let onInitOnce = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    if (!onInitOnce) {
      state.name = defaultValues.name || props.name;
      update();
      console.log(\\"set defaults with props\\");
      onInitOnce = true;
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > onMount 1`] = `
"<div></div>
<script>
  (() => {
    const state = {};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // onMount
    console.log(\\"Runs on mount\\");
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > onMountMultiple 1`] = `
"<div></div>
<script>
  (() => {
    const state = {};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // onMount
    const onMountHook_0 = () => {
      console.log(\\"Runs on mount\\");
    };
    onMountHook_0();
    const onMountHook_1 = () => {
      console.log(\\"Another one runs on Mount\\");
    };
    onMountHook_1();
    const onMountHook_2 = () => {
      console.log(\\"SSR runs on Mount\\");
    };
    onMountHook_2();
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > onUpdate 1`] = `
"<div></div>
"
`;

exports[`Html > jsx > Typescript Test > onUpdateWithDeps 1`] = `
"<div></div>
"
`;

exports[`Html > jsx > Typescript Test > preserveExportOrLocalStatement 1`] = `
"<div></div>
"
`;

exports[`Html > jsx > Typescript Test > preserveTyping 1`] = `
"<div>
  Hello! I can run in React, Vue, Solid, or Liquid!
  <template data-el=\\"div-1\\"><!-- props.name --></template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > propsDestructure 1`] = `
"<div>
  <slot></slot>
  <template data-el=\\"div-2\\"><!-- props.type --></template>

  Hello! I can run in React, Vue, Solid, or Liquid!
</div>
<script>
  (() => {
    const state = { name: \\"Decadef20\\" };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, props.type);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > propsInterface 1`] = `
"<div>
  Hello! I can run in React, Vue, Solid, or Liquid!
  <template data-el=\\"div-1\\"><!-- props.name --></template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > propsType 1`] = `
"<div>
  Hello! I can run in React, Vue, Solid, or Liquid!
  <template data-el=\\"div-1\\"><!-- props.name --></template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > referencingFunInsideHook 1`] = `
"<div></div>
"
`;

exports[`Html > jsx > Typescript Test > renderBlock 1`] = `
"<template data-el=\\"show\\">
  <template data-el=\\"show-2\\">
    <state.tag data-el=\\"state-tag\\"></state.tag>
  </template>
  <template data-el=\\"show-3\\">
    <template data-el=\\"for\\">
      <RenderRepeatedBlock
        data-el=\\"render-repeated-block\\"
      ></RenderRepeatedBlock>
    </template>
  </template>
  <template data-el=\\"show-4\\">
    <state.tag data-el=\\"state-tag-2\\">
      <state.renderComponentTag
        data-el=\\"state-render-component-tag\\"
      ></state.renderComponentTag>

      <template data-el=\\"for-2\\">
        <RenderBlock data-el=\\"render-block\\"></RenderBlock>
      </template>

      <template data-el=\\"for-3\\">
        <BlockStyles data-el=\\"block-styles\\"></BlockStyles>
      </template>
    </state.tag>
  </template>
</template>
<script>
  (() => {
    const state = {
      get component() {
        const componentName = getProcessedBlock({
          block: props.block,
          state: props.context.state,
          context: props.context.context,
          shouldEvaluateBindings: false,
        }).component?.name;
        if (!componentName) {
          return null;
        }
        const ref = props.context.registeredComponents[componentName];
        if (!ref) {
          // TODO: Public doc page with more info about this message
          console.warn(\`
          Could not find a registered component named \\"\${componentName}\\". 
          If you registered it, is the file that registered it imported by the file that needs to render it?\`);
          return undefined;
        } else {
          return ref;
        }
      },
      get tag() {
        return getBlockTag(state.useBlock);
      },
      get useBlock() {
        return state.repeatItemData
          ? props.block
          : getProcessedBlock({
              block: props.block,
              state: props.context.state,
              context: props.context.context,
              shouldEvaluateBindings: true,
            });
      },
      get actions() {
        return getBlockActions({
          block: state.useBlock,
          state: props.context.state,
          context: props.context.context,
        });
      },
      get attributes() {
        const blockProperties = getBlockProperties(state.useBlock);
        return {
          ...blockProperties,
          ...(TARGET === \\"reactNative\\"
            ? {
                style: getReactNativeBlockStyles({
                  block: state.useBlock,
                  context: props.context,
                  blockStyles: blockProperties.style,
                }),
              }
            : {}),
        };
      },
      get shouldWrap() {
        return !state.component?.noWrap;
      },
      get renderComponentProps() {
        return {
          blockChildren: state.useChildren,
          componentRef: state.component?.component,
          componentOptions: {
            ...getBlockComponentOptions(state.useBlock),
            /**
             * These attributes are passed to the wrapper element when there is one. If \`noWrap\` is set to true, then
             * they are provided to the component itself directly.
             */
            ...(state.shouldWrap
              ? {}
              : {
                  attributes: {
                    ...state.attributes,
                    ...state.actions,
                  },
                }),
            customBreakpoints:
              state.childrenContext?.content?.meta?.breakpoints,
          },
          context: state.childrenContext,
        };
      },
      get useChildren() {
        // TO-DO: When should \`canHaveChildren\` dictate rendering?
        // This is currently commented out because some Builder components (e.g. Box) do not have \`canHaveChildren: true\`,
        // but still receive and need to render children.
        // return state.componentInfo?.canHaveChildren ? state.useBlock.children : [];
        return state.useBlock.children ?? [];
      },
      get childrenWithoutParentComponent() {
        /**
         * When there is no \`componentRef\`, there might still be children that need to be rendered. In this case,
         * we render them outside of \`componentRef\`.
         * NOTE: We make sure not to render this if \`repeatItemData\` is non-null, because that means we are rendering an array of
         * blocks, and the children will be repeated within those blocks.
         */
        const shouldRenderChildrenOutsideRef =
          !state.component?.component && !state.repeatItemData;
        return shouldRenderChildrenOutsideRef ? state.useChildren : [];
      },
      get repeatItemData() {
        /**
         * we don't use \`state.useBlock\` here because the processing done within its logic includes evaluating the block's bindings,
         * which will not work if there is a repeat.
         */
        const { repeat, ...blockWithoutRepeat } = props.block;
        if (!repeat?.collection) {
          return undefined;
        }
        const itemsArray = evaluate({
          code: repeat.collection,
          state: props.context.state,
          context: props.context.context,
        });
        if (!Array.isArray(itemsArray)) {
          return undefined;
        }
        const collectionName = repeat.collection.split(\\".\\").pop();
        const itemNameToUse =
          repeat.itemName ||
          (collectionName ? collectionName + \\"Item\\" : \\"item\\");
        const repeatArray =
          itemsArray.map <
          RepeatData >
          ((item, index) => ({
            context: {
              ...props.context,
              state: {
                ...props.context.state,
                $index: index,
                $item: item,
                [itemNameToUse]: item,
                [\`$\${itemNameToUse}Index\`]: index,
              },
            },
            block: blockWithoutRepeat,
          }));
        return repeatArray;
      },
      get inheritedTextStyles() {
        if (TARGET !== \\"reactNative\\") {
          return {};
        }
        const styles = getReactNativeBlockStyles({
          block: state.useBlock,
          context: props.context,
          blockStyles: state.attributes.style,
        });
        return extractTextStyles(styles);
      },
      get childrenContext() {
        return {
          apiKey: props.context.apiKey,
          state: props.context.state,
          content: props.context.content,
          context: props.context.context,
          registeredComponents: props.context.registeredComponents,
          inheritedStyles: state.inheritedTextStyles,
        };
      },
      get renderComponentTag() {
        if (TARGET === \\"reactNative\\") {
          return RenderComponentWithContext;
        } else if (TARGET === \\"vue3\\") {
          // vue3 expects a string for the component tag
          return \\"RenderComponent\\";
        } else {
          return RenderComponent;
        }
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = state.shouldWrap;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-2']\\").forEach((el) => {
        const whenCondition = isEmptyHtmlElement(state.tag);
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-3']\\").forEach((el) => {
        const whenCondition =
          !isEmptyHtmlElement(state.tag) && state.repeatItemData;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = state.repeatItemData;
        renderLoop(el, array, \\"data\\", \\"index\\");
      });

      document
        .querySelectorAll(\\"[data-el='render-repeated-block']\\")
        .forEach((el) => {
          const index = getScope(el, \\"index\\");
          const data = getScope(el, \\"data\\");

          el.key = index;

          el.setAttribute(\\"repeatContext\\", data.context);

          el.setAttribute(\\"block\\", data.block);
        });

      document.querySelectorAll(\\"[data-el='show-4']\\").forEach((el) => {
        const whenCondition =
          !isEmptyHtmlElement(state.tag) && !state.repeatItemData;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='for-2']\\").forEach((el) => {
        let array = state.childrenWithoutParentComponent;
        renderLoop(el, array, \\"child\\");
      });

      document.querySelectorAll(\\"[data-el='render-block']\\").forEach((el) => {
        const child = getScope(el, \\"child\\");

        el.key = \\"render-block-\\" + child.id;

        el.setAttribute(\\"block\\", child);

        el.setAttribute(\\"context\\", state.childrenContext);
      });

      document.querySelectorAll(\\"[data-el='for-3']\\").forEach((el) => {
        let array = state.childrenWithoutParentComponent;
        renderLoop(el, array, \\"child\\");
      });

      document.querySelectorAll(\\"[data-el='block-styles']\\").forEach((el) => {
        const child = getScope(el, \\"child\\");

        el.key = \\"block-style-\\" + child.id;

        el.setAttribute(\\"block\\", child);

        el.setAttribute(\\"context\\", state.childrenContext);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > renderContentExample 1`] = `
"<div class=\\"div\\" data-el=\\"div-1\\">
  <RenderBlocks data-el=\\"render-blocks\\"></RenderBlocks>
</div>
<style>
  .div {
    display: flex;
    flex-direction: columns;
  }
</style>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onDiv1Click);
        el.addEventListener(\\"click\\", onDiv1Click);
      });

      document.querySelectorAll(\\"[data-el='render-blocks']\\").forEach((el) => {
        el.setAttribute(\\"blocks\\", props.content.blocks);
      });

      destroyAnyNodes();

      dispatchNewContentToVisualEditor(props.content);

      pendingUpdate = false;
    }

    // Event handler for 'click' event on div-1
    function onDiv1Click(event) {
      trackClick(props.content.id);
    }

    // Update with initial state on first load
    update();

    // onMount
    sendComponentsToVisualEditor(props.customComponents);
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > rootFragmentMultiNode 1`] = `
"<template data-el=\\"show\\">
  <a data-el=\\"a-1\\">
    <template data-el=\\"div-1\\"><!-- props.text --></template>
  </a>
</template>
<template data-el=\\"show-2\\">
  <button type=\\"button\\" data-el=\\"button-1\\">
    <template data-el=\\"div-2\\"><!-- props.text --></template>
  </button>
</template>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='a-1']\\").forEach((el) => {
        el.setAttribute(\\"href\\", props.link);

        el.setAttribute(
          \\"target\\",
          props.openLinkInNewTab ? \\"_blank\\" : undefined
        );
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      document.querySelectorAll(\\"[data-el='show-2']\\").forEach((el) => {
        const whenCondition = !props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > rootShow 1`] = `
"<template data-el=\\"show\\"><div>Bar</div></template>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.foo === \\"bar\\";
        if (whenCondition) {
          showContent(el);
        }
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > self-referencing component 1`] = `
"<div>
  <template data-el=\\"div-1\\"><!-- props.name --></template>
  <template data-el=\\"show\\">
    <MyComponent name=\\"Bruce Wayne\\"></MyComponent>
  </template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.name);
      });

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.name === \\"Batman\\";
        if (whenCondition) {
          showContent(el);
        }
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > self-referencing component with children 1`] = `
"<div>
  <template data-el=\\"div-1\\"><!-- props.name --></template>
  <slot></slot>
  <template data-el=\\"show\\">
    <MyComponent name=\\"Bruce\\"><div>Wayne</div></MyComponent>
  </template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.name);
      });

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.name === \\"Batman\\";
        if (whenCondition) {
          showContent(el);
        }
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > showExpressions 1`] = `
"<div>
  <template data-el=\\"show\\">Content0</template>
  <template data-el=\\"show-2\\">ContentA</template>
  <template data-el=\\"show-3\\"></template>
  <template data-el=\\"show-4\\">ContentB</template>
  <template data-el=\\"show-5\\">
    <template data-el=\\"div-1\\"><!-- undefined --></template>
  </template>
  <template data-el=\\"show-6\\">ContentC</template>
  <template data-el=\\"show-7\\"></template>
  <template data-el=\\"show-8\\">ContentD</template>
  <template data-el=\\"show-9\\"></template>
  <template data-el=\\"show-10\\">ContentE</template>
  <template data-el=\\"show-11\\">hello</template>
  <template data-el=\\"show-12\\">ContentF</template>
  <template data-el=\\"show-13\\">123</template>
  <template data-el=\\"show-14\\">4mb</template>
  <template data-el=\\"show-15\\">
    <template data-el=\\"show-16\\">20mb</template>
  </template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-2']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-3']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-4']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-5']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, undefined);
      });

      document.querySelectorAll(\\"[data-el='show-6']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-7']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-8']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-9']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-10']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-11']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-12']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-13']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-14']\\").forEach((el) => {
        const whenCondition = props.conditionA === \\"Default\\";
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-15']\\").forEach((el) => {
        const whenCondition = props.conditionA === \\"Default\\";
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-16']\\").forEach((el) => {
        const whenCondition = props.conditionB === \\"Complete\\";
        if (whenCondition) {
          showContent(el);
        }
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > showWithFor 1`] = `
"<template data-el=\\"show\\">
  <template data-el=\\"for\\">
    <div data-el=\\"div-1\\">
      <template data-el=\\"div-2\\"><!-- item --></template>
    </div>
  </template>
</template>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = props.items;
        renderLoop(el, array, \\"item\\", \\"idx\\");
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        const idx = getScope(el, \\"idx\\");

        el.key = idx;
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        const item = getScope(el, \\"item\\");
        renderTextNode(el, item);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > showWithOtherValues 1`] = `
"<div>
  <template data-el=\\"show\\">ContentA</template>
  <template data-el=\\"show-2\\">ContentB</template>
  <template data-el=\\"show-3\\">ContentC</template>
  <template data-el=\\"show-4\\">ContentD</template>
  <template data-el=\\"show-5\\">ContentE</template>
  <template data-el=\\"show-6\\">ContentF</template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-2']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-3']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-4']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-5']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-6']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > showWithRootText 1`] = `
"<template data-el=\\"show\\">ContentA</template>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > signalsOnUpdate 1`] = `
"<div class=\\"test div\\">
  <template data-el=\\"div-1\\"><!-- props.id --></template>
  <template data-el=\\"div-2\\"><!-- props.foo.bar.baz --></template>
</div>
<style>
  .div {
    padding: 10px;
  }
</style>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.id);
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, props.foo.bar.baz);
      });

      destroyAnyNodes();

      console.log(\\"props.id changed\\", props.id);
      console.log(\\"props.foo.value.bar.baz changed\\", props.foo.bar.baz);

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > spreadAttrs 1`] = `
"<input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
"
`;

exports[`Html > jsx > Typescript Test > spreadNestedProps 1`] = `
"<input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
"
`;

exports[`Html > jsx > Typescript Test > spreadProps 1`] = `
"<input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
"
`;

exports[`Html > jsx > Typescript Test > string-literal-store 1`] = `
"<div>
  <template data-el=\\"div-1\\"><!-- state.foo --></template>
</div>
<script>
  (() => {
    const state = { foo: 123 };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.foo);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > string-literal-store-kebab 1`] = `
"<div>
  <template data-el=\\"div-1\\"><!-- state['foo-bar'] --></template>
</div>
<script>
  (() => {
    const state = { foo-bar: 123,};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;


    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach(el => el.remove());
      nodesToDestroy = [];
    }


    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

          document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {


  renderTextNode(el, state['foo-bar']);
          });


      destroyAnyNodes();



      pendingUpdate = false;
    }



    // Update with initial state on first load
    update();








      // Helper text DOM nodes
      function renderTextNode(el, text) {
        const textNode = document.createTextNode(text);
        if (el?.scope) {
          textNode.scope = el.scope
        }
        if (el?.context) {
          child.context = el.context;
        }
        el.after(textNode);
        nodesToDestroy.push(el.nextSibling);
      }


  })()
</script>
"
`;

exports[`Html > jsx > Typescript Test > styleClassAndCss 1`] = `
"<div class=\\"builder-column div\\" data-el=\\"div-1\\"></div>
<style>
  .div {
    display: flex;
    flex-direction: column;
    align-items: stretch;
  }
</style>
<script>
  (() => {
    const state = {};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        Object.assign(el.style, {
          width: \\"100%\\",
        });
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > stylePropClassAndCss 1`] = `
"<div data-el=\\"div-1\\"></div>
<style>
  .div {
    display: flex;
    flex-direction: column;
    align-items: stretch;
  }
</style>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        Object.assign(el.style, props.attributes.style);

        el.className = props.attributes.class + \\" div\\";
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > subComponent 1`] = `
"<Foo></Foo>
"
`;

exports[`Html > jsx > Typescript Test > svgComponent 1`] = `
"<svg fill=\\"none\\" role=\\"img\\" data-el=\\"svg-1\\">
  <defs>
    <filter id=\\"prefix__filter0_f\\" filterUnits=\\"userSpaceOnUse\\">
      <feFlood result=\\"BackgroundImageFix\\"></feFlood>
      <feBlend
        in=\\"SourceGraphic\\"
        in2=\\"BackgroundImageFix\\"
        result=\\"shape\\"
      ></feBlend>
      <feGaussianBlur
        result=\\"effect1_foregroundBlur\\"
        data-el=\\"fe-gaussian-blur\\"
      ></feGaussianBlur>
    </filter>
  </defs>
</svg>
<script>
  (() => {
    const state = {};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='svg-1']\\").forEach((el) => {
        el.setAttribute(\\"viewBox\\", \\"0 0 \\" + 42 + \\" \\" + 42);

        el.setAttribute(\\"width\\", 42);

        el.setAttribute(\\"height\\", 42);
      });

      document
        .querySelectorAll(\\"[data-el='fe-gaussian-blur']\\")
        .forEach((el) => {
          el.setAttribute(\\"stdDeviation\\", 7);
        });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > typeDependency 1`] = `
"<div>
  <template data-el=\\"div-1\\"><!-- props.foo --></template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.foo);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > use-style 1`] = `
"<button type=\\"button\\">Button</button>
<style>
  button {
    background: blue;
    color: white;
    font-size: 12px;
    outline: 1px solid black;
  }
</style>
"
`;

exports[`Html > jsx > Typescript Test > use-style-and-css 1`] = `
"<button type=\\"button\\" class=\\"button\\">Button</button>
<style>
  button {
    font-size: 12px;
    outline: 1px solid black;
  }

  .button {
    background: blue;
    color: white;
  }
</style>
"
`;

exports[`Html > jsx > Typescript Test > use-style-outside-component 1`] = `
"<button type=\\"button\\">Button</button>
<style>
  button {
    background: blue;
    color: white;
    font-size: 12px;
    outline: 1px solid black;
  }
</style>
"
`;

exports[`Html > jsx > Typescript Test > useTarget 1`] = `
"<div>
  <template data-el=\\"div-1\\"><!-- state.name --></template>
</div>
<script>
  (() => {
    const state = {
      get name() {
        const prefix = \\"h\\";
        return prefix + \\"foo\\";
      },
      lastName: \\"bar\\",
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // onMount

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > jsx > Typescript Test > webComponent 1`] = `
"<swiper-container slides-per-view=\\"3\\" navigation=\\"true\\" pagination=\\"true\\">
  <swiper-slide>Slide 1</swiper-slide>
  <swiper-slide>Slide 2</swiper-slide>
  <swiper-slide>Slide 3</swiper-slide>
</swiper-container>
"
`;

exports[`Html > svelte > Javascript Test > basic 1`] = `
"<div>
  <input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />

  Hello! I can run in React, Vue, Solid, or Liquid!
</div>
<script>
  (() => {
    const state = { name: \\"Steve\\" };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);

        el.value = state.name;
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      state.name = event.target.value;
      update();
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > svelte > Javascript Test > bindGroup 1`] = `
"<div>
  <input
    type=\\"radio\\"
    value=\\"Plain\\"
    data-el=\\"input-1\\"
    data-dom-state=\\"input-2\\"
  />
  <input
    type=\\"radio\\"
    value=\\"Whole wheat\\"
    data-el=\\"input-3\\"
    data-dom-state=\\"input-4\\"
  />
  <input
    type=\\"radio\\"
    value=\\"Spinach\\"
    data-el=\\"input-5\\"
    data-dom-state=\\"input-6\\"
  />
  <br />
  <br />
  <input
    type=\\"checkbox\\"
    value=\\"Rice\\"
    data-el=\\"input-7\\"
    data-dom-state=\\"input-8\\"
  />
  <input
    type=\\"checkbox\\"
    value=\\"Beans\\"
    data-el=\\"input-9\\"
    data-dom-state=\\"input-10\\"
  />
  <input
    type=\\"checkbox\\"
    value=\\"Cheese\\"
    data-el=\\"input-11\\"
    data-dom-state=\\"input-12\\"
  />
  <input
    type=\\"checkbox\\"
    value=\\"Guac (extra)\\"
    data-el=\\"input-13\\"
    data-dom-state=\\"input-14\\"
  />
  <p>
    Tortilla:
    <template data-el=\\"div-1\\"><!-- state.tortilla --></template>
  </p>
  <p>
    Fillings:
    <template data-el=\\"div-2\\"><!-- state.fillings --></template>
  </p>
</div>
<script>
  (() => {
    const state = { tortilla: \\"Plain\\", fillings: [] };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.setAttribute(\\"checked\\", state.tortilla === \\"Plain\\");

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      document.querySelectorAll(\\"[data-el='input-3']\\").forEach((el) => {
        el.setAttribute(\\"checked\\", state.tortilla === \\"Whole wheat\\");

        el.removeEventListener(\\"input\\", onInput3Input);
        el.addEventListener(\\"input\\", onInput3Input);
      });

      document.querySelectorAll(\\"[data-el='input-5']\\").forEach((el) => {
        el.setAttribute(\\"checked\\", state.tortilla === \\"Spinach\\");

        el.removeEventListener(\\"input\\", onInput5Input);
        el.addEventListener(\\"input\\", onInput5Input);
      });

      document.querySelectorAll(\\"[data-el='input-7']\\").forEach((el) => {
        el.setAttribute(\\"checked\\", state.fillings === \\"Rice\\");

        el.removeEventListener(\\"input\\", onInput7Input);
        el.addEventListener(\\"input\\", onInput7Input);
      });

      document.querySelectorAll(\\"[data-el='input-9']\\").forEach((el) => {
        el.setAttribute(\\"checked\\", state.fillings === \\"Beans\\");

        el.removeEventListener(\\"input\\", onInput9Input);
        el.addEventListener(\\"input\\", onInput9Input);
      });

      document.querySelectorAll(\\"[data-el='input-11']\\").forEach((el) => {
        el.setAttribute(\\"checked\\", state.fillings === \\"Cheese\\");

        el.removeEventListener(\\"input\\", onInput11Input);
        el.addEventListener(\\"input\\", onInput11Input);
      });

      document.querySelectorAll(\\"[data-el='input-13']\\").forEach((el) => {
        el.setAttribute(\\"checked\\", state.fillings === \\"Guac (extra)\\");

        el.removeEventListener(\\"input\\", onInput13Input);
        el.addEventListener(\\"input\\", onInput13Input);
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.tortilla);
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, state.fillings);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      state.tortilla = event.target.value;
      update();
    }

    // Event handler for 'input' event on input-3
    function onInput3Input(event) {
      state.tortilla = event.target.value;
      update();
    }

    // Event handler for 'input' event on input-5
    function onInput5Input(event) {
      state.tortilla = event.target.value;
      update();
    }

    // Event handler for 'input' event on input-7
    function onInput7Input(event) {
      state.fillings = event.target.value;
      update();
    }

    // Event handler for 'input' event on input-9
    function onInput9Input(event) {
      state.fillings = event.target.value;
      update();
    }

    // Event handler for 'input' event on input-11
    function onInput11Input(event) {
      state.fillings = event.target.value;
      update();
    }

    // Event handler for 'input' event on input-13
    function onInput13Input(event) {
      state.fillings = event.target.value;
      update();
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > svelte > Javascript Test > bindProperty 1`] = `
"<input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
<script>
  (() => {
    const state = { value: \\"hello\\" };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = state.value;
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > svelte > Javascript Test > classDirective 1`] = `
"<input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
<script>
  (() => {
    const state = { focus: true };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.className = \`form-input \${props.disabled ? \\"disabled\\" : \\"\\"} \${
          state.focus ? \\"focus\\" : \\"\\"
        }\`;
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > svelte > Javascript Test > context 1`] = `
"<div>
  <template data-el=\\"div-1\\"><!-- state.activeTab --></template>
</div>
<script>
  (() => {
    const state = { activeTab: 0 };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.activeTab);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > svelte > Javascript Test > each 1`] = `
"<ul>
  <template data-el=\\"for\\">
    <li>
      <template data-el=\\"div-1\\"><!-- num --></template>
    </li>
  </template>
</ul>
<script>
  (() => {
    const state = { numbers: [\\"one\\", \\"two\\", \\"three\\"] };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = state.numbers;
        renderLoop(el, array, \\"num\\");
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        const num = getScope(el, \\"num\\");
        renderTextNode(el, num);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html > svelte > Javascript Test > eventHandlers 1`] = `
"<div>
  <button data-el=\\"button-1\\">Log</button>
  <button data-el=\\"button-2\\">Log</button>
  <button data-el=\\"button-3\\">Log</button>
</div>
<script>
  (() => {
    const state = {
      log: function log(msg = \\"hello\\") {
        console.log(msg);
      },
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='button-1']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton1Click);
        el.addEventListener(\\"click\\", onButton1Click);
      });

      document.querySelectorAll(\\"[data-el='button-2']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton2Click);
        el.addEventListener(\\"click\\", onButton2Click);
      });

      document.querySelectorAll(\\"[data-el='button-3']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton3Click);
        el.addEventListener(\\"click\\", onButton3Click);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'click' event on button-1
    function onButton1Click(a) {
      state.log(\\"hi\\");
    }

    // Event handler for 'click' event on button-2
    function onButton2Click(event) {
      state.log(event);
    }

    // Event handler for 'click' event on button-3
    function onButton3Click(event) {
      state.log(event);
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > svelte > Javascript Test > html 1`] = `
"<div data-el=\\"div-1\\"></div>
<script>
  (() => {
    const state = { html: \\"<b>bold</b>\\" };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.innerHTML = state.html;
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > svelte > Javascript Test > ifElse 1`] = `
"<template data-el=\\"show\\"><button data-el=\\"button-1\\">Hide</button></template>
<script>
  (() => {
    const state = {
      show: true,
      toggle: function toggle() {
        state.show = !state.show;
        update();
      },
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = state.show;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='button-1']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton1Click);
        el.addEventListener(\\"click\\", onButton1Click);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'click' event on button-1
    function onButton1Click(event) {
      state.toggle(event);
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }
  })();
</script>
"
`;

exports[`Html > svelte > Javascript Test > imports 1`] = `
"<div>
  <button type=\\"button\\" data-el=\\"button\\"><slot></slot></button>
</div>
<script>
  (() => {
    const state = { disabled: false };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='button']\\").forEach((el) => {
        el.setAttribute(\\"disabled\\", state.disabled);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > svelte > Javascript Test > lifecycleHooks 1`] = `
"<div></div>
<script>
  (() => {
    const state = {};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // onMount
    console.log(\\"onMount\\");
  })();
</script>
"
`;

exports[`Html > svelte > Javascript Test > reactive 1`] = `
"<div>
  <input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />

  Lowercase:
  <template data-el=\\"div-1\\"><!-- state.lowercaseName --></template>
</div>
<script>
  (() => {
    const state = {
      name: \\"Steve\\",
      get lowercaseName() {
        return state.name.toLowerCase();
      },
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = state.name;
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.lowercaseName);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > svelte > Javascript Test > reactiveWithFn 1`] = `
"<div>
  <input type=\\"number\\" data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
  <input type=\\"number\\" data-el=\\"input-3\\" data-dom-state=\\"input-4\\" />

  Result:
  <template data-el=\\"div-1\\"><!-- state.result --></template>
</div>
<script>
  (() => {
    const state = {
      a: 2,
      b: 5,
      result: null,
      calculateResult: function calculateResult(a_, b_) {
        state.result = a_ * b_;
        update();
      },
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);

        el.value = state.a;
      });

      document.querySelectorAll(\\"[data-el='input-3']\\").forEach((el) => {
        el.removeEventListener(\\"input\\", onInput3Input);
        el.addEventListener(\\"input\\", onInput3Input);

        el.value = state.b;
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.result);
      });

      destroyAnyNodes();

      state.calculateResult(state.a, state.b);

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      state.a = event.target.value;
      update();
    }

    // Event handler for 'input' event on input-3
    function onInput3Input(event) {
      state.b = event.target.value;
      update();
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > svelte > Javascript Test > slots 1`] = `
"<div>
  <slot>default</slot>
  <slot name=\\"Test\\"><div>default</div></slot>
</div>
"
`;

exports[`Html > svelte > Javascript Test > style 1`] = `
"<input class=\\"form-input\\" data-dom-state=\\"input-1\\" />
<style>
  input {
    color: red;
    font-size: 12px;
  }

  .form-input:focus {
    outline: 1px solid blue;
  }
</style>
"
`;

exports[`Html > svelte > Javascript Test > textExpressions 1`] = `
"<div>
  normal:

  <template data-el=\\"div-1\\"><!-- state.a + state.b --></template>
  <br />

  conditional

  <template data-el=\\"div-2\\"><!-- state.a > 2 ? 'hello' : 'bye' --></template>
</div>
<script>
  (() => {
    const state = { a: 5, b: 12 };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.a + state.b);
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, state.a > 2 ? \\"hello\\" : \\"bye\\");
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > svelte > Typescript Test > basic 1`] = `
"<div>
  <input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />

  Hello! I can run in React, Vue, Solid, or Liquid!
</div>
<script>
  (() => {
    const state = { name: \\"Steve\\" };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);

        el.value = state.name;
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      state.name = event.target.value;
      update();
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > svelte > Typescript Test > bindGroup 1`] = `
"<div>
  <input
    type=\\"radio\\"
    value=\\"Plain\\"
    data-el=\\"input-1\\"
    data-dom-state=\\"input-2\\"
  />
  <input
    type=\\"radio\\"
    value=\\"Whole wheat\\"
    data-el=\\"input-3\\"
    data-dom-state=\\"input-4\\"
  />
  <input
    type=\\"radio\\"
    value=\\"Spinach\\"
    data-el=\\"input-5\\"
    data-dom-state=\\"input-6\\"
  />
  <br />
  <br />
  <input
    type=\\"checkbox\\"
    value=\\"Rice\\"
    data-el=\\"input-7\\"
    data-dom-state=\\"input-8\\"
  />
  <input
    type=\\"checkbox\\"
    value=\\"Beans\\"
    data-el=\\"input-9\\"
    data-dom-state=\\"input-10\\"
  />
  <input
    type=\\"checkbox\\"
    value=\\"Cheese\\"
    data-el=\\"input-11\\"
    data-dom-state=\\"input-12\\"
  />
  <input
    type=\\"checkbox\\"
    value=\\"Guac (extra)\\"
    data-el=\\"input-13\\"
    data-dom-state=\\"input-14\\"
  />
  <p>
    Tortilla:
    <template data-el=\\"div-1\\"><!-- state.tortilla --></template>
  </p>
  <p>
    Fillings:
    <template data-el=\\"div-2\\"><!-- state.fillings --></template>
  </p>
</div>
<script>
  (() => {
    const state = { tortilla: \\"Plain\\", fillings: [] };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.setAttribute(\\"checked\\", state.tortilla === \\"Plain\\");

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      document.querySelectorAll(\\"[data-el='input-3']\\").forEach((el) => {
        el.setAttribute(\\"checked\\", state.tortilla === \\"Whole wheat\\");

        el.removeEventListener(\\"input\\", onInput3Input);
        el.addEventListener(\\"input\\", onInput3Input);
      });

      document.querySelectorAll(\\"[data-el='input-5']\\").forEach((el) => {
        el.setAttribute(\\"checked\\", state.tortilla === \\"Spinach\\");

        el.removeEventListener(\\"input\\", onInput5Input);
        el.addEventListener(\\"input\\", onInput5Input);
      });

      document.querySelectorAll(\\"[data-el='input-7']\\").forEach((el) => {
        el.setAttribute(\\"checked\\", state.fillings === \\"Rice\\");

        el.removeEventListener(\\"input\\", onInput7Input);
        el.addEventListener(\\"input\\", onInput7Input);
      });

      document.querySelectorAll(\\"[data-el='input-9']\\").forEach((el) => {
        el.setAttribute(\\"checked\\", state.fillings === \\"Beans\\");

        el.removeEventListener(\\"input\\", onInput9Input);
        el.addEventListener(\\"input\\", onInput9Input);
      });

      document.querySelectorAll(\\"[data-el='input-11']\\").forEach((el) => {
        el.setAttribute(\\"checked\\", state.fillings === \\"Cheese\\");

        el.removeEventListener(\\"input\\", onInput11Input);
        el.addEventListener(\\"input\\", onInput11Input);
      });

      document.querySelectorAll(\\"[data-el='input-13']\\").forEach((el) => {
        el.setAttribute(\\"checked\\", state.fillings === \\"Guac (extra)\\");

        el.removeEventListener(\\"input\\", onInput13Input);
        el.addEventListener(\\"input\\", onInput13Input);
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.tortilla);
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, state.fillings);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      state.tortilla = event.target.value;
      update();
    }

    // Event handler for 'input' event on input-3
    function onInput3Input(event) {
      state.tortilla = event.target.value;
      update();
    }

    // Event handler for 'input' event on input-5
    function onInput5Input(event) {
      state.tortilla = event.target.value;
      update();
    }

    // Event handler for 'input' event on input-7
    function onInput7Input(event) {
      state.fillings = event.target.value;
      update();
    }

    // Event handler for 'input' event on input-9
    function onInput9Input(event) {
      state.fillings = event.target.value;
      update();
    }

    // Event handler for 'input' event on input-11
    function onInput11Input(event) {
      state.fillings = event.target.value;
      update();
    }

    // Event handler for 'input' event on input-13
    function onInput13Input(event) {
      state.fillings = event.target.value;
      update();
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > svelte > Typescript Test > bindProperty 1`] = `
"<input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
<script>
  (() => {
    const state = { value: \\"hello\\" };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = state.value;
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > svelte > Typescript Test > classDirective 1`] = `
"<input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
<script>
  (() => {
    const state = { focus: true };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.className = \`form-input \${props.disabled ? \\"disabled\\" : \\"\\"} \${
          state.focus ? \\"focus\\" : \\"\\"
        }\`;
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > svelte > Typescript Test > context 1`] = `
"<div>
  <template data-el=\\"div-1\\"><!-- state.activeTab --></template>
</div>
<script>
  (() => {
    const state = { activeTab: 0 };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.activeTab);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > svelte > Typescript Test > each 1`] = `
"<ul>
  <template data-el=\\"for\\">
    <li>
      <template data-el=\\"div-1\\"><!-- num --></template>
    </li>
  </template>
</ul>
<script>
  (() => {
    const state = { numbers: [\\"one\\", \\"two\\", \\"three\\"] };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = state.numbers;
        renderLoop(el, array, \\"num\\");
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        const num = getScope(el, \\"num\\");
        renderTextNode(el, num);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html > svelte > Typescript Test > eventHandlers 1`] = `
"<div>
  <button data-el=\\"button-1\\">Log</button>
  <button data-el=\\"button-2\\">Log</button>
  <button data-el=\\"button-3\\">Log</button>
</div>
<script>
  (() => {
    const state = {
      log: function log(msg = \\"hello\\") {
        console.log(msg);
      },
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='button-1']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton1Click);
        el.addEventListener(\\"click\\", onButton1Click);
      });

      document.querySelectorAll(\\"[data-el='button-2']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton2Click);
        el.addEventListener(\\"click\\", onButton2Click);
      });

      document.querySelectorAll(\\"[data-el='button-3']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton3Click);
        el.addEventListener(\\"click\\", onButton3Click);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'click' event on button-1
    function onButton1Click(a) {
      state.log(\\"hi\\");
    }

    // Event handler for 'click' event on button-2
    function onButton2Click(event) {
      state.log(event);
    }

    // Event handler for 'click' event on button-3
    function onButton3Click(event) {
      state.log(event);
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > svelte > Typescript Test > html 1`] = `
"<div data-el=\\"div-1\\"></div>
<script>
  (() => {
    const state = { html: \\"<b>bold</b>\\" };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.innerHTML = state.html;
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > svelte > Typescript Test > ifElse 1`] = `
"<template data-el=\\"show\\"><button data-el=\\"button-1\\">Hide</button></template>
<script>
  (() => {
    const state = {
      show: true,
      toggle: function toggle() {
        state.show = !state.show;
        update();
      },
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = state.show;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='button-1']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton1Click);
        el.addEventListener(\\"click\\", onButton1Click);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'click' event on button-1
    function onButton1Click(event) {
      state.toggle(event);
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }
  })();
</script>
"
`;

exports[`Html > svelte > Typescript Test > imports 1`] = `
"<div>
  <button type=\\"button\\" data-el=\\"button\\"><slot></slot></button>
</div>
<script>
  (() => {
    const state = { disabled: false };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='button']\\").forEach((el) => {
        el.setAttribute(\\"disabled\\", state.disabled);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html > svelte > Typescript Test > lifecycleHooks 1`] = `
"<div></div>
<script>
  (() => {
    const state = {};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // onMount
    console.log(\\"onMount\\");
  })();
</script>
"
`;

exports[`Html > svelte > Typescript Test > reactive 1`] = `
"<div>
  <input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />

  Lowercase:
  <template data-el=\\"div-1\\"><!-- state.lowercaseName --></template>
</div>
<script>
  (() => {
    const state = {
      name: \\"Steve\\",
      get lowercaseName() {
        return state.name.toLowerCase();
      },
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = state.name;
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.lowercaseName);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > svelte > Typescript Test > reactiveWithFn 1`] = `
"<div>
  <input type=\\"number\\" data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
  <input type=\\"number\\" data-el=\\"input-3\\" data-dom-state=\\"input-4\\" />

  Result:
  <template data-el=\\"div-1\\"><!-- state.result --></template>
</div>
<script>
  (() => {
    const state = {
      a: 2,
      b: 5,
      result: null,
      calculateResult: function calculateResult(a_, b_) {
        state.result = a_ * b_;
        update();
      },
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);

        el.value = state.a;
      });

      document.querySelectorAll(\\"[data-el='input-3']\\").forEach((el) => {
        el.removeEventListener(\\"input\\", onInput3Input);
        el.addEventListener(\\"input\\", onInput3Input);

        el.value = state.b;
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.result);
      });

      destroyAnyNodes();

      state.calculateResult(state.a, state.b);

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      state.a = event.target.value;
      update();
    }

    // Event handler for 'input' event on input-3
    function onInput3Input(event) {
      state.b = event.target.value;
      update();
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html > svelte > Typescript Test > slots 1`] = `
"<div>
  <slot>default</slot>
  <slot name=\\"Test\\"><div>default</div></slot>
</div>
"
`;

exports[`Html > svelte > Typescript Test > style 1`] = `
"<input class=\\"form-input\\" data-dom-state=\\"input-1\\" />
<style>
  input {
    color: red;
    font-size: 12px;
  }

  .form-input:focus {
    outline: 1px solid blue;
  }
</style>
"
`;

exports[`Html > svelte > Typescript Test > textExpressions 1`] = `
"<div>
  normal:

  <template data-el=\\"div-1\\"><!-- state.a + state.b --></template>
  <br />

  conditional

  <template data-el=\\"div-2\\"><!-- state.a > 2 ? 'hello' : 'bye' --></template>
</div>
<script>
  (() => {
    const state = { a: 5, b: 12 };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.a + state.b);
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, state.a > 2 ? \\"hello\\" : \\"bye\\");
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;
