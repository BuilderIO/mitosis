// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Html Basic 1`] = `
"<div class=\\"test div\\">
  <input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />

  Hello! I can run in React, Vue, Solid, or Liquid!
</div>
<style>
  .div {
    padding: 10px;
  }
</style>
<script>
  (() => {
    const state = {
      name: \\"Steve\\",
      underscore_fn_name() {
        return \\"bar\\";
      },
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = DEFAULT_VALUES.name || state.name;

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(myEvent) {
      state.name = myEvent.target.value;
      update();
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html BasicFor 1`] = `
"<div>
  <template data-el=\\"for\\">
    <input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />

    Hello
    <template data-el=\\"div-1\\"><!-- person --></template>
    ! I can run in Qwik, Web Component, React, Vue, Solid, or Liquid!
  </template>
</div>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = state.names;
        renderLoop(el, array, \\"person\\");
      });

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = state.name;

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        const person = getScope(el, \\"person\\");
        renderTextNode(el, person);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      const person = getScope(event.currentTarget, \\"person\\");

      state.name = event.target.value + \\" and \\" + person;
      update();
    }

    // Update with initial state on first load
    update();

    // onMount
    console.log(\\"onMount code\\");

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Button 1`] = `
"<template data-el=\\"show\\">
  <a data-el=\\"a-1\\">
    <template data-el=\\"div-1\\"><!-- props.text --></template>
  </a>
</template>

<template data-el=\\"show-2\\">
  <button type=\\"button\\" data-el=\\"button-1\\">
    <template data-el=\\"div-2\\"><!-- props.text --></template>
  </button>
</template>

<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='a-1']\\").forEach((el) => {
        el.setAttribute(\\"href\\", props.link);

        el.setAttribute(
          \\"target\\",
          props.openLinkInNewTab ? \\"_blank\\" : undefined
        );
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      document.querySelectorAll(\\"[data-el='show-2']\\").forEach((el) => {
        const whenCondition = !props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Columns 1`] = `
"<div class=\\"builder-columns div\\">
  <template data-el=\\"for\\">
    <div class=\\"builder-column div-2\\">
      <template data-el=\\"div-1\\"><!-- column.content --></template>

      <template data-el=\\"div-2\\"><!-- index --></template>
    </div>
  </template>
</div>
<style>
  .div {
    display: flex;
    flex-direction: column;
    align-items: stretch;
    line-height: normal;
  }
  @media (max-width: 999px) {
    .div {
      flex-direction: row;
    }
  }
  @media (max-width: 639px) {
    .div {
      flex-direction: row-reverse;
    }
  }
  .div-2 {
    flex-grow: 1;
  }
</style>
<script>
  (() => {
    const state = {
      getColumns() {
        return props.columns || [];
      },
      getGutterSize() {
        return typeof props.space === \\"number\\" ? props.space || 0 : 20;
      },
      getWidth(index) {
        const columns = this.getColumns();
        return (columns[index] && columns[index].width) || 100 / columns.length;
      },
      getColumnCssWidth(index) {
        const columns = this.getColumns();
        const gutterSize = this.getGutterSize();
        const subtractWidth =
          (gutterSize * (columns.length - 1)) / columns.length;
        return \`calc(\${this.getWidth(index)}% - \${subtractWidth}px)\`;
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = props.columns;
        renderLoop(el, array, \\"column\\", \\"index\\");
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        const column = getScope(el, \\"column\\");
        renderTextNode(el, column.content);
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        const index = getScope(el, \\"index\\");
        renderTextNode(el, index);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Image 1`] = `
"<picture data-el=\\"picture-1\\" data-ref=\\"undefined-pictureRef\\">
  <template data-el=\\"show\\">
    <img class=\\"img\\" data-el=\\"img-1\\" />
  </template>

  <source data-el=\\"source-1\\" />
</picture>

<slot></slot>

<style>
  .img {
    opacity: 1;
    transition: opacity 0.2s ease-in-out;
    object-fit: cover;
    object-position: center;
  }
</style>
<script>
  (() => {
    const state = {
      scrollListener: null,
      imageLoaded: false,
      setLoaded() {
        state.imageLoaded = true;
        update();
      },
      useLazyLoading() {
        // TODO: Add more checks here, like testing for real web browsers
        return !!props.lazy && isBrowser();
      },
      isBrowser: function isBrowser() {
        return (
          typeof window !== \\"undefined\\" &&
          window.navigator.product != \\"ReactNative\\"
        );
      },
      load: false,
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = !state.useLazyLoading() || state.load;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='img-1']\\").forEach((el) => {
        el.setAttribute(\\"alt\\", props.altText);

        el.setAttribute(
          \\"aria-role\\",
          props.altText ? \\"presentation\\" : undefined
        );

        el.className = \\"builder-image\\" + (props.class ? \\" \\" + props.class : \\"\\");

        el.setAttribute(\\"src\\", props.image);

        el.removeEventListener(\\"load\\", onImg1Load);
        el.addEventListener(\\"load\\", onImg1Load);

        el.setAttribute(\\"srcset\\", props.srcset);

        el.setAttribute(\\"sizes\\", props.sizes);
      });

      document.querySelectorAll(\\"[data-el='source-1']\\").forEach((el) => {
        el.setAttribute(\\"srcset\\", props.srcset);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'load' event on img-1
    function onImg1Load(event) {
      state.setLoaded();
    }

    // Update with initial state on first load
    update();

    // onMount
    if (state.useLazyLoading()) {
      // throttled scroll capture listener
      const listener = () => {
        if (pictureRef) {
          const rect = pictureRef.getBoundingClientRect();
          const buffer = window.innerHeight / 2;

          if (rect.top < window.innerHeight + buffer) {
            setLoad(true);
            state.scrollListener = null;
            update();
            window.removeEventListener(\\"scroll\\", listener);
          }
        }
      };

      state.scrollListener = listener;
      update();
      window.addEventListener(\\"scroll\\", listener, {
        capture: true,
        passive: true,
      });
      listener();
    }

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }
  })();
</script>
"
`;

exports[`Html ImageState 1`] = `
"<div>
  <template data-el=\\"for\\">
    <img data-el=\\"img-1\\" />
  </template>
</div>
<script>
  (() => {
    const state = { canShow: true, images: [\\"http://example.com/qwik.png\\"] };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = state.images;
        renderLoop(el, array, \\"item\\", \\"itemIndex\\");
      });

      document.querySelectorAll(\\"[data-el='img-1']\\").forEach((el) => {
        const item = getScope(el, \\"item\\");
        const itemIndex = getScope(el, \\"itemIndex\\");

        el.className = \\"custom-class\\";

        el.setAttribute(\\"src\\", item);

        el.key = itemIndex;
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Img 1`] = `
"<img data-el=\\"img-1\\" />
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='img-1']\\").forEach((el) => {
        Object.assign(el.style, {
          objectFit: props.backgroundSize || \\"cover\\",
          objectPosition: props.backgroundPosition || \\"center\\",
        });

        el.key = (Builder.isEditing && props.imgSrc) || \\"default-key\\";

        el.setAttribute(\\"alt\\", props.altText);

        el.setAttribute(\\"src\\", props.imgSrc);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Input block 1`] = `
"<input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.key =
          Builder.isEditing && props.defaultValue
            ? props.defaultValue
            : \\"default-key\\";

        el.setAttribute(\\"placeholder\\", props.placeholder);

        el.setAttribute(\\"type\\", props.type);

        el.setAttribute(\\"name\\", props.name);

        el.value = props.value;

        el.setAttribute(\\"defaultValue\\", props.defaultValue);

        el.setAttribute(\\"required\\", props.required);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Section 1`] = `
"<section data-el=\\"section-1\\">
  <slot></slot>
</section>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='section-1']\\").forEach((el) => {
        Object.assign(
          el.style,
          props.maxWidth && typeof props.maxWidth === \\"number\\"
            ? {
                maxWidth: props.maxWidth,
              }
            : undefined
        );
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html SectionState 1`] = `
"<template data-el=\\"show\\">
  <template data-el=\\"for\\">
    <section data-el=\\"section-1\\">
      <slot></slot>
    </section>
  </template>
</template>
<script>
  (() => {
    const state = { max: 42, items: [42] };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = state.max;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = state.items;
        renderLoop(el, array, \\"item\\");
      });

      document.querySelectorAll(\\"[data-el='section-1']\\").forEach((el) => {
        const item = getScope(el, \\"item\\");
        Object.assign(el.style, {
          maxWidth: item + state.max,
        });
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Select block 1`] = `
"<select data-el=\\"select-1\\" data-dom-state=\\"select-2\\">
  <template data-el=\\"for\\">
    <option data-el=\\"option-1\\">
      <template data-el=\\"div-1\\"><!-- option.name || option.value --></template>
    </option>
  </template>
</select>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='select-1']\\").forEach((el) => {
        el.value = props.value;

        el.key =
          Builder.isEditing && props.defaultValue
            ? props.defaultValue
            : \\"default-key\\";

        el.setAttribute(\\"defaultValue\\", props.defaultValue);

        el.setAttribute(\\"name\\", props.name);
      });

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = props.options;
        renderLoop(el, array, \\"option\\", \\"index\\");
      });

      document.querySelectorAll(\\"[data-el='option-1']\\").forEach((el) => {
        const option = getScope(el, \\"option\\");
        const index = getScope(el, \\"index\\");

        el.value = option.value;

        el.setAttribute(\\"data-index\\", index);
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        const option = getScope(el, \\"option\\");
        renderTextNode(el, option.name || option.value);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Shadow DOM 1`] = `
"<div data-el=\\"div-1\\">
  <button data-el=\\"button-1\\">Write a review</button>

  <template data-el=\\"show\\">
    <input placeholder=\\"Email\\" data-dom-state=\\"input-1\\" />

    <input placeholder=\\"Title\\" class=\\"input\\" data-dom-state=\\"input-2\\" />

    <textarea
      placeholder=\\"How was your experience?\\"
      class=\\"textarea\\"
      data-dom-state=\\"textarea-1\\"
    ></textarea>

    <button class=\\"button\\" data-el=\\"button-2\\">Submit</button>
  </template>

  <template data-el=\\"for\\">
    <div class=\\"review\\" data-el=\\"review\\">
      <img class=\\"img\\" data-el=\\"img-1\\" />

      <div data-el=\\"div-2\\">
        <div>
          N:
          <template data-el=\\"div-3\\"><!-- index --></template>
        </div>

        <div>
          <template data-el=\\"div-4\\"><!-- review.author --></template>
        </div>

        <div>
          <template data-el=\\"div-5\\"><!-- review.reviewMessage --></template>
        </div>
      </div>
    </div>
  </template>
</div>
<style>
  .input {
    display: block;
  }
  .textarea {
    display: block;
  }
  .button {
    display: block;
  }
  .review {
    margin: 10px;
    padding: 10px;
    background: white;
    display: flex;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  }
  .img {
    height: 30px;
    width: 30px;
    margin-right: 10px;
  }
</style>
<script>
  (() => {
    const state = { reviews: [], name: \\"test\\", showReviewPrompt: false };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.setAttribute(\\"data-user\\", state.name);
      });

      document.querySelectorAll(\\"[data-el='button-1']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton1Click);
        el.addEventListener(\\"click\\", onButton1Click);
      });

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = state.showReviewPrompt;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='button-2']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton2Click);
        el.addEventListener(\\"click\\", onButton2Click);
      });

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = state.reviews;
        renderLoop(el, array, \\"review\\", \\"index\\");
      });

      document.querySelectorAll(\\"[data-el='review']\\").forEach((el) => {
        const review = getScope(el, \\"review\\");

        el.key = review.id;
      });

      document.querySelectorAll(\\"[data-el='img-1']\\").forEach((el) => {
        const review = getScope(el, \\"review\\");

        el.setAttribute(\\"src\\", review.avatar);
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        el.className = state.showReviewPrompt ? \\"bg-primary\\" : \\"bg-secondary\\";
      });

      document.querySelectorAll(\\"[data-el='div-3']\\").forEach((el) => {
        const index = getScope(el, \\"index\\");
        renderTextNode(el, index);
      });

      document.querySelectorAll(\\"[data-el='div-4']\\").forEach((el) => {
        const review = getScope(el, \\"review\\");
        renderTextNode(el, review.author);
      });

      document.querySelectorAll(\\"[data-el='div-5']\\").forEach((el) => {
        const review = getScope(el, \\"review\\");
        renderTextNode(el, review.reviewMessage);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'click' event on button-1
    function onButton1Click(event) {
      state.showReviewPrompt = true;
      update();
    }

    // Event handler for 'click' event on button-2
    function onButton2Click(event) {
      state.showReviewPrompt = false;
      update();
    }

    // Update with initial state on first load
    update();

    // onMount
    fetch(
      \`https://stamped.io/api/widget/reviews?storeUrl=builder-io.myshopify.com&apiKey=\${
        props.apiKey || \\"pubkey-8bbDq7W6w4sB3OWeM1HUy2s47702hM\\"
      }&productId=\${props.productId || \\"2410511106127\\"}\`
    )
      .then((res) => res.json())
      .then((data) => {
        state.reviews = data.data;
        update();
      });

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Stamped 1`] = `
"<div data-el=\\"div-1\\">
  <button data-el=\\"button-1\\">Write a review</button>

  <template data-el=\\"show\\">
    <input placeholder=\\"Email\\" data-dom-state=\\"input-1\\" />

    <input placeholder=\\"Title\\" class=\\"input\\" data-dom-state=\\"input-2\\" />

    <textarea
      placeholder=\\"How was your experience?\\"
      class=\\"textarea\\"
      data-dom-state=\\"textarea-1\\"
    ></textarea>

    <button class=\\"button\\" data-el=\\"button-2\\">Submit</button>
  </template>

  <template data-el=\\"for\\">
    <div class=\\"review\\" data-el=\\"review\\">
      <img class=\\"img\\" data-el=\\"img-1\\" />

      <div data-el=\\"div-2\\">
        <div>
          N:
          <template data-el=\\"div-3\\"><!-- index --></template>
        </div>

        <div>
          <template data-el=\\"div-4\\"><!-- review.author --></template>
        </div>

        <div>
          <template data-el=\\"div-5\\"><!-- review.reviewMessage --></template>
        </div>
      </div>
    </div>
  </template>
</div>
<style>
  .input {
    display: block;
  }
  .textarea {
    display: block;
  }
  .button {
    display: block;
  }
  .review {
    margin: 10px;
    padding: 10px;
    background: white;
    display: flex;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  }
  .img {
    height: 30px;
    width: 30px;
    margin-right: 10px;
  }
</style>
<script>
  (() => {
    const state = {
      reviews: [],
      name: \\"test\\",
      showReviewPrompt: false,
      kebabCaseValue() {
        return kebabCase(\\"testThat\\");
      },
      snakeCaseValue() {
        return snakeCase(\\"testThis\\");
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.setAttribute(\\"data-user\\", state.name);
      });

      document.querySelectorAll(\\"[data-el='button-1']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton1Click);
        el.addEventListener(\\"click\\", onButton1Click);
      });

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = state.showReviewPrompt;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='button-2']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton2Click);
        el.addEventListener(\\"click\\", onButton2Click);
      });

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = state.reviews;
        renderLoop(el, array, \\"review\\", \\"index\\");
      });

      document.querySelectorAll(\\"[data-el='review']\\").forEach((el) => {
        const review = getScope(el, \\"review\\");

        el.key = review.id;
      });

      document.querySelectorAll(\\"[data-el='img-1']\\").forEach((el) => {
        const review = getScope(el, \\"review\\");

        el.setAttribute(\\"src\\", review.avatar);
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        el.className = state.showReviewPrompt ? \\"bg-primary\\" : \\"bg-secondary\\";
      });

      document.querySelectorAll(\\"[data-el='div-3']\\").forEach((el) => {
        const index = getScope(el, \\"index\\");
        renderTextNode(el, index);
      });

      document.querySelectorAll(\\"[data-el='div-4']\\").forEach((el) => {
        const review = getScope(el, \\"review\\");
        renderTextNode(el, review.author);
      });

      document.querySelectorAll(\\"[data-el='div-5']\\").forEach((el) => {
        const review = getScope(el, \\"review\\");
        renderTextNode(el, review.reviewMessage);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'click' event on button-1
    function onButton1Click(event) {
      state.showReviewPrompt = true;
      update();
    }

    // Event handler for 'click' event on button-2
    function onButton2Click(event) {
      state.showReviewPrompt = false;
      update();
    }

    // Update with initial state on first load
    update();

    // onMount
    fetch(
      \`https://stamped.io/api/widget/reviews?storeUrl=builder-io.myshopify.com&apiKey=\${
        props.apiKey || \\"pubkey-8bbDq7W6w4sB3OWeM1HUy2s47702hM\\"
      }&productId=\${props.productId || \\"2410511106127\\"}\`
    )
      .then((res) => res.json())
      .then((data) => {
        state.reviews = data.data;
        update();
      });

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Submit button block 1`] = `
"<button type=\\"submit\\" data-el=\\"button-1\\">
  <template data-el=\\"div-1\\"><!-- props.text --></template>
</button>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Text 1`] = `
"<div data-el=\\"div-1\\"></div>
<script>
  (() => {
    const state = { name: \\"Decadef20\\" };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.setAttribute(\\"contentEditable\\", allowEditingText || undefined);

        el.setAttribute(\\"data-name\\", {
          test: state.name || \\"any name\\",
        });

        el.innerHTML =
          props.text ||
          props.content ||
          state.name ||
          '<p class=\\"text-lg\\">my name</p>';
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Textarea 1`] = `
"<textarea data-el=\\"textarea-1\\" data-dom-state=\\"textarea-2\\"></textarea>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='textarea-1']\\").forEach((el) => {
        el.setAttribute(\\"placeholder\\", props.placeholder);

        el.setAttribute(\\"name\\", props.name);

        el.value = props.value;

        el.setAttribute(\\"defaultValue\\", props.defaultValue);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Video 1`] = `
"<video preload=\\"none\\" data-el=\\"video-1\\"></video>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='video-1']\\").forEach((el) => {
        Object.assign(el.style, {
          width: \\"100%\\",
          height: \\"100%\\",
          ...props.attributes?.style,
          objectFit: props.fit,
          objectPosition: props.position,
          // Hack to get object fit to work as expected and
          // not have the video overflow
          borderRadius: 1,
        });

        el.key = props.video || \\"no-src\\";

        el.setAttribute(\\"poster\\", props.posterImage);

        el.setAttribute(\\"autoplay\\", props.autoPlay);

        el.setAttribute(\\"muted\\", props.muted);

        el.setAttribute(\\"controls\\", props.controls);

        el.setAttribute(\\"loop\\", props.loop);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html className 1`] = `
"<div>
  <div class=\\"no binding\\">Without Binding</div>

  <div data-el=\\"div-1\\">With binding</div>
</div>
<script>
  (() => {
    const state = { bindings: \\"a binding\\" };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.className = state.bindings;
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html multipleOnUpdate 1`] = `
"<div></div>
"
`;

exports[`Html multipleOnnUpdateWithDeps 1`] = `
"<div></div>
"
`;

exports[`Html onMount & onUnMount 1`] = `
"<div></div>
<script>
  (() => {
    const state = {};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // onMount
    console.log(\\"Runs on mount\\");
  })();
</script>
"
`;

exports[`Html onUpdate 1`] = `
"<div></div>
"
`;

exports[`Html onUpdateWithDeps 1`] = `
"<div></div>
"
`;
