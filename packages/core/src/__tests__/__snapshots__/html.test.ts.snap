// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Html Javascript Test AdvancedRef 1`] = `
"<div>
  <template data-el=\\"show\\">
    <input
      class=\\"input\\"
      data-el=\\"input-1\\"
      data-dom-state=\\"input-2\\"
      data-ref=\\"undefined-inputRef\\"
    />

    <label for=\\"cars\\" data-el=\\"label-1\\" data-ref=\\"undefined-inputNoArgRef\\">
      Choose a car:
    </label>

    <select name=\\"cars\\" id=\\"cars\\" data-dom-state=\\"select-1\\">
      <option value=\\"supra\\">GR Supra</option>

      <option value=\\"86\\">GR 86</option>
    </select>
  </template>

  Hello

  <template data-el=\\"div-1\\"><!-- state.lowerCaseName() --></template>
  ! I can run in React, Qwik, Vue, Solid, or Web Component!
</div>
<style>
  .input {
    color: red;
  }
</style>
<script>
  (() => {
    const state = {
      name: \\"PatrickJS\\",
      onBlur: function onBlur() {
        // Maintain focus
        inputRef.focus();
      },
      lowerCaseName: function lowerCaseName() {
        return state.name.toLowerCase();
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.showInput;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = state.name;

        el.removeEventListener(\\"blur\\", onInput1Blur);
        el.addEventListener(\\"blur\\", onInput1Blur);

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.lowerCaseName());
      });

      destroyAnyNodes();

      console.log(\\"Received an update\\");

      pendingUpdate = false;
    }

    // Event handler for 'blur' event on input-1
    function onInput1Blur(event) {
      state.onBlur();
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      state.name = event.target.value;
      update();
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Javascript Test Basic 1`] = `
"<div class=\\"test div\\">
  <input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />

  Hello! I can run in React, Vue, Solid, or Liquid!
</div>
<style>
  .div {
    padding: 10px;
  }
</style>
<script>
  (() => {
    const state = {
      name: \\"Steve\\",
      underscore_fn_name() {
        return \\"bar\\";
      },
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = DEFAULT_VALUES.name || state.name;

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(myEvent) {
      state.name = myEvent.target.value;
      update();
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Javascript Test Basic 2`] = `
"<div>
  <template data-el=\\"for\\">
    <template data-el=\\"show\\">
      <input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />

      Hello
      <template data-el=\\"div-1\\"><!-- person --></template>
      ! I can run in Qwik, Web Component, React, Vue, Solid, or Liquid!
    </template>
  </template>
</div>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = state.names;
        renderLoop(el, array, \\"person\\");
      });

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const person = getScope(el, \\"person\\");
        const whenCondition = person === state.name;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = state.name;

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        const person = getScope(el, \\"person\\");
        renderTextNode(el, person);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      const person = getScope(event.currentTarget, \\"person\\");

      state.name = event.target.value + \\" and \\" + person;
      update();
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Javascript Test Basic Context 1`] = `
"<div>
  <template data-el=\\"div-1\\">
    <!-- myService.method('hello') + state.name -->
  </template>

  Hello! I can run in React, Vue, Solid, or Liquid!

  <input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
</div>
<script>
  (() => {
    const state = {
      name: \\"PatrickJS\\",
      onChange: function onChange() {
        const change = myService.method(\\"change\\");
        console.log(change);
      },
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;
    let onInitOnce = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, myService.method(\\"hello\\") + state.name);
      });

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      state.onChange;
    }

    // Update with initial state on first load
    update();

    if (!onInitOnce) {
      const hi = myService.method(\\"hi\\");
      console.log(hi);
      onInitOnce = true;
    }

    // onMount
    const bye = myService.method(\\"hi\\");
    console.log(bye);

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Javascript Test Basic OnMount Update 1`] = `
"<div>
  Hello
  <template data-el=\\"div-1\\"><!-- state.name --></template>
</div>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;
    let onInitOnce = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    if (!onInitOnce) {
      state.name = \\"PatrickJS onInit\\" + props.hi;
      update();
      onInitOnce = true;
    }

    // onMount
    state.name = \\"PatrickJS onMount\\" + props.bye;
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Javascript Test Basic Outputs 1`] = `
"<div></div>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\" };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // onMount
    props.onMessage(state.name);
    props.onEvent(props.message);
  })();
</script>
"
`;

exports[`Html Javascript Test Basic Outputs Meta 1`] = `
"<div></div>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\" };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // onMount
    props.onMessage(state.name);
    props.onEvent(props.message);
  })();
</script>
"
`;

exports[`Html Javascript Test BasicAttribute 1`] = `
"<input
  autocapitalize=\\"on\\"
  autocomplete=\\"on\\"
  data-el=\\"input-1\\"
  data-dom-state=\\"input-2\\"
/>
<script>
  (() => {
    const state = {};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.setAttribute(\\"spellcheck\\", true);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Javascript Test BasicBooleanAttribute 1`] = `
"<div>
  <slot></slot>

  <template data-el=\\"div-2\\"><!-- props.type --></template>

  <MyBooleanAttributeComponent
    data-el=\\"my-boolean-attribute-component\\"
  ></MyBooleanAttributeComponent>

  <MyBooleanAttributeComponent
    data-el=\\"my-boolean-attribute-component-2\\"
  ></MyBooleanAttributeComponent>

  <MyBooleanAttributeComponent
    data-el=\\"my-boolean-attribute-component-3\\"
  ></MyBooleanAttributeComponent>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, props.type);
      });

      document
        .querySelectorAll(\\"[data-el='my-boolean-attribute-component']\\")
        .forEach((el) => {
          el.setAttribute(\\"toggle\\", true);
        });

      document
        .querySelectorAll(\\"[data-el='my-boolean-attribute-component-2']\\")
        .forEach((el) => {
          el.setAttribute(\\"toggle\\", true);
        });

      document
        .querySelectorAll(\\"[data-el='my-boolean-attribute-component-3']\\")
        .forEach((el) => {
          el.setAttribute(\\"list\\", null);
        });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Javascript Test BasicChildComponent 1`] = `
"<div>
  <MyBasicComponent data-el=\\"my-basic-component\\"></MyBasicComponent>

  <div>
    <MyBasicOnMountUpdateComponent
      data-el=\\"my-basic-on-mount-update-component\\"
    ></MyBasicOnMountUpdateComponent>
  </div>
</div>
<script>
  (() => {
    const state = { name: \\"Steve\\", dev: \\"PatrickJS\\" };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document
        .querySelectorAll(\\"[data-el='my-basic-component']\\")
        .forEach((el) => {
          el.setAttribute(\\"id\\", state.dev);
        });

      document
        .querySelectorAll(\\"[data-el='my-basic-on-mount-update-component']\\")
        .forEach((el) => {
          el.setAttribute(\\"hi\\", state.name);

          el.setAttribute(\\"bye\\", state.dev);
        });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Javascript Test BasicFor 1`] = `
"<div>
  <template data-el=\\"for\\">
    <input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />

    Hello
    <template data-el=\\"div-1\\"><!-- person --></template>
    ! I can run in Qwik, Web Component, React, Vue, Solid, or Liquid!
  </template>
</div>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = state.names;
        renderLoop(el, array, \\"person\\");
      });

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = state.name;

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        const person = getScope(el, \\"person\\");
        renderTextNode(el, person);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      const person = getScope(event.currentTarget, \\"person\\");

      state.name = event.target.value + \\" and \\" + person;
      update();
    }

    // Update with initial state on first load
    update();

    // onMount
    console.log(\\"onMount code\\");

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Javascript Test BasicRef 1`] = `
"<div>
  <template data-el=\\"show\\">
    <input
      class=\\"input\\"
      data-el=\\"input-1\\"
      data-dom-state=\\"input-2\\"
      data-ref=\\"undefined-inputRef\\"
    />

    <label for=\\"cars\\" data-el=\\"label-1\\" data-ref=\\"undefined-inputNoArgRef\\">
      Choose a car:
    </label>

    <select name=\\"cars\\" id=\\"cars\\" data-dom-state=\\"select-1\\">
      <option value=\\"supra\\">GR Supra</option>

      <option value=\\"86\\">GR 86</option>
    </select>
  </template>

  Hello

  <template data-el=\\"div-1\\"><!-- state.lowerCaseName() --></template>
  ! I can run in React, Qwik, Vue, Solid, or Web Component!
</div>
<style>
  .input {
    color: red;
  }
</style>
<script>
  (() => {
    const state = {
      name: \\"PatrickJS\\",
      onBlur: function onBlur() {
        // Maintain focus
        inputRef.focus();
      },
      lowerCaseName: function lowerCaseName() {
        return state.name.toLowerCase();
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.showInput;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = state.name;

        el.removeEventListener(\\"blur\\", onInput1Blur);
        el.addEventListener(\\"blur\\", onInput1Blur);

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.lowerCaseName());
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'blur' event on input-1
    function onInput1Blur(event) {
      state.onBlur();
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      state.name = event.target.value;
      update();
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Javascript Test BasicRefAssignment 1`] = `
"<div>
  <button data-el=\\"button-1\\">Click</button>
</div>
<script>
  (() => {
    const state = {
      handlerClick: function handlerClick(event) {
        event.preventDefault();
        console.log(\\"current value\\", holdValueRef);
        holdValueRef = holdValueRef + \\"JS\\";
      },
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='button-1']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton1Click);
        el.addEventListener(\\"click\\", onButton1Click);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'click' event on button-1
    function onButton1Click(evt) {
      state.handlerClick(evt);
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Javascript Test BasicRefPrevious 1`] = `
"<div>
  <h1>
    Now:
    <template data-el=\\"div-1\\"><!-- state.count --></template>
    , before:
    <template data-el=\\"div-2\\"><!-- prevCount --></template>
  </h1>

  <button data-el=\\"button-1\\">Increment</button>
</div>
<script>
  (() => {
    const state = { count: 0 };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.count);
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, prevCount);
      });

      document.querySelectorAll(\\"[data-el='button-1']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton1Click);
        el.addEventListener(\\"click\\", onButton1Click);
      });

      destroyAnyNodes();

      prevCount = state.count;

      pendingUpdate = false;
    }

    // Event handler for 'click' event on button-1
    function onButton1Click(event) {
      state.count += 1;
      update();
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Javascript Test Button 1`] = `
"<div>
  <template data-el=\\"show\\">
    <a data-el=\\"a-1\\">
      <template data-el=\\"div-1\\"><!-- props.text --></template>
    </a>
  </template>

  <template data-el=\\"show-2\\">
    <button type=\\"button\\" data-el=\\"button-1\\">
      <template data-el=\\"div-2\\"><!-- props.text --></template>
    </button>
  </template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='a-1']\\").forEach((el) => {
        el.setAttribute(\\"href\\", props.link);

        el.setAttribute(
          \\"target\\",
          props.openLinkInNewTab ? \\"_blank\\" : undefined
        );
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      document.querySelectorAll(\\"[data-el='show-2']\\").forEach((el) => {
        const whenCondition = !props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Javascript Test Columns 1`] = `
"<div class=\\"builder-columns div\\">
  <template data-el=\\"for\\">
    <div class=\\"builder-column div-2\\">
      <template data-el=\\"div-1\\"><!-- column.content --></template>

      <template data-el=\\"div-2\\"><!-- index --></template>
    </div>
  </template>
</div>
<style>
  .div {
    display: flex;
    flex-direction: column;
    align-items: stretch;
    line-height: normal;
  }
  @media (max-width: 999px) {
    .div {
      flex-direction: row;
    }
  }
  @media (max-width: 639px) {
    .div {
      flex-direction: row-reverse;
    }
  }
  .div-2 {
    flex-grow: 1;
  }
</style>
<script>
  (() => {
    const state = {
      getColumns() {
        return props.columns || [];
      },
      getGutterSize() {
        return typeof props.space === \\"number\\" ? props.space || 0 : 20;
      },
      getWidth(index) {
        const columns = state.getColumns();
        return (columns[index] && columns[index].width) || 100 / columns.length;
      },
      getColumnCssWidth(index) {
        const columns = state.getColumns();
        const gutterSize = state.getGutterSize();
        const subtractWidth =
          (gutterSize * (columns.length - 1)) / columns.length;
        return \`calc(\${state.getWidth(index)}% - \${subtractWidth}px)\`;
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = props.columns;
        renderLoop(el, array, \\"column\\", \\"index\\");
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        const column = getScope(el, \\"column\\");
        renderTextNode(el, column.content);
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        const index = getScope(el, \\"index\\");
        renderTextNode(el, index);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Javascript Test ContentSlotHtml 1`] = `
"<div>
  <slot data-el=\\"slot\\"></slot>

  <div>
    <hr />
  </div>

  <div>
    <slot></slot>
  </div>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='slot']\\").forEach((el) => {
        el.setAttribute(\\"name\\", props.slotTesting);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Javascript Test ContentSlotJSX 1`] = `
"<div>
  <template data-el=\\"show\\">
    <div>
      <template data-el=\\"div-1\\"><!-- props.slotTesting --></template>
    </div>
  </template>

  <div>
    <hr />
  </div>

  <div><slot></slot></div>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.slotTesting;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.slotTesting);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Javascript Test CustomCode 1`] = `
"<div data-el=\\"div-1\\" data-ref=\\"undefined-elem\\"></div>
<script>
  (() => {
    const state = {
      scriptsInserted: [],
      scriptsRun: [],
      findAndRunScripts() {
        // TODO: Move this function to standalone one in '@builder.io/utils'
        if (elem && typeof window !== \\"undefined\\") {
          /** @type {HTMLScriptElement[]} */
          const scripts = elem.getElementsByTagName(\\"script\\");

          for (let i = 0; i < scripts.length; i++) {
            const script = scripts[i];

            if (script.src) {
              if (state.scriptsInserted.includes(script.src)) {
                continue;
              }

              state.scriptsInserted.push(script.src);
              const newScript = document.createElement(\\"script\\");
              newScript.async = true;
              newScript.src = script.src;
              document.head.appendChild(newScript);
            } else if (
              !script.type ||
              [
                \\"text/javascript\\",
                \\"application/javascript\\",
                \\"application/ecmascript\\",
              ].includes(script.type)
            ) {
              if (state.scriptsRun.includes(script.innerText)) {
                continue;
              }

              try {
                state.scriptsRun.push(script.innerText);
                new Function(script.innerText)();
              } catch (error) {
                console.warn(\\"\`CustomCode\`: Error running script:\\", error);
              }
            }
          }
        }
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.className =
          \\"builder-custom-code\\" + (props.replaceNodes ? \\" replace-nodes\\" : \\"\\");

        el.innerHTML = props.code;
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // onMount
    state.findAndRunScripts();
  })();
</script>
"
`;

exports[`Html Javascript Test Embed 1`] = `
"<div data-el=\\"div-1\\" data-ref=\\"undefined-elem\\"></div>
<script>
  (() => {
    const state = {
      scriptsInserted: [],
      scriptsRun: [],
      findAndRunScripts() {
        // TODO: Move this function to standalone one in '@builder.io/utils'
        if (elem && typeof window !== \\"undefined\\") {
          /** @type {HTMLScriptElement[]} */
          const scripts = elem.getElementsByTagName(\\"script\\");

          for (let i = 0; i < scripts.length; i++) {
            const script = scripts[i];

            if (script.src) {
              if (state.scriptsInserted.includes(script.src)) {
                continue;
              }

              state.scriptsInserted.push(script.src);
              const newScript = document.createElement(\\"script\\");
              newScript.async = true;
              newScript.src = script.src;
              document.head.appendChild(newScript);
            } else if (
              !script.type ||
              [
                \\"text/javascript\\",
                \\"application/javascript\\",
                \\"application/ecmascript\\",
              ].includes(script.type)
            ) {
              if (state.scriptsRun.includes(script.innerText)) {
                continue;
              }

              try {
                state.scriptsRun.push(script.innerText);
                new Function(script.innerText)();
              } catch (error) {
                console.warn(\\"\`CustomCode\`: Error running script:\\", error);
              }
            }
          }
        }
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.className =
          \\"builder-custom-code\\" + (props.replaceNodes ? \\" replace-nodes\\" : \\"\\");

        el.innerHTML = props.code;
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // onMount
    state.findAndRunScripts();
  })();
</script>
"
`;

exports[`Html Javascript Test Image 1`] = `
"<div>
  <picture data-el=\\"picture-1\\" data-ref=\\"undefined-pictureRef\\">
    <template data-el=\\"show\\">
      <img data-el=\\"img-1\\" />
    </template>

    <source data-el=\\"source-1\\" />
  </picture>

  <slot></slot>
</div>
<style>
  .img {
    opacity: 1;
    transition: opacity 0.2s ease-in-out;
    object-fit: cover;
    object-position: center;
  }
</style>
<script>
  (() => {
    const state = {
      scrollListener: null,
      imageLoaded: false,
      setLoaded() {
        state.imageLoaded = true;
        update();
      },
      useLazyLoading() {
        // TODO: Add more checks here, like testing for real web browsers
        return !!props.lazy && isBrowser();
      },
      isBrowser: function isBrowser() {
        return (
          typeof window !== \\"undefined\\" &&
          window.navigator.product != \\"ReactNative\\"
        );
      },
      load: false,
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = !state.useLazyLoading() || state.load;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='img-1']\\").forEach((el) => {
        el.setAttribute(\\"alt\\", props.altText);

        el.setAttribute(
          \\"aria-role\\",
          props.altText ? \\"presentation\\" : undefined
        );

        el.className =
          \\"builder-image\\" + (props._class ? \\" \\" + props._class : \\"\\") + \\" img\\";

        el.setAttribute(\\"src\\", props.image);

        el.removeEventListener(\\"load\\", onImg1Load);
        el.addEventListener(\\"load\\", onImg1Load);

        el.setAttribute(\\"srcset\\", props.srcset);

        el.setAttribute(\\"sizes\\", props.sizes);
      });

      document.querySelectorAll(\\"[data-el='source-1']\\").forEach((el) => {
        el.setAttribute(\\"srcset\\", props.srcset);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'load' event on img-1
    function onImg1Load(event) {
      state.setLoaded();
    }

    // Update with initial state on first load
    update();

    // onMount
    if (state.useLazyLoading()) {
      // throttled scroll capture listener
      const listener = () => {
        if (pictureRef) {
          const rect = pictureRef.getBoundingClientRect();
          const buffer = window.innerHeight / 2;

          if (rect.top < window.innerHeight + buffer) {
            setLoad(true);
            state.scrollListener = null;
            update();
            window.removeEventListener(\\"scroll\\", listener);
          }
        }
      };

      state.scrollListener = listener;
      update();
      window.addEventListener(\\"scroll\\", listener, {
        capture: true,
        passive: true,
      });
      listener();
    }

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }
  })();
</script>
"
`;

exports[`Html Javascript Test Image State 1`] = `
"<div>
  <template data-el=\\"for\\">
    <img class=\\"custom-class\\" data-el=\\"img-1\\" />
  </template>
</div>
<script>
  (() => {
    const state = { canShow: true, images: [\\"http://example.com/qwik.png\\"] };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = state.images;
        renderLoop(el, array, \\"item\\", \\"itemIndex\\");
      });

      document.querySelectorAll(\\"[data-el='img-1']\\").forEach((el) => {
        const item = getScope(el, \\"item\\");
        const itemIndex = getScope(el, \\"itemIndex\\");

        el.setAttribute(\\"src\\", item);

        el.key = itemIndex;
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Javascript Test Img 1`] = `
"<img data-el=\\"img-1\\" />
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='img-1']\\").forEach((el) => {
        Object.assign(el.style, {
          objectFit: props.backgroundSize || \\"cover\\",
          objectPosition: props.backgroundPosition || \\"center\\",
        });

        el.key = (Builder.isEditing && props.imgSrc) || \\"default-key\\";

        el.setAttribute(\\"alt\\", props.altText);

        el.setAttribute(\\"src\\", props.imgSrc);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Javascript Test Input 1`] = `
"<input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.key =
          Builder.isEditing && props.defaultValue
            ? props.defaultValue
            : \\"default-key\\";

        el.setAttribute(\\"placeholder\\", props.placeholder);

        el.setAttribute(\\"type\\", props.type);

        el.setAttribute(\\"name\\", props.name);

        el.value = props.value;

        el.setAttribute(\\"defaultValue\\", props.defaultValue);

        el.setAttribute(\\"required\\", props.required);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Javascript Test RawText 1`] = `
"<span data-el=\\"span-1\\"></span>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='span-1']\\").forEach((el) => {
        el.className = props.attributes?.class || props.attributes?.className;

        el.innerHTML = props.text || \\"\\";
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Javascript Test Section 1`] = `
"<section data-el=\\"section-1\\">
  <slot></slot>
</section>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='section-1']\\").forEach((el) => {
        Object.assign(
          el.style,
          props.maxWidth && typeof props.maxWidth === \\"number\\"
            ? {
                maxWidth: props.maxWidth,
              }
            : undefined
        );
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Javascript Test Section 2`] = `
"<template data-el=\\"show\\">
  <template data-el=\\"for\\">
    <section data-el=\\"section-1\\">
      <slot></slot>
    </section>
  </template>
</template>
<script>
  (() => {
    const state = { max: 42, items: [42] };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = state.max;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = state.items;
        renderLoop(el, array, \\"item\\");
      });

      document.querySelectorAll(\\"[data-el='section-1']\\").forEach((el) => {
        const item = getScope(el, \\"item\\");
        Object.assign(el.style, {
          maxWidth: item + state.max,
        });
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Javascript Test Select 1`] = `
"<select data-el=\\"select-1\\" data-dom-state=\\"select-2\\">
  <template data-el=\\"for\\">
    <option data-el=\\"option-1\\">
      <template data-el=\\"div-1\\"><!-- option.name || option.value --></template>
    </option>
  </template>
</select>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='select-1']\\").forEach((el) => {
        el.value = props.value;

        el.key =
          Builder.isEditing && props.defaultValue
            ? props.defaultValue
            : \\"default-key\\";

        el.setAttribute(\\"defaultValue\\", props.defaultValue);

        el.setAttribute(\\"name\\", props.name);
      });

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = props.options;
        renderLoop(el, array, \\"option\\", \\"index\\");
      });

      document.querySelectorAll(\\"[data-el='option-1']\\").forEach((el) => {
        const option = getScope(el, \\"option\\");
        const index = getScope(el, \\"index\\");

        el.value = option.value;

        el.setAttribute(\\"data-index\\", index);
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        const option = getScope(el, \\"option\\");
        renderTextNode(el, option.name || option.value);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Javascript Test SlotHtml 1`] = `
"<div>
  <ContentSlotCode>
    <slot data-el=\\"slot\\"></slot>
  </ContentSlotCode>
</div>
<script>
  (() => {
    const state = {};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='slot']\\").forEach((el) => {
        el.setAttribute(\\"testing\\", <div>Hello</div>);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Javascript Test SlotJsx 1`] = `
"<div>
  <ContentSlotCode data-el=\\"content-slot-code\\"></ContentSlotCode>
</div>
<script>
  (() => {
    const state = {};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document
        .querySelectorAll(\\"[data-el='content-slot-code']\\")
        .forEach((el) => {
          el.setAttribute(\\"slotTesting\\", <div>Hello</div>);
        });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Javascript Test Stamped.io 1`] = `
"<div data-el=\\"div-1\\">
  <button data-el=\\"button-1\\">Write a review</button>

  <template data-el=\\"show\\">
    <input placeholder=\\"Email\\" data-dom-state=\\"input-1\\" />

    <input placeholder=\\"Title\\" class=\\"input\\" data-dom-state=\\"input-2\\" />

    <textarea
      placeholder=\\"How was your experience?\\"
      class=\\"textarea\\"
      data-dom-state=\\"textarea-1\\"
    ></textarea>

    <button class=\\"button\\" data-el=\\"button-2\\">Submit</button>
  </template>

  <template data-el=\\"for\\">
    <div class=\\"review\\" data-el=\\"review\\">
      <img class=\\"img\\" data-el=\\"img-1\\" />

      <div data-el=\\"div-2\\">
        <div>
          N:
          <template data-el=\\"div-3\\"><!-- index --></template>
        </div>

        <div>
          <template data-el=\\"div-4\\"><!-- review.author --></template>
        </div>

        <div>
          <template data-el=\\"div-5\\"><!-- review.reviewMessage --></template>
        </div>
      </div>
    </div>
  </template>
</div>
<style>
  .input {
    display: block;
  }
  .textarea {
    display: block;
  }
  .button {
    display: block;
  }
  .review {
    margin: 10px;
    padding: 10px;
    background: white;
    display: flex;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  }
  .img {
    height: 30px;
    width: 30px;
    margin-right: 10px;
  }
</style>
<script>
  (() => {
    const state = {
      reviews: [],
      name: \\"test\\",
      showReviewPrompt: false,
      kebabCaseValue() {
        return kebabCase(\\"testThat\\");
      },
      snakeCaseValue() {
        return snakeCase(\\"testThis\\");
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.setAttribute(\\"data-user\\", state.name);
      });

      document.querySelectorAll(\\"[data-el='button-1']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton1Click);
        el.addEventListener(\\"click\\", onButton1Click);
      });

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = state.showReviewPrompt;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='button-2']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton2Click);
        el.addEventListener(\\"click\\", onButton2Click);
      });

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = state.reviews;
        renderLoop(el, array, \\"review\\", \\"index\\");
      });

      document.querySelectorAll(\\"[data-el='review']\\").forEach((el) => {
        const review = getScope(el, \\"review\\");

        el.key = review.id;
      });

      document.querySelectorAll(\\"[data-el='img-1']\\").forEach((el) => {
        const review = getScope(el, \\"review\\");

        el.setAttribute(\\"src\\", review.avatar);
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        el.className = state.showReviewPrompt ? \\"bg-primary\\" : \\"bg-secondary\\";
      });

      document.querySelectorAll(\\"[data-el='div-3']\\").forEach((el) => {
        const index = getScope(el, \\"index\\");
        renderTextNode(el, index);
      });

      document.querySelectorAll(\\"[data-el='div-4']\\").forEach((el) => {
        const review = getScope(el, \\"review\\");
        renderTextNode(el, review.author);
      });

      document.querySelectorAll(\\"[data-el='div-5']\\").forEach((el) => {
        const review = getScope(el, \\"review\\");
        renderTextNode(el, review.reviewMessage);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'click' event on button-1
    function onButton1Click(event) {
      state.showReviewPrompt = true;
      update();
    }

    // Event handler for 'click' event on button-2
    function onButton2Click(event) {
      event.preventDefault();
      state.showReviewPrompt = false;
      update();
    }

    // Update with initial state on first load
    update();

    // onMount
    fetch(
      \`https://stamped.io/api/widget/reviews?storeUrl=builder-io.myshopify.com&apiKey=\${
        props.apiKey || \\"pubkey-8bbDq7W6w4sB3OWeM1HUy2s47702hM\\"
      }&productId=\${props.productId || \\"2410511106127\\"}\`
    )
      .then((res) => res.json())
      .then((data) => {
        state.reviews = data.data;
        update();
      });

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Javascript Test Submit 1`] = `
"<button type=\\"submit\\" data-el=\\"button-1\\">
  <template data-el=\\"div-1\\"><!-- props.text --></template>
</button>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Javascript Test Text 1`] = `
"<div data-el=\\"div-1\\"></div>
<script>
  (() => {
    const state = { name: \\"Decadef20\\" };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.setAttribute(\\"contentEditable\\", allowEditingText || undefined);

        el.setAttribute(\\"data-name\\", {
          test: state.name || \\"any name\\",
        });

        el.innerHTML =
          props.text ||
          props.content ||
          state.name ||
          '<p class=\\"text-lg\\">my name</p>';
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Javascript Test Textarea 1`] = `
"<textarea data-el=\\"textarea-1\\" data-dom-state=\\"textarea-2\\"></textarea>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='textarea-1']\\").forEach((el) => {
        el.setAttribute(\\"placeholder\\", props.placeholder);

        el.setAttribute(\\"name\\", props.name);

        el.value = props.value;

        el.setAttribute(\\"defaultValue\\", props.defaultValue);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Javascript Test Video 1`] = `
"<video preload=\\"none\\" data-el=\\"video-1\\"></video>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='video-1']\\").forEach((el) => {
        Object.assign(el.style, {
          width: \\"100%\\",
          height: \\"100%\\",
          ...props.attributes?.style,
          objectFit: props.fit,
          objectPosition: props.position,
          // Hack to get object fit to work as expected and
          // not have the video overflow
          borderRadius: 1,
        });

        el.key = props.video || \\"no-src\\";

        el.setAttribute(\\"poster\\", props.posterImage);

        el.setAttribute(\\"autoplay\\", props.autoPlay);

        el.setAttribute(\\"muted\\", props.muted);

        el.setAttribute(\\"controls\\", props.controls);

        el.setAttribute(\\"loop\\", props.loop);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Javascript Test basicForwardRef 1`] = `
"<div>
  <input
    class=\\"input\\"
    data-el=\\"input-1\\"
    data-dom-state=\\"input-2\\"
    data-ref=\\"undefined-props.inputRef\\"
  />
</div>
<style>
  .input {
    color: red;
  }
</style>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\" };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = state.name;

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      state.name = event.target.value;
      update();
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Javascript Test basicForwardRefMetadata 1`] = `
"<div>
  <input
    class=\\"input\\"
    data-el=\\"input-1\\"
    data-dom-state=\\"input-2\\"
    data-ref=\\"undefined-props.inputRef\\"
  />
</div>
<style>
  .input {
    color: red;
  }
</style>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\" };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = state.name;

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      state.name = event.target.value;
      update();
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Javascript Test basicOnUpdateReturn 1`] = `
"<div>
  Hello!
  <template data-el=\\"div-1\\"><!-- state.name --></template>
</div>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\" };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.name);
      });

      destroyAnyNodes();

      const controller = new AbortController();
      const signal = controller.signal;
      fetch(\\"https://patrickjs.com/api/resource.json\\", {
        signal,
      })
        .then((response) => response.json())
        .then((data) => {
          state.name = data.name;
          update();
        });
      return () => {
        if (!signal.aborted) {
          controller.abort();
        }
      };

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Javascript Test class + ClassName + css 1`] = `
"<div class=\\"test2 test div\\">
  Hello! I can run in React, Vue, Solid, or Liquid!
</div>
<style>
  .div {
    padding: 10px;
  }
</style>
"
`;

exports[`Html Javascript Test class + css 1`] = `
"<div class=\\"test div\\">Hello! I can run in React, Vue, Solid, or Liquid!</div>
<style>
  .div {
    padding: 10px;
  }
</style>
"
`;

exports[`Html Javascript Test className + css 1`] = `
"<div class=\\"test div\\">Hello! I can run in React, Vue, Solid, or Liquid!</div>
<style>
  .div {
    padding: 10px;
  }
</style>
"
`;

exports[`Html Javascript Test className 1`] = `
"<div>
  <div class=\\"no binding\\">Without Binding</div>

  <div data-el=\\"div-1\\">With binding</div>
</div>
<script>
  (() => {
    const state = { bindings: \\"a binding\\" };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.className = state.bindings;
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Javascript Test classState 1`] = `
"<div data-el=\\"div-1\\">Hello! I can run in React, Vue, Solid, or Liquid!</div>
<style>
  .div {
    padding: 10px;
  }
</style>
<script>
  (() => {
    const state = {
      classState: \\"testClassName\\",
      styleState: {
        color: \\"red\\",
      },
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.className = state.classState + \\" div\\";

        Object.assign(el.style, state.styleState);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Javascript Test componentWithContext 1`] = `
"<template data-el=\\"div-1\\"><!-- foo.value --></template>

<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, foo.value);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Javascript Test defaultProps 1`] = `
"<div>
  <template data-el=\\"show\\">
    <a data-el=\\"a-1\\">
      <template data-el=\\"div-1\\"><!-- props.text --></template>
    </a>
  </template>

  <template data-el=\\"show-2\\">
    <button type=\\"button\\" data-el=\\"button-1\\">
      <template data-el=\\"div-2\\"><!-- props.text --></template>
    </button>
  </template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='a-1']\\").forEach((el) => {
        el.setAttribute(\\"href\\", props.link);

        el.setAttribute(
          \\"target\\",
          props.openLinkInNewTab ? \\"_blank\\" : undefined
        );
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      document.querySelectorAll(\\"[data-el='show-2']\\").forEach((el) => {
        const whenCondition = !props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Javascript Test defaultPropsOutsideComponent 1`] = `
"<div>
  <template data-el=\\"show\\">
    <a data-el=\\"a-1\\">
      <template data-el=\\"div-1\\"><!-- props.text --></template>
    </a>
  </template>

  <template data-el=\\"show-2\\">
    <button type=\\"button\\" data-el=\\"button-1\\">
      <template data-el=\\"div-2\\"><!-- props.text --></template>
    </button>
  </template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='a-1']\\").forEach((el) => {
        el.setAttribute(\\"href\\", props.link);

        el.setAttribute(
          \\"target\\",
          props.openLinkInNewTab ? \\"_blank\\" : undefined
        );
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      document.querySelectorAll(\\"[data-el='show-2']\\").forEach((el) => {
        const whenCondition = !props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Javascript Test defaultValsWithTypes 1`] = `
"<div>
  Hello
  <template data-el=\\"div-1\\">
    <!-- props.name || DEFAULT_VALUES.name -->
  </template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.name || DEFAULT_VALUES.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Javascript Test import types 1`] = `
"<RenderBlock data-el=\\"render-block\\"></RenderBlock>
"
`;

exports[`Html Javascript Test multipleOnUpdate 1`] = `
"<div></div>
"
`;

exports[`Html Javascript Test multipleOnUpdateWithDeps 1`] = `
"<div></div>
"
`;

exports[`Html Javascript Test multipleSpreads 1`] = `
"<input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
"
`;

exports[`Html Javascript Test nestedShow 1`] = `
"<template data-el=\\"show\\">
  <template data-el=\\"show-2\\">
    <div>if condition A and condition B</div>
  </template>
</template>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-2']\\").forEach((el) => {
        const whenCondition = !props.conditionB;
        if (whenCondition) {
          showContent(el);
        }
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }
  })();
</script>
"
`;

exports[`Html Javascript Test nestedStyles 1`] = `
"<div class=\\"div\\">Hello world</div>
<style>
  .div {
    display: flex;
    foo: var(--bar);
  }
  @media (max-width: env(--mobile)) {
    .div {
      display: block;
    }
  }
  .div:hover {
    display: flex;
  }
  .div .nested-selector {
    display: grid;
  }
</style>
"
`;

exports[`Html Javascript Test onInit & onMount 1`] = `
"<div></div>
<script>
  (() => {
    const state = {};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;
    let onInitOnce = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    if (!onInitOnce) {
      console.log(\\"onInit\\");
      onInitOnce = true;
    }

    // onMount
    console.log(\\"onMount\\");
  })();
</script>
"
`;

exports[`Html Javascript Test onInit 1`] = `
"<div>
  Default name defined by parent
  <template data-el=\\"div-1\\"><!-- state.name --></template>
</div>
<script>
  (() => {
    const state = { name: \\"\\" };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;
    let onInitOnce = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    if (!onInitOnce) {
      state.name = defaultValues.name || props.name;
      update();
      console.log(\\"set defaults with props\\");
      onInitOnce = true;
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Javascript Test onMount 1`] = `
"<div></div>
<script>
  (() => {
    const state = {};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // onMount
    console.log(\\"Runs on mount\\");
  })();
</script>
"
`;

exports[`Html Javascript Test onUpdate 1`] = `
"<div></div>
"
`;

exports[`Html Javascript Test onUpdateWithDeps 1`] = `
"<div></div>
"
`;

exports[`Html Javascript Test preserveExportOrLocalStatement 1`] = `
"<div></div>
"
`;

exports[`Html Javascript Test preserveTyping 1`] = `
"<div>
  Hello! I can run in React, Vue, Solid, or Liquid!
  <template data-el=\\"div-1\\"><!-- props.name --></template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Javascript Test propsDestructure 1`] = `
"<div>
  <slot></slot>

  <template data-el=\\"div-2\\"><!-- props.type --></template>

  Hello! I can run in React, Vue, Solid, or Liquid!
</div>
<script>
  (() => {
    const state = { name: \\"Decadef20\\" };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, props.type);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Javascript Test propsInterface 1`] = `
"<div>
  Hello! I can run in React, Vue, Solid, or Liquid!
  <template data-el=\\"div-1\\"><!-- props.name --></template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Javascript Test propsType 1`] = `
"<div>
  Hello! I can run in React, Vue, Solid, or Liquid!
  <template data-el=\\"div-1\\"><!-- props.name --></template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Javascript Test renderContentExample 1`] = `
"<div class=\\"div\\" data-el=\\"div-1\\">
  <RenderBlocks data-el=\\"render-blocks\\"></RenderBlocks>
</div>
<style>
  .div {
    display: flex;
    flex-direction: columns;
  }
</style>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onDiv1Click);
        el.addEventListener(\\"click\\", onDiv1Click);
      });

      document.querySelectorAll(\\"[data-el='render-blocks']\\").forEach((el) => {
        el.setAttribute(\\"blocks\\", props.content.blocks);
      });

      destroyAnyNodes();

      dispatchNewContentToVisualEditor(props.content);

      pendingUpdate = false;
    }

    // Event handler for 'click' event on div-1
    function onDiv1Click(event) {
      trackClick(props.content.id);
    }

    // Update with initial state on first load
    update();

    // onMount
    sendComponentsToVisualEditor(props.customComponents);
  })();
</script>
"
`;

exports[`Html Javascript Test rootFragmentMultiNode 1`] = `
"<template data-el=\\"show\\">
  <a data-el=\\"a-1\\">
    <template data-el=\\"div-1\\"><!-- props.text --></template>
  </a>
</template>

<template data-el=\\"show-2\\">
  <button type=\\"button\\" data-el=\\"button-1\\">
    <template data-el=\\"div-2\\"><!-- props.text --></template>
  </button>
</template>

<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='a-1']\\").forEach((el) => {
        el.setAttribute(\\"href\\", props.link);

        el.setAttribute(
          \\"target\\",
          props.openLinkInNewTab ? \\"_blank\\" : undefined
        );
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      document.querySelectorAll(\\"[data-el='show-2']\\").forEach((el) => {
        const whenCondition = !props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Javascript Test rootShow 1`] = `
"<template data-el=\\"show\\">
  <div>Bar</div>
</template>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.foo === \\"bar\\";
        if (whenCondition) {
          showContent(el);
        }
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }
  })();
</script>
"
`;

exports[`Html Javascript Test self-referencing component 1`] = `
"<div>
  <template data-el=\\"div-1\\"><!-- props.name --></template>

  <template data-el=\\"show\\">
    <MyComponent name=\\"Bruce Wayne\\"></MyComponent>
  </template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.name);
      });

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.name === \\"Batman\\";
        if (whenCondition) {
          showContent(el);
        }
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Javascript Test self-referencing component with children 1`] = `
"<div>
  <template data-el=\\"div-1\\"><!-- props.name --></template>

  <slot></slot>

  <template data-el=\\"show\\">
    <MyComponent name=\\"Bruce\\">
      <div>Wayne</div>
    </MyComponent>
  </template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.name);
      });

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.name === \\"Batman\\";
        if (whenCondition) {
          showContent(el);
        }
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Javascript Test showWithFor 1`] = `
"<template data-el=\\"show\\">
  <template data-el=\\"for\\">
    <div data-el=\\"div-1\\">
      <template data-el=\\"div-2\\"><!-- item --></template>
    </div>
  </template>
</template>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = props.items;
        renderLoop(el, array, \\"item\\", \\"idx\\");
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        const idx = getScope(el, \\"idx\\");

        el.key = idx;
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        const item = getScope(el, \\"item\\");
        renderTextNode(el, item);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Javascript Test spreadAttrs 1`] = `
"<input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
"
`;

exports[`Html Javascript Test spreadNestedProps 1`] = `
"<input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
"
`;

exports[`Html Javascript Test spreadProps 1`] = `
"<input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
"
`;

exports[`Html Javascript Test subComponent 1`] = `
"<Foo></Foo>
"
`;

exports[`Html Javascript Test typeDependency 1`] = `
"<div>
  <template data-el=\\"div-1\\"><!-- props.foo --></template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.foo);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Javascript Test use-style 1`] = `
"<button type=\\"button\\">Button</button>
<style>
  button {
    background: blue;
    color: white;
    font-size: 12px;
    outline: 1px solid black;
  }
</style>
"
`;

exports[`Html Javascript Test use-style-and-css 1`] = `
"<button type=\\"button\\" class=\\"button\\">Button</button>
<style>
  .button {
    background: blue;
    color: white;
  }

  button {
    font-size: 12px;
    outline: 1px solid black;
  }
</style>
"
`;

exports[`Html Javascript Test use-style-outside-component 1`] = `
"<button type=\\"button\\">Button</button>
<style>
  button {
    background: blue;
    color: white;
    font-size: 12px;
    outline: 1px solid black;
  }
</style>
"
`;

exports[`Html Remove Internal mitosis package 1`] = `
"<div>
  Hello
  <template data-el=\\"div-1\\"><!-- state.name --></template>
  ! I can run in React, Qwik, Vue, Solid, or Liquid!
</div>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\" };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Typescript Test AdvancedRef 1`] = `
"<div>
  <template data-el=\\"show\\">
    <input
      class=\\"input\\"
      data-el=\\"input-1\\"
      data-dom-state=\\"input-2\\"
      data-ref=\\"undefined-inputRef\\"
    />

    <label for=\\"cars\\" data-el=\\"label-1\\" data-ref=\\"undefined-inputNoArgRef\\">
      Choose a car:
    </label>

    <select name=\\"cars\\" id=\\"cars\\" data-dom-state=\\"select-1\\">
      <option value=\\"supra\\">GR Supra</option>

      <option value=\\"86\\">GR 86</option>
    </select>
  </template>

  Hello

  <template data-el=\\"div-1\\"><!-- state.lowerCaseName() --></template>
  ! I can run in React, Qwik, Vue, Solid, or Web Component!
</div>
<style>
  .input {
    color: red;
  }
</style>
<script>
  (() => {
    const state = {
      name: \\"PatrickJS\\",
      onBlur: function onBlur() {
        // Maintain focus
        inputRef.focus();
      },
      lowerCaseName: function lowerCaseName() {
        return state.name.toLowerCase();
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.showInput;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = state.name;

        el.removeEventListener(\\"blur\\", onInput1Blur);
        el.addEventListener(\\"blur\\", onInput1Blur);

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.lowerCaseName());
      });

      destroyAnyNodes();

      console.log(\\"Received an update\\");

      pendingUpdate = false;
    }

    // Event handler for 'blur' event on input-1
    function onInput1Blur(event) {
      state.onBlur();
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      state.name = event.target.value;
      update();
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Typescript Test Basic 1`] = `
"<div class=\\"test div\\">
  <input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />

  Hello! I can run in React, Vue, Solid, or Liquid!
</div>
<style>
  .div {
    padding: 10px;
  }
</style>
<script>
  (() => {
    const state = {
      name: \\"Steve\\",
      underscore_fn_name() {
        return \\"bar\\";
      },
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = DEFAULT_VALUES.name || state.name;

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(myEvent) {
      state.name = myEvent.target.value;
      update();
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Typescript Test Basic 2`] = `
"<div>
  <template data-el=\\"for\\">
    <template data-el=\\"show\\">
      <input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />

      Hello
      <template data-el=\\"div-1\\"><!-- person --></template>
      ! I can run in Qwik, Web Component, React, Vue, Solid, or Liquid!
    </template>
  </template>
</div>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = state.names;
        renderLoop(el, array, \\"person\\");
      });

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const person = getScope(el, \\"person\\");
        const whenCondition = person === state.name;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = state.name;

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        const person = getScope(el, \\"person\\");
        renderTextNode(el, person);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      const person = getScope(event.currentTarget, \\"person\\");

      state.name = event.target.value + \\" and \\" + person;
      update();
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Typescript Test Basic Context 1`] = `
"<div>
  <template data-el=\\"div-1\\">
    <!-- myService.method('hello') + state.name -->
  </template>

  Hello! I can run in React, Vue, Solid, or Liquid!

  <input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
</div>
<script>
  (() => {
    const state = {
      name: \\"PatrickJS\\",
      onChange: function onChange() {
        const change = myService.method(\\"change\\");
        console.log(change);
      },
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;
    let onInitOnce = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, myService.method(\\"hello\\") + state.name);
      });

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      state.onChange;
    }

    // Update with initial state on first load
    update();

    if (!onInitOnce) {
      const hi = myService.method(\\"hi\\");
      console.log(hi);
      onInitOnce = true;
    }

    // onMount
    const bye = myService.method(\\"hi\\");
    console.log(bye);

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Typescript Test Basic OnMount Update 1`] = `
"<div>
  Hello
  <template data-el=\\"div-1\\"><!-- state.name --></template>
</div>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;
    let onInitOnce = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    if (!onInitOnce) {
      state.name = \\"PatrickJS onInit\\" + props.hi;
      update();
      onInitOnce = true;
    }

    // onMount
    state.name = \\"PatrickJS onMount\\" + props.bye;
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Typescript Test Basic Outputs 1`] = `
"<div></div>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\" };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // onMount
    props.onMessage(state.name);
    props.onEvent(props.message);
  })();
</script>
"
`;

exports[`Html Typescript Test Basic Outputs Meta 1`] = `
"<div></div>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\" };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // onMount
    props.onMessage(state.name);
    props.onEvent(props.message);
  })();
</script>
"
`;

exports[`Html Typescript Test BasicAttribute 1`] = `
"<input
  autocapitalize=\\"on\\"
  autocomplete=\\"on\\"
  data-el=\\"input-1\\"
  data-dom-state=\\"input-2\\"
/>
<script>
  (() => {
    const state = {};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.setAttribute(\\"spellcheck\\", true);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Typescript Test BasicBooleanAttribute 1`] = `
"<div>
  <slot></slot>

  <template data-el=\\"div-2\\"><!-- props.type --></template>

  <MyBooleanAttributeComponent
    data-el=\\"my-boolean-attribute-component\\"
  ></MyBooleanAttributeComponent>

  <MyBooleanAttributeComponent
    data-el=\\"my-boolean-attribute-component-2\\"
  ></MyBooleanAttributeComponent>

  <MyBooleanAttributeComponent
    data-el=\\"my-boolean-attribute-component-3\\"
  ></MyBooleanAttributeComponent>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, props.type);
      });

      document
        .querySelectorAll(\\"[data-el='my-boolean-attribute-component']\\")
        .forEach((el) => {
          el.setAttribute(\\"toggle\\", true);
        });

      document
        .querySelectorAll(\\"[data-el='my-boolean-attribute-component-2']\\")
        .forEach((el) => {
          el.setAttribute(\\"toggle\\", true);
        });

      document
        .querySelectorAll(\\"[data-el='my-boolean-attribute-component-3']\\")
        .forEach((el) => {
          el.setAttribute(\\"list\\", null);
        });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Typescript Test BasicChildComponent 1`] = `
"<div>
  <MyBasicComponent data-el=\\"my-basic-component\\"></MyBasicComponent>

  <div>
    <MyBasicOnMountUpdateComponent
      data-el=\\"my-basic-on-mount-update-component\\"
    ></MyBasicOnMountUpdateComponent>
  </div>
</div>
<script>
  (() => {
    const state = { name: \\"Steve\\", dev: \\"PatrickJS\\" };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document
        .querySelectorAll(\\"[data-el='my-basic-component']\\")
        .forEach((el) => {
          el.setAttribute(\\"id\\", state.dev);
        });

      document
        .querySelectorAll(\\"[data-el='my-basic-on-mount-update-component']\\")
        .forEach((el) => {
          el.setAttribute(\\"hi\\", state.name);

          el.setAttribute(\\"bye\\", state.dev);
        });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Typescript Test BasicFor 1`] = `
"<div>
  <template data-el=\\"for\\">
    <input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />

    Hello
    <template data-el=\\"div-1\\"><!-- person --></template>
    ! I can run in Qwik, Web Component, React, Vue, Solid, or Liquid!
  </template>
</div>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = state.names;
        renderLoop(el, array, \\"person\\");
      });

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = state.name;

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        const person = getScope(el, \\"person\\");
        renderTextNode(el, person);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      const person = getScope(event.currentTarget, \\"person\\");

      state.name = event.target.value + \\" and \\" + person;
      update();
    }

    // Update with initial state on first load
    update();

    // onMount
    console.log(\\"onMount code\\");

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Typescript Test BasicRef 1`] = `
"<div>
  <template data-el=\\"show\\">
    <input
      class=\\"input\\"
      data-el=\\"input-1\\"
      data-dom-state=\\"input-2\\"
      data-ref=\\"undefined-inputRef\\"
    />

    <label for=\\"cars\\" data-el=\\"label-1\\" data-ref=\\"undefined-inputNoArgRef\\">
      Choose a car:
    </label>

    <select name=\\"cars\\" id=\\"cars\\" data-dom-state=\\"select-1\\">
      <option value=\\"supra\\">GR Supra</option>

      <option value=\\"86\\">GR 86</option>
    </select>
  </template>

  Hello

  <template data-el=\\"div-1\\"><!-- state.lowerCaseName() --></template>
  ! I can run in React, Qwik, Vue, Solid, or Web Component!
</div>
<style>
  .input {
    color: red;
  }
</style>
<script>
  (() => {
    const state = {
      name: \\"PatrickJS\\",
      onBlur: function onBlur() {
        // Maintain focus
        inputRef.focus();
      },
      lowerCaseName: function lowerCaseName() {
        return state.name.toLowerCase();
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.showInput;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = state.name;

        el.removeEventListener(\\"blur\\", onInput1Blur);
        el.addEventListener(\\"blur\\", onInput1Blur);

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.lowerCaseName());
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'blur' event on input-1
    function onInput1Blur(event) {
      state.onBlur();
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      state.name = event.target.value;
      update();
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Typescript Test BasicRefAssignment 1`] = `
"<div>
  <button data-el=\\"button-1\\">Click</button>
</div>
<script>
  (() => {
    const state = {
      handlerClick: function handlerClick(event) {
        event.preventDefault();
        console.log(\\"current value\\", holdValueRef);
        holdValueRef = holdValueRef + \\"JS\\";
      },
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='button-1']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton1Click);
        el.addEventListener(\\"click\\", onButton1Click);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'click' event on button-1
    function onButton1Click(evt) {
      state.handlerClick(evt);
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Typescript Test BasicRefPrevious 1`] = `
"<div>
  <h1>
    Now:
    <template data-el=\\"div-1\\"><!-- state.count --></template>
    , before:
    <template data-el=\\"div-2\\"><!-- prevCount --></template>
  </h1>

  <button data-el=\\"button-1\\">Increment</button>
</div>
<script>
  (() => {
    const state = { count: 0 };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.count);
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, prevCount);
      });

      document.querySelectorAll(\\"[data-el='button-1']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton1Click);
        el.addEventListener(\\"click\\", onButton1Click);
      });

      destroyAnyNodes();

      prevCount = state.count;

      pendingUpdate = false;
    }

    // Event handler for 'click' event on button-1
    function onButton1Click(event) {
      state.count += 1;
      update();
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Typescript Test Button 1`] = `
"<div>
  <template data-el=\\"show\\">
    <a data-el=\\"a-1\\">
      <template data-el=\\"div-1\\"><!-- props.text --></template>
    </a>
  </template>

  <template data-el=\\"show-2\\">
    <button type=\\"button\\" data-el=\\"button-1\\">
      <template data-el=\\"div-2\\"><!-- props.text --></template>
    </button>
  </template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='a-1']\\").forEach((el) => {
        el.setAttribute(\\"href\\", props.link);

        el.setAttribute(
          \\"target\\",
          props.openLinkInNewTab ? \\"_blank\\" : undefined
        );
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      document.querySelectorAll(\\"[data-el='show-2']\\").forEach((el) => {
        const whenCondition = !props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Typescript Test Columns 1`] = `
"<div class=\\"builder-columns div\\">
  <template data-el=\\"for\\">
    <div class=\\"builder-column div-2\\">
      <template data-el=\\"div-1\\"><!-- column.content --></template>

      <template data-el=\\"div-2\\"><!-- index --></template>
    </div>
  </template>
</div>
<style>
  .div {
    display: flex;
    flex-direction: column;
    align-items: stretch;
    line-height: normal;
  }
  @media (max-width: 999px) {
    .div {
      flex-direction: row;
    }
  }
  @media (max-width: 639px) {
    .div {
      flex-direction: row-reverse;
    }
  }
  .div-2 {
    flex-grow: 1;
  }
</style>
<script>
  (() => {
    const state = {
      getColumns() {
        return props.columns || [];
      },
      getGutterSize() {
        return typeof props.space === \\"number\\" ? props.space || 0 : 20;
      },
      getWidth(index) {
        const columns = state.getColumns();
        return (columns[index] && columns[index].width) || 100 / columns.length;
      },
      getColumnCssWidth(index) {
        const columns = state.getColumns();
        const gutterSize = state.getGutterSize();
        const subtractWidth =
          (gutterSize * (columns.length - 1)) / columns.length;
        return \`calc(\${state.getWidth(index)}% - \${subtractWidth}px)\`;
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = props.columns;
        renderLoop(el, array, \\"column\\", \\"index\\");
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        const column = getScope(el, \\"column\\");
        renderTextNode(el, column.content);
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        const index = getScope(el, \\"index\\");
        renderTextNode(el, index);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Typescript Test ContentSlotHtml 1`] = `
"<div>
  <slot data-el=\\"slot\\"></slot>

  <div>
    <hr />
  </div>

  <div>
    <slot></slot>
  </div>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='slot']\\").forEach((el) => {
        el.setAttribute(\\"name\\", props.slotTesting);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Typescript Test ContentSlotJSX 1`] = `
"<div>
  <template data-el=\\"show\\">
    <div>
      <template data-el=\\"div-1\\"><!-- props.slotTesting --></template>
    </div>
  </template>

  <div>
    <hr />
  </div>

  <div><slot></slot></div>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.slotTesting;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.slotTesting);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Typescript Test CustomCode 1`] = `
"<div data-el=\\"div-1\\" data-ref=\\"undefined-elem\\"></div>
<script>
  (() => {
    const state = {
      scriptsInserted: [],
      scriptsRun: [],
      findAndRunScripts() {
        // TODO: Move this function to standalone one in '@builder.io/utils'
        if (elem && typeof window !== \\"undefined\\") {
          /** @type {HTMLScriptElement[]} */
          const scripts = elem.getElementsByTagName(\\"script\\");

          for (let i = 0; i < scripts.length; i++) {
            const script = scripts[i];

            if (script.src) {
              if (state.scriptsInserted.includes(script.src)) {
                continue;
              }

              state.scriptsInserted.push(script.src);
              const newScript = document.createElement(\\"script\\");
              newScript.async = true;
              newScript.src = script.src;
              document.head.appendChild(newScript);
            } else if (
              !script.type ||
              [
                \\"text/javascript\\",
                \\"application/javascript\\",
                \\"application/ecmascript\\",
              ].includes(script.type)
            ) {
              if (state.scriptsRun.includes(script.innerText)) {
                continue;
              }

              try {
                state.scriptsRun.push(script.innerText);
                new Function(script.innerText)();
              } catch (error) {
                console.warn(\\"\`CustomCode\`: Error running script:\\", error);
              }
            }
          }
        }
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.className =
          \\"builder-custom-code\\" + (props.replaceNodes ? \\" replace-nodes\\" : \\"\\");

        el.innerHTML = props.code;
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // onMount
    state.findAndRunScripts();
  })();
</script>
"
`;

exports[`Html Typescript Test Embed 1`] = `
"<div data-el=\\"div-1\\" data-ref=\\"undefined-elem\\"></div>
<script>
  (() => {
    const state = {
      scriptsInserted: [],
      scriptsRun: [],
      findAndRunScripts() {
        // TODO: Move this function to standalone one in '@builder.io/utils'
        if (elem && typeof window !== \\"undefined\\") {
          /** @type {HTMLScriptElement[]} */
          const scripts = elem.getElementsByTagName(\\"script\\");

          for (let i = 0; i < scripts.length; i++) {
            const script = scripts[i];

            if (script.src) {
              if (state.scriptsInserted.includes(script.src)) {
                continue;
              }

              state.scriptsInserted.push(script.src);
              const newScript = document.createElement(\\"script\\");
              newScript.async = true;
              newScript.src = script.src;
              document.head.appendChild(newScript);
            } else if (
              !script.type ||
              [
                \\"text/javascript\\",
                \\"application/javascript\\",
                \\"application/ecmascript\\",
              ].includes(script.type)
            ) {
              if (state.scriptsRun.includes(script.innerText)) {
                continue;
              }

              try {
                state.scriptsRun.push(script.innerText);
                new Function(script.innerText)();
              } catch (error) {
                console.warn(\\"\`CustomCode\`: Error running script:\\", error);
              }
            }
          }
        }
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.className =
          \\"builder-custom-code\\" + (props.replaceNodes ? \\" replace-nodes\\" : \\"\\");

        el.innerHTML = props.code;
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // onMount
    state.findAndRunScripts();
  })();
</script>
"
`;

exports[`Html Typescript Test Image 1`] = `
"<div>
  <picture data-el=\\"picture-1\\" data-ref=\\"undefined-pictureRef\\">
    <template data-el=\\"show\\">
      <img data-el=\\"img-1\\" />
    </template>

    <source data-el=\\"source-1\\" />
  </picture>

  <slot></slot>
</div>
<style>
  .img {
    opacity: 1;
    transition: opacity 0.2s ease-in-out;
    object-fit: cover;
    object-position: center;
  }
</style>
<script>
  (() => {
    const state = {
      scrollListener: null,
      imageLoaded: false,
      setLoaded() {
        state.imageLoaded = true;
        update();
      },
      useLazyLoading() {
        // TODO: Add more checks here, like testing for real web browsers
        return !!props.lazy && isBrowser();
      },
      isBrowser: function isBrowser() {
        return (
          typeof window !== \\"undefined\\" &&
          window.navigator.product != \\"ReactNative\\"
        );
      },
      load: false,
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = !state.useLazyLoading() || state.load;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='img-1']\\").forEach((el) => {
        el.setAttribute(\\"alt\\", props.altText);

        el.setAttribute(
          \\"aria-role\\",
          props.altText ? \\"presentation\\" : undefined
        );

        el.className =
          \\"builder-image\\" + (props._class ? \\" \\" + props._class : \\"\\") + \\" img\\";

        el.setAttribute(\\"src\\", props.image);

        el.removeEventListener(\\"load\\", onImg1Load);
        el.addEventListener(\\"load\\", onImg1Load);

        el.setAttribute(\\"srcset\\", props.srcset);

        el.setAttribute(\\"sizes\\", props.sizes);
      });

      document.querySelectorAll(\\"[data-el='source-1']\\").forEach((el) => {
        el.setAttribute(\\"srcset\\", props.srcset);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'load' event on img-1
    function onImg1Load(event) {
      state.setLoaded();
    }

    // Update with initial state on first load
    update();

    // onMount
    if (state.useLazyLoading()) {
      // throttled scroll capture listener
      const listener = () => {
        if (pictureRef) {
          const rect = pictureRef.getBoundingClientRect();
          const buffer = window.innerHeight / 2;

          if (rect.top < window.innerHeight + buffer) {
            setLoad(true);
            state.scrollListener = null;
            update();
            window.removeEventListener(\\"scroll\\", listener);
          }
        }
      };

      state.scrollListener = listener;
      update();
      window.addEventListener(\\"scroll\\", listener, {
        capture: true,
        passive: true,
      });
      listener();
    }

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }
  })();
</script>
"
`;

exports[`Html Typescript Test Image State 1`] = `
"<div>
  <template data-el=\\"for\\">
    <img class=\\"custom-class\\" data-el=\\"img-1\\" />
  </template>
</div>
<script>
  (() => {
    const state = { canShow: true, images: [\\"http://example.com/qwik.png\\"] };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = state.images;
        renderLoop(el, array, \\"item\\", \\"itemIndex\\");
      });

      document.querySelectorAll(\\"[data-el='img-1']\\").forEach((el) => {
        const item = getScope(el, \\"item\\");
        const itemIndex = getScope(el, \\"itemIndex\\");

        el.setAttribute(\\"src\\", item);

        el.key = itemIndex;
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Typescript Test Img 1`] = `
"<img data-el=\\"img-1\\" />
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='img-1']\\").forEach((el) => {
        Object.assign(el.style, {
          objectFit: props.backgroundSize || \\"cover\\",
          objectPosition: props.backgroundPosition || \\"center\\",
        });

        el.key = (Builder.isEditing && props.imgSrc) || \\"default-key\\";

        el.setAttribute(\\"alt\\", props.altText);

        el.setAttribute(\\"src\\", props.imgSrc);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Typescript Test Input 1`] = `
"<input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.key =
          Builder.isEditing && props.defaultValue
            ? props.defaultValue
            : \\"default-key\\";

        el.setAttribute(\\"placeholder\\", props.placeholder);

        el.setAttribute(\\"type\\", props.type);

        el.setAttribute(\\"name\\", props.name);

        el.value = props.value;

        el.setAttribute(\\"defaultValue\\", props.defaultValue);

        el.setAttribute(\\"required\\", props.required);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Typescript Test RawText 1`] = `
"<span data-el=\\"span-1\\"></span>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='span-1']\\").forEach((el) => {
        el.className = props.attributes?.class || props.attributes?.className;

        el.innerHTML = props.text || \\"\\";
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Typescript Test Section 1`] = `
"<section data-el=\\"section-1\\">
  <slot></slot>
</section>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='section-1']\\").forEach((el) => {
        Object.assign(
          el.style,
          props.maxWidth && typeof props.maxWidth === \\"number\\"
            ? {
                maxWidth: props.maxWidth,
              }
            : undefined
        );
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Typescript Test Section 2`] = `
"<template data-el=\\"show\\">
  <template data-el=\\"for\\">
    <section data-el=\\"section-1\\">
      <slot></slot>
    </section>
  </template>
</template>
<script>
  (() => {
    const state = { max: 42, items: [42] };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = state.max;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = state.items;
        renderLoop(el, array, \\"item\\");
      });

      document.querySelectorAll(\\"[data-el='section-1']\\").forEach((el) => {
        const item = getScope(el, \\"item\\");
        Object.assign(el.style, {
          maxWidth: item + state.max,
        });
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Typescript Test Select 1`] = `
"<select data-el=\\"select-1\\" data-dom-state=\\"select-2\\">
  <template data-el=\\"for\\">
    <option data-el=\\"option-1\\">
      <template data-el=\\"div-1\\"><!-- option.name || option.value --></template>
    </option>
  </template>
</select>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='select-1']\\").forEach((el) => {
        el.value = props.value;

        el.key =
          Builder.isEditing && props.defaultValue
            ? props.defaultValue
            : \\"default-key\\";

        el.setAttribute(\\"defaultValue\\", props.defaultValue);

        el.setAttribute(\\"name\\", props.name);
      });

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = props.options;
        renderLoop(el, array, \\"option\\", \\"index\\");
      });

      document.querySelectorAll(\\"[data-el='option-1']\\").forEach((el) => {
        const option = getScope(el, \\"option\\");
        const index = getScope(el, \\"index\\");

        el.value = option.value;

        el.setAttribute(\\"data-index\\", index);
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        const option = getScope(el, \\"option\\");
        renderTextNode(el, option.name || option.value);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Typescript Test SlotHtml 1`] = `
"<div>
  <ContentSlotCode>
    <slot data-el=\\"slot\\"></slot>
  </ContentSlotCode>
</div>
<script>
  (() => {
    const state = {};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='slot']\\").forEach((el) => {
        el.setAttribute(\\"testing\\", <div>Hello</div>);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Typescript Test SlotJsx 1`] = `
"<div>
  <ContentSlotCode data-el=\\"content-slot-code\\"></ContentSlotCode>
</div>
<script>
  (() => {
    const state = {};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document
        .querySelectorAll(\\"[data-el='content-slot-code']\\")
        .forEach((el) => {
          el.setAttribute(\\"slotTesting\\", <div>Hello</div>);
        });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Typescript Test Stamped.io 1`] = `
"<div data-el=\\"div-1\\">
  <button data-el=\\"button-1\\">Write a review</button>

  <template data-el=\\"show\\">
    <input placeholder=\\"Email\\" data-dom-state=\\"input-1\\" />

    <input placeholder=\\"Title\\" class=\\"input\\" data-dom-state=\\"input-2\\" />

    <textarea
      placeholder=\\"How was your experience?\\"
      class=\\"textarea\\"
      data-dom-state=\\"textarea-1\\"
    ></textarea>

    <button class=\\"button\\" data-el=\\"button-2\\">Submit</button>
  </template>

  <template data-el=\\"for\\">
    <div class=\\"review\\" data-el=\\"review\\">
      <img class=\\"img\\" data-el=\\"img-1\\" />

      <div data-el=\\"div-2\\">
        <div>
          N:
          <template data-el=\\"div-3\\"><!-- index --></template>
        </div>

        <div>
          <template data-el=\\"div-4\\"><!-- review.author --></template>
        </div>

        <div>
          <template data-el=\\"div-5\\"><!-- review.reviewMessage --></template>
        </div>
      </div>
    </div>
  </template>
</div>
<style>
  .input {
    display: block;
  }
  .textarea {
    display: block;
  }
  .button {
    display: block;
  }
  .review {
    margin: 10px;
    padding: 10px;
    background: white;
    display: flex;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  }
  .img {
    height: 30px;
    width: 30px;
    margin-right: 10px;
  }
</style>
<script>
  (() => {
    const state = {
      reviews: [],
      name: \\"test\\",
      showReviewPrompt: false,
      kebabCaseValue() {
        return kebabCase(\\"testThat\\");
      },
      snakeCaseValue() {
        return snakeCase(\\"testThis\\");
      },
    };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.setAttribute(\\"data-user\\", state.name);
      });

      document.querySelectorAll(\\"[data-el='button-1']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton1Click);
        el.addEventListener(\\"click\\", onButton1Click);
      });

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = state.showReviewPrompt;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='button-2']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onButton2Click);
        el.addEventListener(\\"click\\", onButton2Click);
      });

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = state.reviews;
        renderLoop(el, array, \\"review\\", \\"index\\");
      });

      document.querySelectorAll(\\"[data-el='review']\\").forEach((el) => {
        const review = getScope(el, \\"review\\");

        el.key = review.id;
      });

      document.querySelectorAll(\\"[data-el='img-1']\\").forEach((el) => {
        const review = getScope(el, \\"review\\");

        el.setAttribute(\\"src\\", review.avatar);
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        el.className = state.showReviewPrompt ? \\"bg-primary\\" : \\"bg-secondary\\";
      });

      document.querySelectorAll(\\"[data-el='div-3']\\").forEach((el) => {
        const index = getScope(el, \\"index\\");
        renderTextNode(el, index);
      });

      document.querySelectorAll(\\"[data-el='div-4']\\").forEach((el) => {
        const review = getScope(el, \\"review\\");
        renderTextNode(el, review.author);
      });

      document.querySelectorAll(\\"[data-el='div-5']\\").forEach((el) => {
        const review = getScope(el, \\"review\\");
        renderTextNode(el, review.reviewMessage);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'click' event on button-1
    function onButton1Click(event) {
      state.showReviewPrompt = true;
      update();
    }

    // Event handler for 'click' event on button-2
    function onButton2Click(event) {
      event.preventDefault();
      state.showReviewPrompt = false;
      update();
    }

    // Update with initial state on first load
    update();

    // onMount
    fetch(
      \`https://stamped.io/api/widget/reviews?storeUrl=builder-io.myshopify.com&apiKey=\${
        props.apiKey || \\"pubkey-8bbDq7W6w4sB3OWeM1HUy2s47702hM\\"
      }&productId=\${props.productId || \\"2410511106127\\"}\`
    )
      .then((res) => res.json())
      .then((data) => {
        state.reviews = data.data;
        update();
      });

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Typescript Test Submit 1`] = `
"<button type=\\"submit\\" data-el=\\"button-1\\">
  <template data-el=\\"div-1\\"><!-- props.text --></template>
</button>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Typescript Test Text 1`] = `
"<div data-el=\\"div-1\\"></div>
<script>
  (() => {
    const state = { name: \\"Decadef20\\" };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.setAttribute(\\"contentEditable\\", allowEditingText || undefined);

        el.setAttribute(\\"data-name\\", {
          test: state.name || \\"any name\\",
        });

        el.innerHTML =
          props.text ||
          props.content ||
          state.name ||
          '<p class=\\"text-lg\\">my name</p>';
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Typescript Test Textarea 1`] = `
"<textarea data-el=\\"textarea-1\\" data-dom-state=\\"textarea-2\\"></textarea>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='textarea-1']\\").forEach((el) => {
        el.setAttribute(\\"placeholder\\", props.placeholder);

        el.setAttribute(\\"name\\", props.name);

        el.value = props.value;

        el.setAttribute(\\"defaultValue\\", props.defaultValue);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Typescript Test Video 1`] = `
"<video preload=\\"none\\" data-el=\\"video-1\\"></video>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='video-1']\\").forEach((el) => {
        Object.assign(el.style, {
          width: \\"100%\\",
          height: \\"100%\\",
          ...props.attributes?.style,
          objectFit: props.fit,
          objectPosition: props.position,
          // Hack to get object fit to work as expected and
          // not have the video overflow
          borderRadius: 1,
        });

        el.key = props.video || \\"no-src\\";

        el.setAttribute(\\"poster\\", props.posterImage);

        el.setAttribute(\\"autoplay\\", props.autoPlay);

        el.setAttribute(\\"muted\\", props.muted);

        el.setAttribute(\\"controls\\", props.controls);

        el.setAttribute(\\"loop\\", props.loop);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Typescript Test basicForwardRef 1`] = `
"<div>
  <input
    class=\\"input\\"
    data-el=\\"input-1\\"
    data-dom-state=\\"input-2\\"
    data-ref=\\"undefined-props.inputRef\\"
  />
</div>
<style>
  .input {
    color: red;
  }
</style>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\" };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = state.name;

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      state.name = event.target.value;
      update();
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Typescript Test basicForwardRefMetadata 1`] = `
"<div>
  <input
    class=\\"input\\"
    data-el=\\"input-1\\"
    data-dom-state=\\"input-2\\"
    data-ref=\\"undefined-props.inputRef\\"
  />
</div>
<style>
  .input {
    color: red;
  }
</style>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\" };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='input-1']\\").forEach((el) => {
        el.value = state.name;

        el.removeEventListener(\\"input\\", onInput1Input);
        el.addEventListener(\\"input\\", onInput1Input);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Event handler for 'input' event on input-1
    function onInput1Input(event) {
      state.name = event.target.value;
      update();
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Typescript Test basicOnUpdateReturn 1`] = `
"<div>
  Hello!
  <template data-el=\\"div-1\\"><!-- state.name --></template>
</div>
<script>
  (() => {
    const state = { name: \\"PatrickJS\\" };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.name);
      });

      destroyAnyNodes();

      const controller = new AbortController();
      const signal = controller.signal;
      fetch(\\"https://patrickjs.com/api/resource.json\\", {
        signal,
      })
        .then((response) => response.json())
        .then((data) => {
          state.name = data.name;
          update();
        });
      return () => {
        if (!signal.aborted) {
          controller.abort();
        }
      };

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Typescript Test class + ClassName + css 1`] = `
"<div class=\\"test2 test div\\">
  Hello! I can run in React, Vue, Solid, or Liquid!
</div>
<style>
  .div {
    padding: 10px;
  }
</style>
"
`;

exports[`Html Typescript Test class + css 1`] = `
"<div class=\\"test div\\">Hello! I can run in React, Vue, Solid, or Liquid!</div>
<style>
  .div {
    padding: 10px;
  }
</style>
"
`;

exports[`Html Typescript Test className + css 1`] = `
"<div class=\\"test div\\">Hello! I can run in React, Vue, Solid, or Liquid!</div>
<style>
  .div {
    padding: 10px;
  }
</style>
"
`;

exports[`Html Typescript Test className 1`] = `
"<div>
  <div class=\\"no binding\\">Without Binding</div>

  <div data-el=\\"div-1\\">With binding</div>
</div>
<script>
  (() => {
    const state = { bindings: \\"a binding\\" };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.className = state.bindings;
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Typescript Test classState 1`] = `
"<div data-el=\\"div-1\\">Hello! I can run in React, Vue, Solid, or Liquid!</div>
<style>
  .div {
    padding: 10px;
  }
</style>
<script>
  (() => {
    const state = {
      classState: \\"testClassName\\",
      styleState: {
        color: \\"red\\",
      },
    };

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.className = state.classState + \\" div\\";

        Object.assign(el.style, state.styleState);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();
  })();
</script>
"
`;

exports[`Html Typescript Test componentWithContext 1`] = `
"<template data-el=\\"div-1\\"><!-- foo.value --></template>

<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, foo.value);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Typescript Test defaultProps 1`] = `
"<div>
  <template data-el=\\"show\\">
    <a data-el=\\"a-1\\">
      <template data-el=\\"div-1\\"><!-- props.text --></template>
    </a>
  </template>

  <template data-el=\\"show-2\\">
    <button type=\\"button\\" data-el=\\"button-1\\">
      <template data-el=\\"div-2\\"><!-- props.text --></template>
    </button>
  </template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='a-1']\\").forEach((el) => {
        el.setAttribute(\\"href\\", props.link);

        el.setAttribute(
          \\"target\\",
          props.openLinkInNewTab ? \\"_blank\\" : undefined
        );
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      document.querySelectorAll(\\"[data-el='show-2']\\").forEach((el) => {
        const whenCondition = !props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Typescript Test defaultPropsOutsideComponent 1`] = `
"<div>
  <template data-el=\\"show\\">
    <a data-el=\\"a-1\\">
      <template data-el=\\"div-1\\"><!-- props.text --></template>
    </a>
  </template>

  <template data-el=\\"show-2\\">
    <button type=\\"button\\" data-el=\\"button-1\\">
      <template data-el=\\"div-2\\"><!-- props.text --></template>
    </button>
  </template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='a-1']\\").forEach((el) => {
        el.setAttribute(\\"href\\", props.link);

        el.setAttribute(
          \\"target\\",
          props.openLinkInNewTab ? \\"_blank\\" : undefined
        );
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      document.querySelectorAll(\\"[data-el='show-2']\\").forEach((el) => {
        const whenCondition = !props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Typescript Test defaultValsWithTypes 1`] = `
"<div>
  Hello
  <template data-el=\\"div-1\\">
    <!-- props.name || DEFAULT_VALUES.name -->
  </template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.name || DEFAULT_VALUES.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Typescript Test import types 1`] = `
"<RenderBlock data-el=\\"render-block\\"></RenderBlock>
"
`;

exports[`Html Typescript Test multipleOnUpdate 1`] = `
"<div></div>
"
`;

exports[`Html Typescript Test multipleOnUpdateWithDeps 1`] = `
"<div></div>
"
`;

exports[`Html Typescript Test multipleSpreads 1`] = `
"<input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
"
`;

exports[`Html Typescript Test nestedShow 1`] = `
"<template data-el=\\"show\\">
  <template data-el=\\"show-2\\">
    <div>if condition A and condition B</div>
  </template>
</template>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='show-2']\\").forEach((el) => {
        const whenCondition = !props.conditionB;
        if (whenCondition) {
          showContent(el);
        }
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }
  })();
</script>
"
`;

exports[`Html Typescript Test nestedStyles 1`] = `
"<div class=\\"div\\">Hello world</div>
<style>
  .div {
    display: flex;
    foo: var(--bar);
  }
  @media (max-width: env(--mobile)) {
    .div {
      display: block;
    }
  }
  .div:hover {
    display: flex;
  }
  .div .nested-selector {
    display: grid;
  }
</style>
"
`;

exports[`Html Typescript Test onInit & onMount 1`] = `
"<div></div>
<script>
  (() => {
    const state = {};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;
    let onInitOnce = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    if (!onInitOnce) {
      console.log(\\"onInit\\");
      onInitOnce = true;
    }

    // onMount
    console.log(\\"onMount\\");
  })();
</script>
"
`;

exports[`Html Typescript Test onInit 1`] = `
"<div>
  Default name defined by parent
  <template data-el=\\"div-1\\"><!-- state.name --></template>
</div>
<script>
  (() => {
    const state = { name: \\"\\" };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;
    let onInitOnce = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, state.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    if (!onInitOnce) {
      state.name = defaultValues.name || props.name;
      update();
      console.log(\\"set defaults with props\\");
      onInitOnce = true;
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Typescript Test onMount 1`] = `
"<div></div>
<script>
  (() => {
    const state = {};

    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // onMount
    console.log(\\"Runs on mount\\");
  })();
</script>
"
`;

exports[`Html Typescript Test onUpdate 1`] = `
"<div></div>
"
`;

exports[`Html Typescript Test onUpdateWithDeps 1`] = `
"<div></div>
"
`;

exports[`Html Typescript Test preserveExportOrLocalStatement 1`] = `
"<div></div>
"
`;

exports[`Html Typescript Test preserveTyping 1`] = `
"<div>
  Hello! I can run in React, Vue, Solid, or Liquid!
  <template data-el=\\"div-1\\"><!-- props.name --></template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Typescript Test propsDestructure 1`] = `
"<div>
  <slot></slot>

  <template data-el=\\"div-2\\"><!-- props.type --></template>

  Hello! I can run in React, Vue, Solid, or Liquid!
</div>
<script>
  (() => {
    const state = { name: \\"Decadef20\\" };
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, props.type);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Typescript Test propsInterface 1`] = `
"<div>
  Hello! I can run in React, Vue, Solid, or Liquid!
  <template data-el=\\"div-1\\"><!-- props.name --></template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Typescript Test propsType 1`] = `
"<div>
  Hello! I can run in React, Vue, Solid, or Liquid!
  <template data-el=\\"div-1\\"><!-- props.name --></template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.name);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Typescript Test renderContentExample 1`] = `
"<div class=\\"div\\" data-el=\\"div-1\\">
  <RenderBlocks data-el=\\"render-blocks\\"></RenderBlocks>
</div>
<style>
  .div {
    display: flex;
    flex-direction: columns;
  }
</style>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        el.removeEventListener(\\"click\\", onDiv1Click);
        el.addEventListener(\\"click\\", onDiv1Click);
      });

      document.querySelectorAll(\\"[data-el='render-blocks']\\").forEach((el) => {
        el.setAttribute(\\"blocks\\", props.content.blocks);
      });

      destroyAnyNodes();

      dispatchNewContentToVisualEditor(props.content);

      pendingUpdate = false;
    }

    // Event handler for 'click' event on div-1
    function onDiv1Click(event) {
      trackClick(props.content.id);
    }

    // Update with initial state on first load
    update();

    // onMount
    sendComponentsToVisualEditor(props.customComponents);
  })();
</script>
"
`;

exports[`Html Typescript Test rootFragmentMultiNode 1`] = `
"<template data-el=\\"show\\">
  <a data-el=\\"a-1\\">
    <template data-el=\\"div-1\\"><!-- props.text --></template>
  </a>
</template>

<template data-el=\\"show-2\\">
  <button type=\\"button\\" data-el=\\"button-1\\">
    <template data-el=\\"div-2\\"><!-- props.text --></template>
  </button>
</template>

<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='a-1']\\").forEach((el) => {
        el.setAttribute(\\"href\\", props.link);

        el.setAttribute(
          \\"target\\",
          props.openLinkInNewTab ? \\"_blank\\" : undefined
        );
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      document.querySelectorAll(\\"[data-el='show-2']\\").forEach((el) => {
        const whenCondition = !props.link;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        renderTextNode(el, props.text);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Typescript Test rootShow 1`] = `
"<template data-el=\\"show\\">
  <div>Bar</div>
</template>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.foo === \\"bar\\";
        if (whenCondition) {
          showContent(el);
        }
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }
  })();
</script>
"
`;

exports[`Html Typescript Test self-referencing component 1`] = `
"<div>
  <template data-el=\\"div-1\\"><!-- props.name --></template>

  <template data-el=\\"show\\">
    <MyComponent name=\\"Bruce Wayne\\"></MyComponent>
  </template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.name);
      });

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.name === \\"Batman\\";
        if (whenCondition) {
          showContent(el);
        }
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Typescript Test self-referencing component with children 1`] = `
"<div>
  <template data-el=\\"div-1\\"><!-- props.name --></template>

  <slot></slot>

  <template data-el=\\"show\\">
    <MyComponent name=\\"Bruce\\">
      <div>Wayne</div>
    </MyComponent>
  </template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.name);
      });

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.name === \\"Batman\\";
        if (whenCondition) {
          showContent(el);
        }
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Typescript Test showWithFor 1`] = `
"<template data-el=\\"show\\">
  <template data-el=\\"for\\">
    <div data-el=\\"div-1\\">
      <template data-el=\\"div-2\\"><!-- item --></template>
    </div>
  </template>
</template>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='show']\\").forEach((el) => {
        const whenCondition = props.conditionA;
        if (whenCondition) {
          showContent(el);
        }
      });

      document.querySelectorAll(\\"[data-el='for']\\").forEach((el) => {
        let array = props.items;
        renderLoop(el, array, \\"item\\", \\"idx\\");
      });

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        const idx = getScope(el, \\"idx\\");

        el.key = idx;
      });

      document.querySelectorAll(\\"[data-el='div-2']\\").forEach((el) => {
        const item = getScope(el, \\"item\\");
        renderTextNode(el, item);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    function showContent(el) {
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
      // grabs the content of a node that is between <template> tags
      // iterates through child nodes to register all content including text elements
      // attaches the content after the template

      const elementFragment = el.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (el?.scope) {
          child.scope = el.scope;
        }
        if (el?.context) {
          child.context = el.context;
        }
        nodesToDestroy.push(child);
      });
      el.after(elementFragment);
    }

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }

    // Helper to render loops
    function renderLoop(template, array, itemName, itemIndex, collectionName) {
      const collection = [];
      for (let [index, value] of array.entries()) {
        const elementFragment = template.content.cloneNode(true);
        const children = Array.from(elementFragment.childNodes);
        const localScope = {};
        let scope = localScope;
        if (template?.scope) {
          const getParent = {
            get(target, prop, receiver) {
              if (prop in target) {
                return target[prop];
              }
              if (prop in template.scope) {
                return template.scope[prop];
              }
              return target[prop];
            },
          };
          scope = new Proxy(localScope, getParent);
        }
        children.forEach((child) => {
          if (itemName !== undefined) {
            scope[itemName] = value;
          }
          if (itemIndex !== undefined) {
            scope[itemIndex] = index;
          }
          if (collectionName !== undefined) {
            scope[collectionName] = array;
          }
          child.scope = scope;
          if (template.context) {
            child.context = template.context;
          }
          this.nodesToDestroy.push(child);
          collection.unshift(child);
        });
        collection.forEach((child) => template.after(child));
      }
    }

    function getScope(el, name) {
      do {
        let value = el?.scope?.[name];
        if (value !== undefined) {
          return value;
        }
      } while ((el = el.parentNode));
    }
  })();
</script>
"
`;

exports[`Html Typescript Test spreadAttrs 1`] = `
"<input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
"
`;

exports[`Html Typescript Test spreadNestedProps 1`] = `
"<input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
"
`;

exports[`Html Typescript Test spreadProps 1`] = `
"<input data-el=\\"input-1\\" data-dom-state=\\"input-2\\" />
"
`;

exports[`Html Typescript Test subComponent 1`] = `
"<Foo></Foo>
"
`;

exports[`Html Typescript Test typeDependency 1`] = `
"<div>
  <template data-el=\\"div-1\\"><!-- props.foo --></template>
</div>
<script>
  (() => {
    const state = {};
    let props = {};
    let context = null;
    let nodesToDestroy = [];
    let pendingUpdate = false;

    function destroyAnyNodes() {
      // destroy current view template refs before rendering again
      nodesToDestroy.forEach((el) => el.remove());
      nodesToDestroy = [];
    }

    // Function to update data bindings and loops
    // call update() when you mutate state and need the updates to reflect
    // in the dom
    function update() {
      if (pendingUpdate === true) {
        return;
      }
      pendingUpdate = true;

      document.querySelectorAll(\\"[data-el='div-1']\\").forEach((el) => {
        renderTextNode(el, props.foo);
      });

      destroyAnyNodes();

      pendingUpdate = false;
    }

    // Update with initial state on first load
    update();

    // Helper text DOM nodes
    function renderTextNode(el, text) {
      const textNode = document.createTextNode(text);
      if (el?.scope) {
        textNode.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      el.after(textNode);
      nodesToDestroy.push(el.nextSibling);
    }
  })();
</script>
"
`;

exports[`Html Typescript Test use-style 1`] = `
"<button type=\\"button\\">Button</button>
<style>
  button {
    background: blue;
    color: white;
    font-size: 12px;
    outline: 1px solid black;
  }
</style>
"
`;

exports[`Html Typescript Test use-style-and-css 1`] = `
"<button type=\\"button\\" class=\\"button\\">Button</button>
<style>
  .button {
    background: blue;
    color: white;
  }

  button {
    font-size: 12px;
    outline: 1px solid black;
  }
</style>
"
`;

exports[`Html Typescript Test use-style-outside-component 1`] = `
"<button type=\\"button\\">Button</button>
<style>
  button {
    background: blue;
    color: white;
    font-size: 12px;
    outline: 1px solid black;
  }
</style>
"
`;
