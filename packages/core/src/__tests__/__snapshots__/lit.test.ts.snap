// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Lit > jsx > Javascript Test > Advanced 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-for-show-component\\")
export default class MyBasicForShowComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() name = \\"PatrickJS\\";
  @state() names = [\\"Steve\\", \\"PatrickJS\\"];

  render() {
    return html\`

          <main>
          \${this.names?.map(
            (person, i) => html\`
      <div>\${i} : \${person}</div>
      \`
          )} \${this.names?.map((person, index) => html\`<span>\${person}</span>\`)}
          \${this.names?.map((_, index) => html\`<br />\`)} \${Array.from({
      length: 10,
    })?.map(
      (_, ee) => html\`
      <pre>\${ee}</pre>
      \`
    )} \${Array.from({ length: 10 })?.map(
      (_, index) => html\`
      <p>\${index}</p>
      \`
    )} \${this.names?.map(
      (person, index) => html\`<span
        >\${person} \${index}</span
      >\`
    )} \${Array.from({ length: 10 })?.map(
      (person, count) => html\`<span
        >\${person} \${count}</span
      >\`
    )} \${this.names?.map(
      (person, i) => html\`<span>\${person} \${i}</span>\`
    )} \${Array.from({ length: 10 })?.map(
      (person, index) => html\`<span
        >\${person} \${index}</span
      >\`
    )}
        </main>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > AdvancedRef 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-ref-component\\")
export default class MyBasicRefComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @query('[ref=\\"inputRef\\"]')
  inputRef!: HTMLElement;

  @query('[ref=\\"inputNoArgRef\\"]')
  inputNoArgRef!: HTMLElement;

  @property() showInput: any;

  @state() name = \\"PatrickJS\\";

  onBlur = function onBlur() {
    // Maintain focus
    this.inputRef.focus();
  };
  lowerCaseName = function lowerCaseName() {
    return this.name.toLowerCase();
  };

  updated() {
    console.log(\\"Received an update\\");
  }

  render() {
    return html\`
          <style>.input {
  color: red;
}
</style>
          <div>
          \${
            this.showInput
              ? html\`<my-fragment
           ><input ref=\\"inputRef\\" .value=\${this.name} @blur=\${(event) =>
                  this.onBlur()}
           @change=\${(event) => (this.name = event.target.value)} />
           <label for=\\"cars\\" ref=\\"inputNoArgRef\\"> Choose a car: </label>
           <select name=\\"cars\\" id=\\"cars\\">
             <option value=\\"supra\\">GR Supra</option>
             <option value=\\"86\\">GR 86</option>
           </select></my-fragment
         >\`
              : null
          } Hello \${this.lowerCaseName()} ! I can run in React, Qwik, Vue,
          Solid, or Web Component!
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > Basic 1`] = `
"export const DEFAULT_VALUES = {
  name: \\"Steve\\",
};

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() name = \\"Steve\\";
  @state() age = 1;
  @state() sports = [\\"\\"];

  underscore_fn_name() {
    return \\"bar\\";
  }

  render() {
    return html\`
          <style>.div {
  padding: 10px;
}
</style>
          <div>
          <input .value=\${DEFAULT_VALUES.name || this.name} @change=\${(
      myEvent
    ) =>
      (this.name =
        myEvent.target.value)} /> Hello! I can run in React, Vue, Solid, or
          Liquid! &gt;
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > Basic 2`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-for-show-component\\")
export default class MyBasicForShowComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() name = \\"PatrickJS\\";
  @state() names = [\\"Steve\\", \\"PatrickJS\\"];

  render() {
    return html\`

          <div>
          \${this.names?.map(
            (person, index) =>
              html\`\${
                person === this.name
                  ? html\`<input .value=\${this.name} @change=\${(event) => {
                      this.name = event.target.value + \\" and \\" + person;
                    }} /> Hello \${person} ! I can run in
          Qwik, Web Component, React, Vue, Solid, or Liquid! \`
                  : null
              }\`
          )}
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > Basic Context 1`] = `
"import { Injector, MyService, createInjector } from \\"@dummy/injection-js\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() name = \\"PatrickJS\\";

  onChange = function onChange() {
    const change = myService.method(\\"change\\");
    console.log(change);
  };

  connectedCallback() {
    const bye = myService.method(\\"hi\\");
    console.log(bye);
  }

  render() {
    return html\`

          <div>
          \${
            myService.method(\\"hello\\") + this.name
          } Hello! I can run in React, Vue,
          Solid, or Liquid! <input @change=\${(event) => this.onChange} />
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > Basic OnMount Update 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-on-mount-update-component\\")
export default class MyBasicOnMountUpdateComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() bye: any;
  @property() hi: any;

  @state() name = \\"PatrickJS\\";
  @state() names = [\\"Steve\\", \\"PatrickJS\\"];

  connectedCallback() {
    this.name = \\"PatrickJS onMount\\" + this.bye;
  }

  render() {
    return html\`

          <div>Hello \${this.name}</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > Basic Outputs 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-outputs-component\\")
export default class MyBasicOutputsComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() onMessage: any;
  @property() onEvent: any;
  @property() message: any;

  @state() name = \\"PatrickJS\\";

  connectedCallback() {
    this.onMessage(this.name);
    this.onEvent(this.message);
  }

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > Basic Outputs Meta 1`] = `
"/**
          useMetadata:
          {\\"outputs\\":[\\"onMessage\\",\\"onEvent\\"],\\"baz\\":\\"metadata inside component\\"}
          */

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-outputs-component\\")
export default class MyBasicOutputsComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() onMessage: any;
  @property() onEvent: any;
  @property() message: any;

  @state() name = \\"PatrickJS\\";

  connectedCallback() {
    this.onMessage(this.name);
    this.onEvent(this.message);
  }

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > BasicAttribute 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <input autocapitalize=\\"on\\" autocomplete=\\"on\\" .spellcheck=\\"\${true}\\" />

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > BasicBooleanAttribute 1`] = `
"import MyBooleanAttributeComponent from \\"./basic-boolean-attribute-component.raw\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-boolean-attribute\\")
export default class MyBooleanAttribute extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() children: any;
  @property() type: any;

  render() {
    return html\`

          <div>
          \${this.children ? html\`\${this.children} \${this.type}\` : null}
          <my-boolean-attribute-component
            .toggle=\\"\${true}\\"
          ></my-boolean-attribute-component>
          <my-boolean-attribute-component
            .toggle=\\"\${true}\\"
          ></my-boolean-attribute-component>
          <my-boolean-attribute-component
            .list=\\"\${null}\\"
          ></my-boolean-attribute-component>
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > BasicChildComponent 1`] = `
"import MyBasicOnMountUpdateComponent from \\"./basic-onMount-update.raw\\";
import MyBasicComponent from \\"./basic.raw\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-child-component\\")
export default class MyBasicChildComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() name = \\"Steve\\";
  @state() dev = \\"PatrickJS\\";

  render() {
    return html\`

          <div>
          <my-basic-component .id=\\"\${this.dev}\\"></my-basic-component>
          <div>
            <my-basic-on-mount-update-component
              .hi=\\"\${this.name}\\"
              .bye=\\"\${this.dev}\\"
            ></my-basic-on-mount-update-component>
          </div>
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > BasicFor 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-for-component\\")
export default class MyBasicForComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() name = \\"PatrickJS\\";
  @state() names = [\\"Steve\\", \\"PatrickJS\\"];

  connectedCallback() {
    console.log(\\"onMount code\\");
  }

  render() {
    return html\`

          <div>
          \${this.names?.map(
            (person, index) => html\`<my-fragment
        ><input .value=\${this.name} @change=\${(event) => {
              this.name = event.target.value + \\" and \\" + person;
            }} /> Hello \${person} ! I can run in
        Qwik, Web Component, React, Vue, Solid, or Liquid! </my-fragment
      >\`
          )}
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > BasicRef 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-ref-component\\")
export default class MyBasicRefComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @query('[ref=\\"inputRef\\"]')
  inputRef!: HTMLElement;

  @query('[ref=\\"inputNoArgRef\\"]')
  inputNoArgRef!: HTMLElement;

  @property() showInput: any;

  @state() name = \\"PatrickJS\\";

  onBlur = function onBlur() {
    // Maintain focus
    this.inputRef?.focus();
  };
  lowerCaseName = function lowerCaseName() {
    return this.name.toLowerCase();
  };

  render() {
    return html\`
          <style>.input {
  color: red;
}
</style>
          <div>
          \${
            this.showInput
              ? html\`<my-fragment
           ><input ref=\\"inputRef\\" .value=\${this.name} @blur=\${(event) =>
                  this.onBlur()}
           @change=\${(event) => (this.name = event.target.value)} />
           <label for=\\"cars\\" ref=\\"inputNoArgRef\\"> Choose a car: </label>
           <select name=\\"cars\\" id=\\"cars\\">
             <option value=\\"supra\\">GR Supra</option>
             <option value=\\"86\\">GR 86</option>
           </select></my-fragment
         >\`
              : null
          } Hello \${this.lowerCaseName()} ! I can run in React, Qwik, Vue,
          Solid, or Web Component!
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > BasicRefAssignment 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-ref-assignment-component\\")
export default class MyBasicRefAssignmentComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  handlerClick = function handlerClick(event) {
    event.preventDefault();
    console.log(\\"current value\\", this.holdValueRef);
    this.holdValueRef = this.holdValueRef + \\"JS\\";
  };

  render() {
    return html\`

          <div ><button  @click=\${async (evt) =>
            await this.handlerClick(evt)} >Click</button></div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > BasicRefPrevious 1`] = `
"export function usePrevious(value) {
  // The ref object is a generic container whose current property is mutable ...
  // ... and can hold any value, similar to an instance property on a class
  let ref = useRef(null); // Store current value in ref

  onUpdate(() => {
    ref = value;
  }, [value]); // Only re-run if value changes
  // Return previous value (happens before update in useEffect above)

  return ref;
}

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-previous-component\\")
export default class MyPreviousComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() count = 0;

  updated() {
    this.prevCount = this.count;
  }

  render() {
    return html\`

          <div ><h1 >
                Now:
        \${this.count}
        , before:
        \${this.prevCount}</h1>
        <button  @click=\${(event) =>
          (this.count += 1)} >Increment</button></div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > Button 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"my-button\\")
export default class Button extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() link: any;
  @property() attributes: any;
  @property() openLinkInNewTab: any;
  @property() text: any;

  render() {
    return html\`

          <div >\${
            this.link
              ? html\`<a  \${spread(props.attributes)}  .href=\${
                  this.link
                }  .target=\${this.openLinkInNewTab ? \\"_blank\\" : undefined} >\${
                  this.text
                }</a>\`
              : null
          }
        \${
          !this.link
            ? html\`<button  type=\\"button\\"  \${spread(props.attributes)} >\${
                this.text
              }</button>\`
            : null
        }</div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > Columns 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-column\\")
export default class Column extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() columns: any;
  @property() space: any;

  getColumns() {
    return this.columns || [];
  }
  getGutterSize() {
    return typeof this.space === \\"number\\" ? this.space || 0 : 20;
  }
  getWidth(index) {
    const columns = this.getColumns();
    return (columns[index] && columns[index].width) || 100 / columns.length;
  }
  getColumnCssWidth(index) {
    const columns = this.getColumns();
    const gutterSize = this.getGutterSize();
    const subtractWidth = (gutterSize * (columns.length - 1)) / columns.length;
    return \`calc(\${this.getWidth(index)}% - \${subtractWidth}px)\`;
  }

  render() {
    return html\`
          <style>.div {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  line-height: normal;
}
@media (max-width: 999px) {
  .div {
    flex-direction: row;
  }
}
@media (max-width: 639px) {
  .div {
    flex-direction: row-reverse;
  }
}
.div-2 {
  flex-grow: 1;
}
</style>
          <div>
          \${this.columns?.map(
            (column, index) => html\`
         <div>\${column.content} \${index}</div>
         \`
          )}
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > ContentSlotHtml 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"content-slot-code\\")
export default class ContentSlotCode extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() slotTesting: any;

  render() {
    return html\`

          <div>
          <my-slot .name=\\"\${this.slotTesting}\\"></my-slot>
          <div><hr /></div>
          <div><my-slot></my-slot></div>
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > ContentSlotJSX 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"content-slot-jsx-code\\")
export default class ContentSlotJsxCode extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() slotContent: any;
  @property() children: any;
  @property() slotReference: any;
  @property() attributes: any;
  @property() content: any;

  @state() name = \\"king\\";
  @state() showContent = false;

  get cls() {
    return this.slotContent && this.children ? \`\${this.name}-content\` : \\"\\";
  }
  show() {
    this.slotContent ? 1 : \\"\\";
  }

  render() {
    return html\`

          \${
            this.slotReference
              ? html\`<div  class={state.cls}  .name=\${
                  this.slotContent ? \\"name1\\" : \\"name2\\"
                }  .title=\${this.slotContent ? \\"title1\\" : \\"title2\\"}  \${spread(
                  props.attributes
                )}  @click=\${(event) => this.show()} >\${
                  this.showContent && this.slotContent
                    ? html\`<my-slot  name=\\"content\\" >\${this.content}</my-slot>\`
                    : null
                }
       <div ><hr  /></div>
       <div >\${this.children}</div></div>\`
              : null
          }
        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > CustomCode 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"custom-code\\")
export default class CustomCode extends LitElement {
  createRenderRoot() {
    return this;
  }

  @query('[ref=\\"elem\\"]')
  elem!: HTMLElement;

  @property() replaceNodes: any;
  @property() code: any;

  @state() scriptsInserted = [];
  @state() scriptsRun = [];

  findAndRunScripts() {
    // TODO: Move this function to standalone one in '@builder.io/utils'
    if (this.elem && typeof window !== \\"undefined\\") {
      /** @type {HTMLScriptElement[]} */
      const scripts = this.elem.getElementsByTagName(\\"script\\");

      for (let i = 0; i < scripts.length; i++) {
        const script = scripts[i];

        if (script.src) {
          if (this.scriptsInserted.includes(script.src)) {
            continue;
          }

          this.scriptsInserted.push(script.src);
          const newScript = document.createElement(\\"script\\");
          newScript.async = true;
          newScript.src = script.src;
          document.head.appendChild(newScript);
        } else if (
          !script.type ||
          [
            \\"text/javascript\\",
            \\"application/javascript\\",
            \\"application/ecmascript\\",
          ].includes(script.type)
        ) {
          if (this.scriptsRun.includes(script.innerText)) {
            continue;
          }

          try {
            this.scriptsRun.push(script.innerText);
            new Function(script.innerText)();
          } catch (error) {
            console.warn(\\"\`CustomCode\`: Error running script:\\", error);
          }
        }
      }
    }
  }

  connectedCallback() {
    this.findAndRunScripts();
  }

  render() {
    return html\`

          <div  class={'builder-custom-code' + (props.replaceNodes ? ' replace-nodes' : '')}  ref=\\"elem\\"  .innerHTML=\${this.code} ></div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > Embed 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"custom-code\\")
export default class CustomCode extends LitElement {
  createRenderRoot() {
    return this;
  }

  @query('[ref=\\"elem\\"]')
  elem!: HTMLElement;

  @property() replaceNodes: any;
  @property() code: any;

  @state() scriptsInserted = [];
  @state() scriptsRun = [];

  findAndRunScripts() {
    // TODO: Move this function to standalone one in '@builder.io/utils'
    if (this.elem && typeof window !== \\"undefined\\") {
      /** @type {HTMLScriptElement[]} */
      const scripts = this.elem.getElementsByTagName(\\"script\\");

      for (let i = 0; i < scripts.length; i++) {
        const script = scripts[i];

        if (script.src) {
          if (this.scriptsInserted.includes(script.src)) {
            continue;
          }

          this.scriptsInserted.push(script.src);
          const newScript = document.createElement(\\"script\\");
          newScript.async = true;
          newScript.src = script.src;
          document.head.appendChild(newScript);
        } else if (
          !script.type ||
          [
            \\"text/javascript\\",
            \\"application/javascript\\",
            \\"application/ecmascript\\",
          ].includes(script.type)
        ) {
          if (this.scriptsRun.includes(script.innerText)) {
            continue;
          }

          try {
            this.scriptsRun.push(script.innerText);
            new Function(script.innerText)();
          } catch (error) {
            console.warn(\\"\`CustomCode\`: Error running script:\\", error);
          }
        }
      }
    }
  }

  connectedCallback() {
    this.findAndRunScripts();
  }

  render() {
    return html\`

          <div  class={'builder-custom-code' + (props.replaceNodes ? ' replace-nodes' : '')}  ref=\\"elem\\"  .innerHTML=\${this.code} ></div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > Form 1`] = `
"import { Builder, builder } from \\"@builder.io/sdk\\";
import {
  BuilderBlock as BuilderBlockComponent,
  BuilderBlocks,
  get,
  set,
} from \\"@fake\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"form-component\\")
export default class FormComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @query('[ref=\\"formRef\\"]')
  formRef!: HTMLElement;

  @property() previewState: any;
  @property() sendWithJs: any;
  @property() sendSubmissionsTo: any;
  @property() action: any;
  @property() customHeaders: any;
  @property() contentType: any;
  @property() sendSubmissionsToEmail: any;
  @property() name: any;
  @property() method: any;
  @property() errorMessagePath: any;
  @property() resetFormOnSubmit: any;
  @property() successUrl: any;
  @property() validate: any;
  @property() attributes: any;
  @property() builderBlock: any;
  @property() errorMessage: any;
  @property() sendingMessage: any;
  @property() successMessage: any;

  @state() formState = \\"unsubmitted\\";
  @state() responseData = null;
  @state() formErrorMessage = \\"\\";

  get submissionState() {
    return (Builder.isEditing && this.previewState) || this.formState;
  }
  onSubmit(event) {
    const sendWithJs = this.sendWithJs || this.sendSubmissionsTo === \\"email\\";

    if (this.sendSubmissionsTo === \\"zapier\\") {
      event.preventDefault();
    } else if (sendWithJs) {
      if (!(this.action || this.sendSubmissionsTo === \\"email\\")) {
        event.preventDefault();
        return;
      }

      event.preventDefault();
      const el = event.currentTarget;
      const headers = this.customHeaders || {};
      let body;
      const formData = new FormData(el); // TODO: maybe support null

      const formPairs = Array.from(
        event.currentTarget.querySelectorAll(\\"input,select,textarea\\")
      )
        .filter((el) => !!el.name)
        .map((el) => {
          let value;
          const key = el.name;

          if (el instanceof HTMLInputElement) {
            if (el.type === \\"radio\\") {
              if (el.checked) {
                value = el.name;
                return {
                  key,
                  value,
                };
              }
            } else if (el.type === \\"checkbox\\") {
              value = el.checked;
            } else if (el.type === \\"number\\" || el.type === \\"range\\") {
              const num = el.valueAsNumber;

              if (!isNaN(num)) {
                value = num;
              }
            } else if (el.type === \\"file\\") {
              // TODO: one vs multiple files
              value = el.files;
            } else {
              value = el.value;
            }
          } else {
            value = el.value;
          }

          return {
            key,
            value,
          };
        });
      let contentType = this.contentType;

      if (this.sendSubmissionsTo === \\"email\\") {
        contentType = \\"multipart/form-data\\";
      }

      Array.from(formPairs).forEach(({ value }) => {
        if (
          value instanceof File ||
          (Array.isArray(value) && value[0] instanceof File) ||
          value instanceof FileList
        ) {
          contentType = \\"multipart/form-data\\";
        }
      }); // TODO: send as urlEncoded or multipart by default
      // because of ease of use and reliability in browser API
      // for encoding the form?

      if (contentType !== \\"application/json\\") {
        body = formData;
      } else {
        // Json
        const json = {};
        Array.from(formPairs).forEach(({ value, key }) => {
          set(json, key, value);
        });
        body = JSON.stringify(json);
      }

      if (contentType && contentType !== \\"multipart/form-data\\") {
        if (
          /* Zapier doesn't allow content-type header to be sent from browsers */
          !(sendWithJs && this.action?.includes(\\"zapier.com\\"))
        ) {
          headers[\\"content-type\\"] = contentType;
        }
      }

      const presubmitEvent = new CustomEvent(\\"presubmit\\", {
        detail: {
          body,
        },
      });

      if (this.formRef) {
        this.formRef.dispatchEvent(presubmitEvent);

        if (presubmitEvent.defaultPrevented) {
          return;
        }
      }

      this.formState = \\"sending\\";
      const formUrl = \`\${
        builder.env === \\"dev\\" ? \\"http://localhost:5000\\" : \\"https://builder.io\\"
      }/api/v1/form-submit?apiKey=\${builder.apiKey}&to=\${btoa(
        this.sendSubmissionsToEmail || \\"\\"
      )}&name=\${encodeURIComponent(this.name || \\"\\")}\`;
      fetch(
        this.sendSubmissionsTo === \\"email\\" ? formUrl : this.action,
        /* TODO: throw error if no action URL */
        {
          body,
          headers,
          method: this.method || \\"post\\",
        }
      ).then(
        async (res) => {
          let body;
          const contentType = res.headers.get(\\"content-type\\");

          if (contentType && contentType.indexOf(\\"application/json\\") !== -1) {
            body = await res.json();
          } else {
            body = await res.text();
          }

          if (!res.ok && this.errorMessagePath) {
            /* TODO: allow supplying an error formatter function */
            let message = get(body, this.errorMessagePath);

            if (message) {
              if (typeof message !== \\"string\\") {
                /* TODO: ideally convert json to yaml so it woul dbe like
            error: - email has been taken */
                message = JSON.stringify(message);
              }

              this.formErrorMessage = message;
            }
          }

          this.responseData = body;
          this.formState = res.ok ? \\"success\\" : \\"error\\";

          if (res.ok) {
            const submitSuccessEvent = new CustomEvent(\\"submit:success\\", {
              detail: {
                res,
                body,
              },
            });

            if (this.formRef) {
              this.formRef.dispatchEvent(submitSuccessEvent);

              if (submitSuccessEvent.defaultPrevented) {
                return;
              }
              /* TODO: option to turn this on/off? */

              if (this.resetFormOnSubmit !== false) {
                this.formRef.reset();
              }
            }
            /* TODO: client side route event first that can be preventDefaulted */

            if (this.successUrl) {
              if (this.formRef) {
                const event = new CustomEvent(\\"route\\", {
                  detail: {
                    url: this.successUrl,
                  },
                });
                this.formRef.dispatchEvent(event);

                if (!event.defaultPrevented) {
                  location.href = this.successUrl;
                }
              } else {
                location.href = this.successUrl;
              }
            }
          }
        },
        (err) => {
          const submitErrorEvent = new CustomEvent(\\"submit:error\\", {
            detail: {
              error: err,
            },
          });

          if (this.formRef) {
            this.formRef.dispatchEvent(submitErrorEvent);

            if (submitErrorEvent.defaultPrevented) {
              return;
            }
          }

          this.responseData = err;
          this.formState = \\"error\\";
        }
      );
    }
  }

  render() {
    return html\`
          <style>.pre {
  padding: 10px;
  color: red;
  text-align: center;
}
</style>
          <form  .validate=\${this.validate}  ref=\\"formRef\\"  .action=\${
      !this.sendWithJs && this.action
    }  .method=\${this.method}  .name=\${this.name}  @submit=\${(event) =>
      this.onSubmit(event)}  \${spread(props.attributes)} >\${
      this.builderBlock && this.builderBlock.children
        ? html\`\${this.builderBlock?.children?.map(
            (block, index) =>
              html\`<builder-block-component  .key=\${block.id}  .block=\${block}  .index=\${index} ></builder-block-component>\`
          )}\`
        : null
    }
        \${
          this.submissionState === \\"error\\"
            ? html\`<builder-blocks  dataPath=\\"errorMessage\\"  .blocks=\${this.errorMessage} ></builder-blocks>\`
            : null
        }
        \${
          this.submissionState === \\"sending\\"
            ? html\`<builder-blocks  dataPath=\\"sendingMessage\\"  .blocks=\${this.sendingMessage} ></builder-blocks>\`
            : null
        }
        \${
          this.submissionState === \\"error\\" && this.responseData
            ? html\`<pre >\${JSON.stringify(this.responseData, null, 2)}</pre>\`
            : null
        }
        \${
          this.submissionState === \\"success\\"
            ? html\`<builder-blocks  dataPath=\\"successMessage\\"  .blocks=\${this.successMessage} ></builder-blocks>\`
            : null
        }</form>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > Image 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-image\\")
export default class Image extends LitElement {
  createRenderRoot() {
    return this;
  }

  @query('[ref=\\"pictureRef\\"]')
  pictureRef!: HTMLElement;

  @property() lazy: any;
  @property() altText: any;
  @property() _class: any;
  @property() image: any;
  @property() srcset: any;
  @property() sizes: any;
  @property() children: any;

  @state() scrollListener = null;
  @state() imageLoaded = false;
  @state() load = false;

  setLoaded() {
    this.imageLoaded = true;
  }
  useLazyLoading() {
    // TODO: Add more checks here, like testing for real web browsers
    return !!this.lazy && this.isBrowser();
  }
  isBrowser = function isBrowser() {
    return (
      typeof window !== \\"undefined\\" && window.navigator.product != \\"ReactNative\\"
    );
  };

  connectedCallback() {
    if (this.useLazyLoading()) {
      // throttled scroll capture listener
      const listener = () => {
        if (this.pictureRef) {
          const rect = this.pictureRef.getBoundingClientRect();
          const buffer = window.innerHeight / 2;

          if (rect.top < window.innerHeight + buffer) {
            this.load = true;
            this.scrollListener = null;
            window.removeEventListener(\\"scroll\\", listener);
          }
        }
      };

      this.scrollListener = listener;
      window.addEventListener(\\"scroll\\", listener, {
        capture: true,
        passive: true,
      });
      listener();
    }
  }
  disconnectedCallback() {
    if (this.scrollListener) {
      window.removeEventListener(\\"scroll\\", this.scrollListener);
    }
  }

  render() {
    return html\`
          <style>.img {
  opacity: 1;
  transition: opacity 0.2s ease-in-out;
  object-fit: cover;
  object-position: center;
}
</style>
          <div>
          <picture ref=\\"pictureRef\\"
            >\${
              !this.useLazyLoading() || this.load
                ? html\`<img class={'builder-image' +
           (props._class ? ' ' + props._class : '') + ' img'} .alt=\${
             this.altText
           }
           aria-role=\${this.altText ? \\"presentation\\" : undefined} .src=\${
                    this.image
                  }
           @load=\${(event) => this.setLoaded()} .srcset=\${this.srcset}
           .sizes=\${this.sizes} />\`
                : null
            }
            <source .srcset=\\"\${this.srcset}\\"
          /></picture>
          \${this.children}
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > Image State 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"img-state-component\\")
export default class ImgStateComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() canShow = true;
  @state() images = [\\"http://example.com/qwik.png\\"];

  render() {
    return html\`

          <div>
          \${this.images?.map(
            (item, itemIndex) => html\`<my-fragment
        ><img .src=\\"\${item}\\" .key=\\"\${itemIndex}\\" /></my-fragment
      >\`
          )}
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > Img 1`] = `
"import { Builder } from \\"@builder.io/sdk\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"img-component\\")
export default class ImgComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() backgroundSize: any;
  @property() backgroundPosition: any;
  @property() attributes: any;
  @property() imgSrc: any;
  @property() altText: any;

  render() {
    return html\`

          <img .style=\${{
            objectFit: this.backgroundSize || \\"cover\\",
            objectPosition: this.backgroundPosition || \\"center\\",
          }} \${spread(props.attributes)}
        .key=\${(Builder.isEditing && this.imgSrc) || \\"default-key\\"} .alt=\${
      this.altText
    }
        .src=\${this.imgSrc} />

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > Input 1`] = `
"import { Builder } from \\"@builder.io/sdk\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"form-input-component\\")
export default class FormInputComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() attributes: any;
  @property() defaultValue: any;
  @property() placeholder: any;
  @property() type: any;
  @property() name: any;
  @property() value: any;
  @property() required: any;
  @property() onChange: any;

  render() {
    return html\`

          <input \${spread(props.attributes)} .key=\${
      Builder.isEditing && this.defaultValue ? this.defaultValue : \\"default-key\\"
    } .placeholder=\${this.placeholder}
        .type=\${this.type} .name=\${this.name} .value=\${this.value}
        .defaultValue=\${this.defaultValue} .required=\${
      this.required
    } @change=\${(event) => this.onChange?.(event.target.value)} />

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > InputParent 1`] = `
"import FormInputComponent from \\"./input.raw\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-stepper\\")
export default class Stepper extends LitElement {
  createRenderRoot() {
    return this;
  }

  handleChange(value) {
    console.log(value);
  }

  render() {
    return html\`

          <form-input-component  name=\\"kingzez\\"  type=\\"text\\"  @change=\${(
            value
          ) => this.handleChange(value)} ></form-input-component>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > NestedStore 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"nested-store\\")
export default class NestedStore extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() _id = \\"abc\\";
  @state() _messageId = this._id + \\"-message\\";

  render() {
    return html\`

          <div .id=\\"\${this._id}\\">
          Test

          <p .id=\\"\${this._messageId}\\">Message</p>
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > RawText 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"raw-text\\")
export default class RawText extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() attributes: any;
  @property() text: any;

  render() {
    return html\`

          <span  class={props.attributes?.class || props.attributes?.className}  .innerHTML=\${
            this.text || \\"\\"
          } ></span>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > Section 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"section-component\\")
export default class SectionComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() attributes: any;
  @property() maxWidth: any;
  @property() children: any;

  render() {
    return html\`

          <section  \${spread(props.attributes)}  .style=\${
      this.maxWidth && typeof this.maxWidth === \\"number\\"
        ? {
            maxWidth: this.maxWidth,
          }
        : undefined
    } >\${this.children}</section>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > Section 2`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"section-state-component\\")
export default class SectionStateComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() attributes: any;
  @property() children: any;

  @state() max = 42;
  @state() items = [42];

  render() {
    return html\`

          \${
            this.max
              ? html\`\${this.items?.map(
                  (item, index) =>
                    html\`<section  \${spread(props.attributes)}  .style=\${{
                      maxWidth: item + this.max,
                    }} >\${this.children}</section>\`
                )}\`
              : null
          }
        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > Select 1`] = `
"import { Builder } from \\"@builder.io/sdk\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"select-component\\")
export default class SelectComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() attributes: any;
  @property() value: any;
  @property() defaultValue: any;
  @property() name: any;
  @property() options: any;

  render() {
    return html\`

          <select  \${spread(props.attributes)}  .value=\${this.value}  .key=\${
      Builder.isEditing && this.defaultValue ? this.defaultValue : \\"default-key\\"
    }  .defaultValue=\${this.defaultValue}  .name=\${
      this.name
    } >\${this.options?.map(
      (option, index) =>
        html\`<option  .value=\${option.value}  data-index=\${index} >\${
          option.name || option.value
        }</option>\`
    )}</select>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > SlotDefault 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"slot-code\\")
export default class SlotCode extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <div>
          <my-slot><div>Default content</div></my-slot>
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > SlotHtml 1`] = `
"import ContentSlotCode from \\"./content-slot-jsx.raw\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"slot-code\\")
export default class SlotCode extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <div ><content-slot-code ><my-slot  .testing=\${(
            <div>Hello</div>
          )} ></my-slot></content-slot-code></div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > SlotJsx 1`] = `
"import ContentSlotCode from \\"./content-slot-jsx.raw\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"slot-code\\")
export default class SlotCode extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <div ><content-slot-code  .slotTesting=\${(
            <div>Hello</div>
          )} ></content-slot-code></div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > SlotNamed 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"slot-code\\")
export default class SlotCode extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <div>
          <my-slot name=\\"myAwesomeSlot\\"></my-slot>
          <my-slot name=\\"top\\"></my-slot>
          <my-slot name=\\"left\\">Default left</my-slot>
          <my-slot>Default Child</my-slot>
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > Stamped.io 1`] = `
"import { kebabCase, snakeCase } from \\"lodash\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"smile-reviews\\")
export default class SmileReviews extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() apiKey: any;
  @property() productId: any;

  @state() reviews = [];
  @state() name = \\"test\\";
  @state() showReviewPrompt = false;

  kebabCaseValue() {
    return kebabCase(\\"testThat\\");
  }
  snakeCaseValue() {
    return snakeCase(\\"testThis\\");
  }

  connectedCallback() {
    fetch(
      \`https://stamped.io/api/widget/reviews?storeUrl=builder-io.myshopify.com&apiKey=\${
        this.apiKey || \\"pubkey-8bbDq7W6w4sB3OWeM1HUy2s47702hM\\"
      }&productId=\${this.productId || \\"2410511106127\\"}\`
    )
      .then((res) => res.json())
      .then((data) => {
        this.reviews = data.data;
      });
  }

  render() {
    return html\`
          <style>.input {
  display: block;
}
.textarea {
  display: block;
}
.button {
  display: block;
}
.review {
  margin: 10px;
  padding: 10px;
  background: white;
  display: flex;
  border-radius: 5px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  -webkit-font-smoothing: antialiased;
}
.img {
  height: 30px;
  width: 30px;
  margin-right: 10px;
}
</style>
          <div  data-user=\${this.name} ><button  @click=\${(event) =>
      (this.showReviewPrompt = true)} >Write a review</button>
        \${
          this.showReviewPrompt || \\"asdf\\"
            ? html\`<input  placeholder=\\"Email\\"  />
       <input  placeholder=\\"Title\\"  />
       <textarea  placeholder=\\"How was your experience?\\" ></textarea>
       <button  @click=\${(ev) => {
         ev.preventDefault();
         this.showReviewPrompt = false;
       }} >
                 Submit
               </button>\`
            : null
        }
        \${this.reviews?.map(
          (review, index) =>
            html\`<div  .key=\${review.id} ><img  .src=\${review.avatar}  />
       <div  class={state.showReviewPrompt ? 'bg-primary' : 'bg-secondary'} ><div >N:
       \${index}</div>
       <div >\${review.author}</div>
       <div >\${review.reviewMessage}</div></div></div>\`
        )}</div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > StoreComment 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"string-literal-store\\")
export default class StringLiteralStore extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() foo = true;

  bar() {}

  render() {
    return html\`

          <my-fragment>\${this.foo}</my-fragment>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > StoreShadowVars 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() errors = {};

  foo(errors) {
    return errors;
  }

  render() {
    return html\`

          <my-fragment>\${this.foo(this.errors)}</my-fragment>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > StoreWithState 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() foo = false;

  bar() {
    return this.foo;
  }

  render() {
    return html\`

          <my-fragment>\${this.bar()}</my-fragment>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > Submit 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"submit-button\\")
export default class SubmitButton extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() attributes: any;
  @property() text: any;

  render() {
    return html\`

          <button type=\\"submit\\" \${spread(props.attributes)}>\${
      this.text
    }</button>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > Text 1`] = `
"import { Builder } from \\"@builder.io/sdk\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-text\\")
export default class Text extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() text: any;
  @property() content: any;

  @state() name = \\"Decadef20\\";

  render() {
    return html\`

          <div  .contentEditable=\${allowEditingText || undefined}  data-name=\${{
      test: this.name || \\"any name\\",
    }}  .innerHTML=\${
      this.text || this.content || this.name || '<p class=\\"text-lg\\">my name</p>'
    } ></div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > Textarea 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"my-textarea\\")
export default class Textarea extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() attributes: any;
  @property() placeholder: any;
  @property() name: any;
  @property() value: any;
  @property() defaultValue: any;

  render() {
    return html\`

          <textarea
          \${spread(props.attributes)}
          .placeholder=\\"\${this.placeholder}\\"
          .name=\\"\${this.name}\\"
          .value=\\"\${this.value}\\"
          .defaultValue=\\"\${this.defaultValue}\\"
        ></textarea>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > UseValueAndFnFromStore 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"use-value-and-fn-from-store\\")
export default class UseValueAndFnFromStore extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() onChange: any;

  @state() _id = \\"abc\\";
  @state() _active = false;

  _do(id) {
    this._active = !!id;

    if (this.onChange) {
      this.onChange(this._active);
    }
  }

  updated() {
    if (this._do) {
      this._do(this._id);
    }
  }

  render() {
    return html\`

          <div>Test</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > Video 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"my-video\\")
export default class Video extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() attributes: any;
  @property() fit: any;
  @property() position: any;
  @property() video: any;
  @property() posterImage: any;
  @property() autoPlay: any;
  @property() muted: any;
  @property() controls: any;
  @property() loop: any;

  render() {
    return html\`

          <video  preload=\\"none\\"  \${spread(props.attributes)}  .style=\${{
      width: \\"100%\\",
      height: \\"100%\\",
      ...this.attributes?.style,
      objectFit: this.fit,
      objectPosition: this.position,
      // Hack to get object fit to work as expected and
      // not have the video overflow
      borderRadius: 1,
    }}  .key=\${this.video || \\"no-src\\"}  .poster=\${
      this.posterImage
    }  .autoplay=\${this.autoPlay}  .muted=\${this.muted}  .controls=\${
      this.controls
    }  .loop=\${this.loop} ></video>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > arrowFunctionInUseStore 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() name = \\"steve\\";

  setName(value) {
    this.name = value;
  }
  updateNameWithArrowFn(value) {
    this.name = value;
  }

  render() {
    return html\`

          <div>Hello \${this.name}</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > basicForFragment 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"basic-for-fragment\\")
export default class BasicForFragment extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <div>
          \${[\\"a\\", \\"b\\", \\"c\\"]?.map(
            (option, index) => html\`<my-fragment
        .key=\\"\${\`key-\${option}\`}\\"
        ><div>\${option}</div></my-fragment
      >\`
          )}
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > basicForNoTagReference 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-for-no-tag-ref-component\\")
export default class MyBasicForNoTagRefComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() actions: any;

  @state() name = \\"VincentW\\";
  @state() TagName = \\"div\\";
  @state() tag = \\"span\\";

  get TagNameGetter() {
    return \\"span\\";
  }

  render() {
    return html\`

          <state.TagNameGetter>
          Hello
          <state.tag>\${this.name}</state.tag>
          \${this.actions?.map(
            (action, index) => html\`<state.TagName
          ><action.icon></action.icon> <span>\${action.text}</span></state.TagName
        >\`
          )}</state.TagNameGetter
        >

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > basicForwardRef 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-forward-ref-component\\")
export default class MyBasicForwardRefComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @query('[ref=\\"props.inputRef\\"]')
  propsInputRef!: HTMLElement;

  @property() inputRef: any;

  @state() name = \\"PatrickJS\\";

  render() {
    return html\`
          <style>.input {
  color: red;
}
</style>
          <div>
          <input ref=\\"props.inputRef\\" .value=\${this.name} @change=\${(event) =>
      (this.name = event.target.value)} />
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > basicForwardRefMetadata 1`] = `
"/**
          useMetadata:
          {\\"forwardRef\\":\\"inputRef\\"}
          */

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-forward-ref-component\\")
export default class MyBasicForwardRefComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @query('[ref=\\"props.inputRef\\"]')
  propsInputRef!: HTMLElement;

  @property() inputRef: any;

  @state() name = \\"PatrickJS\\";

  render() {
    return html\`
          <style>.input {
  color: red;
}
</style>
          <div>
          <input ref=\\"props.inputRef\\" .value=\${this.name} @change=\${(event) =>
      (this.name = event.target.value)} />
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > basicOnUpdateReturn 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-on-update-return-component\\")
export default class MyBasicOnUpdateReturnComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() name = \\"PatrickJS\\";

  updated() {
    const controller = new AbortController();
    const signal = controller.signal;
    fetch(\\"https://patrickjs.com/api/resource.json\\", {
      signal,
    })
      .then((response) => response.json())
      .then((data) => {
        this.name = data.name;
      });
    return () => {
      if (!signal.aborted) {
        controller.abort();
      }
    };
  }

  render() {
    return html\`

          <div>Hello! \${this.name}</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > class + ClassName + css 1`] = `
"import \\"./my-component.ts\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`
          <style>.div {
  padding: 10px;
}
</style>
          <div>
          <my-comp> Hello! I can run in React, Vue, Solid, or Liquid! </my-comp>
          <div>Hello! I can run in React, Vue, Solid, or Liquid!</div>
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > class + css 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`
          <style>.div {
  padding: 10px;
}
</style>
          <div>Hello! I can run in React, Vue, Solid, or Liquid!</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > className + css 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`
          <style>.div {
  padding: 10px;
}
</style>
          <div>Hello! I can run in React, Vue, Solid, or Liquid!</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > className 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"class-name-code\\")
export default class ClassNameCode extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() bindings = \\"a binding\\";

  render() {
    return html\`

          <div>
          <div>Without Binding</div>
          <div class=\\"{state.bindings}\\">With binding</div>
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > classState 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() classState = \\"testClassName\\";
  @state() styleState = {
    color: \\"red\\",
  };

  render() {
    return html\`
          <style>.div {
  padding: 10px;
}
</style>
          <div  class={state.classState + ' div'}  .style=\${this.styleState} >
              Hello! I can run in React, Vue, Solid, or Liquid!
            </div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > complexMeta 1`] = `
"/**
          useMetadata:
          {\\"x\\":\\"y\\",\\"stringValue\\":\\"d\\",\\"booleanValue\\":true,\\"numberValue\\":1,\\"innerObject\\":{\\"stringValue\\":\\"inner\\",\\"numberValue\\":2,\\"booleanValue\\":false}}
          */

import { abc } from \\"./meta-sub\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"complex-meta-raw\\")
export default class ComplexMetaRaw extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > componentWithContext 1`] = `
"import Context1 from \\"@dummy/1\\";
import Context2 from \\"@dummy/2\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"component-with-context\\")
export default class ComponentWithContext extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() content: any;

  render() {
    return html\`

          <my-fragment><my-fragment>\${foo.value}</my-fragment></my-fragment>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > componentWithContextMultiRoot 1`] = `
"import Context1 from \\"@dummy/1\\";
import Context2 from \\"@dummy/2\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"component-with-context\\")
export default class ComponentWithContext extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() content: any;

  render() {
    return html\`

          <my-fragment
          ><my-fragment>\${foo.value}</my-fragment>
          <div>other</div></my-fragment
        >

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > contentState 1`] = `
"import BuilderContext from \\"@dummy/context.js\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"render-content\\")
export default class RenderContent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() content: any;
  @property() customComponents: any;

  render() {
    return html\`

          <div>setting context</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > defaultProps 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"my-button\\")
export default class Button extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() link: any;
  @property() attributes: any;
  @property() openLinkInNewTab: any;
  @property() text: any;
  @property() onClick: any;
  @property() buttonText: any;

  render() {
    return html\`

          <div >\${
            this.link
              ? html\`<a  \${spread(props.attributes)}  .href=\${
                  this.link
                }  .target=\${this.openLinkInNewTab ? \\"_blank\\" : undefined} >\${
                  this.text
                }</a>\`
              : null
          }
        \${
          !this.link
            ? html\`<button  type=\\"button\\"  \${spread(
                props.attributes
              )}  @click=\${(event) => this.onClick()} >\${
                this.buttonText
              }</button>\`
            : null
        }</div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > defaultPropsOutsideComponent 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"my-button\\")
export default class Button extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() link: any;
  @property() attributes: any;
  @property() openLinkInNewTab: any;
  @property() text: any;
  @property() onClick: any;

  render() {
    return html\`

          <div >\${
            this.link
              ? html\`<a  \${spread(props.attributes)}  .href=\${
                  this.link
                }  .target=\${this.openLinkInNewTab ? \\"_blank\\" : undefined} >\${
                  this.text
                }</a>\`
              : null
          }
        \${
          !this.link
            ? html\`<button  type=\\"button\\"  \${spread(
                props.attributes
              )}  @click=\${(event) => this.onClick(event)} >\${
                this.text
              }</button>\`
            : null
        }</div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > defaultValsWithTypes 1`] = `
"const DEFAULT_VALUES = {
  name: \\"Sami\\",
};

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"component-with-types\\")
export default class ComponentWithTypes extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() name: any;

  render() {
    return html\`

          <div>Hello \${this.name || DEFAULT_VALUES.name}</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > eventInputAndChange 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"event-input-and-change\\")
export default class EventInputAndChange extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() name = \\"Steve\\";

  render() {
    return html\`
          <style>.input {
  color: red;
}
</style>
          <div>
          <input .value=\${this.name} @input=\${(event) =>
      (this.name = event.target.value)}
          @change=\${(event) =>
            (this.name = event.target.value)} /> Hello! I can run in
          React, Vue, Solid, or Liquid!
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > expressionState 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() componentRef: any;

  @state() refToUse = !(this.componentRef instanceof Function)
    ? this.componentRef
    : null;

  render() {
    return html\`

          <div>\${this.refToUse}</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > figmaMeta 1`] = `
"/**
          useMetadata:
          {\\"name\\":\\"def-button-beta-outlined\\",\\"url\\":\\"https://www.figma.com/xxx\\",\\"iconSmall\\":{\\"type\\":\\"instance\\",\\"key\\":\\" Icon Small\\"},\\"iconMedium\\":{\\"type\\":\\"instance\\",\\"key\\":\\" Icon Medium\\"},\\"label\\":{\\"type\\":\\"string\\",\\"key\\":\\" Label\\"},\\"icon\\":{\\"type\\":\\"boolean\\",\\"key\\":\\" Icon\\",\\"value\\":{\\"false\\":false,\\"true\\":\\"placeholder\\"}},\\"interactiveState\\":{\\"type\\":\\"enum\\",\\"key\\":\\"Interactive State\\",\\"value\\":{\\"(Def) Enabled\\":false,\\"Hovered\\":false,\\"Pressed\\":false,\\"Focused\\":false,\\"Disabled\\":\\"true\\"}},\\"size\\":{\\"type\\":\\"enum\\",\\"key\\":\\"Size\\",\\"value\\":{\\"(Def) Medium\\":false,\\"Small\\":\\"small\\"}},\\"width\\":{\\"type\\":\\"enum\\",\\"key\\":\\"Width\\",\\"value\\":{\\"(Def) Auto Width\\":false,\\"Full Width\\":\\"full\\"}}}
          */

import { outline } from \\"./data\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"figma-button\\")
export default class FigmaButton extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() icon: any;
  @property() interactiveState: any;
  @property() width: any;
  @property() size: any;
  @property() label: any;

  render() {
    return html\`

          <button
          data-icon=\\"\${this.icon}\\"
          data-disabled=\\"\${this.interactiveState}\\"
          data-width=\\"\${this.width}\\"
          data-size=\\"\${this.size}\\"
        >
          \${this.label}
        </button>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > getterState 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-button\\")
export default class Button extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() foo: any;

  get foo2() {
    return this.foo + \\"foo\\";
  }
  get bar() {
    return \\"bar\\";
  }
  baz(i) {
    return i + this.foo2.length;
  }

  render() {
    return html\`

          <div>
          <p>\${this.foo2}</p>
          <p>\${this.bar}</p>
          <p>\${this.baz(1)}</p>
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > import types 1`] = `
"import RenderBlock from \\"./builder-render-block.raw\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"render-content\\")
export default class RenderContent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() renderContentProps: any;

  getRenderContentProps(block, index) {
    return {
      block: block,
      index: index,
    };
  }

  render() {
    return html\`

          <render-block
          \${spread(
            state.getRenderContentProps(props.renderContentProps.block, 0)
          )}
        ></render-block>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > multipleOnUpdate 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"multiple-on-update\\")
export default class MultipleOnUpdate extends LitElement {
  createRenderRoot() {
    return this;
  }

  updated() {
    console.log(\\"Runs on every update/rerender\\");

    console.log(\\"Runs on every update/rerender as well\\");
  }

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > multipleOnUpdateWithDeps 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"multiple-on-update-with-deps\\")
export default class MultipleOnUpdateWithDeps extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() a = \\"a\\";
  @state() b = \\"b\\";
  @state() c = \\"c\\";
  @state() d = \\"d\\";

  updated() {
    console.log(\\"Runs when a or b changes\\", this.a, this.b);

    if (this.a === \\"a\\") {
      this.a = \\"b\\";
    }

    console.log(\\"Runs when c or d changes\\", this.c, this.d);

    if (this.a === \\"a\\") {
      this.a = \\"b\\";
    }
  }

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > multipleSpreads 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() attrs = {
    hello: \\"world\\",
  };

  render() {
    return html\`

          <input \${spread(state.attrs)} \${spread(props)} />

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > nestedShow 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"nested-show\\")
export default class NestedShow extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() conditionA: any;
  @property() conditionB: any;

  render() {
    return html\`

          \${
            this.conditionA
              ? html\`\${
                  !this.conditionB
                    ? html\`
        <div>if condition A and condition B</div>
        \`
                    : html\`
        <div>else-condition-B</div>
        \`
                }\`
              : html\`
    <div>else-condition-A</div>
    \`
          }

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > nestedStyles 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"nested-styles\\")
export default class NestedStyles extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`
          <style>.div {
  display: flex;
  --bar: red;
  color: var(--bar);
}
@media (max-width: env(--mobile)) {
  .div {
    display: block;
  }
}
.div:hover {
  display: flex;
}
.div:active {
  display: inline;
}
.div .nested-selector {
  display: grid;
}
.div .nested-selector:hover {
  display: block;
}
.div.nested-selector:active {
  display: inline-block;
}
</style>
          <div>Hello world</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > onEvent 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-embed\\")
export default class Embed extends LitElement {
  createRenderRoot() {
    return this;
  }

  @query('[ref=\\"elem\\"]')
  elem!: HTMLElement;

  foo(event) {
    console.log(\\"test2\\");
  }

  connectedCallback() {
    this.elem.dispatchEvent(new CustomEvent(\\"initEditingBldr\\"));
  }

  render() {
    return html\`

          <div ref=\\"elem\\"><div>Test</div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > onInit & onMount 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"on-init\\")
export default class OnInit extends LitElement {
  createRenderRoot() {
    return this;
  }

  connectedCallback() {
    console.log(\\"onMount\\");
  }

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > onInit 1`] = `
"export const defaultValues = {
  name: \\"PatrickJS\\",
};

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"on-init\\")
export default class OnInit extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() name: any;

  @state() name = \\"\\";

  render() {
    return html\`

          <div>Default name defined by parent \${this.name}</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > onInitPlain 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"on-init-plain\\")
export default class OnInitPlain extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > onMount 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-comp\\")
export default class Comp extends LitElement {
  createRenderRoot() {
    return this;
  }

  connectedCallback() {
    console.log(\\"Runs on mount\\");
  }
  disconnectedCallback() {
    console.log(\\"Runs on unMount\\");
  }

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > onMountMultiple 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-comp\\")
export default class Comp extends LitElement {
  createRenderRoot() {
    return this;
  }

  connectedCallback() {
    const onMountHook_0 = () => {
      console.log(\\"Runs on mount\\");
    };

    onMountHook_0();

    const onMountHook_1 = () => {
      console.log(\\"Another one runs on Mount\\");
    };

    onMountHook_1();

    const onMountHook_2 = () => {
      console.log(\\"SSR runs on Mount\\");
    };

    onMountHook_2();
  }

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > onUpdate 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"on-update\\")
export default class OnUpdate extends LitElement {
  createRenderRoot() {
    return this;
  }

  updated() {
    console.log(\\"Runs on every update/rerender\\");
  }

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > onUpdateWithDeps 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"on-update-with-deps\\")
export default class OnUpdateWithDeps extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() size: any;

  @state() a = \\"a\\";
  @state() b = \\"b\\";

  updated() {
    console.log(\\"Runs when a, b or size changes\\", this.a, this.b, this.size);
  }

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > preserveExportOrLocalStatement 1`] = `
"const b = 3;
const foo = () => {};
export const a = 3;
export const bar = () => {};
export function run(value) {}

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > preserveTyping 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() name: any;

  render() {
    return html\`

          <div>Hello! I can run in React, Vue, Solid, or Liquid! \${this.name}</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > propsDestructure 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() children: any;
  @property() type: any;

  @state() name = \\"Decadef20\\";

  render() {
    return html\`

          <div>
          \${this.children} \${this.type} Hello! I can run in React, Vue, Solid, or
          Liquid!
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > propsInterface 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() name: any;

  render() {
    return html\`

          <div>Hello! I can run in React, Vue, Solid, or Liquid! \${this.name}</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > propsType 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() name: any;

  render() {
    return html\`

          <div>Hello! I can run in React, Vue, Solid, or Liquid! \${this.name}</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > referencingFunInsideHook 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"on-update\\")
export default class OnUpdate extends LitElement {
  createRenderRoot() {
    return this;
  }

  foo = function foo(params) {};
  bar = function bar() {};
  zoo = function zoo() {
    const params = {
      cb: this.bar,
    };
  };

  updated() {
    this.foo({
      someOption: this.bar,
    });
  }

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > renderBlock 1`] = `
"import { TARGET } from \\"../../constants/target.js\\";
import { evaluate } from \\"../../functions/evaluate.js\\";
import { extractTextStyles } from \\"../../functions/extract-text-styles.js\\";
import { getBlockActions } from \\"../../functions/get-block-actions.js\\";
import { getBlockComponentOptions } from \\"../../functions/get-block-component-options.js\\";
import { getBlockProperties } from \\"../../functions/get-block-properties.js\\";
import { getBlockTag } from \\"../../functions/get-block-tag.js\\";
import { getProcessedBlock } from \\"../../functions/get-processed-block.js\\";
import { getReactNativeBlockStyles } from \\"../../functions/get-react-native-block-styles.js\\";
import \\"./block-styles.ts\\";
import { isEmptyHtmlElement } from \\"./render-block.helpers.js\\";
import RenderComponentWithContext from \\"./render-component-with-context.js\\";
import \\"./render-component.ts\\";
import \\"./render-repeated-block.ts\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"render-block\\")
export default class RenderBlock extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() block: any;
  @property() context: any;

  get component() {
    const componentName = getProcessedBlock({
      block: this.block,
      state: this.context.state,
      context: this.context.context,
      shouldEvaluateBindings: false,
    }).component?.name;

    if (!componentName) {
      return null;
    }

    const ref = this.context.registeredComponents[componentName];

    if (!ref) {
      // TODO: Public doc page with more info about this message
      console.warn(\`
          Could not find a registered component named \\"\${componentName}\\".
          If you registered it, is the file that registered it imported by the file that needs to render it?\`);
      return undefined;
    } else {
      return ref;
    }
  }
  get tag() {
    return getBlockTag(this.useBlock);
  }
  get useBlock() {
    return this.repeatItemData
      ? this.block
      : getProcessedBlock({
          block: this.block,
          state: this.context.state,
          context: this.context.context,
          shouldEvaluateBindings: true,
        });
  }
  get actions() {
    return getBlockActions({
      block: this.useBlock,
      state: this.context.state,
      context: this.context.context,
    });
  }
  get attributes() {
    const blockProperties = getBlockProperties(this.useBlock);
    return {
      ...blockProperties,
      ...(TARGET === \\"reactNative\\"
        ? {
            style: getReactNativeBlockStyles({
              block: this.useBlock,
              context: this.context,
              blockStyles: blockProperties.style,
            }),
          }
        : {}),
    };
  }
  get shouldWrap() {
    return !this.component?.noWrap;
  }
  get renderComponentProps() {
    return {
      blockChildren: this.useChildren,
      componentRef: this.component?.component,
      componentOptions: {
        ...getBlockComponentOptions(this.useBlock),

        /**
         * These attributes are passed to the wrapper element when there is one. If \`noWrap\` is set to true, then
         * they are provided to the component itself directly.
         */
        ...(this.shouldWrap
          ? {}
          : {
              attributes: { ...this.attributes, ...this.actions },
            }),
        customBreakpoints: this.childrenContext?.content?.meta?.breakpoints,
      },
      context: this.childrenContext,
    };
  }
  get useChildren() {
    // TO-DO: When should \`canHaveChildren\` dictate rendering?
    // This is currently commented out because some Builder components (e.g. Box) do not have \`canHaveChildren: true\`,
    // but still receive and need to render children.
    // return state.componentInfo?.canHaveChildren ? state.useBlock.children : [];
    return this.useBlock.children ?? [];
  }
  get childrenWithoutParentComponent() {
    /**
     * When there is no \`componentRef\`, there might still be children that need to be rendered. In this case,
     * we render them outside of \`componentRef\`.
     * NOTE: We make sure not to render this if \`repeatItemData\` is non-null, because that means we are rendering an array of
     * blocks, and the children will be repeated within those blocks.
     */
    const shouldRenderChildrenOutsideRef =
      !this.component?.component && !this.repeatItemData;
    return shouldRenderChildrenOutsideRef ? this.useChildren : [];
  }
  get repeatItemData() {
    /**
     * we don't use \`state.useBlock\` here because the processing done within its logic includes evaluating the block's bindings,
     * which will not work if there is a repeat.
     */
    const { repeat, ...blockWithoutRepeat } = this.block;

    if (!repeat?.collection) {
      return undefined;
    }

    const itemsArray = evaluate({
      code: repeat.collection,
      state: this.context.state,
      context: this.context.context,
    });

    if (!Array.isArray(itemsArray)) {
      return undefined;
    }

    const collectionName = repeat.collection.split(\\".\\").pop();
    const itemNameToUse =
      repeat.itemName || (collectionName ? collectionName + \\"Item\\" : \\"item\\");
    const repeatArray = itemsArray.map((item, index) => ({
      context: {
        ...this.context,
        state: {
          ...this.context.state,
          $index: index,
          $item: item,
          [itemNameToUse]: item,
          [\`$\${itemNameToUse}Index\`]: index,
        },
      },
      block: blockWithoutRepeat,
    }));
    return repeatArray;
  }
  get inheritedTextStyles() {
    if (TARGET !== \\"reactNative\\") {
      return {};
    }

    const styles = getReactNativeBlockStyles({
      block: this.useBlock,
      context: this.context,
      blockStyles: this.attributes.style,
    });
    return extractTextStyles(styles);
  }
  get childrenContext() {
    return {
      apiKey: this.context.apiKey,
      state: this.context.state,
      content: this.context.content,
      context: this.context.context,
      registeredComponents: this.context.registeredComponents,
      inheritedStyles: this.inheritedTextStyles,
    };
  }
  get renderComponentTag() {
    if (TARGET === \\"reactNative\\") {
      return RenderComponentWithContext;
    } else if (TARGET === \\"vue3\\") {
      // vue3 expects a string for the component tag
      return \\"RenderComponent\\";
    } else {
      return RenderComponent;
    }
  }

  render() {
    return html\`

          \${
            this.shouldWrap
              ? html\`\${
                  isEmptyHtmlElement(this.tag)
                    ? html\`<state.tag  \${spread(state.attributes)}  \${spread(
                        state.actions
                      )} ></state.tag>\`
                    : null
                }
       \${
         !isEmptyHtmlElement(this.tag) && this.repeatItemData
           ? html\`\${this.repeatItemData?.map(
               (data, index) =>
                 html\`<render-repeated-block  .key=\${index}  .repeatContext=\${data.context}  .block=\${data.block} ></render-repeated-block>\`
             )}\`
           : null
       }
       \${
         !isEmptyHtmlElement(this.tag) && !this.repeatItemData
           ? html\`<state.tag  \${spread(state.attributes)}  \${spread(
               state.actions
             )} ><state.renderComponentTag  \${spread(
               state.renderComponentProps
             )} ></state.renderComponentTag>
        \${this.childrenWithoutParentComponent?.map(
          (child, index) =>
            html\`<render-block  .key=\${
              \\"render-block-\\" + child.id
            }  .block=\${child}  .context=\${
              this.childrenContext
            } ></render-block>\`
        )}
        \${this.childrenWithoutParentComponent?.map(
          (child, index) =>
            html\`<block-styles  .key=\${
              \\"block-style-\\" + child.id
            }  .block=\${child}  .context=\${
              this.childrenContext
            } ></block-styles>\`
        )}</state.tag>\`
           : null
       }\`
              : html\`<state.renderComponentTag  \${spread(
                  state.renderComponentProps
                )} ></state.renderComponentTag>\`
          }
        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > renderContentExample 1`] = `
"import BuilderContext from \\"@dummy/context.js\\";
import {
  dispatchNewContentToVisualEditor,
  sendComponentsToVisualEditor,
  trackClick,
} from \\"@dummy/injection-js\\";
import \\"@dummy/RenderBlocks.ts\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"render-content\\")
export default class RenderContent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() customComponents: any;
  @property() content: any;

  connectedCallback() {
    sendComponentsToVisualEditor(this.customComponents);
  }

  updated() {
    dispatchNewContentToVisualEditor(this.content);
  }

  render() {
    return html\`
          <style>.div {
  display: flex;
  flex-direction: columns;
}
</style>
          <div  @click=\${(event) =>
            trackClick(this.content.id)} ><render-blocks  .blocks=\${
      this.content.blocks
    } ></render-blocks></div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > rootFragmentMultiNode 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"my-button\\")
export default class Button extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() link: any;
  @property() attributes: any;
  @property() openLinkInNewTab: any;
  @property() text: any;

  render() {
    return html\`

          <my-fragment >\${
            this.link
              ? html\`<a  \${spread(props.attributes)}  .href=\${
                  this.link
                }  .target=\${this.openLinkInNewTab ? \\"_blank\\" : undefined} >\${
                  this.text
                }</a>\`
              : null
          }
        \${
          !this.link
            ? html\`<button  type=\\"button\\"  \${spread(props.attributes)} >\${
                this.text
              }</button>\`
            : null
        }</my-fragment>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > rootShow 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"render-styles\\")
export default class RenderStyles extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() foo: any;

  render() {
    return html\`

          \${
            this.foo === \\"bar\\"
              ? html\`
    <div>Bar</div>
    \`
              : html\`
    <div>Foo</div>
    \`
          }

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > self-referencing component 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() name: any;

  render() {
    return html\`

          <div>
          \${this.name} \${
      this.name === \\"Batman\\"
        ? html\`<my-component
        name=\\"Bruce Wayne\\"
      ></my-component
      >\`
        : null
    }
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > self-referencing component with children 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() name: any;
  @property() children: any;

  render() {
    return html\`

          <div>
          \${this.name} \${this.children} \${
      this.name === \\"Batman\\"
        ? html\`<my-component
        name=\\"Bruce\\"
        ><div>Wayne</div></my-component
      >\`
        : null
    }
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > setState 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"set-state\\")
export default class SetState extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() n = [\\"123\\"];

  someFn() {
    this.n[0] = \\"123\\";
  }

  render() {
    return html\`

          <div ><button  @click=\${(event) =>
            this.someFn()} >Click me</button></div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > showExpressions 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"show-with-other-values\\")
export default class ShowWithOtherValues extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() conditionA: any;
  @property() conditionB: any;
  @property() conditionC: any;

  render() {
    return html\`

          <div>
          \${this.conditionA ? html\`Content0\` : html\`ContentA\`} \${
      this.conditionA ? html\`ContentA\` : null
    } \${this.conditionA ? html\`\` : html\`ContentA\`}
          \${this.conditionA ? html\`ContentB\` : html\`\${undefined}\`} \${
      this.conditionA ? html\`\${undefined}\` : html\`ContentB\`
    } \${this.conditionA ? html\`ContentC\` : null} \${
      this.conditionA ? html\`\` : html\`ContentC\`
    } \${this.conditionA ? html\`ContentD\` : null} \${
      this.conditionA ? html\`\` : html\`ContentD\`
    }
          \${this.conditionA ? html\`ContentE\` : html\`hello\`} \${
      this.conditionA ? html\`hello\` : html\`ContentE\`
    } \${this.conditionA ? html\`ContentF\` : html\`123\`}
          \${this.conditionA ? html\`123\` : html\`ContentF\`} \${
      this.conditionA === \\"Default\\"
        ? html\`4mb\`
        : html\`\${this.conditionB === \\"Complete\\" ? html\`20mb\` : html\`9mb\`}\`
    } \${
      this.conditionA === \\"Default\\"
        ? html\`\${this.conditionB === \\"Complete\\" ? html\`20mb\` : html\`9mb\`}\`
        : html\`4mb\`
    } \${
      this.conditionA === \\"Default\\"
        ? html\`\${
            this.conditionB === \\"Complete\\"
              ? html\`
          <div>complete</div>
          \`
              : html\`9mb\`
          }\`
        : html\`\${
            this.conditionC === \\"Complete\\"
              ? html\`dff\`
              : html\`
          <div>complete else</div>
          \`
          }\`
    }
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > showWithFor 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"nested-show\\")
export default class NestedShow extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() conditionA: any;
  @property() items: any;

  render() {
    return html\`

          \${
            this.conditionA
              ? html\`\${this.items?.map(
                  (item, idx) => html\`
        <div .key=\\"\${idx}\\">\${item}</div>
        \`
                )}\`
              : html\`
    <div>else-condition-A</div>
    \`
          }

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > showWithOtherValues 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"show-with-other-values\\")
export default class ShowWithOtherValues extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() conditionA: any;

  render() {
    return html\`

          <div>
          \${this.conditionA ? html\` ContentA \` : null} \${
      this.conditionA
        ? html\`
      ContentB \`
        : html\`\${undefined}\`
    } \${this.conditionA ? html\` ContentC \` : null}
          \${this.conditionA ? html\` ContentD \` : null} \${
      this.conditionA
        ? html\`
      ContentE \`
        : html\`hello\`
    } \${this.conditionA ? html\` ContentF \` : html\`123\`}
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > showWithRootText 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"show-root-text\\")
export default class ShowRootText extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() conditionA: any;

  render() {
    return html\`

          \${
            this.conditionA
              ? html\` ContentA \`
              : html\`
    <div>else-condition-A</div>
    \`
          }

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > signalsOnUpdate 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() id: any;
  @property() foo: any;

  updated() {
    console.log(\\"props.id changed\\", this.id);
    console.log(\\"props.foo.value.bar.baz changed\\", this.foo.value.bar.baz);
  }

  render() {
    return html\`
          <style>.div {
  padding: 10px;
}
</style>
          <div>\${this.id} \${this.foo.value.bar.baz}</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > spreadAttrs 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <input \${spread(attrs)} />

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > spreadNestedProps 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() nested: any;

  render() {
    return html\`

          <input \${spread(props.nested)} />

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > spreadProps 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <input \${spread(props)} />

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > store-async-function 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"string-literal-store\\")
export default class StringLiteralStore extends LitElement {
  createRenderRoot() {
    return this;
  }

  arrowFunction = async function arrowFunction() {
    return Promise.resolve();
  };
  namedFunction = async function namedFunction() {
    return Promise.resolve();
  };
  fetchUsers = async function fetchUsers() {
    return Promise.resolve();
  };

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > string-literal-store 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"string-literal-store\\")
export default class StringLiteralStore extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() foo = 123;

  render() {
    return html\`

          <div>\${this.foo}</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > styleClassAndCss 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`
          <style>.div {
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
</style>
          <div  .style=\${{
            width: \\"100%\\",
          }} ></div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > stylePropClassAndCss 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"style-prop-class-and-css\\")
export default class StylePropClassAndCss extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() attributes: any;

  render() {
    return html\`
          <style>.div {
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
</style>
          <div  class={props.attributes.class + ' div'}  .style=\${this.attributes.style} ></div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > subComponent 1`] = `
"import \\"./foo-sub-component.ts\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"sub-component\\")
export default class SubComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <my-foo></my-foo>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > svgComponent 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"svg-component\\")
export default class SvgComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <svg  fill=\\"none\\"  role=\\"img\\"  .viewBox=\${
            \\"0 0 \\" + 42 + \\" \\" + 42
          }  .width=\${42}  .height=\${42} ><defs ><filter  id=\\"prefix__filter0_f\\"  filterUnits=\\"userSpaceOnUse\\" ><feFlood  result=\\"BackgroundImageFix\\" ></feFlood>
        <feBlend  in=\\"SourceGraphic\\"  in2=\\"BackgroundImageFix\\"  result=\\"shape\\" ></feBlend>
        <feGaussianBlur  result=\\"effect1_foregroundBlur\\"  .stdDeviation=\${7} ></feGaussianBlur></filter></defs></svg>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > typeDependency 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"type-dependency\\")
export default class TypeDependency extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() foo: any;

  render() {
    return html\`

          <div>\${this.foo}</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > typeExternalStore 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"type-external-store\\")
export default class TypeExternalStore extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() _name = \\"test\\";

  render() {
    return html\`

          <div>Hello \${this._name} !</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > typeGetterStore 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"type-getter-store\\")
export default class TypeGetterStore extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() name = \\"test\\";

  getName() {
    if (this.name === \\"a\\") {
      return \\"b\\";
    }

    return this.name;
  }
  get test() {
    return \\"test\\";
  }

  render() {
    return html\`

          <div>Hello \${this.name} !</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > use-style 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`
          <style>button {
  background: blue;
  color: white;
  font-size: 12px;
  outline: 1px solid black;
}
</style>
          <button type=\\"button\\">Button</button>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > use-style-and-css 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`
          <style>button {
  font-size: 12px;
  outline: 1px solid black;
}

.button {
  background: blue;
  color: white;
}
</style>
          <button type=\\"button\\">Button</button>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > use-style-outside-component 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`
          <style>button {
  background: blue;
  color: white;
  font-size: 12px;
  outline: 1px solid black;
}
</style>
          <button type=\\"button\\">Button</button>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > useTarget 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"use-target-component\\")
export default class UseTargetComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() lastName = \\"bar\\";
  @state() foo = \\"bar\\";

  get name() {
    const prefix = \\"li\\";
    return prefix + \\"foo\\";
  }

  connectedCallback() {
    console.log(this.foo);
    this.foo = \\"bar\\";
  }

  render() {
    return html\`

          <div>\${this.name}</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Javascript Test > webComponent 1`] = `
"import { register } from \\"swiper/element/bundle\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-web-component\\")
export default class MyBasicWebComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <swiper-container slides-per-view=\\"3\\" navigation=\\"true\\" pagination=\\"true\\"
          ><swiper-slide>Slide 1</swiper-slide>
          <swiper-slide>Slide 2</swiper-slide>
          <swiper-slide>Slide 3</swiper-slide></swiper-container
        >

        \`;
  }
}
"
`;

exports[`Lit > jsx > Remove Internal mitosis package 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() name = \\"PatrickJS\\";

  render() {
    return html\`

          <div>Hello \${this.name} ! I can run in React, Qwik, Vue, Solid, or Liquid!</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > Advanced 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-for-show-component\\")
export default class MyBasicForShowComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() name = \\"PatrickJS\\";
  @state() names = [\\"Steve\\", \\"PatrickJS\\"];

  render() {
    return html\`

          <main>
          \${this.names?.map(
            (person, i) => html\`
      <div>\${i} : \${person}</div>
      \`
          )} \${this.names?.map((person, index) => html\`<span>\${person}</span>\`)}
          \${this.names?.map((_, index) => html\`<br />\`)} \${Array.from({
      length: 10,
    })?.map(
      (_, ee) => html\`
      <pre>\${ee}</pre>
      \`
    )} \${Array.from({ length: 10 })?.map(
      (_, index) => html\`
      <p>\${index}</p>
      \`
    )} \${this.names?.map(
      (person, index) => html\`<span
        >\${person} \${index}</span
      >\`
    )} \${Array.from({ length: 10 })?.map(
      (person, count) => html\`<span
        >\${person} \${count}</span
      >\`
    )} \${this.names?.map(
      (person, i) => html\`<span>\${person} \${i}</span>\`
    )} \${Array.from({ length: 10 })?.map(
      (person, index) => html\`<span
        >\${person} \${index}</span
      >\`
    )}
        </main>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > AdvancedRef 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export interface Props {
  showInput: boolean;
}

@customElement(\\"my-basic-ref-component\\")
export default class MyBasicRefComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @query('[ref=\\"inputRef\\"]')
  inputRef!: HTMLElement;

  @query('[ref=\\"inputNoArgRef\\"]')
  inputNoArgRef!: HTMLElement;

  @property() showInput: any;

  @state() name = \\"PatrickJS\\";

  onBlur = function onBlur() {
    // Maintain focus
    this.inputRef.focus();
  };
  lowerCaseName = function lowerCaseName() {
    return this.name.toLowerCase();
  };

  updated() {
    console.log(\\"Received an update\\");
  }

  render() {
    return html\`
          <style>.input {
  color: red;
}
</style>
          <div>
          \${
            this.showInput
              ? html\`<my-fragment
           ><input ref=\\"inputRef\\" .value=\${this.name} @blur=\${(event) =>
                  this.onBlur()}
           @change=\${(event) => (this.name = event.target.value)} />
           <label for=\\"cars\\" ref=\\"inputNoArgRef\\"> Choose a car: </label>
           <select name=\\"cars\\" id=\\"cars\\">
             <option value=\\"supra\\">GR Supra</option>
             <option value=\\"86\\">GR 86</option>
           </select></my-fragment
         >\`
              : null
          } Hello \${this.lowerCaseName()} ! I can run in React, Qwik, Vue,
          Solid, or Web Component!
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > Basic 1`] = `
"export const DEFAULT_VALUES = {
  name: \\"Steve\\",
};

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export interface MyBasicComponentProps {
  id: string;
}

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() name = \\"Steve\\";
  @state() age = 1;
  @state() sports = [\\"\\"];

  underscore_fn_name() {
    return \\"bar\\";
  }

  render() {
    return html\`
          <style>.div {
  padding: 10px;
}
</style>
          <div>
          <input .value=\${DEFAULT_VALUES.name || this.name} @change=\${(
      myEvent
    ) =>
      (this.name =
        myEvent.target.value)} /> Hello! I can run in React, Vue, Solid, or
          Liquid! &gt;
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > Basic 2`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-for-show-component\\")
export default class MyBasicForShowComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() name = \\"PatrickJS\\";
  @state() names = [\\"Steve\\", \\"PatrickJS\\"];

  render() {
    return html\`

          <div>
          \${this.names?.map(
            (person, index) =>
              html\`\${
                person === this.name
                  ? html\`<input .value=\${this.name} @change=\${(event) => {
                      this.name = event.target.value + \\" and \\" + person;
                    }} /> Hello \${person} ! I can run in
          Qwik, Web Component, React, Vue, Solid, or Liquid! \`
                  : null
              }\`
          )}
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > Basic Context 1`] = `
"import { Injector, MyService, createInjector } from \\"@dummy/injection-js\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() name = \\"PatrickJS\\";

  onChange = function onChange() {
    const change = myService.method(\\"change\\");
    console.log(change);
  };

  connectedCallback() {
    const bye = myService.method(\\"hi\\");
    console.log(bye);
  }

  render() {
    return html\`

          <div>
          \${
            myService.method(\\"hello\\") + this.name
          } Hello! I can run in React, Vue,
          Solid, or Liquid! <input @change=\${(event) => this.onChange} />
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > Basic OnMount Update 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export interface Props {
  hi: string;
  bye: string;
}

@customElement(\\"my-basic-on-mount-update-component\\")
export default class MyBasicOnMountUpdateComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() bye: any;
  @property() hi: any;

  @state() name = \\"PatrickJS\\";
  @state() names = [\\"Steve\\", \\"PatrickJS\\"];

  connectedCallback() {
    this.name = \\"PatrickJS onMount\\" + this.bye;
  }

  render() {
    return html\`

          <div>Hello \${this.name}</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > Basic Outputs 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-outputs-component\\")
export default class MyBasicOutputsComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() onMessage: any;
  @property() onEvent: any;
  @property() message: any;

  @state() name = \\"PatrickJS\\";

  connectedCallback() {
    this.onMessage(this.name);
    this.onEvent(this.message);
  }

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > Basic Outputs Meta 1`] = `
"/**
          useMetadata:
          {\\"outputs\\":[\\"onMessage\\",\\"onEvent\\"],\\"baz\\":\\"metadata inside component\\"}
          */

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-outputs-component\\")
export default class MyBasicOutputsComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() onMessage: any;
  @property() onEvent: any;
  @property() message: any;

  @state() name = \\"PatrickJS\\";

  connectedCallback() {
    this.onMessage(this.name);
    this.onEvent(this.message);
  }

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > BasicAttribute 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <input autocapitalize=\\"on\\" autocomplete=\\"on\\" .spellcheck=\\"\${true}\\" />

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > BasicBooleanAttribute 1`] = `
"import MyBooleanAttributeComponent from \\"./basic-boolean-attribute-component.raw\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

type Props = {
  children: any;
  type: string;
};

@customElement(\\"my-boolean-attribute\\")
export default class MyBooleanAttribute extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() children: any;
  @property() type: any;

  render() {
    return html\`

          <div>
          \${this.children ? html\`\${this.children} \${this.type}\` : null}
          <my-boolean-attribute-component
            .toggle=\\"\${true}\\"
          ></my-boolean-attribute-component>
          <my-boolean-attribute-component
            .toggle=\\"\${true}\\"
          ></my-boolean-attribute-component>
          <my-boolean-attribute-component
            .list=\\"\${null}\\"
          ></my-boolean-attribute-component>
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > BasicChildComponent 1`] = `
"import MyBasicOnMountUpdateComponent from \\"./basic-onMount-update.raw\\";
import MyBasicComponent from \\"./basic.raw\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-child-component\\")
export default class MyBasicChildComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() name = \\"Steve\\";
  @state() dev = \\"PatrickJS\\";

  render() {
    return html\`

          <div>
          <my-basic-component .id=\\"\${this.dev}\\"></my-basic-component>
          <div>
            <my-basic-on-mount-update-component
              .hi=\\"\${this.name}\\"
              .bye=\\"\${this.dev}\\"
            ></my-basic-on-mount-update-component>
          </div>
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > BasicFor 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-for-component\\")
export default class MyBasicForComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() name = \\"PatrickJS\\";
  @state() names = [\\"Steve\\", \\"PatrickJS\\"];

  connectedCallback() {
    console.log(\\"onMount code\\");
  }

  render() {
    return html\`

          <div>
          \${this.names?.map(
            (person, index) => html\`<my-fragment
        ><input .value=\${this.name} @change=\${(event) => {
              this.name = event.target.value + \\" and \\" + person;
            }} /> Hello \${person} ! I can run in
        Qwik, Web Component, React, Vue, Solid, or Liquid! </my-fragment
      >\`
          )}
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > BasicRef 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export interface Props {
  showInput: boolean;
}

@customElement(\\"my-basic-ref-component\\")
export default class MyBasicRefComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @query('[ref=\\"inputRef\\"]')
  inputRef!: HTMLElement;

  @query('[ref=\\"inputNoArgRef\\"]')
  inputNoArgRef!: HTMLElement;

  @property() showInput: any;

  @state() name = \\"PatrickJS\\";

  onBlur = function onBlur() {
    // Maintain focus
    this.inputRef?.focus();
  };
  lowerCaseName = function lowerCaseName() {
    return this.name.toLowerCase();
  };

  render() {
    return html\`
          <style>.input {
  color: red;
}
</style>
          <div>
          \${
            this.showInput
              ? html\`<my-fragment
           ><input ref=\\"inputRef\\" .value=\${this.name} @blur=\${(event) =>
                  this.onBlur()}
           @change=\${(event) => (this.name = event.target.value)} />
           <label for=\\"cars\\" ref=\\"inputNoArgRef\\"> Choose a car: </label>
           <select name=\\"cars\\" id=\\"cars\\">
             <option value=\\"supra\\">GR Supra</option>
             <option value=\\"86\\">GR 86</option>
           </select></my-fragment
         >\`
              : null
          } Hello \${this.lowerCaseName()} ! I can run in React, Qwik, Vue,
          Solid, or Web Component!
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > BasicRefAssignment 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export interface Props {
  showInput: boolean;
}

@customElement(\\"my-basic-ref-assignment-component\\")
export default class MyBasicRefAssignmentComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  handlerClick = function handlerClick(event: Event) {
    event.preventDefault();
    console.log(\\"current value\\", this.holdValueRef);
    this.holdValueRef = this.holdValueRef + \\"JS\\";
  };

  render() {
    return html\`

          <div ><button  @click=\${async (evt) =>
            await this.handlerClick(evt)} >Click</button></div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > BasicRefPrevious 1`] = `
"export function usePrevious<T>(value: T) {
  // The ref object is a generic container whose current property is mutable ...
  // ... and can hold any value, similar to an instance property on a class
  let ref = useRef<T>(null); // Store current value in ref

  onUpdate(() => {
    ref = value;
  }, [value]); // Only re-run if value changes
  // Return previous value (happens before update in useEffect above)

  return ref;
}

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export interface Props {
  showInput: boolean;
}

@customElement(\\"my-previous-component\\")
export default class MyPreviousComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() count = 0;

  updated() {
    this.prevCount = this.count;
  }

  render() {
    return html\`

          <div ><h1 >
                Now:
        \${this.count}
        , before:
        \${this.prevCount}</h1>
        <button  @click=\${(event) =>
          (this.count += 1)} >Increment</button></div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > Button 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export interface ButtonProps {
  attributes?: any;
  text?: string;
  link?: string;
  openLinkInNewTab?: boolean;
}

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"my-button\\")
export default class Button extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() link: any;
  @property() attributes: any;
  @property() openLinkInNewTab: any;
  @property() text: any;

  render() {
    return html\`

          <div >\${
            this.link
              ? html\`<a  \${spread(props.attributes)}  .href=\${
                  this.link
                }  .target=\${this.openLinkInNewTab ? \\"_blank\\" : undefined} >\${
                  this.text
                }</a>\`
              : null
          }
        \${
          !this.link
            ? html\`<button  type=\\"button\\"  \${spread(props.attributes)} >\${
                this.text
              }</button>\`
            : null
        }</div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > Columns 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

type Column = {
  content: any; // TODO: Implement this when support for dynamic CSS lands

  width?: number;
};
export interface ColumnProps {
  columns?: Column[]; // TODO: Implement this when support for dynamic CSS lands

  space?: number; // TODO: Implement this when support for dynamic CSS lands

  stackColumnsAt?: \\"tablet\\" | \\"mobile\\" | \\"never\\"; // TODO: Implement this when support for dynamic CSS lands

  reverseColumnsWhenStacked?: boolean;
}

@customElement(\\"my-column\\")
export default class Column extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() columns: any;
  @property() space: any;

  getColumns() {
    return this.columns || [];
  }
  getGutterSize() {
    return typeof this.space === \\"number\\" ? this.space || 0 : 20;
  }
  getWidth(index: number) {
    const columns = this.getColumns();
    return (columns[index] && columns[index].width) || 100 / columns.length;
  }
  getColumnCssWidth(index: number) {
    const columns = this.getColumns();
    const gutterSize = this.getGutterSize();
    const subtractWidth = (gutterSize * (columns.length - 1)) / columns.length;
    return \`calc(\${this.getWidth(index)}% - \${subtractWidth}px)\`;
  }

  render() {
    return html\`
          <style>.div {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  line-height: normal;
}
@media (max-width: 999px) {
  .div {
    flex-direction: row;
  }
}
@media (max-width: 639px) {
  .div {
    flex-direction: row-reverse;
  }
}
.div-2 {
  flex-grow: 1;
}
</style>
          <div>
          \${this.columns?.map(
            (column, index) => html\`
         <div>\${column.content} \${index}</div>
         \`
          )}
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > ContentSlotHtml 1`] = `
"import type { JSX } from \\"../../../../jsx-runtime\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

type Props = {
  [key: string]: string | JSX.Element;
  slotTesting: JSX.Element;
};

@customElement(\\"content-slot-code\\")
export default class ContentSlotCode extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() slotTesting: any;

  render() {
    return html\`

          <div>
          <my-slot .name=\\"\${this.slotTesting}\\"></my-slot>
          <div><hr /></div>
          <div><my-slot></my-slot></div>
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > ContentSlotJSX 1`] = `
"import type { JSX } from \\"../../../../jsx-runtime\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

type Props = {
  [key: string]: string | JSX.Element;
};

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"content-slot-jsx-code\\")
export default class ContentSlotJsxCode extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() slotContent: any;
  @property() children: any;
  @property() slotReference: any;
  @property() attributes: any;
  @property() content: any;

  @state() name = \\"king\\";
  @state() showContent = false;

  get cls() {
    return this.slotContent && this.children ? \`\${this.name}-content\` : \\"\\";
  }
  show() {
    this.slotContent ? 1 : \\"\\";
  }

  render() {
    return html\`

          \${
            this.slotReference
              ? html\`<div  class={state.cls}  .name=\${
                  this.slotContent ? \\"name1\\" : \\"name2\\"
                }  .title=\${this.slotContent ? \\"title1\\" : \\"title2\\"}  \${spread(
                  props.attributes
                )}  @click=\${(event) => this.show()} >\${
                  this.showContent && this.slotContent
                    ? html\`<my-slot  name=\\"content\\" >\${this.content}</my-slot>\`
                    : null
                }
       <div ><hr  /></div>
       <div >\${this.children}</div></div>\`
              : null
          }
        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > CustomCode 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export interface CustomCodeProps {
  code: string;
  replaceNodes?: boolean;
}

@customElement(\\"custom-code\\")
export default class CustomCode extends LitElement {
  createRenderRoot() {
    return this;
  }

  @query('[ref=\\"elem\\"]')
  elem!: HTMLElement;

  @property() replaceNodes: any;
  @property() code: any;

  @state() scriptsInserted = [];
  @state() scriptsRun = [];

  findAndRunScripts() {
    // TODO: Move this function to standalone one in '@builder.io/utils'
    if (this.elem && typeof window !== \\"undefined\\") {
      /** @type {HTMLScriptElement[]} */
      const scripts = this.elem.getElementsByTagName(\\"script\\");

      for (let i = 0; i < scripts.length; i++) {
        const script = scripts[i];

        if (script.src) {
          if (this.scriptsInserted.includes(script.src)) {
            continue;
          }

          this.scriptsInserted.push(script.src);
          const newScript = document.createElement(\\"script\\");
          newScript.async = true;
          newScript.src = script.src;
          document.head.appendChild(newScript);
        } else if (
          !script.type ||
          [
            \\"text/javascript\\",
            \\"application/javascript\\",
            \\"application/ecmascript\\",
          ].includes(script.type)
        ) {
          if (this.scriptsRun.includes(script.innerText)) {
            continue;
          }

          try {
            this.scriptsRun.push(script.innerText);
            new Function(script.innerText)();
          } catch (error) {
            console.warn(\\"\`CustomCode\`: Error running script:\\", error);
          }
        }
      }
    }
  }

  connectedCallback() {
    this.findAndRunScripts();
  }

  render() {
    return html\`

          <div  class={'builder-custom-code' + (props.replaceNodes ? ' replace-nodes' : '')}  ref=\\"elem\\"  .innerHTML=\${this.code} ></div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > Embed 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export interface CustomCodeProps {
  code: string;
  replaceNodes?: boolean;
}

@customElement(\\"custom-code\\")
export default class CustomCode extends LitElement {
  createRenderRoot() {
    return this;
  }

  @query('[ref=\\"elem\\"]')
  elem!: HTMLElement;

  @property() replaceNodes: any;
  @property() code: any;

  @state() scriptsInserted = [];
  @state() scriptsRun = [];

  findAndRunScripts() {
    // TODO: Move this function to standalone one in '@builder.io/utils'
    if (this.elem && typeof window !== \\"undefined\\") {
      /** @type {HTMLScriptElement[]} */
      const scripts = this.elem.getElementsByTagName(\\"script\\");

      for (let i = 0; i < scripts.length; i++) {
        const script = scripts[i];

        if (script.src) {
          if (this.scriptsInserted.includes(script.src)) {
            continue;
          }

          this.scriptsInserted.push(script.src);
          const newScript = document.createElement(\\"script\\");
          newScript.async = true;
          newScript.src = script.src;
          document.head.appendChild(newScript);
        } else if (
          !script.type ||
          [
            \\"text/javascript\\",
            \\"application/javascript\\",
            \\"application/ecmascript\\",
          ].includes(script.type)
        ) {
          if (this.scriptsRun.includes(script.innerText)) {
            continue;
          }

          try {
            this.scriptsRun.push(script.innerText);
            new Function(script.innerText)();
          } catch (error) {
            console.warn(\\"\`CustomCode\`: Error running script:\\", error);
          }
        }
      }
    }
  }

  connectedCallback() {
    this.findAndRunScripts();
  }

  render() {
    return html\`

          <div  class={'builder-custom-code' + (props.replaceNodes ? ' replace-nodes' : '')}  ref=\\"elem\\"  .innerHTML=\${this.code} ></div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > Form 1`] = `
"import { Builder, BuilderElement, builder } from \\"@builder.io/sdk\\";
import {
  BuilderBlock as BuilderBlockComponent,
  BuilderBlocks,
  get,
  set,
} from \\"@fake\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export interface FormProps {
  attributes?: any;
  name?: string;
  action?: string;
  validate?: boolean;
  method?: string;
  builderBlock?: BuilderElement;
  sendSubmissionsTo?: string;
  sendSubmissionsToEmail?: string;
  sendWithJs?: boolean;
  contentType?: string;
  customHeaders?: {
    [key: string]: string;
  };
  successUrl?: string;
  previewState?: FormState;
  successMessage?: BuilderElement[];
  errorMessage?: BuilderElement[];
  sendingMessage?: BuilderElement[];
  resetFormOnSubmit?: boolean;
  errorMessagePath?: string;
}
export type FormState = \\"unsubmitted\\" | \\"sending\\" | \\"success\\" | \\"error\\";

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"form-component\\")
export default class FormComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @query('[ref=\\"formRef\\"]')
  formRef!: HTMLElement;

  @property() previewState: any;
  @property() sendWithJs: any;
  @property() sendSubmissionsTo: any;
  @property() action: any;
  @property() customHeaders: any;
  @property() contentType: any;
  @property() sendSubmissionsToEmail: any;
  @property() name: any;
  @property() method: any;
  @property() errorMessagePath: any;
  @property() resetFormOnSubmit: any;
  @property() successUrl: any;
  @property() validate: any;
  @property() attributes: any;
  @property() builderBlock: any;
  @property() errorMessage: any;
  @property() sendingMessage: any;
  @property() successMessage: any;

  @state() formState = \\"unsubmitted\\";
  @state() responseData = null;
  @state() formErrorMessage = \\"\\";

  get submissionState() {
    return (Builder.isEditing && this.previewState) || this.formState;
  }
  onSubmit(
    event: Event & {
      currentTarget: HTMLFormElement;
    }
  ) {
    const sendWithJs = this.sendWithJs || this.sendSubmissionsTo === \\"email\\";

    if (this.sendSubmissionsTo === \\"zapier\\") {
      event.preventDefault();
    } else if (sendWithJs) {
      if (!(this.action || this.sendSubmissionsTo === \\"email\\")) {
        event.preventDefault();
        return;
      }

      event.preventDefault();
      const el = event.currentTarget;
      const headers = this.customHeaders || {};
      let body: any;
      const formData = new FormData(el); // TODO: maybe support null

      const formPairs: {
        key: string;
        value: File | boolean | number | string | FileList;
      }[] = Array.from(
        event.currentTarget.querySelectorAll(\\"input,select,textarea\\")
      )
        .filter((el) => !!(el as HTMLInputElement).name)
        .map((el) => {
          let value: any;
          const key = (el as HTMLImageElement).name;

          if (el instanceof HTMLInputElement) {
            if (el.type === \\"radio\\") {
              if (el.checked) {
                value = el.name;
                return {
                  key,
                  value,
                };
              }
            } else if (el.type === \\"checkbox\\") {
              value = el.checked;
            } else if (el.type === \\"number\\" || el.type === \\"range\\") {
              const num = el.valueAsNumber;

              if (!isNaN(num)) {
                value = num;
              }
            } else if (el.type === \\"file\\") {
              // TODO: one vs multiple files
              value = el.files;
            } else {
              value = el.value;
            }
          } else {
            value = (el as HTMLInputElement).value;
          }

          return {
            key,
            value,
          };
        });
      let contentType = this.contentType;

      if (this.sendSubmissionsTo === \\"email\\") {
        contentType = \\"multipart/form-data\\";
      }

      Array.from(formPairs).forEach(({ value }) => {
        if (
          value instanceof File ||
          (Array.isArray(value) && value[0] instanceof File) ||
          value instanceof FileList
        ) {
          contentType = \\"multipart/form-data\\";
        }
      }); // TODO: send as urlEncoded or multipart by default
      // because of ease of use and reliability in browser API
      // for encoding the form?

      if (contentType !== \\"application/json\\") {
        body = formData;
      } else {
        // Json
        const json = {};
        Array.from(formPairs).forEach(({ value, key }) => {
          set(json, key, value);
        });
        body = JSON.stringify(json);
      }

      if (contentType && contentType !== \\"multipart/form-data\\") {
        if (
          /* Zapier doesn't allow content-type header to be sent from browsers */
          !(sendWithJs && this.action?.includes(\\"zapier.com\\"))
        ) {
          headers[\\"content-type\\"] = contentType;
        }
      }

      const presubmitEvent = new CustomEvent(\\"presubmit\\", {
        detail: {
          body,
        },
      });

      if (this.formRef) {
        this.formRef.dispatchEvent(presubmitEvent);

        if (presubmitEvent.defaultPrevented) {
          return;
        }
      }

      this.formState = \\"sending\\";
      const formUrl = \`\${
        builder.env === \\"dev\\" ? \\"http://localhost:5000\\" : \\"https://builder.io\\"
      }/api/v1/form-submit?apiKey=\${builder.apiKey}&to=\${btoa(
        this.sendSubmissionsToEmail || \\"\\"
      )}&name=\${encodeURIComponent(this.name || \\"\\")}\`;
      fetch(
        this.sendSubmissionsTo === \\"email\\" ? formUrl : this.action!,
        /* TODO: throw error if no action URL */
        {
          body,
          headers,
          method: this.method || \\"post\\",
        }
      ).then(
        async (res) => {
          let body;
          const contentType = res.headers.get(\\"content-type\\");

          if (contentType && contentType.indexOf(\\"application/json\\") !== -1) {
            body = await res.json();
          } else {
            body = await res.text();
          }

          if (!res.ok && this.errorMessagePath) {
            /* TODO: allow supplying an error formatter function */
            let message = get(body, this.errorMessagePath);

            if (message) {
              if (typeof message !== \\"string\\") {
                /* TODO: ideally convert json to yaml so it woul dbe like
            error: - email has been taken */
                message = JSON.stringify(message);
              }

              this.formErrorMessage = message;
            }
          }

          this.responseData = body;
          this.formState = res.ok ? \\"success\\" : \\"error\\";

          if (res.ok) {
            const submitSuccessEvent = new CustomEvent(\\"submit:success\\", {
              detail: {
                res,
                body,
              },
            });

            if (this.formRef) {
              this.formRef.dispatchEvent(submitSuccessEvent);

              if (submitSuccessEvent.defaultPrevented) {
                return;
              }
              /* TODO: option to turn this on/off? */

              if (this.resetFormOnSubmit !== false) {
                this.formRef.reset();
              }
            }
            /* TODO: client side route event first that can be preventDefaulted */

            if (this.successUrl) {
              if (this.formRef) {
                const event = new CustomEvent(\\"route\\", {
                  detail: {
                    url: this.successUrl,
                  },
                });
                this.formRef.dispatchEvent(event);

                if (!event.defaultPrevented) {
                  location.href = this.successUrl;
                }
              } else {
                location.href = this.successUrl;
              }
            }
          }
        },
        (err) => {
          const submitErrorEvent = new CustomEvent(\\"submit:error\\", {
            detail: {
              error: err,
            },
          });

          if (this.formRef) {
            this.formRef.dispatchEvent(submitErrorEvent);

            if (submitErrorEvent.defaultPrevented) {
              return;
            }
          }

          this.responseData = err;
          this.formState = \\"error\\";
        }
      );
    }
  }

  render() {
    return html\`
          <style>.pre {
  padding: 10px;
  color: red;
  text-align: center;
}
</style>
          <form  .validate=\${this.validate}  ref=\\"formRef\\"  .action=\${
      !this.sendWithJs && this.action
    }  .method=\${this.method}  .name=\${this.name}  @submit=\${(event) =>
      this.onSubmit(event)}  \${spread(props.attributes)} >\${
      this.builderBlock && this.builderBlock.children
        ? html\`\${this.builderBlock?.children?.map(
            (block, index) =>
              html\`<builder-block-component  .key=\${block.id}  .block=\${block}  .index=\${index} ></builder-block-component>\`
          )}\`
        : null
    }
        \${
          this.submissionState === \\"error\\"
            ? html\`<builder-blocks  dataPath=\\"errorMessage\\"  .blocks=\${this
                .errorMessage!} ></builder-blocks>\`
            : null
        }
        \${
          this.submissionState === \\"sending\\"
            ? html\`<builder-blocks  dataPath=\\"sendingMessage\\"  .blocks=\${this
                .sendingMessage!} ></builder-blocks>\`
            : null
        }
        \${
          this.submissionState === \\"error\\" && this.responseData
            ? html\`<pre >\${JSON.stringify(this.responseData, null, 2)}</pre>\`
            : null
        }
        \${
          this.submissionState === \\"success\\"
            ? html\`<builder-blocks  dataPath=\\"successMessage\\"  .blocks=\${this
                .successMessage!} ></builder-blocks>\`
            : null
        }</form>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > Image 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

// TODO: AMP Support?
export interface ImageProps {
  _class?: string;
  image: string;
  sizes?: string;
  lazy?: boolean;
  height?: number;
  width?: number;
  altText?: string;
  backgroundSize?: string;
  backgroundPosition?: string; // TODO: Support generating Builder.io and or Shopify \`srcset\`s when needed

  srcset?: string; // TODO: Implement support for custom aspect ratios

  aspectRatio?: number; // TODO: This might not work as expected in terms of positioning

  children?: any;
}

@customElement(\\"my-image\\")
export default class Image extends LitElement {
  createRenderRoot() {
    return this;
  }

  @query('[ref=\\"pictureRef\\"]')
  pictureRef!: HTMLElement;

  @property() lazy: any;
  @property() altText: any;
  @property() _class: any;
  @property() image: any;
  @property() srcset: any;
  @property() sizes: any;
  @property() children: any;

  @state() scrollListener = null;
  @state() imageLoaded = false;
  @state() load = false;

  setLoaded() {
    this.imageLoaded = true;
  }
  useLazyLoading() {
    // TODO: Add more checks here, like testing for real web browsers
    return !!this.lazy && this.isBrowser();
  }
  isBrowser = function isBrowser() {
    return (
      typeof window !== \\"undefined\\" && window.navigator.product != \\"ReactNative\\"
    );
  };

  connectedCallback() {
    if (this.useLazyLoading()) {
      // throttled scroll capture listener
      const listener = () => {
        if (this.pictureRef) {
          const rect = this.pictureRef.getBoundingClientRect();
          const buffer = window.innerHeight / 2;

          if (rect.top < window.innerHeight + buffer) {
            this.load = true;
            this.scrollListener = null;
            window.removeEventListener(\\"scroll\\", listener);
          }
        }
      };

      this.scrollListener = listener;
      window.addEventListener(\\"scroll\\", listener, {
        capture: true,
        passive: true,
      });
      listener();
    }
  }
  disconnectedCallback() {
    if (this.scrollListener) {
      window.removeEventListener(\\"scroll\\", this.scrollListener);
    }
  }

  render() {
    return html\`
          <style>.img {
  opacity: 1;
  transition: opacity 0.2s ease-in-out;
  object-fit: cover;
  object-position: center;
}
</style>
          <div>
          <picture ref=\\"pictureRef\\"
            >\${
              !this.useLazyLoading() || this.load
                ? html\`<img class={'builder-image' +
           (props._class ? ' ' + props._class : '') + ' img'} .alt=\${
             this.altText
           }
           aria-role=\${this.altText ? \\"presentation\\" : undefined} .src=\${
                    this.image
                  }
           @load=\${(event) => this.setLoaded()} .srcset=\${this.srcset}
           .sizes=\${this.sizes} />\`
                : null
            }
            <source .srcset=\\"\${this.srcset}\\"
          /></picture>
          \${this.children}
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > Image State 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"img-state-component\\")
export default class ImgStateComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() canShow = true;
  @state() images = [\\"http://example.com/qwik.png\\"];

  render() {
    return html\`

          <div>
          \${this.images?.map(
            (item, itemIndex) => html\`<my-fragment
        ><img .src=\\"\${item}\\" .key=\\"\${itemIndex}\\" /></my-fragment
      >\`
          )}
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > Img 1`] = `
"import { Builder } from \\"@builder.io/sdk\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export interface ImgProps {
  attributes?: any;
  imgSrc?: string;
  altText?: string;
  backgroundSize?: \\"cover\\" | \\"contain\\";
  backgroundPosition?:
    | \\"center\\"
    | \\"top\\"
    | \\"left\\"
    | \\"right\\"
    | \\"bottom\\"
    | \\"top left\\"
    | \\"top right\\"
    | \\"bottom left\\"
    | \\"bottom right\\";
}

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"img-component\\")
export default class ImgComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() backgroundSize: any;
  @property() backgroundPosition: any;
  @property() attributes: any;
  @property() imgSrc: any;
  @property() altText: any;

  render() {
    return html\`

          <img .style=\${{
            objectFit: this.backgroundSize || \\"cover\\",
            objectPosition: this.backgroundPosition || \\"center\\",
          }} \${spread(props.attributes)}
        .key=\${(Builder.isEditing && this.imgSrc) || \\"default-key\\"} .alt=\${
      this.altText
    }
        .src=\${this.imgSrc} />

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > Input 1`] = `
"import { Builder } from \\"@builder.io/sdk\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export interface FormInputProps {
  type?: string;
  attributes?: any;
  name?: string;
  value?: string;
  placeholder?: string;
  defaultValue?: string;
  required?: boolean;
  onChange?: (value: string) => void;
}

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"form-input-component\\")
export default class FormInputComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() attributes: any;
  @property() defaultValue: any;
  @property() placeholder: any;
  @property() type: any;
  @property() name: any;
  @property() value: any;
  @property() required: any;
  @property() onChange: any;

  render() {
    return html\`

          <input \${spread(props.attributes)} .key=\${
      Builder.isEditing && this.defaultValue ? this.defaultValue : \\"default-key\\"
    } .placeholder=\${this.placeholder}
        .type=\${this.type} .name=\${this.name} .value=\${this.value}
        .defaultValue=\${this.defaultValue} .required=\${
      this.required
    } @change=\${(event) => this.onChange?.(event.target.value)} />

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > InputParent 1`] = `
"import FormInputComponent from \\"./input.raw\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-stepper\\")
export default class Stepper extends LitElement {
  createRenderRoot() {
    return this;
  }

  handleChange(value: string) {
    console.log(value);
  }

  render() {
    return html\`

          <form-input-component  name=\\"kingzez\\"  type=\\"text\\"  @change=\${(
            value
          ) => this.handleChange(value)} ></form-input-component>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > NestedStore 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

type MyStore = {
  _id?: string;
  _messageId?: string;
};

@customElement(\\"nested-store\\")
export default class NestedStore extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() _id = \\"abc\\";
  @state() _messageId = this._id + \\"-message\\";

  render() {
    return html\`

          <div .id=\\"\${this._id}\\">
          Test

          <p .id=\\"\${this._messageId}\\">Message</p>
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > RawText 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export interface RawTextProps {
  attributes?: any;
  text?: string; // builderBlock?: any;
}

@customElement(\\"raw-text\\")
export default class RawText extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() attributes: any;
  @property() text: any;

  render() {
    return html\`

          <span  class={props.attributes?.class || props.attributes?.className}  .innerHTML=\${
            this.text || \\"\\"
          } ></span>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > Section 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export interface SectionProps {
  maxWidth?: number;
  attributes?: any;
  children?: any;
}

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"section-component\\")
export default class SectionComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() attributes: any;
  @property() maxWidth: any;
  @property() children: any;

  render() {
    return html\`

          <section  \${spread(props.attributes)}  .style=\${
      this.maxWidth && typeof this.maxWidth === \\"number\\"
        ? {
            maxWidth: this.maxWidth,
          }
        : undefined
    } >\${this.children}</section>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > Section 2`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export interface SectionProps {
  maxWidth?: number;
  attributes?: any;
  children?: any;
}

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"section-state-component\\")
export default class SectionStateComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() attributes: any;
  @property() children: any;

  @state() max = 42;
  @state() items = [42];

  render() {
    return html\`

          \${
            this.max
              ? html\`\${this.items?.map(
                  (item, index) =>
                    html\`<section  \${spread(props.attributes)}  .style=\${{
                      maxWidth: item + this.max,
                    }} >\${this.children}</section>\`
                )}\`
              : null
          }
        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > Select 1`] = `
"import { Builder } from \\"@builder.io/sdk\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export interface FormSelectProps {
  options?: {
    name?: string;
    value: string;
  }[];
  attributes?: any;
  name?: string;
  value?: string;
  defaultValue?: string;
}

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"select-component\\")
export default class SelectComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() attributes: any;
  @property() value: any;
  @property() defaultValue: any;
  @property() name: any;
  @property() options: any;

  render() {
    return html\`

          <select  \${spread(props.attributes)}  .value=\${this.value}  .key=\${
      Builder.isEditing && this.defaultValue ? this.defaultValue : \\"default-key\\"
    }  .defaultValue=\${this.defaultValue}  .name=\${
      this.name
    } >\${this.options?.map(
      (option, index) =>
        html\`<option  .value=\${option.value}  data-index=\${index} >\${
          option.name || option.value
        }</option>\`
    )}</select>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > SlotDefault 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

type Props = {
  [key: string]: string;
};

@customElement(\\"slot-code\\")
export default class SlotCode extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <div>
          <my-slot><div>Default content</div></my-slot>
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > SlotHtml 1`] = `
"import ContentSlotCode from \\"./content-slot-jsx.raw\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

type Props = {
  [key: string]: string;
};

@customElement(\\"slot-code\\")
export default class SlotCode extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <div ><content-slot-code ><my-slot  .testing=\${(
            <div>Hello</div>
          )} ></my-slot></content-slot-code></div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > SlotJsx 1`] = `
"import ContentSlotCode from \\"./content-slot-jsx.raw\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

type Props = {
  [key: string]: string;
};

@customElement(\\"slot-code\\")
export default class SlotCode extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <div ><content-slot-code  .slotTesting=\${(
            <div>Hello</div>
          )} ></content-slot-code></div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > SlotNamed 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

type Props = {
  [key: string]: string;
};

@customElement(\\"slot-code\\")
export default class SlotCode extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <div>
          <my-slot name=\\"myAwesomeSlot\\"></my-slot>
          <my-slot name=\\"top\\"></my-slot>
          <my-slot name=\\"left\\">Default left</my-slot>
          <my-slot>Default Child</my-slot>
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > Stamped.io 1`] = `
"import { kebabCase, snakeCase } from \\"lodash\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

type SmileReviewsProps = {
  productId: string;
  apiKey: string;
};

@customElement(\\"smile-reviews\\")
export default class SmileReviews extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() apiKey: any;
  @property() productId: any;

  @state() reviews = [];
  @state() name = \\"test\\";
  @state() showReviewPrompt = false;

  kebabCaseValue() {
    return kebabCase(\\"testThat\\");
  }
  snakeCaseValue() {
    return snakeCase(\\"testThis\\");
  }

  connectedCallback() {
    fetch(
      \`https://stamped.io/api/widget/reviews?storeUrl=builder-io.myshopify.com&apiKey=\${
        this.apiKey || \\"pubkey-8bbDq7W6w4sB3OWeM1HUy2s47702hM\\"
      }&productId=\${this.productId || \\"2410511106127\\"}\`
    )
      .then((res) => res.json())
      .then((data) => {
        this.reviews = data.data;
      });
  }

  render() {
    return html\`
          <style>.input {
  display: block;
}
.textarea {
  display: block;
}
.button {
  display: block;
}
.review {
  margin: 10px;
  padding: 10px;
  background: white;
  display: flex;
  border-radius: 5px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  -webkit-font-smoothing: antialiased;
}
.img {
  height: 30px;
  width: 30px;
  margin-right: 10px;
}
</style>
          <div  data-user=\${this.name} ><button  @click=\${(event) =>
      (this.showReviewPrompt = true)} >Write a review</button>
        \${
          this.showReviewPrompt || \\"asdf\\"
            ? html\`<input  placeholder=\\"Email\\"  />
       <input  placeholder=\\"Title\\"  />
       <textarea  placeholder=\\"How was your experience?\\" ></textarea>
       <button  @click=\${(ev) => {
         ev.preventDefault();
         this.showReviewPrompt = false;
       }} >
                 Submit
               </button>\`
            : null
        }
        \${this.reviews?.map(
          (review, index) =>
            html\`<div  .key=\${review.id} ><img  .src=\${review.avatar}  />
       <div  class={state.showReviewPrompt ? 'bg-primary' : 'bg-secondary'} ><div >N:
       \${index}</div>
       <div >\${review.author}</div>
       <div >\${review.reviewMessage}</div></div></div>\`
        )}</div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > StoreComment 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"string-literal-store\\")
export default class StringLiteralStore extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() foo = true;

  bar() {}

  render() {
    return html\`

          <my-fragment>\${this.foo}</my-fragment>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > StoreShadowVars 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() errors = {};

  foo(errors) {
    return errors;
  }

  render() {
    return html\`

          <my-fragment>\${this.foo(this.errors)}</my-fragment>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > StoreWithState 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() foo = false;

  bar() {
    return this.foo;
  }

  render() {
    return html\`

          <my-fragment>\${this.bar()}</my-fragment>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > Submit 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export interface ButtonProps {
  attributes?: any;
  text?: string;
}

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"submit-button\\")
export default class SubmitButton extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() attributes: any;
  @property() text: any;

  render() {
    return html\`

          <button type=\\"submit\\" \${spread(props.attributes)}>\${
      this.text
    }</button>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > Text 1`] = `
"import { Builder } from \\"@builder.io/sdk\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export interface TextProps {
  attributes?: any;
  rtlMode: boolean;
  text?: string;
  content?: string;
  builderBlock?: any;
}

@customElement(\\"my-text\\")
export default class Text extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() text: any;
  @property() content: any;

  @state() name = \\"Decadef20\\";

  render() {
    return html\`

          <div  .contentEditable=\${allowEditingText || undefined}  data-name=\${{
      test: this.name || \\"any name\\",
    }}  .innerHTML=\${
      this.text || this.content || this.name || '<p class=\\"text-lg\\">my name</p>'
    } ></div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > Textarea 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export interface TextareaProps {
  attributes?: any;
  name?: string;
  value?: string;
  defaultValue?: string;
  placeholder?: string;
}

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"my-textarea\\")
export default class Textarea extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() attributes: any;
  @property() placeholder: any;
  @property() name: any;
  @property() value: any;
  @property() defaultValue: any;

  render() {
    return html\`

          <textarea
          \${spread(props.attributes)}
          .placeholder=\\"\${this.placeholder}\\"
          .name=\\"\${this.name}\\"
          .value=\\"\${this.value}\\"
          .defaultValue=\\"\${this.defaultValue}\\"
        ></textarea>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > UseValueAndFnFromStore 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

type MyProps = {
  onChange?: (active: boolean) => void;
};
type MyStore = {
  _id?: string;
  _active?: boolean;
  _do?: (id?: string) => void;
};

@customElement(\\"use-value-and-fn-from-store\\")
export default class UseValueAndFnFromStore extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() onChange: any;

  @state() _id = \\"abc\\";
  @state() _active = false;

  _do(id?: string) {
    this._active = !!id;

    if (this.onChange) {
      this.onChange(this._active);
    }
  }

  updated() {
    if (this._do) {
      this._do(this._id);
    }
  }

  render() {
    return html\`

          <div>Test</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > Video 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export interface VideoProps {
  attributes?: any;
  video?: string;
  autoPlay?: boolean;
  controls?: boolean;
  muted?: boolean;
  loop?: boolean;
  playsInline?: boolean;
  aspectRatio?: number;
  width?: number;
  height?: number;
  fit?: \\"contain\\" | \\"cover\\" | \\"fill\\";
  position?:
    | \\"center\\"
    | \\"top\\"
    | \\"left\\"
    | \\"right\\"
    | \\"bottom\\"
    | \\"top left\\"
    | \\"top right\\"
    | \\"bottom left\\"
    | \\"bottom right\\";
  posterImage?: string;
  lazyLoad?: boolean;
}

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"my-video\\")
export default class Video extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() attributes: any;
  @property() fit: any;
  @property() position: any;
  @property() video: any;
  @property() posterImage: any;
  @property() autoPlay: any;
  @property() muted: any;
  @property() controls: any;
  @property() loop: any;

  render() {
    return html\`

          <video  preload=\\"none\\"  \${spread(props.attributes)}  .style=\${{
      width: \\"100%\\",
      height: \\"100%\\",
      ...this.attributes?.style,
      objectFit: this.fit,
      objectPosition: this.position,
      // Hack to get object fit to work as expected and
      // not have the video overflow
      borderRadius: 1,
    }}  .key=\${this.video || \\"no-src\\"}  .poster=\${
      this.posterImage
    }  .autoplay=\${this.autoPlay}  .muted=\${this.muted}  .controls=\${
      this.controls
    }  .loop=\${this.loop} ></video>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > arrowFunctionInUseStore 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() name = \\"steve\\";

  setName(value) {
    this.name = value;
  }
  updateNameWithArrowFn(value) {
    this.name = value;
  }

  render() {
    return html\`

          <div>Hello \${this.name}</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > basicForFragment 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"basic-for-fragment\\")
export default class BasicForFragment extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <div>
          \${[\\"a\\", \\"b\\", \\"c\\"]?.map(
            (option, index) => html\`<my-fragment
        .key=\\"\${\`key-\${option}\`}\\"
        ><div>\${option}</div></my-fragment
      >\`
          )}
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > basicForNoTagReference 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-for-no-tag-ref-component\\")
export default class MyBasicForNoTagRefComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() actions: any;

  @state() name = \\"VincentW\\";
  @state() TagName = \\"div\\";
  @state() tag = \\"span\\";

  get TagNameGetter() {
    return \\"span\\";
  }

  render() {
    return html\`

          <state.TagNameGetter>
          Hello
          <state.tag>\${this.name}</state.tag>
          \${this.actions?.map(
            (action, index) => html\`<state.TagName
          ><action.icon></action.icon> <span>\${action.text}</span></state.TagName
        >\`
          )}</state.TagNameGetter
        >

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > basicForwardRef 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export interface Props {
  showInput: boolean;
  inputRef: HTMLInputElement;
}

@customElement(\\"my-basic-forward-ref-component\\")
export default class MyBasicForwardRefComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @query('[ref=\\"props.inputRef\\"]')
  propsInputRef!: HTMLElement;

  @property() inputRef: any;

  @state() name = \\"PatrickJS\\";

  render() {
    return html\`
          <style>.input {
  color: red;
}
</style>
          <div>
          <input ref=\\"props.inputRef\\" .value=\${this.name} @change=\${(event) =>
      (this.name = event.target.value)} />
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > basicForwardRefMetadata 1`] = `
"/**
          useMetadata:
          {\\"forwardRef\\":\\"inputRef\\"}
          */

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export interface Props {
  showInput: boolean;
  inputRef: HTMLInputElement;
}

@customElement(\\"my-basic-forward-ref-component\\")
export default class MyBasicForwardRefComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @query('[ref=\\"props.inputRef\\"]')
  propsInputRef!: HTMLElement;

  @property() inputRef: any;

  @state() name = \\"PatrickJS\\";

  render() {
    return html\`
          <style>.input {
  color: red;
}
</style>
          <div>
          <input ref=\\"props.inputRef\\" .value=\${this.name} @change=\${(event) =>
      (this.name = event.target.value)} />
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > basicOnUpdateReturn 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-on-update-return-component\\")
export default class MyBasicOnUpdateReturnComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() name = \\"PatrickJS\\";

  updated() {
    const controller = new AbortController();
    const signal = controller.signal;
    fetch(\\"https://patrickjs.com/api/resource.json\\", {
      signal,
    })
      .then((response) => response.json())
      .then((data) => {
        this.name = data.name;
      });
    return () => {
      if (!signal.aborted) {
        controller.abort();
      }
    };
  }

  render() {
    return html\`

          <div>Hello! \${this.name}</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > class + ClassName + css 1`] = `
"import \\"./my-component.ts\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`
          <style>.div {
  padding: 10px;
}
</style>
          <div>
          <my-comp> Hello! I can run in React, Vue, Solid, or Liquid! </my-comp>
          <div>Hello! I can run in React, Vue, Solid, or Liquid!</div>
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > class + css 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`
          <style>.div {
  padding: 10px;
}
</style>
          <div>Hello! I can run in React, Vue, Solid, or Liquid!</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > className + css 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`
          <style>.div {
  padding: 10px;
}
</style>
          <div>Hello! I can run in React, Vue, Solid, or Liquid!</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > className 1`] = `
"import type { JSX } from \\"../../../../jsx-runtime\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

type Props = {
  [key: string]: string | JSX.Element;
  slotTesting: JSX.Element;
};

@customElement(\\"class-name-code\\")
export default class ClassNameCode extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() bindings = \\"a binding\\";

  render() {
    return html\`

          <div>
          <div>Without Binding</div>
          <div class=\\"{state.bindings}\\">With binding</div>
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > classState 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() classState = \\"testClassName\\";
  @state() styleState = {
    color: \\"red\\",
  };

  render() {
    return html\`
          <style>.div {
  padding: 10px;
}
</style>
          <div  class={state.classState + ' div'}  .style=\${this.styleState} >
              Hello! I can run in React, Vue, Solid, or Liquid!
            </div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > complexMeta 1`] = `
"/**
          useMetadata:
          {\\"x\\":\\"y\\",\\"stringValue\\":\\"d\\",\\"booleanValue\\":true,\\"numberValue\\":1,\\"innerObject\\":{\\"stringValue\\":\\"inner\\",\\"numberValue\\":2,\\"booleanValue\\":false}}
          */

import { abc } from \\"./meta-sub\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"complex-meta-raw\\")
export default class ComplexMetaRaw extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > componentWithContext 1`] = `
"import Context1 from \\"@dummy/1\\";
import Context2 from \\"@dummy/2\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export interface ComponentWithContextProps {
  content: string;
}

@customElement(\\"component-with-context\\")
export default class ComponentWithContext extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() content: any;

  render() {
    return html\`

          <my-fragment><my-fragment>\${foo.value}</my-fragment></my-fragment>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > componentWithContextMultiRoot 1`] = `
"import Context1 from \\"@dummy/1\\";
import Context2 from \\"@dummy/2\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export interface ComponentWithContextProps {
  content: string;
}

@customElement(\\"component-with-context\\")
export default class ComponentWithContext extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() content: any;

  render() {
    return html\`

          <my-fragment
          ><my-fragment>\${foo.value}</my-fragment>
          <div>other</div></my-fragment
        >

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > contentState 1`] = `
"import BuilderContext from \\"@dummy/context.js\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"render-content\\")
export default class RenderContent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() content: any;
  @property() customComponents: any;

  render() {
    return html\`

          <div>setting context</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > defaultProps 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export interface ButtonProps {
  attributes?: any;
  text?: string;
  buttonText?: string; // no default value

  link?: string;
  openLinkInNewTab?: boolean;
  onClick?: () => void;
}

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"my-button\\")
export default class Button extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() link: any;
  @property() attributes: any;
  @property() openLinkInNewTab: any;
  @property() text: any;
  @property() onClick: any;
  @property() buttonText: any;

  render() {
    return html\`

          <div >\${
            this.link
              ? html\`<a  \${spread(props.attributes)}  .href=\${
                  this.link
                }  .target=\${this.openLinkInNewTab ? \\"_blank\\" : undefined} >\${
                  this.text
                }</a>\`
              : null
          }
        \${
          !this.link
            ? html\`<button  type=\\"button\\"  \${spread(
                props.attributes
              )}  @click=\${(event) => this.onClick()} >\${
                this.buttonText
              }</button>\`
            : null
        }</div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > defaultPropsOutsideComponent 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export interface ButtonProps {
  attributes?: any;
  text?: string;
  link?: string;
  openLinkInNewTab?: boolean;
  onClick: () => void;
}

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"my-button\\")
export default class Button extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() link: any;
  @property() attributes: any;
  @property() openLinkInNewTab: any;
  @property() text: any;
  @property() onClick: any;

  render() {
    return html\`

          <div >\${
            this.link
              ? html\`<a  \${spread(props.attributes)}  .href=\${
                  this.link
                }  .target=\${this.openLinkInNewTab ? \\"_blank\\" : undefined} >\${
                  this.text
                }</a>\`
              : null
          }
        \${
          !this.link
            ? html\`<button  type=\\"button\\"  \${spread(
                props.attributes
              )}  @click=\${(event) => this.onClick(event)} >\${
                this.text
              }</button>\`
            : null
        }</div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > defaultValsWithTypes 1`] = `
"const DEFAULT_VALUES: Props = {
  name: \\"Sami\\",
};

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

type Props = {
  name: string;
};

@customElement(\\"component-with-types\\")
export default class ComponentWithTypes extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() name: any;

  render() {
    return html\`

          <div>Hello \${this.name || DEFAULT_VALUES.name}</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > eventInputAndChange 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"event-input-and-change\\")
export default class EventInputAndChange extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() name = \\"Steve\\";

  render() {
    return html\`
          <style>.input {
  color: red;
}
</style>
          <div>
          <input .value=\${this.name} @input=\${(event) =>
      (this.name = event.target.value)}
          @change=\${(event) =>
            (this.name = event.target.value)} /> Hello! I can run in
          React, Vue, Solid, or Liquid!
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > expressionState 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() componentRef: any;

  @state() refToUse = !(this.componentRef instanceof Function)
    ? this.componentRef
    : null;

  render() {
    return html\`

          <div>\${this.refToUse}</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > figmaMeta 1`] = `
"/**
          useMetadata:
          {\\"name\\":\\"def-button-beta-outlined\\",\\"url\\":\\"https://www.figma.com/xxx\\",\\"iconSmall\\":{\\"type\\":\\"instance\\",\\"key\\":\\" Icon Small\\"},\\"iconMedium\\":{\\"type\\":\\"instance\\",\\"key\\":\\" Icon Medium\\"},\\"label\\":{\\"type\\":\\"string\\",\\"key\\":\\" Label\\"},\\"icon\\":{\\"type\\":\\"boolean\\",\\"key\\":\\" Icon\\",\\"value\\":{\\"false\\":false,\\"true\\":\\"placeholder\\"}},\\"interactiveState\\":{\\"type\\":\\"enum\\",\\"key\\":\\"Interactive State\\",\\"value\\":{\\"(Def) Enabled\\":false,\\"Hovered\\":false,\\"Pressed\\":false,\\"Focused\\":false,\\"Disabled\\":\\"true\\"}},\\"size\\":{\\"type\\":\\"enum\\",\\"key\\":\\"Size\\",\\"value\\":{\\"(Def) Medium\\":false,\\"Small\\":\\"small\\"}},\\"width\\":{\\"type\\":\\"enum\\",\\"key\\":\\"Width\\",\\"value\\":{\\"(Def) Auto Width\\":false,\\"Full Width\\":\\"full\\"}}}
          */

import { outline } from \\"./data\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"figma-button\\")
export default class FigmaButton extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() icon: any;
  @property() interactiveState: any;
  @property() width: any;
  @property() size: any;
  @property() label: any;

  render() {
    return html\`

          <button
          data-icon=\\"\${this.icon}\\"
          data-disabled=\\"\${this.interactiveState}\\"
          data-width=\\"\${this.width}\\"
          data-size=\\"\${this.size}\\"
        >
          \${this.label}
        </button>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > getterState 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export interface ButtonProps {
  foo: string;
}

@customElement(\\"my-button\\")
export default class Button extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() foo: any;

  get foo2() {
    return this.foo + \\"foo\\";
  }
  get bar() {
    return \\"bar\\";
  }
  baz(i: number) {
    return i + this.foo2.length;
  }

  render() {
    return html\`

          <div>
          <p>\${this.foo2}</p>
          <p>\${this.bar}</p>
          <p>\${this.baz(1)}</p>
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > import types 1`] = `
"import { BuilderContent, GetContentOptions } from \\"@builder.io/sdk\\";
import RenderBlock, { RenderBlockProps } from \\"./builder-render-block.raw\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

type RenderContentProps = {
  options?: GetContentOptions;
  content: BuilderContent;
  renderContentProps: RenderBlockProps;
};

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"render-content\\")
export default class RenderContent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() renderContentProps: any;

  getRenderContentProps(block, index) {
    return {
      block: block,
      index: index,
    };
  }

  render() {
    return html\`

          <render-block
          \${spread(
            state.getRenderContentProps(props.renderContentProps.block, 0)
          )}
        ></render-block>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > multipleOnUpdate 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"multiple-on-update\\")
export default class MultipleOnUpdate extends LitElement {
  createRenderRoot() {
    return this;
  }

  updated() {
    console.log(\\"Runs on every update/rerender\\");

    console.log(\\"Runs on every update/rerender as well\\");
  }

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > multipleOnUpdateWithDeps 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"multiple-on-update-with-deps\\")
export default class MultipleOnUpdateWithDeps extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() a = \\"a\\";
  @state() b = \\"b\\";
  @state() c = \\"c\\";
  @state() d = \\"d\\";

  updated() {
    console.log(\\"Runs when a or b changes\\", this.a, this.b);

    if (this.a === \\"a\\") {
      this.a = \\"b\\";
    }

    console.log(\\"Runs when c or d changes\\", this.c, this.d);

    if (this.a === \\"a\\") {
      this.a = \\"b\\";
    }
  }

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > multipleSpreads 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() attrs = {
    hello: \\"world\\",
  };

  render() {
    return html\`

          <input \${spread(state.attrs)} \${spread(props)} />

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > nestedShow 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

interface Props {
  conditionA: boolean;
  conditionB: boolean;
}

@customElement(\\"nested-show\\")
export default class NestedShow extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() conditionA: any;
  @property() conditionB: any;

  render() {
    return html\`

          \${
            this.conditionA
              ? html\`\${
                  !this.conditionB
                    ? html\`
        <div>if condition A and condition B</div>
        \`
                    : html\`
        <div>else-condition-B</div>
        \`
                }\`
              : html\`
      <div>else-condition-A</div>
      \`
          }

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > nestedStyles 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"nested-styles\\")
export default class NestedStyles extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`
          <style>.div {
  display: flex;
  --bar: red;
  color: var(--bar);
}
@media (max-width: env(--mobile)) {
  .div {
    display: block;
  }
}
.div:hover {
  display: flex;
}
.div:active {
  display: inline;
}
.div .nested-selector {
  display: grid;
}
.div .nested-selector:hover {
  display: block;
}
.div.nested-selector:active {
  display: inline-block;
}
</style>
          <div>Hello world</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > onEvent 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-embed\\")
export default class Embed extends LitElement {
  createRenderRoot() {
    return this;
  }

  @query('[ref=\\"elem\\"]')
  elem!: HTMLElement;

  foo(event) {
    console.log(\\"test2\\");
  }

  connectedCallback() {
    this.elem.dispatchEvent(new CustomEvent(\\"initEditingBldr\\"));
  }

  render() {
    return html\`

          <div ref=\\"elem\\"><div>Test</div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > onInit & onMount 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"on-init\\")
export default class OnInit extends LitElement {
  createRenderRoot() {
    return this;
  }

  connectedCallback() {
    console.log(\\"onMount\\");
  }

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > onInit 1`] = `
"export const defaultValues = {
  name: \\"PatrickJS\\",
};

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

type Props = {
  name: string;
};

@customElement(\\"on-init\\")
export default class OnInit extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() name: any;

  @state() name = \\"\\";

  render() {
    return html\`

          <div>Default name defined by parent \${this.name}</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > onInitPlain 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"on-init-plain\\")
export default class OnInitPlain extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > onMount 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-comp\\")
export default class Comp extends LitElement {
  createRenderRoot() {
    return this;
  }

  connectedCallback() {
    console.log(\\"Runs on mount\\");
  }
  disconnectedCallback() {
    console.log(\\"Runs on unMount\\");
  }

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > onMountMultiple 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-comp\\")
export default class Comp extends LitElement {
  createRenderRoot() {
    return this;
  }

  connectedCallback() {
    const onMountHook_0 = () => {
      console.log(\\"Runs on mount\\");
    };

    onMountHook_0();

    const onMountHook_1 = () => {
      console.log(\\"Another one runs on Mount\\");
    };

    onMountHook_1();

    const onMountHook_2 = () => {
      console.log(\\"SSR runs on Mount\\");
    };

    onMountHook_2();
  }

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > onUpdate 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"on-update\\")
export default class OnUpdate extends LitElement {
  createRenderRoot() {
    return this;
  }

  updated() {
    console.log(\\"Runs on every update/rerender\\");
  }

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > onUpdateWithDeps 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

type Props = {
  size: string;
};

@customElement(\\"on-update-with-deps\\")
export default class OnUpdateWithDeps extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() size: any;

  @state() a = \\"a\\";
  @state() b = \\"b\\";

  updated() {
    console.log(\\"Runs when a, b or size changes\\", this.a, this.b, this.size);
  }

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > preserveExportOrLocalStatement 1`] = `
"const b = 3;
const foo = () => {};
export const a = 3;
export const bar = () => {};
export function run<T>(value: T) {}

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

type Types = {
  s: any[];
};
interface IPost {
  len: number;
}
export interface MyBasicComponentProps {
  id: string;
}

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > preserveTyping 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export type A = \\"test\\";
export interface C {
  n: \\"test\\";
}
type B = \\"test2\\";
interface D {
  n: \\"test\\";
}
export interface MyBasicComponentProps {
  name: string;
  age?: number;
}

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() name: any;

  render() {
    return html\`

          <div>Hello! I can run in React, Vue, Solid, or Liquid! \${this.name}</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > propsDestructure 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

type Props = {
  children: any;
  type: string;
};

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() children: any;
  @property() type: any;

  @state() name = \\"Decadef20\\";

  render() {
    return html\`

          <div>
          \${this.children} \${this.type} Hello! I can run in React, Vue, Solid, or
          Liquid!
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > propsInterface 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

interface Person {
  name: string;
  age?: number;
}

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() name: any;

  render() {
    return html\`

          <div>Hello! I can run in React, Vue, Solid, or Liquid! \${this.name}</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > propsType 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

type Person = {
  name: string;
  age?: number;
};

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() name: any;

  render() {
    return html\`

          <div>Hello! I can run in React, Vue, Solid, or Liquid! \${this.name}</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > referencingFunInsideHook 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"on-update\\")
export default class OnUpdate extends LitElement {
  createRenderRoot() {
    return this;
  }

  foo = function foo(params) {};
  bar = function bar() {};
  zoo = function zoo() {
    const params = {
      cb: this.bar,
    };
  };

  updated() {
    this.foo({
      someOption: this.bar,
    });
  }

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > renderBlock 1`] = `
"import { TARGET } from \\"../../constants/target.js\\";
import type {
  BuilderContextInterface,
  RegisteredComponent,
} from \\"../../context/types.js\\";
import { evaluate } from \\"../../functions/evaluate.js\\";
import { extractTextStyles } from \\"../../functions/extract-text-styles.js\\";
import { getBlockActions } from \\"../../functions/get-block-actions.js\\";
import { getBlockComponentOptions } from \\"../../functions/get-block-component-options.js\\";
import { getBlockProperties } from \\"../../functions/get-block-properties.js\\";
import { getBlockTag } from \\"../../functions/get-block-tag.js\\";
import { getProcessedBlock } from \\"../../functions/get-processed-block.js\\";
import { getReactNativeBlockStyles } from \\"../../functions/get-react-native-block-styles.js\\";
import type { BuilderBlock } from \\"../../types/builder-block.js\\";
import type { Nullable } from \\"../../types/typescript.js\\";
import \\"./block-styles.ts\\";
import { isEmptyHtmlElement } from \\"./render-block.helpers.js\\";
import RenderComponentWithContext from \\"./render-component-with-context.js\\";
import \\"./render-component.ts\\";
import \\"./render-component.ts\\";
import \\"./render-repeated-block.ts\\";
import type { RepeatData } from \\"./types.js\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export type RenderBlockProps = {
  block: BuilderBlock;
  context: BuilderContextInterface;
};

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"render-block\\")
export default class RenderBlock extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() block: any;
  @property() context: any;

  get component() {
    const componentName = getProcessedBlock({
      block: this.block,
      state: this.context.state,
      context: this.context.context,
      shouldEvaluateBindings: false,
    }).component?.name;

    if (!componentName) {
      return null;
    }

    const ref = this.context.registeredComponents[componentName];

    if (!ref) {
      // TODO: Public doc page with more info about this message
      console.warn(\`
          Could not find a registered component named \\"\${componentName}\\".
          If you registered it, is the file that registered it imported by the file that needs to render it?\`);
      return undefined;
    } else {
      return ref;
    }
  }
  get tag() {
    return getBlockTag(this.useBlock);
  }
  get useBlock() {
    return this.repeatItemData
      ? this.block
      : getProcessedBlock({
          block: this.block,
          state: this.context.state,
          context: this.context.context,
          shouldEvaluateBindings: true,
        });
  }
  get actions() {
    return getBlockActions({
      block: this.useBlock,
      state: this.context.state,
      context: this.context.context,
    });
  }
  get attributes() {
    const blockProperties = getBlockProperties(this.useBlock);
    return {
      ...blockProperties,
      ...(TARGET === \\"reactNative\\"
        ? {
            style: getReactNativeBlockStyles({
              block: this.useBlock,
              context: this.context,
              blockStyles: blockProperties.style,
            }),
          }
        : {}),
    };
  }
  get shouldWrap() {
    return !this.component?.noWrap;
  }
  get renderComponentProps() {
    return {
      blockChildren: this.useChildren,
      componentRef: this.component?.component,
      componentOptions: {
        ...getBlockComponentOptions(this.useBlock),

        /**
         * These attributes are passed to the wrapper element when there is one. If \`noWrap\` is set to true, then
         * they are provided to the component itself directly.
         */
        ...(this.shouldWrap
          ? {}
          : {
              attributes: { ...this.attributes, ...this.actions },
            }),
        customBreakpoints: this.childrenContext?.content?.meta?.breakpoints,
      },
      context: this.childrenContext,
    };
  }
  get useChildren() {
    // TO-DO: When should \`canHaveChildren\` dictate rendering?
    // This is currently commented out because some Builder components (e.g. Box) do not have \`canHaveChildren: true\`,
    // but still receive and need to render children.
    // return state.componentInfo?.canHaveChildren ? state.useBlock.children : [];
    return this.useBlock.children ?? [];
  }
  get childrenWithoutParentComponent() {
    /**
     * When there is no \`componentRef\`, there might still be children that need to be rendered. In this case,
     * we render them outside of \`componentRef\`.
     * NOTE: We make sure not to render this if \`repeatItemData\` is non-null, because that means we are rendering an array of
     * blocks, and the children will be repeated within those blocks.
     */
    const shouldRenderChildrenOutsideRef =
      !this.component?.component && !this.repeatItemData;
    return shouldRenderChildrenOutsideRef ? this.useChildren : [];
  }
  get repeatItemData() {
    /**
     * we don't use \`state.useBlock\` here because the processing done within its logic includes evaluating the block's bindings,
     * which will not work if there is a repeat.
     */
    const { repeat, ...blockWithoutRepeat } = this.block;

    if (!repeat?.collection) {
      return undefined;
    }

    const itemsArray = evaluate({
      code: repeat.collection,
      state: this.context.state,
      context: this.context.context,
    });

    if (!Array.isArray(itemsArray)) {
      return undefined;
    }

    const collectionName = repeat.collection.split(\\".\\").pop();
    const itemNameToUse =
      repeat.itemName || (collectionName ? collectionName + \\"Item\\" : \\"item\\");
    const repeatArray = itemsArray.map<RepeatData>((item, index) => ({
      context: {
        ...this.context,
        state: {
          ...this.context.state,
          $index: index,
          $item: item,
          [itemNameToUse]: item,
          [\`$\${itemNameToUse}Index\`]: index,
        },
      },
      block: blockWithoutRepeat,
    }));
    return repeatArray;
  }
  get inheritedTextStyles() {
    if (TARGET !== \\"reactNative\\") {
      return {};
    }

    const styles = getReactNativeBlockStyles({
      block: this.useBlock,
      context: this.context,
      blockStyles: this.attributes.style,
    });
    return extractTextStyles(styles);
  }
  get childrenContext() {
    return {
      apiKey: this.context.apiKey,
      state: this.context.state,
      content: this.context.content,
      context: this.context.context,
      registeredComponents: this.context.registeredComponents,
      inheritedStyles: this.inheritedTextStyles,
    };
  }
  get renderComponentTag() {
    if (TARGET === \\"reactNative\\") {
      return RenderComponentWithContext;
    } else if (TARGET === \\"vue3\\") {
      // vue3 expects a string for the component tag
      return \\"RenderComponent\\";
    } else {
      return RenderComponent;
    }
  }

  render() {
    return html\`

          \${
            this.shouldWrap
              ? html\`\${
                  isEmptyHtmlElement(this.tag)
                    ? html\`<state.tag  \${spread(state.attributes)}  \${spread(
                        state.actions
                      )} ></state.tag>\`
                    : null
                }
       \${
         !isEmptyHtmlElement(this.tag) && this.repeatItemData
           ? html\`\${this.repeatItemData?.map(
               (data, index) =>
                 html\`<render-repeated-block  .key=\${index}  .repeatContext=\${data.context}  .block=\${data.block} ></render-repeated-block>\`
             )}\`
           : null
       }
       \${
         !isEmptyHtmlElement(this.tag) && !this.repeatItemData
           ? html\`<state.tag  \${spread(state.attributes)}  \${spread(
               state.actions
             )} ><state.renderComponentTag  \${spread(
               state.renderComponentProps
             )} ></state.renderComponentTag>
        \${this.childrenWithoutParentComponent?.map(
          (child, index) =>
            html\`<render-block  .key=\${
              \\"render-block-\\" + child.id
            }  .block=\${child}  .context=\${
              this.childrenContext
            } ></render-block>\`
        )}
        \${this.childrenWithoutParentComponent?.map(
          (child, index) =>
            html\`<block-styles  .key=\${
              \\"block-style-\\" + child.id
            }  .block=\${child}  .context=\${
              this.childrenContext
            } ></block-styles>\`
        )}</state.tag>\`
           : null
       }\`
              : html\`<state.renderComponentTag  \${spread(
                  state.renderComponentProps
                )} ></state.renderComponentTag>\`
          }
        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > renderContentExample 1`] = `
"import BuilderContext from \\"@dummy/context.js\\";
import {
  dispatchNewContentToVisualEditor,
  sendComponentsToVisualEditor,
  trackClick,
} from \\"@dummy/injection-js\\";
import \\"@dummy/RenderBlocks.ts\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

type Props = {
  customComponents: string[];
  content: {
    blocks: any[];
    id: string;
  };
};

@customElement(\\"render-content\\")
export default class RenderContent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() customComponents: any;
  @property() content: any;

  connectedCallback() {
    sendComponentsToVisualEditor(this.customComponents);
  }

  updated() {
    dispatchNewContentToVisualEditor(this.content);
  }

  render() {
    return html\`
          <style>.div {
  display: flex;
  flex-direction: columns;
}
</style>
          <div  @click=\${(event) =>
            trackClick(this.content.id)} ><render-blocks  .blocks=\${
      this.content.blocks
    } ></render-blocks></div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > rootFragmentMultiNode 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export interface ButtonProps {
  attributes?: any;
  text?: string;
  link?: string;
  openLinkInNewTab?: boolean;
}

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"my-button\\")
export default class Button extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() link: any;
  @property() attributes: any;
  @property() openLinkInNewTab: any;
  @property() text: any;

  render() {
    return html\`

          <my-fragment >\${
            this.link
              ? html\`<a  \${spread(props.attributes)}  .href=\${
                  this.link
                }  .target=\${this.openLinkInNewTab ? \\"_blank\\" : undefined} >\${
                  this.text
                }</a>\`
              : null
          }
        \${
          !this.link
            ? html\`<button  type=\\"button\\"  \${spread(props.attributes)} >\${
                this.text
              }</button>\`
            : null
        }</my-fragment>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > rootShow 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export interface RenderStylesProps {
  foo: string;
}

@customElement(\\"render-styles\\")
export default class RenderStyles extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() foo: any;

  render() {
    return html\`

          \${
            this.foo === \\"bar\\"
              ? html\`
      <div>Bar</div>
      \`
              : html\`
      <div>Foo</div>
      \`
          }

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > self-referencing component 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() name: any;

  render() {
    return html\`

          <div>
          \${this.name} \${
      this.name === \\"Batman\\"
        ? html\`<my-component
        name=\\"Bruce Wayne\\"
      ></my-component
      >\`
        : null
    }
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > self-referencing component with children 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() name: any;
  @property() children: any;

  render() {
    return html\`

          <div>
          \${this.name} \${this.children} \${
      this.name === \\"Batman\\"
        ? html\`<my-component
        name=\\"Bruce\\"
        ><div>Wayne</div></my-component
      >\`
        : null
    }
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > setState 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"set-state\\")
export default class SetState extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() n = [\\"123\\"];

  someFn() {
    this.n[0] = \\"123\\";
  }

  render() {
    return html\`

          <div ><button  @click=\${(event) =>
            this.someFn()} >Click me</button></div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > showExpressions 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

interface Props {
  conditionA: boolean;
  conditionB: boolean;
}

@customElement(\\"show-with-other-values\\")
export default class ShowWithOtherValues extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() conditionA: any;
  @property() conditionB: any;
  @property() conditionC: any;

  render() {
    return html\`

          <div>
          \${this.conditionA ? html\`Content0\` : html\`ContentA\`} \${
      this.conditionA ? html\`ContentA\` : null
    } \${this.conditionA ? html\`\` : html\`ContentA\`}
          \${this.conditionA ? html\`ContentB\` : html\`\${undefined}\`} \${
      this.conditionA ? html\`\${undefined}\` : html\`ContentB\`
    } \${this.conditionA ? html\`ContentC\` : null} \${
      this.conditionA ? html\`\` : html\`ContentC\`
    } \${this.conditionA ? html\`ContentD\` : null} \${
      this.conditionA ? html\`\` : html\`ContentD\`
    }
          \${this.conditionA ? html\`ContentE\` : html\`hello\`} \${
      this.conditionA ? html\`hello\` : html\`ContentE\`
    } \${this.conditionA ? html\`ContentF\` : html\`123\`}
          \${this.conditionA ? html\`123\` : html\`ContentF\`} \${
      this.conditionA === \\"Default\\"
        ? html\`4mb\`
        : html\`\${this.conditionB === \\"Complete\\" ? html\`20mb\` : html\`9mb\`}\`
    } \${
      this.conditionA === \\"Default\\"
        ? html\`\${this.conditionB === \\"Complete\\" ? html\`20mb\` : html\`9mb\`}\`
        : html\`4mb\`
    } \${
      this.conditionA === \\"Default\\"
        ? html\`\${
            this.conditionB === \\"Complete\\"
              ? html\`
          <div>complete</div>
          \`
              : html\`9mb\`
          }\`
        : html\`\${
            this.conditionC === \\"Complete\\"
              ? html\`dff\`
              : html\`
          <div>complete else</div>
          \`
          }\`
    }
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > showWithFor 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

interface Props {
  conditionA: boolean;
  items: string[];
}

@customElement(\\"nested-show\\")
export default class NestedShow extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() conditionA: any;
  @property() items: any;

  render() {
    return html\`

          \${
            this.conditionA
              ? html\`\${this.items?.map(
                  (item, idx) => html\`
        <div .key=\\"\${idx}\\">\${item}</div>
        \`
                )}\`
              : html\`
      <div>else-condition-A</div>
      \`
          }

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > showWithOtherValues 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

interface Props {
  conditionA: boolean;
}

@customElement(\\"show-with-other-values\\")
export default class ShowWithOtherValues extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() conditionA: any;

  render() {
    return html\`

          <div>
          \${this.conditionA ? html\` ContentA \` : null} \${
      this.conditionA
        ? html\`
        ContentB \`
        : html\`\${undefined}\`
    } \${this.conditionA ? html\` ContentC \` : null}
          \${this.conditionA ? html\` ContentD \` : null} \${
      this.conditionA
        ? html\`
        ContentE \`
        : html\`hello\`
    } \${this.conditionA ? html\` ContentF \` : html\`123\`}
        </div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > showWithRootText 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

interface Props {
  conditionA: boolean;
}

@customElement(\\"show-root-text\\")
export default class ShowRootText extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() conditionA: any;

  render() {
    return html\`

          \${
            this.conditionA
              ? html\` ContentA \`
              : html\`
      <div>else-condition-A</div>
      \`
          }

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > signalsOnUpdate 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

type Props = {
  id: string;
  foo: {
    bar: {
      baz: number;
    };
  };
};

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() id: any;
  @property() foo: any;

  updated() {
    console.log(\\"props.id changed\\", this.id);
    console.log(\\"props.foo.value.bar.baz changed\\", this.foo.bar.baz);
  }

  render() {
    return html\`
          <style>.div {
  padding: 10px;
}
</style>
          <div>\${this.id} \${this.foo.bar.baz}</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > spreadAttrs 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <input \${spread(attrs)} />

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > spreadNestedProps 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() nested: any;

  render() {
    return html\`

          <input \${spread(props.nested)} />

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > spreadProps 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

const spread = (properties) =>
  directive((part) => {
    for (const property in properties) {
      const value = properties[attr];
      part.element[property] = value;
    }
  });

@customElement(\\"my-basic-component\\")
export default class MyBasicComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <input \${spread(props)} />

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > store-async-function 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"string-literal-store\\")
export default class StringLiteralStore extends LitElement {
  createRenderRoot() {
    return this;
  }

  arrowFunction = async function arrowFunction() {
    return Promise.resolve();
  };
  namedFunction = async function namedFunction() {
    return Promise.resolve();
  };
  fetchUsers = async function fetchUsers() {
    return Promise.resolve();
  };

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > string-literal-store 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"string-literal-store\\")
export default class StringLiteralStore extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() foo = 123;

  render() {
    return html\`

          <div>\${this.foo}</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > styleClassAndCss 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`
          <style>.div {
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
</style>
          <div  .style=\${{
            width: \\"100%\\",
          }} ></div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > stylePropClassAndCss 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"style-prop-class-and-css\\")
export default class StylePropClassAndCss extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() attributes: any;

  render() {
    return html\`
          <style>.div {
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
</style>
          <div  class={props.attributes.class + ' div'}  .style=\${this.attributes.style} ></div>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > subComponent 1`] = `
"import \\"./foo-sub-component.ts\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"sub-component\\")
export default class SubComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <my-foo></my-foo>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > svgComponent 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"svg-component\\")
export default class SvgComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <svg  fill=\\"none\\"  role=\\"img\\"  .viewBox=\${
            \\"0 0 \\" + 42 + \\" \\" + 42
          }  .width=\${42}  .height=\${42} ><defs ><filter  id=\\"prefix__filter0_f\\"  filterUnits=\\"userSpaceOnUse\\" ><feFlood  result=\\"BackgroundImageFix\\" ></feFlood>
        <feBlend  in=\\"SourceGraphic\\"  in2=\\"BackgroundImageFix\\"  result=\\"shape\\" ></feBlend>
        <feGaussianBlur  result=\\"effect1_foregroundBlur\\"  .stdDeviation=\${7} ></feGaussianBlur></filter></defs></svg>
        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > typeDependency 1`] = `
"import type { Foo } from \\"./foo-type\\";
import \\"./type-export.ts\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

export type TypeDependencyProps = {
  foo: Foo;
  foo2: Foo2;
};

@customElement(\\"type-dependency\\")
export default class TypeDependency extends LitElement {
  createRenderRoot() {
    return this;
  }

  @property() foo: any;

  render() {
    return html\`

          <div>\${this.foo}</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > typeExternalStore 1`] = `
"import { FooStore } from \\"./foo-store\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"type-external-store\\")
export default class TypeExternalStore extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() _name = \\"test\\";

  render() {
    return html\`

          <div>Hello \${this._name} !</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > typeGetterStore 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

type GetterStore = {
  getName: () => string;
  name: string;
  get test(): string;
};

@customElement(\\"type-getter-store\\")
export default class TypeGetterStore extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() name = \\"test\\";

  getName() {
    if (this.name === \\"a\\") {
      return \\"b\\";
    }

    return this.name;
  }
  get test() {
    return \\"test\\";
  }

  render() {
    return html\`

          <div>Hello \${this.name} !</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > use-style 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`
          <style>button {
  background: blue;
  color: white;
  font-size: 12px;
  outline: 1px solid black;
}
</style>
          <button type=\\"button\\">Button</button>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > use-style-and-css 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`
          <style>button {
  font-size: 12px;
  outline: 1px solid black;
}

.button {
  background: blue;
  color: white;
}
</style>
          <button type=\\"button\\">Button</button>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > use-style-outside-component 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`
          <style>button {
  background: blue;
  color: white;
  font-size: 12px;
  outline: 1px solid black;
}
</style>
          <button type=\\"button\\">Button</button>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > useTarget 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"use-target-component\\")
export default class UseTargetComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() lastName = \\"bar\\";
  @state() foo = \\"bar\\";

  get name() {
    const prefix = \\"li\\";
    return prefix + \\"foo\\";
  }

  connectedCallback() {
    console.log(this.foo);
    this.foo = \\"bar\\";
  }

  render() {
    return html\`

          <div>\${this.name}</div>

        \`;
  }
}
"
`;

exports[`Lit > jsx > Typescript Test > webComponent 1`] = `
"import { register } from \\"swiper/element/bundle\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-basic-web-component\\")
export default class MyBasicWebComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <swiper-container slides-per-view=\\"3\\" navigation=\\"true\\" pagination=\\"true\\"
          ><swiper-slide>Slide 1</swiper-slide>
          <swiper-slide>Slide 2</swiper-slide>
          <swiper-slide>Slide 3</swiper-slide></swiper-container
        >

        \`;
  }
}
"
`;

exports[`Lit > svelte > Javascript Test > basic 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() name = \\"Steve\\";

  render() {
    return html\`

          <div>
          <input @change=\${(event) => (this.name = event.target.value)}
          .value=\${
            this.name
          } /> Hello! I can run in React, Vue, Solid, or Liquid!
        </div>

        \`;
  }
}
"
`;

exports[`Lit > svelte > Javascript Test > bindGroup 1`] = `
"import { LitElement, html, css } from 'lit';
import { customElement, property, state, query } from 'lit/decorators.js';




@customElement('my-component')
export default class MyComponent extends LitElement {

    createRenderRoot() {
      return this;
    }









    @state()  tortilla= \\"Plain\\"
@state()  fillings= []







  render() {
    return html\`

          <div>
          <input type=\\"radio\\" value=\\"Plain\\" .checked=\${this.tortilla === 'Plain'}
          @change=\${(event) => this.tortilla = event.target.value} /> <input
          type=\\"radio\\" value=\\"Whole wheat\\" .checked=\${this.tortilla === 'Whole wheat'}
          @change=\${(event) => this.tortilla = event.target.value} /> <input
          type=\\"radio\\" value=\\"Spinach\\" .checked=\${this.tortilla === 'Spinach'}
          @change=\${(event) => this.tortilla = event.target.value} />
          <br />
          <br />
          <input type=\\"checkbox\\" value=\\"Rice\\" .checked=\${this.fillings === 'Rice'}
          @change=\${(event) => this.fillings = event.target.value} /> <input
          type=\\"checkbox\\" value=\\"Beans\\" .checked=\${this.fillings === 'Beans'}
          @change=\${(event) => this.fillings = event.target.value} /> <input
          type=\\"checkbox\\" value=\\"Cheese\\" .checked=\${this.fillings === 'Cheese'}
          @change=\${(event) => this.fillings = event.target.value} /> <input
          type=\\"checkbox\\" value=\\"Guac (extra)\\" .checked=\${this.fillings === 'Guac
          (extra)'} @change=\${(event) => this.fillings = event.target.value} />
          <p>Tortilla: \${this.tortilla}</p>
          <p>Fillings: \${this.fillings}</p>
        </div>

        \`
  }
}"
`;

exports[`Lit > svelte > Javascript Test > bindProperty 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() value = \\"hello\\";

  render() {
    return html\`

          <input .value=\\"\${this.value}\\" />

        \`;
  }
}
"
`;

exports[`Lit > svelte > Javascript Test > classDirective 1`] = `
"import { LitElement, html, css } from 'lit';
import { customElement, property, state, query } from 'lit/decorators.js';




@customElement('my-component')
export default class MyComponent extends LitElement {

    createRenderRoot() {
      return this;
    }







  @property() disabled: any

    @state()  focus= true







  render() {
    return html\`

          <input class={\`form-input \${props.disabled ? 'disabled' : ''} \${state.focus ?
    'focus' : ''}\`} />

        \`
  }
}"
`;

exports[`Lit > svelte > Javascript Test > context 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() activeTab = 0;

  render() {
    return html\`

          <div>\${this.activeTab}</div>

        \`;
  }
}
"
`;

exports[`Lit > svelte > Javascript Test > each 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() numbers = [\\"one\\", \\"two\\", \\"three\\"];

  render() {
    return html\`

          <ul>
          \${this.numbers?.map(
            (num, index) => html\`
      <li>\${num}</li>
      \`
          )}
        </ul>

        \`;
  }
}
"
`;

exports[`Lit > svelte > Javascript Test > eventHandlers 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  log = function log(msg = \\"hello\\") {
    console.log(msg);
  };

  render() {
    return html\`

          <div ><button  @click=\${(a) => this.log(\\"hi\\")} >Log</button>
        <button  @click=\${(event) => this.log(event)} >Log</button>
        <button  @click=\${(event) => this.log(event)} >Log</button></div>
        \`;
  }
}
"
`;

exports[`Lit > svelte > Javascript Test > html 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() html = \\"<b>bold</b>\\";

  render() {
    return html\`

          <div .innerHTML=\\"\${this.html}\\"></div>

        \`;
  }
}
"
`;

exports[`Lit > svelte > Javascript Test > ifElse 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() show = true;

  toggle = function toggle() {
    this.show = !this.show;
  };

  render() {
    return html\`

          \${
            this.show
              ? html\`<button  @click=\${(event) =>
                  this.toggle(event)} > Hide </button>\`
              : html\`<button  @click=\${(event) =>
                  this.toggle(event)} > Show </button>\`
          }
        \`;
  }
}
"
`;

exports[`Lit > svelte > Javascript Test > imports 1`] = `
"import \\"./Button.ts\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() disabled = false;

  render() {
    return html\`

          <div>
          <my-button type=\\"button\\" .disabled=\\"\${this.disabled}\\"
            ><my-slot></my-slot
          ></my-button>
        </div>

        \`;
  }
}
"
`;

exports[`Lit > svelte > Javascript Test > lifecycleHooks 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  connectedCallback() {
    console.log(\\"onMount\\");
  }
  disconnectedCallback() {
    console.log(\\"onDestroy\\");
  }
  updated() {
    console.log(\\"onAfterUpdate\\");
  }

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > svelte > Javascript Test > reactive 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() name = \\"Steve\\";

  get lowercaseName() {
    return this.name.toLowerCase();
  }

  render() {
    return html\`

          <div>
          <input .value=\\"\${this.name}\\" />

          Lowercase: \${this.lowercaseName}
        </div>

        \`;
  }
}
"
`;

exports[`Lit > svelte > Javascript Test > reactiveWithFn 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() a = 2;
  @state() b = 5;
  @state() result = null;

  calculateResult = function calculateResult(a_, b_) {
    this.result = a_ * b_;
  };

  updated() {
    this.calculateResult(this.a, this.b);
  }

  render() {
    return html\`

          <div>
          <input type=\\"number\\" @change=\${(event) =>
            (this.a = event.target.value)}
          .value=\${this.a} /> <input type=\\"number\\" @change=\${(event) =>
      (this.b = event.target.value)} .value=\${this.b} /> Result: \${this.result}
        </div>

        \`;
  }
}
"
`;

exports[`Lit > svelte > Javascript Test > slots 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <div>
          <my-slot>default</my-slot> <my-slot name=\\"Test\\"><div>default</div></my-slot>
        </div>

        \`;
  }
}
"
`;

exports[`Lit > svelte > Javascript Test > style 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`
          <style>input {
  color: red;
  font-size: 12px;
}

.form-input:focus {
  outline: 1px solid blue;
}
</style>
          <input />

        \`;
  }
}
"
`;

exports[`Lit > svelte > Javascript Test > textExpressions 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() a = 5;
  @state() b = 12;

  render() {
    return html\`

          <div>
          normal: \${this.a + this.b}
          <br />

          conditional \${this.a > 2 ? \\"hello\\" : \\"bye\\"}
        </div>

        \`;
  }
}
"
`;

exports[`Lit > svelte > Typescript Test > basic 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() name = \\"Steve\\";

  render() {
    return html\`

          <div>
          <input @change=\${(event) => (this.name = event.target.value)}
          .value=\${
            this.name
          } /> Hello! I can run in React, Vue, Solid, or Liquid!
        </div>

        \`;
  }
}
"
`;

exports[`Lit > svelte > Typescript Test > bindGroup 1`] = `
"import { LitElement, html, css } from 'lit';
import { customElement, property, state, query } from 'lit/decorators.js';




@customElement('my-component')
export default class MyComponent extends LitElement {

    createRenderRoot() {
      return this;
    }









    @state()  tortilla= \\"Plain\\"
@state()  fillings= []







  render() {
    return html\`

          <div>
          <input type=\\"radio\\" value=\\"Plain\\" .checked=\${this.tortilla === 'Plain'}
          @change=\${(event) => this.tortilla = event.target.value} /> <input
          type=\\"radio\\" value=\\"Whole wheat\\" .checked=\${this.tortilla === 'Whole wheat'}
          @change=\${(event) => this.tortilla = event.target.value} /> <input
          type=\\"radio\\" value=\\"Spinach\\" .checked=\${this.tortilla === 'Spinach'}
          @change=\${(event) => this.tortilla = event.target.value} />
          <br />
          <br />
          <input type=\\"checkbox\\" value=\\"Rice\\" .checked=\${this.fillings === 'Rice'}
          @change=\${(event) => this.fillings = event.target.value} /> <input
          type=\\"checkbox\\" value=\\"Beans\\" .checked=\${this.fillings === 'Beans'}
          @change=\${(event) => this.fillings = event.target.value} /> <input
          type=\\"checkbox\\" value=\\"Cheese\\" .checked=\${this.fillings === 'Cheese'}
          @change=\${(event) => this.fillings = event.target.value} /> <input
          type=\\"checkbox\\" value=\\"Guac (extra)\\" .checked=\${this.fillings === 'Guac
          (extra)'} @change=\${(event) => this.fillings = event.target.value} />
          <p>Tortilla: \${this.tortilla}</p>
          <p>Fillings: \${this.fillings}</p>
        </div>

        \`
  }
}"
`;

exports[`Lit > svelte > Typescript Test > bindProperty 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() value = \\"hello\\";

  render() {
    return html\`

          <input .value=\\"\${this.value}\\" />

        \`;
  }
}
"
`;

exports[`Lit > svelte > Typescript Test > classDirective 1`] = `
"import { LitElement, html, css } from 'lit';
import { customElement, property, state, query } from 'lit/decorators.js';




@customElement('my-component')
export default class MyComponent extends LitElement {

    createRenderRoot() {
      return this;
    }







  @property() disabled: any

    @state()  focus= true







  render() {
    return html\`

          <input class={\`form-input \${props.disabled ? 'disabled' : ''} \${state.focus ?
    'focus' : ''}\`} />

        \`
  }
}"
`;

exports[`Lit > svelte > Typescript Test > context 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() activeTab = 0;

  render() {
    return html\`

          <div>\${this.activeTab}</div>

        \`;
  }
}
"
`;

exports[`Lit > svelte > Typescript Test > each 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() numbers = [\\"one\\", \\"two\\", \\"three\\"];

  render() {
    return html\`

          <ul>
          \${this.numbers?.map(
            (num, index) => html\`
      <li>\${num}</li>
      \`
          )}
        </ul>

        \`;
  }
}
"
`;

exports[`Lit > svelte > Typescript Test > eventHandlers 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  log = function log(msg = \\"hello\\") {
    console.log(msg);
  };

  render() {
    return html\`

          <div ><button  @click=\${(a) => this.log(\\"hi\\")} >Log</button>
        <button  @click=\${(event) => this.log(event)} >Log</button>
        <button  @click=\${(event) => this.log(event)} >Log</button></div>
        \`;
  }
}
"
`;

exports[`Lit > svelte > Typescript Test > html 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() html = \\"<b>bold</b>\\";

  render() {
    return html\`

          <div .innerHTML=\\"\${this.html}\\"></div>

        \`;
  }
}
"
`;

exports[`Lit > svelte > Typescript Test > ifElse 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() show = true;

  toggle = function toggle() {
    this.show = !this.show;
  };

  render() {
    return html\`

          \${
            this.show
              ? html\`<button  @click=\${(event) =>
                  this.toggle(event)} > Hide </button>\`
              : html\`<button  @click=\${(event) =>
                  this.toggle(event)} > Show </button>\`
          }
        \`;
  }
}
"
`;

exports[`Lit > svelte > Typescript Test > imports 1`] = `
"import \\"./Button.ts\\";

import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() disabled = false;

  render() {
    return html\`

          <div>
          <my-button type=\\"button\\" .disabled=\\"\${this.disabled}\\"
            ><my-slot></my-slot
          ></my-button>
        </div>

        \`;
  }
}
"
`;

exports[`Lit > svelte > Typescript Test > lifecycleHooks 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  connectedCallback() {
    console.log(\\"onMount\\");
  }
  disconnectedCallback() {
    console.log(\\"onDestroy\\");
  }
  updated() {
    console.log(\\"onAfterUpdate\\");
  }

  render() {
    return html\`

          <div></div>

        \`;
  }
}
"
`;

exports[`Lit > svelte > Typescript Test > reactive 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() name = \\"Steve\\";

  get lowercaseName() {
    return this.name.toLowerCase();
  }

  render() {
    return html\`

          <div>
          <input .value=\\"\${this.name}\\" />

          Lowercase: \${this.lowercaseName}
        </div>

        \`;
  }
}
"
`;

exports[`Lit > svelte > Typescript Test > reactiveWithFn 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() a = 2;
  @state() b = 5;
  @state() result = null;

  calculateResult = function calculateResult(a_, b_) {
    this.result = a_ * b_;
  };

  updated() {
    this.calculateResult(this.a, this.b);
  }

  render() {
    return html\`

          <div>
          <input type=\\"number\\" @change=\${(event) =>
            (this.a = event.target.value)}
          .value=\${this.a} /> <input type=\\"number\\" @change=\${(event) =>
      (this.b = event.target.value)} .value=\${this.b} /> Result: \${this.result}
        </div>

        \`;
  }
}
"
`;

exports[`Lit > svelte > Typescript Test > slots 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`

          <div>
          <my-slot>default</my-slot> <my-slot name=\\"Test\\"><div>default</div></my-slot>
        </div>

        \`;
  }
}
"
`;

exports[`Lit > svelte > Typescript Test > style 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  render() {
    return html\`
          <style>input {
  color: red;
  font-size: 12px;
}

.form-input:focus {
  outline: 1px solid blue;
}
</style>
          <input />

        \`;
  }
}
"
`;

exports[`Lit > svelte > Typescript Test > textExpressions 1`] = `
"import { LitElement, html, css } from \\"lit\\";
import { customElement, property, state, query } from \\"lit/decorators.js\\";

@customElement(\\"my-component\\")
export default class MyComponent extends LitElement {
  createRenderRoot() {
    return this;
  }

  @state() a = 5;
  @state() b = 12;

  render() {
    return html\`

          <div>
          normal: \${this.a + this.b}
          <br />

          conditional \${this.a > 2 ? \\"hello\\" : \\"bye\\"}
        </div>

        \`;
  }
}
"
`;
