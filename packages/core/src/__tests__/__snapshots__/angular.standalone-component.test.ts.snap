// Vitest Snapshot v1

exports[`Angular standalone component > Standalone option should prevent NgModule generation in basic components 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component } from \\"@angular/core\\";

export const DEFAULT_VALUES = {
  name: \\"Steve\\",
};

@Component({
  selector: \\"my-basic-component, MyBasicComponent\\",
  template: \`
    <div class=\\"test div\\">
      <input
        [attr.value]=\\"DEFAULT_VALUES.name || name\\"
        (input)=\\"name = $event.target.value\\"
      />

      Hello! I can run in React, Vue, Solid, or Liquid!
    </div>
  \`,
  styles: [
    \`
      .div {
        padding: 10px;
      }
    \`,
  ],
})
export class MyBasicComponent {
  DEFAULT_VALUES = DEFAULT_VALUES;

  name = \\"Steve\\";
  underscore_fn_name() {
    return \\"bar\\";
  }
  age = 1;
  sports = [\\"\\"];
}

@NgModule({
  declarations: [MyBasicComponent],
  imports: [CommonModule],
  exports: [MyBasicComponent],
})
export class MyBasicComponentModule {}
"
`;

exports[`Angular standalone component > Standalone option should prevent NgModule generation in basic components 2`] = `
"import { Component } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

export const DEFAULT_VALUES = {
  name: \\"Steve\\",
};

@Component({
  selector: \\"my-basic-component, MyBasicComponent\\",
  template: \`
    <div class=\\"test div\\">
      <input
        [attr.value]=\\"DEFAULT_VALUES.name || name\\"
        (input)=\\"name = $event.target.value\\"
      />

      Hello! I can run in React, Vue, Solid, or Liquid!
    </div>
  \`,
  styles: [
    \`
      .div {
        padding: 10px;
      }
    \`,
  ],
  standalone: true,
  imports: [CommonModule],
})
export class MyBasicComponent {
  DEFAULT_VALUES = DEFAULT_VALUES;

  name = \\"Steve\\";
  underscore_fn_name() {
    return \\"bar\\";
  }
  age = 1;
  sports = [\\"\\"];
}
"
`;

exports[`Angular standalone component > Standalone option should prevent NgModule generation in complex components 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component, Input } from \\"@angular/core\\";

import { getBlockActions } from \\"../../functions/get-block-actions.js\\";
import { getBlockComponentOptions } from \\"../../functions/get-block-component-options.js\\";
import { getBlockProperties } from \\"../../functions/get-block-properties.js\\";
import { getBlockTag } from \\"../../functions/get-block-tag.js\\";
import { getProcessedBlock } from \\"../../functions/get-processed-block.js\\";
import { evaluate } from \\"../../functions/evaluate.js\\";
import { isEmptyHtmlElement } from \\"./render-block.helpers.js\\";
import { TARGET } from \\"../../constants/target.js\\";
import { extractTextStyles } from \\"../../functions/extract-text-styles.js\\";
import { getReactNativeBlockStyles } from \\"../../functions/get-react-native-block-styles.js\\";

@Component({
  selector: \\"render-block, RenderBlock\\",
  template: \`
    <ng-container *ngIf=\\"shouldWrap\\">
      <ng-container *ngIf=\\"isEmptyHtmlElement(tag)\\">
        <state.tag></state.tag>
      </ng-container>

      <ng-container *ngIf=\\"!isEmptyHtmlElement(tag) && repeatItemData\\">
        <ng-container *ngFor=\\"let data of repeatItemData; let index = index\\">
          <render-repeated-block
            [key]=\\"index\\"
            [repeatContext]=\\"data.context\\"
            [block]=\\"data.block\\"
          ></render-repeated-block>
        </ng-container>
      </ng-container>

      <ng-container *ngIf=\\"!isEmptyHtmlElement(tag) && !repeatItemData\\">
        <state.tag>
          <state.renderComponentTag></state.renderComponentTag>

          <ng-container *ngFor=\\"let child of childrenWithoutParentComponent\\">
            <RenderBlock
              [key]=\\"'render-block-' + child.id\\"
              [block]=\\"child\\"
              [context]=\\"childrenContext\\"
            ></RenderBlock>
          </ng-container>

          <ng-container *ngFor=\\"let child of childrenWithoutParentComponent\\">
            <block-styles
              [key]=\\"'block-style-' + child.id\\"
              [block]=\\"child\\"
              [context]=\\"childrenContext\\"
            ></block-styles>
          </ng-container>
        </state.tag>
      </ng-container>
    </ng-container>
  \`,
})
export class RenderBlock {
  isEmptyHtmlElement = isEmptyHtmlElement;

  @Input() block: any;
  @Input() context: any;

  get component() {
    const componentName = getProcessedBlock({
      block: this.block,
      this: this.context.state,
      context: this.context.context,
      shouldEvaluateBindings: false,
    }).component?.name;

    if (!componentName) {
      return null;
    }

    const ref = this.context.registeredComponents[componentName];

    if (!ref) {
      // TODO: Public doc page with more info about this message
      console.warn(\`
          Could not find a registered this.component named \\"\${componentName}\\".
          If you registered it, is the file that registered it imported by the file that needs to render it?\`);
      return undefined;
    } else {
      return ref;
    }
  }
  get tag() {
    return getBlockTag(this.useBlock);
  }
  get useBlock() {
    return this.repeatItemData
      ? this.block
      : getProcessedBlock({
          block: this.block,
          this: this.context.state,
          context: this.context.context,
          shouldEvaluateBindings: true,
        });
  }
  get actions() {
    return getBlockActions({
      block: this.useBlock,
      this: this.context.state,
      context: this.context.context,
    });
  }
  get attributes() {
    const blockProperties = getBlockProperties(this.useBlock);
    return {
      ...blockProperties,
      ...(TARGET === \\"reactNative\\"
        ? {
            style: getReactNativeBlockStyles({
              block: this.useBlock,
              context: this.context,
              blockStyles: blockProperties.style,
            }),
          }
        : {}),
    };
  }
  get shouldWrap() {
    return !this.component?.noWrap;
  }
  get renderComponentProps() {
    return {
      blockChildren: this.useChildren,
      componentRef: this.component?.component,
      componentOptions: {
        ...getBlockComponentOptions(this.useBlock),

        /**
         * These this.attributes are passed to the wrapper element when there is one. If \`noWrap\` is set to true, then
         * they are provided to the this.component itself directly.
         */
        ...(this.shouldWrap
          ? {}
          : {
              attributes: { ...this.attributes, ...this.actions },
            }),
        customBreakpoints: this.childrenContext?.content?.meta?.breakpoints,
      },
      context: this.childrenContext,
    };
  }
  get useChildren() {
    // TO-DO: When should \`canHaveChildren\` dictate rendering?
    // This is currently commented out because some Builder components (e.g. Box) do not have \`canHaveChildren: true\`,
    // but still receive and need to render children.
    // return state.componentInfo?.canHaveChildren ? state.useBlock.children : [];
    return this.useBlock.children ?? [];
  }
  get childrenWithoutParentComponent() {
    /**
     * When there is no \`componentRef\`, there might still be children that need to be rendered. In this case,
     * we render them outside of \`componentRef\`.
     * NOTE: We make sure not to render this if \`repeatItemData\` is non-null, because that means we are rendering an array of
     * blocks, and the children will be repeated within those blocks.
     */
    const shouldRenderChildrenOutsideRef =
      !this.component?.component && !this.repeatItemData;
    return shouldRenderChildrenOutsideRef ? this.useChildren : [];
  }
  get repeatItemData() {
    /**
     * we don't use \`state.useBlock\` here because the processing done within its logic includes evaluating the block's bindings,
     * which will not work if there is a repeat.
     */
    const { repeat, ...blockWithoutRepeat } = this.block;

    if (!repeat?.collection) {
      return undefined;
    }

    const itemsArray = evaluate({
      code: repeat.collection,
      this: this.context.state,
      context: this.context.context,
    });

    if (!Array.isArray(itemsArray)) {
      return undefined;
    }

    const collectionName = repeat.collection.split(\\".\\").pop();
    const itemNameToUse =
      repeat.itemName || (collectionName ? collectionName + \\"Item\\" : \\"item\\");
    const repeatArray = itemsArray.map((item, index) => ({
      context: {
        ...this.context,
        this: {
          ...this.context.state,
          $index: index,
          $item: item,
          [itemNameToUse]: item,
          [\`$\${itemNameToUse}Index\`]: index,
        },
      },
      block: blockWithoutRepeat,
    }));
    return repeatArray;
  }
  get inheritedTextStyles() {
    if (TARGET !== \\"reactNative\\") {
      return {};
    }

    const styles = getReactNativeBlockStyles({
      block: this.useBlock,
      context: this.context,
      blockStyles: this.attributes.style,
    });
    return extractTextStyles(styles);
  }
  get childrenContext() {
    return {
      apiKey: this.context.apiKey,
      this: this.context.state,
      content: this.context.content,
      context: this.context.context,
      registeredComponents: this.context.registeredComponents,
      inheritedStyles: this.inheritedTextStyles,
    };
  }
  get renderComponentTag() {
    if (TARGET === \\"reactNative\\") {
      return RenderComponentWithContext;
    } else if (TARGET === \\"vue3\\") {
      // vue3 expects a string for the this.component tag
      return \\"RenderComponent\\";
    } else {
      return RenderComponent;
    }
  }
}

@NgModule({
  declarations: [RenderBlock],
  imports: [
    CommonModule,
    RenderRepeatedBlockModule,
    RenderBlockModule,
    BlockStylesModule,
  ],
  exports: [RenderBlock],
})
export class RenderBlockModule {}
"
`;

exports[`Angular standalone component > Standalone option should prevent NgModule generation in complex components 2`] = `
"import { Component, Input } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { getBlockActions } from \\"../../functions/get-block-actions.js\\";
import { getBlockComponentOptions } from \\"../../functions/get-block-component-options.js\\";
import { getBlockProperties } from \\"../../functions/get-block-properties.js\\";
import { getBlockTag } from \\"../../functions/get-block-tag.js\\";
import { getProcessedBlock } from \\"../../functions/get-processed-block.js\\";
import { evaluate } from \\"../../functions/evaluate.js\\";
import BlockStyles from \\"./block-styles\\";
import { isEmptyHtmlElement } from \\"./render-block.helpers.js\\";
import RenderRepeatedBlock from \\"./render-repeated-block\\";
import { TARGET } from \\"../../constants/target.js\\";
import { extractTextStyles } from \\"../../functions/extract-text-styles.js\\";
import RenderComponentWithContext from \\"./render-component-with-context\\";
import RenderComponent from \\"./render-component\\";
import { getReactNativeBlockStyles } from \\"../../functions/get-react-native-block-styles.js\\";

@Component({
  selector: \\"render-block, RenderBlock\\",
  template: \`
    <ng-container *ngIf=\\"shouldWrap\\">
      <ng-container *ngIf=\\"isEmptyHtmlElement(tag)\\">
        <state.tag></state.tag>
      </ng-container>

      <ng-container *ngIf=\\"!isEmptyHtmlElement(tag) && repeatItemData\\">
        <ng-container *ngFor=\\"let data of repeatItemData; let index = index\\">
          <render-repeated-block
            [key]=\\"index\\"
            [repeatContext]=\\"data.context\\"
            [block]=\\"data.block\\"
          ></render-repeated-block>
        </ng-container>
      </ng-container>

      <ng-container *ngIf=\\"!isEmptyHtmlElement(tag) && !repeatItemData\\">
        <state.tag>
          <state.renderComponentTag></state.renderComponentTag>

          <ng-container *ngFor=\\"let child of childrenWithoutParentComponent\\">
            <RenderBlock
              [key]=\\"'render-block-' + child.id\\"
              [block]=\\"child\\"
              [context]=\\"childrenContext\\"
            ></RenderBlock>
          </ng-container>

          <ng-container *ngFor=\\"let child of childrenWithoutParentComponent\\">
            <block-styles
              [key]=\\"'block-style-' + child.id\\"
              [block]=\\"child\\"
              [context]=\\"childrenContext\\"
            ></block-styles>
          </ng-container>
        </state.tag>
      </ng-container>
    </ng-container>
  \`,
  standalone: true,
  imports: [CommonModule, RenderRepeatedBlock, RenderBlock, BlockStyles],
})
export class RenderBlock {
  isEmptyHtmlElement = isEmptyHtmlElement;

  @Input() block: any;
  @Input() context: any;

  get component() {
    const componentName = getProcessedBlock({
      block: this.block,
      this: this.context.state,
      context: this.context.context,
      shouldEvaluateBindings: false,
    }).component?.name;

    if (!componentName) {
      return null;
    }

    const ref = this.context.registeredComponents[componentName];

    if (!ref) {
      // TODO: Public doc page with more info about this message
      console.warn(\`
          Could not find a registered this.component named \\"\${componentName}\\".
          If you registered it, is the file that registered it imported by the file that needs to render it?\`);
      return undefined;
    } else {
      return ref;
    }
  }
  get tag() {
    return getBlockTag(this.useBlock);
  }
  get useBlock() {
    return this.repeatItemData
      ? this.block
      : getProcessedBlock({
          block: this.block,
          this: this.context.state,
          context: this.context.context,
          shouldEvaluateBindings: true,
        });
  }
  get actions() {
    return getBlockActions({
      block: this.useBlock,
      this: this.context.state,
      context: this.context.context,
    });
  }
  get attributes() {
    const blockProperties = getBlockProperties(this.useBlock);
    return {
      ...blockProperties,
      ...(TARGET === \\"reactNative\\"
        ? {
            style: getReactNativeBlockStyles({
              block: this.useBlock,
              context: this.context,
              blockStyles: blockProperties.style,
            }),
          }
        : {}),
    };
  }
  get shouldWrap() {
    return !this.component?.noWrap;
  }
  get renderComponentProps() {
    return {
      blockChildren: this.useChildren,
      componentRef: this.component?.component,
      componentOptions: {
        ...getBlockComponentOptions(this.useBlock),

        /**
         * These this.attributes are passed to the wrapper element when there is one. If \`noWrap\` is set to true, then
         * they are provided to the this.component itself directly.
         */
        ...(this.shouldWrap
          ? {}
          : {
              attributes: { ...this.attributes, ...this.actions },
            }),
        customBreakpoints: this.childrenContext?.content?.meta?.breakpoints,
      },
      context: this.childrenContext,
    };
  }
  get useChildren() {
    // TO-DO: When should \`canHaveChildren\` dictate rendering?
    // This is currently commented out because some Builder components (e.g. Box) do not have \`canHaveChildren: true\`,
    // but still receive and need to render children.
    // return state.componentInfo?.canHaveChildren ? state.useBlock.children : [];
    return this.useBlock.children ?? [];
  }
  get childrenWithoutParentComponent() {
    /**
     * When there is no \`componentRef\`, there might still be children that need to be rendered. In this case,
     * we render them outside of \`componentRef\`.
     * NOTE: We make sure not to render this if \`repeatItemData\` is non-null, because that means we are rendering an array of
     * blocks, and the children will be repeated within those blocks.
     */
    const shouldRenderChildrenOutsideRef =
      !this.component?.component && !this.repeatItemData;
    return shouldRenderChildrenOutsideRef ? this.useChildren : [];
  }
  get repeatItemData() {
    /**
     * we don't use \`state.useBlock\` here because the processing done within its logic includes evaluating the block's bindings,
     * which will not work if there is a repeat.
     */
    const { repeat, ...blockWithoutRepeat } = this.block;

    if (!repeat?.collection) {
      return undefined;
    }

    const itemsArray = evaluate({
      code: repeat.collection,
      this: this.context.state,
      context: this.context.context,
    });

    if (!Array.isArray(itemsArray)) {
      return undefined;
    }

    const collectionName = repeat.collection.split(\\".\\").pop();
    const itemNameToUse =
      repeat.itemName || (collectionName ? collectionName + \\"Item\\" : \\"item\\");
    const repeatArray = itemsArray.map((item, index) => ({
      context: {
        ...this.context,
        this: {
          ...this.context.state,
          $index: index,
          $item: item,
          [itemNameToUse]: item,
          [\`$\${itemNameToUse}Index\`]: index,
        },
      },
      block: blockWithoutRepeat,
    }));
    return repeatArray;
  }
  get inheritedTextStyles() {
    if (TARGET !== \\"reactNative\\") {
      return {};
    }

    const styles = getReactNativeBlockStyles({
      block: this.useBlock,
      context: this.context,
      blockStyles: this.attributes.style,
    });
    return extractTextStyles(styles);
  }
  get childrenContext() {
    return {
      apiKey: this.context.apiKey,
      this: this.context.state,
      content: this.context.content,
      context: this.context.context,
      registeredComponents: this.context.registeredComponents,
      inheritedStyles: this.inheritedTextStyles,
    };
  }
  get renderComponentTag() {
    if (TARGET === \\"reactNative\\") {
      return RenderComponentWithContext;
    } else if (TARGET === \\"vue3\\") {
      // vue3 expects a string for the this.component tag
      return \\"RenderComponent\\";
    } else {
      return RenderComponent;
    }
  }
}
"
`;

exports[`Angular standalone component > Standalone option should prevent NgModule generation in components with sub-components 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component } from \\"@angular/core\\";

@Component({
  selector: \\"sub-component, SubComponent\\",
  template: \`
    <foo></foo>
  \`,
})
export class SubComponent {}

@NgModule({
  declarations: [SubComponent],
  imports: [CommonModule, FooModule],
  exports: [SubComponent],
})
export class SubComponentModule {}
"
`;

exports[`Angular standalone component > Standalone option should prevent NgModule generation when used whith sub-components 1`] = `
"import { NgModule } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import { Component } from \\"@angular/core\\";

@Component({
  selector: \\"sub-component, SubComponent\\",
  template: \`
    <foo></foo>
  \`,
})
export class SubComponent {}

@NgModule({
  declarations: [SubComponent],
  imports: [CommonModule, FooModule],
  exports: [SubComponent],
})
export class SubComponentModule {}
"
`;

exports[`Angular standalone component > Standalone option should prevent NgModule generation when used whith sub-components 2`] = `
"import { Component } from \\"@angular/core\\";
import { CommonModule } from \\"@angular/common\\";

import Foo from \\"./foo-sub-component\\";

@Component({
  selector: \\"sub-component, SubComponent\\",
  template: \`
    <foo></foo>
  \`,
  standalone: true,
  imports: [CommonModule, Foo],
})
export class SubComponent {}
"
`;
