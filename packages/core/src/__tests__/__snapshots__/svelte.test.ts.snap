// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Svelte AdvancedRef 1`] = `
"<script lang=\\"ts\\">
  import { afterUpdate } from \\"svelte\\";

  export let showInput: boolean;

  function onBlur() {
    // Maintain focus
    inputRef.focus();
  }

  function lowerCaseName() {
    return name.toLowerCase();
  }

  let inputRef;
  let inputNoArgRef;

  let name = \\"PatrickJS\\";

  function onUpdateFn_0() {
    console.log(\\"Received an update\\");
  }
  $: onUpdateFn_0(...[inputRef, inputNoArgRef]);
</script>

<div>
  {#if showInput}
    <input
      class=\\"input\\"
      bind:this={inputRef}
      on:blur={(event) => {
        onBlur();
      }}
      bind:value={name}
    />

    <label for=\\"cars\\" bind:this={inputNoArgRef}> Choose a car: </label>

    <select name=\\"cars\\" id=\\"cars\\">
      <option value=\\"supra\\">GR Supra</option>
      <option value=\\"86\\">GR 86</option>
    </select>
  {/if}
  Hello
  {lowerCaseName()}! I can run in React, Qwik, Vue, Solid, or Web Component!
</div>

<style>
  .input {
    color: red;
  }
</style>
"
`;

exports[`Svelte Basic 1`] = `
"<script lang=\\"ts\\">
  export const DEFAULT_VALUES = {
    name: \\"Steve\\",
  };

  function underscore_fn_name() {
    return \\"bar\\";
  }

  let name = \\"Steve\\";
</script>

<div class=\\"test div\\">
  <input
    value={DEFAULT_VALUES.name || name}
    on:change={(myEvent) => {
      name = myEvent.target.value;
    }}
  />
  Hello! I can run in React, Vue, Solid, or Liquid!
</div>

<style>
  .div {
    padding: 10px;
  }
</style>
"
`;

exports[`Svelte Basic 2`] = `
"<script lang=\\"ts\\">
  let name = \\"PatrickJS\\";
  let names = [\\"Steve\\", \\"PatrickJS\\"];
</script>

<div>
  {#each names as person}
    {#if person === name}
      <input
        value={name}
        on:change={(event) => {
          name = event.target.value + \\" and \\" + person;
        }}
      />

      Hello
      {person}
      ! I can run in Qwik, Web Component, React, Vue, Solid, or Liquid!
    {/if}
  {/each}
</div>
"
`;

exports[`Svelte Basic Context 1`] = `
"<script lang=\\"ts\\">
  import { getContext, onMount, setContext } from \\"svelte\\";

  import { Injector, createInjector, MyService } from \\"@dummy/injection-js\\";

  let myService = getContext(MyService.key);
  setContext(Injector.key, undefined);

  function onChange() {
    const change = myService.method(\\"change\\");
    console.log(change);
  }

  let name = \\"PatrickJS\\";

  onMount(() => {
    const bye = myService.method(\\"hi\\");
    console.log(bye);
  });
</script>

<div>
  {myService.method(\\"hello\\") + name}
  Hello! I can run in React, Vue, Solid, or Liquid!
  <input on:change={onChange} />
</div>
"
`;

exports[`Svelte Basic OnMount Update 1`] = `
"<script lang=\\"ts\\">
  import { onMount } from \\"svelte\\";

  export let hi: string;
  export let bye: string;

  let name = \\"PatrickJS\\";
  let names = [\\"Steve\\", \\"PatrickJS\\"];

  onMount(() => {
    name = \\"PatrickJS onMount\\" + bye;
  });
</script>

<div>Hello {name}</div>
"
`;

exports[`Svelte Basic Outputs 1`] = `
"<script lang=\\"ts\\">
  import { onMount } from \\"svelte\\";

  export let onMessage;
  export let onEvent;
  export let message;

  let name = \\"PatrickJS\\";

  onMount(() => {
    onMessage(name);
    onEvent(message);
  });
</script>

<div />
"
`;

exports[`Svelte Basic Outputs Meta 1`] = `
"<script lang=\\"ts\\">
  import { onMount } from \\"svelte\\";

  export let onMessage;
  export let onEvent;
  export let message;

  let name = \\"PatrickJS\\";

  onMount(() => {
    onMessage(name);
    onEvent(message);
  });
</script>

<div />
"
`;

exports[`Svelte BasicChildComponent 1`] = `
"<script lang=\\"ts\\">
  import MyBasicComponent from \\"./basic.raw\\";
  import MyBasicOnMountUpdateComponent from \\"./basic-onMount-update.raw\\";

  let name = \\"Steve\\";
  let dev = \\"PatrickJS\\";
</script>

<div>
  <MyBasicComponent id={dev} />
  <div>
    <MyBasicOnMountUpdateComponent hi={name} bye={dev} />
  </div>
</div>
"
`;

exports[`Svelte BasicFor 1`] = `
"<script lang=\\"ts\\">
  import { onMount } from \\"svelte\\";

  let name = \\"PatrickJS\\";
  let names = [\\"Steve\\", \\"PatrickJS\\"];

  onMount(() => {
    console.log(\\"onMount code\\");
  });
</script>

<div>
  {#each names as person}
    <input
      value={name}
      on:change={(event) => {
        name = event.target.value + \\" and \\" + person;
      }}
    />

    Hello
    {person}
    ! I can run in Qwik, Web Component, React, Vue, Solid, or Liquid!
  {/each}
</div>
"
`;

exports[`Svelte BasicRef 1`] = `
"<script lang=\\"ts\\">
  export let showInput: boolean;

  function onBlur() {
    // Maintain focus
    inputRef.focus();
  }

  function lowerCaseName() {
    return name.toLowerCase();
  }

  let inputRef;
  let inputNoArgRef;

  let name = \\"PatrickJS\\";
</script>

<div>
  {#if showInput}
    <input
      class=\\"input\\"
      bind:this={inputRef}
      on:blur={(event) => {
        onBlur();
      }}
      bind:value={name}
    />

    <label for=\\"cars\\" bind:this={inputNoArgRef}> Choose a car: </label>

    <select name=\\"cars\\" id=\\"cars\\">
      <option value=\\"supra\\">GR Supra</option>
      <option value=\\"86\\">GR 86</option>
    </select>
  {/if}
  Hello
  {lowerCaseName()}! I can run in React, Qwik, Vue, Solid, or Web Component!
</div>

<style>
  .input {
    color: red;
  }
</style>
"
`;

exports[`Svelte BasicRefAssignment 1`] = `
"<script lang=\\"ts\\">
  function handlerClick(event) {
    event.preventDefault();
    console.log(\\"current value\\", holdValueRef);
    holdValueRef = holdValueRef + \\"JS\\";
  }
</script>

<div>
  <button
    on:click={(evt) => {
      handlerClick(evt);
    }}>Click</button
  >
</div>
"
`;

exports[`Svelte BasicRefPrevious 1`] = `
"<script lang=\\"ts\\">
  import { afterUpdate } from \\"svelte\\";

  export function usePrevious<T>(value: T) {
    // The ref object is a generic container whose current property is mutable ...
    // ... and can hold any value, similar to an instance property on a class
    let ref = useRef<T>(null); // Store current value in ref

    onUpdate(() => {
      ref = value;
    }, [value]); // Only re-run if value changes
    // Return previous value (happens before update in useEffect above)

    return ref;
  }

  let count = 0;

  function onUpdateFn_0() {
    prevCount = count;
  }
  $: onUpdateFn_0(...[count]);
</script>

<div>
  <h1>
    Now: {count}, before: {prevCount}
  </h1>
  <button
    on:click={(event) => {
      count += 1;
    }}>Increment</button
  >
</div>
"
`;

exports[`Svelte Button 1`] = `
"<script lang=\\"ts\\">
  export let link: string;
  export let attributes: any;
  export let openLinkInNewTab: boolean;
  export let text: string;
</script>

{#if link}
  <a
    {...attributes}
    href={link}
    target={openLinkInNewTab ? \\"_blank\\" : undefined}
  >
    {text}
  </a>
{/if}

{#if !link}
  <button {...attributes} type=\\"button\\">
    {text}
  </button>
{/if}
"
`;

exports[`Svelte Columns 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface ColumnProps {
    columns?: Column[]; // TODO: Implement this when support for dynamic CSS lands

    space?: number; // TODO: Implement this when support for dynamic CSS lands

    stackColumnsAt?: \\"tablet\\" | \\"mobile\\" | \\"never\\"; // TODO: Implement this when support for dynamic CSS lands

    reverseColumnsWhenStacked?: boolean;
  }
</script>

<script lang=\\"ts\\">
  export let columns;
  export let space;

  function getColumns() {
    return columns || [];
  }

  function getGutterSize() {
    return typeof space === \\"number\\" ? space || 0 : 20;
  }

  function getWidth(index) {
    const columns = getColumns();
    return (columns[index] && columns[index].width) || 100 / columns.length;
  }

  function getColumnCssWidth(index) {
    const columns = getColumns();
    const gutterSize = getGutterSize();
    const subtractWidth = (gutterSize * (columns.length - 1)) / columns.length;
    return \`calc(\${getWidth(index)}% - \${subtractWidth}px)\`;
  }
</script>

<div class=\\"builder-columns div\\">
  {#each columns as column, index}
    <div class=\\"builder-column div-2\\">
      {column.content}
      {index}
    </div>
  {/each}
</div>

<style>
  .div {
    display: flex;
    flex-direction: column;
    align-items: stretch;
    line-height: normal;
  }
  @media (max-width: 999px) {
    .div {
      flex-direction: row;
    }
  }
  @media (max-width: 639px) {
    .div {
      flex-direction: row-reverse;
    }
  }
  .div-2 {
    flex-grow: 1;
  }
</style>
"
`;

exports[`Svelte CustomCode 1`] = `
"<script lang=\\"ts\\">
  import { onMount } from \\"svelte\\";

  export let replaceNodes: boolean;
  export let code: string;

  function findAndRunScripts() {
    // TODO: Move this function to standalone one in '@builder.io/utils'
    if (elem && typeof window !== \\"undefined\\") {
      /** @type {HTMLScriptElement[]} */
      const scripts = elem.getElementsByTagName(\\"script\\");

      for (let i = 0; i < scripts.length; i++) {
        const script = scripts[i];

        if (script.src) {
          if (scriptsInserted.includes(script.src)) {
            continue;
          }

          scriptsInserted.push(script.src);
          const newScript = document.createElement(\\"script\\");
          newScript.async = true;
          newScript.src = script.src;
          document.head.appendChild(newScript);
        } else if (
          !script.type ||
          [
            \\"text/javascript\\",
            \\"application/javascript\\",
            \\"application/ecmascript\\",
          ].includes(script.type)
        ) {
          if (scriptsRun.includes(script.innerText)) {
            continue;
          }

          try {
            scriptsRun.push(script.innerText);
            new Function(script.innerText)();
          } catch (error) {
            console.warn(\\"\`CustomCode\`: Error running script:\\", error);
          }
        }
      }
    }
  }

  let elem;

  let scriptsInserted = [];
  let scriptsRun = [];

  onMount(() => {
    findAndRunScripts();
  });
</script>

<div
  bind:this={elem}
  class={\\"builder-custom-code\\" + (replaceNodes ? \\" replace-nodes\\" : \\"\\")}
>
  {@html code}
</div>
"
`;

exports[`Svelte Embed 1`] = `
"<script lang=\\"ts\\">
  import { onMount } from \\"svelte\\";

  export let replaceNodes: boolean;
  export let code: string;

  function findAndRunScripts() {
    // TODO: Move this function to standalone one in '@builder.io/utils'
    if (elem && typeof window !== \\"undefined\\") {
      /** @type {HTMLScriptElement[]} */
      const scripts = elem.getElementsByTagName(\\"script\\");

      for (let i = 0; i < scripts.length; i++) {
        const script = scripts[i];

        if (script.src) {
          if (scriptsInserted.includes(script.src)) {
            continue;
          }

          scriptsInserted.push(script.src);
          const newScript = document.createElement(\\"script\\");
          newScript.async = true;
          newScript.src = script.src;
          document.head.appendChild(newScript);
        } else if (
          !script.type ||
          [
            \\"text/javascript\\",
            \\"application/javascript\\",
            \\"application/ecmascript\\",
          ].includes(script.type)
        ) {
          if (scriptsRun.includes(script.innerText)) {
            continue;
          }

          try {
            scriptsRun.push(script.innerText);
            new Function(script.innerText)();
          } catch (error) {
            console.warn(\\"\`CustomCode\`: Error running script:\\", error);
          }
        }
      }
    }
  }

  let elem;

  let scriptsInserted = [];
  let scriptsRun = [];

  onMount(() => {
    findAndRunScripts();
  });
</script>

<div
  bind:this={elem}
  class={\\"builder-custom-code\\" + (replaceNodes ? \\" replace-nodes\\" : \\"\\")}
>
  {@html code}
</div>
"
`;

exports[`Svelte Form 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export type FormState = \\"unsubmitted\\" | \\"sending\\" | \\"success\\" | \\"error\\";
</script>

<script lang=\\"ts\\">
  import { BuilderBlock as BuilderBlockComponent } from \\"@fake\\";
  import { Builder, builder } from \\"@builder.io/sdk\\";
  import { BuilderBlocks } from \\"@fake\\";
  import { set } from \\"@fake\\";
  import { get } from \\"@fake\\";

  export let previewState: FormState;
  export let sendWithJs: boolean;
  export let sendSubmissionsTo: string;
  export let action: string;
  export let customHeaders: any;
  export let contentType: string;
  export let sendSubmissionsToEmail: string;
  export let name: string;
  export let method: string;
  export let errorMessagePath: string;
  export let resetFormOnSubmit: boolean;
  export let successUrl: string;
  export let validate: boolean;
  export let attributes: any;
  export let builderBlock: BuilderElement;
  export let errorMessage: BuilderElement[];
  export let sendingMessage: BuilderElement[];
  export let successMessage: BuilderElement[];

  function onSubmit(event) {
    const sendWithJs = sendWithJs || sendSubmissionsTo === \\"email\\";

    if (sendSubmissionsTo === \\"zapier\\") {
      event.preventDefault();
    } else if (sendWithJs) {
      if (!(action || sendSubmissionsTo === \\"email\\")) {
        event.preventDefault();
        return;
      }

      event.preventDefault();
      const el = event.currentTarget;
      const headers = customHeaders || {};
      let body;
      const formData = new FormData(el); // TODO: maybe support null

      const formPairs = Array.from(
        event.currentTarget.querySelectorAll(\\"input,select,textarea\\")
      )
        .filter((el) => !!el.name)
        .map((el) => {
          let value;
          const key = el.name;

          if (el instanceof HTMLInputElement) {
            if (el.type === \\"radio\\") {
              if (el.checked) {
                value = el.name;
                return {
                  key,
                  value,
                };
              }
            } else if (el.type === \\"checkbox\\") {
              value = el.checked;
            } else if (el.type === \\"number\\" || el.type === \\"range\\") {
              const num = el.valueAsNumber;

              if (!isNaN(num)) {
                value = num;
              }
            } else if (el.type === \\"file\\") {
              // TODO: one vs multiple files
              value = el.files;
            } else {
              value = el.value;
            }
          } else {
            value = el.value;
          }

          return {
            key,
            value,
          };
        });
      let contentType = contentType;

      if (sendSubmissionsTo === \\"email\\") {
        contentType = \\"multipart/form-data\\";
      }

      Array.from(formPairs).forEach(({ value }) => {
        if (
          value instanceof File ||
          (Array.isArray(value) && value[0] instanceof File) ||
          value instanceof FileList
        ) {
          contentType = \\"multipart/form-data\\";
        }
      }); // TODO: send as urlEncoded or multipart by default
      // because of ease of use and reliability in browser API
      // for encoding the form?

      if (contentType !== \\"application/json\\") {
        body = formData;
      } else {
        // Json
        const json = {};
        Array.from(formPairs).forEach(({ value, key }) => {
          set(json, key, value);
        });
        body = JSON.stringify(json);
      }

      if (contentType && contentType !== \\"multipart/form-data\\") {
        if (
          /* Zapier doesn't allow content-type header to be sent from browsers */
          !(sendWithJs && action?.includes(\\"zapier.com\\"))
        ) {
          headers[\\"content-type\\"] = contentType;
        }
      }

      const presubmitEvent = new CustomEvent(\\"presubmit\\", {
        detail: {
          body,
        },
      });

      if (formRef) {
        formRef.dispatchEvent(presubmitEvent);

        if (presubmitEvent.defaultPrevented) {
          return;
        }
      }

      formState = \\"sending\\";
      const formUrl = \`\${
        builder.env === \\"dev\\" ? \\"http://localhost:5000\\" : \\"https://builder.io\\"
      }/api/v1/form-submit?apiKey=\${builder.apiKey}&to=\${btoa(
        sendSubmissionsToEmail || \\"\\"
      )}&name=\${encodeURIComponent(name || \\"\\")}\`;
      fetch(
        sendSubmissionsTo === \\"email\\" ? formUrl : action,
        /* TODO: throw error if no action URL */
        {
          body,
          headers,
          method: method || \\"post\\",
        }
      ).then(
        async (res) => {
          let body;
          const contentType = res.headers.get(\\"content-type\\");

          if (contentType && contentType.indexOf(\\"application/json\\") !== -1) {
            body = await res.json();
          } else {
            body = await res.text();
          }

          if (!res.ok && errorMessagePath) {
            /* TODO: allow supplying an error formatter function */
            let message = get(body, errorMessagePath);

            if (message) {
              if (typeof message !== \\"string\\") {
                /* TODO: ideally convert json to yaml so it woul dbe like
           error: - email has been taken */
                message = JSON.stringify(message);
              }

              formErrorMessage = message;
            }
          }

          responseData = body;
          formState = res.ok ? \\"success\\" : \\"error\\";

          if (res.ok) {
            const submitSuccessEvent = new CustomEvent(\\"submit:success\\", {
              detail: {
                res,
                body,
              },
            });

            if (formRef) {
              formRef.dispatchEvent(submitSuccessEvent);

              if (submitSuccessEvent.defaultPrevented) {
                return;
              }
              /* TODO: option to turn this on/off? */

              if (resetFormOnSubmit !== false) {
                formRef.reset();
              }
            }
            /* TODO: client side route event first that can be preventDefaulted */

            if (successUrl) {
              if (formRef) {
                const event = new CustomEvent(\\"route\\", {
                  detail: {
                    url: successUrl,
                  },
                });
                formRef.dispatchEvent(event);

                if (!event.defaultPrevented) {
                  location.href = successUrl;
                }
              } else {
                location.href = successUrl;
              }
            }
          }
        },
        (err) => {
          const submitErrorEvent = new CustomEvent(\\"submit:error\\", {
            detail: {
              error: err,
            },
          });

          if (formRef) {
            formRef.dispatchEvent(submitErrorEvent);

            if (submitErrorEvent.defaultPrevented) {
              return;
            }
          }

          responseData = err;
          formState = \\"error\\";
        }
      );
    }
  }
  $: submissionState = () => {
    return (Builder.isEditing && previewState) || formState;
  };

  let formRef;

  let formState = \\"unsubmitted\\";
  let responseData = null;
  let formErrorMessage = \\"\\";
</script>

<form
  {...attributes}
  {validate}
  bind:this={formRef}
  action={!sendWithJs && action}
  {method}
  {name}
  on:submit={(event) => {
    onSubmit(event);
  }}
>
  {#if builderBlock && builderBlock.children}
    {#each builderBlock?.children as block, index (block.id)}
      <BuilderBlockComponent {block} {index} />
    {/each}
  {/if}

  {#if submissionState() === \\"error\\"}
    <BuilderBlocks dataPath=\\"errorMessage\\" blocks={errorMessage} />
  {/if}

  {#if submissionState() === \\"sending\\"}
    <BuilderBlocks dataPath=\\"sendingMessage\\" blocks={sendingMessage} />
  {/if}

  {#if submissionState() === \\"error\\" && responseData}
    <pre class=\\"builder-form-error-text pre\\">
        {JSON.stringify(responseData, null, 2)}
      </pre>
  {/if}

  {#if submissionState() === \\"success\\"}
    <BuilderBlocks dataPath=\\"successMessage\\" blocks={successMessage} />
  {/if}
</form>

<style>
  .pre {
    padding: 10px;
    color: red;
    text-align: center;
  }
</style>
"
`;

exports[`Svelte Image 1`] = `
"<script lang=\\"ts\\">
  import { onDestroy, onMount } from \\"svelte\\";

  export let lazy: boolean;
  export let altText: string;
  export let _class: string;
  export let image: string;
  export let srcset: string;
  export let sizes: string;

  function setLoaded() {
    imageLoaded = true;
  }

  function useLazyLoading() {
    // TODO: Add more checks here, like testing for real web browsers
    return !!lazy && isBrowser();
  }

  function isBrowser() {
    return (
      typeof window !== \\"undefined\\" && window.navigator.product != \\"ReactNative\\"
    );
  }

  let pictureRef;

  let scrollListener = null;
  let imageLoaded = false;
  let load = false;

  onMount(() => {
    if (useLazyLoading()) {
      // throttled scroll capture listener
      const listener = () => {
        if (pictureRef) {
          const rect = pictureRef.getBoundingClientRect();
          const buffer = window.innerHeight / 2;

          if (rect.top < window.innerHeight + buffer) {
            setLoad(true);
            scrollListener = null;
            window.removeEventListener(\\"scroll\\", listener);
          }
        }
      };

      scrollListener = listener;
      window.addEventListener(\\"scroll\\", listener, {
        capture: true,
        passive: true,
      });
      listener();
    }
  });

  onDestroy(() => {
    if (scrollListener) {
      window.removeEventListener(\\"scroll\\", scrollListener);
    }
  });
</script>

<picture bind:this={pictureRef}>
  {#if !useLazyLoading() || load}
    <img
      alt={altText}
      aria-role={altText ? \\"presentation\\" : undefined}
      class={\\"builder-image\\" + (_class ? \\" \\" + _class : \\"\\") + \\" img\\"}
      src={image}
      on:load={(event) => {
        setLoaded();
      }}
      {srcset}
      {sizes}
    />
  {/if}
  <source {srcset} />
</picture>

<slot />

<style>
  .img {
    opacity: 1;
    transition: opacity 0.2s ease-in-out;
    object-fit: cover;
    object-position: center;
  }
</style>
"
`;

exports[`Svelte Image State 1`] = `
"<script lang=\\"ts\\">
  let canShow = true;
  let images = [\\"http://example.com/qwik.png\\"];
</script>

<div>
  {#each images as item, itemIndex}
    <img class=\\"custom-class\\" src={item} key={itemIndex} />
  {/each}
</div>
"
`;

exports[`Svelte Img 1`] = `
"<script lang=\\"ts\\">
  import { Builder } from \\"@builder.io/sdk\\";

  export let backgroundSize: \\"cover\\" | \\"contain\\";
  export let backgroundPosition:
    | \\"center\\"
    | \\"top\\"
    | \\"left\\"
    | \\"right\\"
    | \\"bottom\\"
    | \\"top left\\"
    | \\"top right\\"
    | \\"bottom left\\"
    | \\"bottom right\\";
  export let attributes: any;
  export let imgSrc: string;
  export let altText: string;

  function mitosis_styling(node, vars) {
    Object.entries(vars).forEach(([p, v]) => {
      node.style[p] = v;
    });
  }
</script>

<img
  {...attributes}
  use:mitosis_styling={{
    objectFit: backgroundSize || \\"cover\\",
    objectPosition: backgroundPosition || \\"center\\",
  }}
  key={(Builder.isEditing && imgSrc) || \\"default-key\\"}
  alt={altText}
  src={imgSrc}
/>
"
`;

exports[`Svelte Input 1`] = `
"<script lang=\\"ts\\">
  import { Builder } from \\"@builder.io/sdk\\";

  export let attributes: any;
  export let defaultValue: string;
  export let placeholder: string;
  export let type: string;
  export let name: string;
  export let value: string;
  export let required: boolean;
</script>

<input
  {...attributes}
  key={Builder.isEditing && defaultValue ? defaultValue : \\"default-key\\"}
  {placeholder}
  {type}
  {name}
  {value}
  {defaultValue}
  {required}
/>
"
`;

exports[`Svelte RawText 1`] = `
"<script lang=\\"ts\\">
  export let attributes: any;
  export let text: string;
</script>

<span class={attributes?.class || attributes?.className}
  >{@html text || \\"\\"}</span
>
"
`;

exports[`Svelte Remove Internal mitosis package 1`] = `
"<script lang=\\"ts\\">
  let name = \\"PatrickJS\\";
</script>

<div>Hello {name}! I can run in React, Qwik, Vue, Solid, or Liquid!</div>
"
`;

exports[`Svelte Section 1`] = `
"<script lang=\\"ts\\">
  export let attributes: any;
  export let maxWidth: number;

  function mitosis_styling(node, vars) {
    Object.entries(vars).forEach(([p, v]) => {
      node.style[p] = v;
    });
  }
</script>

<section
  {...attributes}
  use:mitosis_styling={maxWidth && typeof maxWidth === \\"number\\"
    ? {
        maxWidth: maxWidth,
      }
    : undefined}
>
  <slot />
</section>
"
`;

exports[`Svelte Section 2`] = `
"<script lang=\\"ts\\">
  export let attributes: any;

  function mitosis_styling(node, vars) {
    Object.entries(vars).forEach(([p, v]) => {
      node.style[p] = v;
    });
  }

  let max = 42;
  let items = [42];
</script>

{#if max}
  {#each items as item}
    <section
      {...attributes}
      use:mitosis_styling={{
        maxWidth: item + max,
      }}
    >
      <slot />
    </section>
  {/each}
{/if}
"
`;

exports[`Svelte Select 1`] = `
"<script lang=\\"ts\\">
  import { Builder } from \\"@builder.io/sdk\\";

  export let attributes: any;
  export let value: string;
  export let defaultValue: string;
  export let name: string;
  export let options: any;
</script>

<select
  {...attributes}
  {value}
  key={Builder.isEditing && defaultValue ? defaultValue : \\"default-key\\"}
  {defaultValue}
  {name}
>
  {#each options as option, index}
    <option value={option.value} data-index={index}>
      {option.name || option.value}
    </option>
  {/each}
</select>
"
`;

exports[`Svelte Stamped.io 1`] = `
"<script lang=\\"ts\\">
  import { onMount } from \\"svelte\\";

  import { kebabCase } from \\"lodash\\";
  import { snakeCase } from \\"lodash\\";

  export let apiKey: string;
  export let productId: string;

  function kebabCaseValue() {
    return kebabCase(\\"testThat\\");
  }

  function snakeCaseValue() {
    return snakeCase(\\"testThis\\");
  }

  let reviews = [];
  let name = \\"test\\";
  let showReviewPrompt = false;

  onMount(() => {
    fetch(
      \`https://stamped.io/api/widget/reviews?storeUrl=builder-io.myshopify.com&apiKey=\${
        apiKey || \\"pubkey-8bbDq7W6w4sB3OWeM1HUy2s47702hM\\"
      }&productId=\${productId || \\"2410511106127\\"}\`
    )
      .then((res) => res.json())
      .then((data) => {
        reviews = data.data;
      });
  });
</script>

<div data-user={name}>
  <button
    on:click={(event) => {
      showReviewPrompt = true;
    }}>Write a review</button
  >

  {#if showReviewPrompt}
    <input placeholder=\\"Email\\" />

    <input placeholder=\\"Title\\" class=\\"input\\" />

    <textarea placeholder=\\"How was your experience?\\" class=\\"textarea\\" />

    <button
      class=\\"button\\"
      on:click={(event) => {
        event.preventDefault();
        showReviewPrompt = false;
      }}
    >
      Submit
    </button>
  {/if}

  {#each reviews as review, index (review.id)}
    <div class=\\"review\\">
      <img class=\\"img\\" src={review.avatar} />
      <div class={showReviewPrompt ? \\"bg-primary\\" : \\"bg-secondary\\"}>
        <div>N: {index}</div>
        <div>{review.author}</div>
        <div>{review.reviewMessage}</div>
      </div>
    </div>
  {/each}
</div>

<style>
  .input {
    display: block;
  }
  .textarea {
    display: block;
  }
  .button {
    display: block;
  }
  .review {
    margin: 10px;
    padding: 10px;
    background: white;
    display: flex;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  }
  .img {
    height: 30px;
    width: 30px;
    margin-right: 10px;
  }
</style>
"
`;

exports[`Svelte Submit 1`] = `
"<script lang=\\"ts\\">
  export let attributes: any;
  export let text: string;
</script>

<button {...attributes} type=\\"submit\\">
  {text}
</button>
"
`;

exports[`Svelte Text 1`] = `
"<script lang=\\"ts\\">
  import { Builder } from \\"@builder.io/sdk\\";

  export let text: string;
  export let content: string;

  let name = \\"Decadef20\\";
</script>

<div
  contentEditable={allowEditingText || undefined}
  data-name={{
    test: name || \\"any name\\",
  }}
>
  {@html text || content || name || '<p class=\\"text-lg\\">my name</p>'}
</div>
"
`;

exports[`Svelte Textarea 1`] = `
"<script lang=\\"ts\\">
  export let attributes: any;
  export let placeholder: string;
  export let name: string;
  export let value: string;
  export let defaultValue: string;
</script>

<textarea {...attributes} {placeholder} {name} {value} {defaultValue} />
"
`;

exports[`Svelte Video 1`] = `
"<script lang=\\"ts\\">
  export let attributes: any;
  export let fit: \\"contain\\" | \\"cover\\" | \\"fill\\";
  export let position:
    | \\"center\\"
    | \\"top\\"
    | \\"left\\"
    | \\"right\\"
    | \\"bottom\\"
    | \\"top left\\"
    | \\"top right\\"
    | \\"bottom left\\"
    | \\"bottom right\\";
  export let video: string;
  export let posterImage: string;
  export let autoPlay: boolean;
  export let muted: boolean;
  export let controls: boolean;
  export let loop: boolean;

  function mitosis_styling(node, vars) {
    Object.entries(vars).forEach(([p, v]) => {
      node.style[p] = v;
    });
  }
</script>

<video
  {...attributes}
  use:mitosis_styling={{
    width: \\"100%\\",
    height: \\"100%\\",
    ...attributes?.style,
    objectFit: fit,
    objectPosition: position,
    // Hack to get object fit to work as expected and
    // not have the video overflow
    borderRadius: 1,
  }}
  preload=\\"none\\"
  key={video || \\"no-src\\"}
  poster={posterImage}
  autoplay={autoPlay}
  {muted}
  {controls}
  {loop}
/>
"
`;

exports[`Svelte basicForwardRef 1`] = `
"<script lang=\\"ts\\">
  export let inputRef: HTMLInputElement;

  let inputRef;

  let name = \\"PatrickJS\\";
</script>

<div>
  <input class=\\"input\\" bind:this={inputRef} bind:value={name} />
</div>

<style>
  .input {
    color: red;
  }
</style>
"
`;

exports[`Svelte basicForwardRefMetadata 1`] = `
"<script lang=\\"ts\\">
  export let inputRef: HTMLInputElement;

  let inputRef;

  let name = \\"PatrickJS\\";
</script>

<div>
  <input class=\\"input\\" bind:this={inputRef} bind:value={name} />
</div>

<style>
  .input {
    color: red;
  }
</style>
"
`;

exports[`Svelte basicOnUpdateReturn 1`] = `
"<script lang=\\"ts\\">
  import { afterUpdate } from \\"svelte\\";

  let name = \\"PatrickJS\\";

  function onUpdateFn_0() {
    const controller = new AbortController();
    const signal = controller.signal;
    fetch(\\"https://patrickjs.com/api/resource.json\\", {
      signal,
    })
      .then((response) => response.json())
      .then((data) => {
        name = data.name;
      });
    return () => {
      if (!signal.aborted) {
        controller.abort();
      }
    };
  }
  $: onUpdateFn_0(...[name]);
</script>

<div>Hello! {name}</div>
"
`;

exports[`Svelte class + ClassName + css 1`] = `
"<script lang=\\"ts\\">
</script>

<div class=\\"test2 test div\\">
  Hello! I can run in React, Vue, Solid, or Liquid!
</div>

<style>
  .div {
    padding: 10px;
  }
</style>
"
`;

exports[`Svelte class + css 1`] = `
"<script lang=\\"ts\\">
</script>

<div class=\\"test div\\">Hello! I can run in React, Vue, Solid, or Liquid!</div>

<style>
  .div {
    padding: 10px;
  }
</style>
"
`;

exports[`Svelte className + css 1`] = `
"<script lang=\\"ts\\">
</script>

<div class=\\"test div\\">Hello! I can run in React, Vue, Solid, or Liquid!</div>

<style>
  .div {
    padding: 10px;
  }
</style>
"
`;

exports[`Svelte className 1`] = `
"<script lang=\\"ts\\">
  let bindings = \\"a binding\\";
</script>

<div>
  <div class=\\"no binding\\">Without Binding</div>

  <div class={bindings}>With binding</div>
</div>
"
`;

exports[`Svelte defaultProps 1`] = `
"<script lang=\\"ts\\">
  export let link: string = \\"https://builder.io/\\";
  export let attributes: any;
  export let openLinkInNewTab: boolean = false;
  export let text: string = \\"default text\\";
</script>

{#if link}
  <a
    {...attributes}
    href={link}
    target={openLinkInNewTab ? \\"_blank\\" : undefined}
  >
    {text}
  </a>
{/if}

{#if !link}
  <button {...attributes} type=\\"button\\">
    {text}
  </button>
{/if}
"
`;

exports[`Svelte defaultValsWithTypes 1`] = `
"<script lang=\\"ts\\">
  const DEFAULT_VALUES: Props = {
    name: \\"Sami\\",
  };

  export let name: string;
</script>

<div>Hello {name || DEFAULT_VALUES.name}</div>
"
`;

exports[`Svelte multipleOnUpdate 1`] = `
"<script lang=\\"ts\\">
  import { afterUpdate } from \\"svelte\\";

  afterUpdate(() => {
    console.log(\\"Runs on every update/rerender\\");
  });
  afterUpdate(() => {
    console.log(\\"Runs on every update/rerender as well\\");
  });
</script>

<div />
"
`;

exports[`Svelte multipleOnUpdateWithDeps 1`] = `
"<script lang=\\"ts\\">
  import { afterUpdate } from \\"svelte\\";

  let a = \\"a\\";
  let b = \\"b\\";
  let c = \\"c\\";
  let d = \\"d\\";

  function onUpdateFn_0() {
    console.log(\\"Runs when a or b changes\\", a, b);

    if (a === \\"a\\") {
      a = \\"b\\";
    }
  }
  $: onUpdateFn_0(...[a, b]);
  function onUpdateFn_1() {
    console.log(\\"Runs when c or d changes\\", c, d);

    if (a === \\"a\\") {
      a = \\"b\\";
    }
  }
  $: onUpdateFn_1(...[c, d]);
</script>

<div />
"
`;

exports[`Svelte nestedShow 1`] = `
"<script lang=\\"ts\\">
  export let conditionA: boolean;
  export let conditionB: boolean;
</script>

{#if conditionA}
  {#if !conditionB}
    <div>if condition A and condition B</div>
  {:else}
    <div>else-condition-B</div>
  {/if}
{:else}
  <div>else-condition-A</div>
{/if}
"
`;

exports[`Svelte nestedStyles 1`] = `
"<script lang=\\"ts\\">
</script>

<div class=\\"div\\">Hello world</div>

<style>
  .div {
    display: flex;
    foo: var(--bar);
  }
  @media (max-width: env(--mobile)) {
    .div {
      display: block;
    }
  }
  .div:hover {
    display: flex;
  }
  .div .nested-selector {
    display: grid;
  }
</style>
"
`;

exports[`Svelte onInit & onMount 1`] = `
"<script lang=\\"ts\\">
  import { onMount } from \\"svelte\\";

  onMount(() => {
    console.log(\\"onMount\\");
  });
</script>

<div />
"
`;

exports[`Svelte onInit 1`] = `
"<script lang=\\"ts\\">
  export const defaultValues = {
    name: \\"PatrickJS\\",
  };

  export let name: string;

  let name = \\"\\";
</script>

<div>Default name defined by parent {name}</div>
"
`;

exports[`Svelte onMount 1`] = `
"<script lang=\\"ts\\">
  import { onDestroy, onMount } from \\"svelte\\";

  onMount(() => {
    console.log(\\"Runs on mount\\");
  });

  onDestroy(() => {
    console.log(\\"Runs on unMount\\");
  });
</script>

<div />
"
`;

exports[`Svelte onUpdate 1`] = `
"<script lang=\\"ts\\">
  import { afterUpdate } from \\"svelte\\";

  afterUpdate(() => {
    console.log(\\"Runs on every update/rerender\\");
  });
</script>

<div />
"
`;

exports[`Svelte onUpdateWithDeps 1`] = `
"<script lang=\\"ts\\">
  import { afterUpdate } from \\"svelte\\";

  let a = \\"a\\";
  let b = \\"b\\";

  function onUpdateFn_0() {
    console.log(\\"Runs when a or b changes\\", a, b);
  }
  $: onUpdateFn_0(...[a, b]);
</script>

<div />
"
`;

exports[`Svelte preserveExportOrLocalStatement 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  interface IPost {
    len: number;
  }

  export interface MyBasicComponentProps {
    id: string;
  }
</script>

<script lang=\\"ts\\">
  const b = 3;
  const foo = () => {};
  export const a = 3;
  export const bar = () => {};
  export function run<T>(value: T) {}
</script>

<div />
"
`;

exports[`Svelte preserveTyping 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface C {
    n: \\"test\\";
  }

  type B = \\"test2\\";

  interface D {
    n: \\"test\\";
  }

  export interface MyBasicComponentProps {
    name: string;
    age?: number;
  }
</script>

<script lang=\\"ts\\">
  export let name;
</script>

<div>Hello! I can run in React, Vue, Solid, or Liquid! {name}</div>
"
`;

exports[`Svelte propsDestructure 1`] = `
"<script lang=\\"ts\\">
  export let type: string;

  let name = \\"Decadef20\\";
</script>

<div>
  <slot />
  {type}
  Hello! I can run in React, Vue, Solid, or Liquid!
</div>
"
`;

exports[`Svelte propsInterface 1`] = `
"<script lang=\\"ts\\">
  export let name: string;
</script>

<div>Hello! I can run in React, Vue, Solid, or Liquid! {name}</div>
"
`;

exports[`Svelte propsType 1`] = `
"<script lang=\\"ts\\">
  export let name: string;
</script>

<div>Hello! I can run in React, Vue, Solid, or Liquid! {name}</div>
"
`;

exports[`Svelte rootShow 1`] = `
"<script lang=\\"ts\\">
  export let foo;
</script>

{#if foo === \\"bar\\"}
  <div>Bar</div>
{:else}
  <div>Foo</div>
{/if}
"
`;

exports[`Svelte self-referencing component 1`] = `
"<script lang=\\"ts\\">
  export let name;
</script>

<div>
  {name}

  {#if name === \\"Batman\\"}
    <svelte:self name=\\"Bruce Wayne\\" />
  {/if}
</div>
"
`;

exports[`Svelte self-referencing component with children 1`] = `
"<script lang=\\"ts\\">
  export let name;
</script>

<div>
  {name}
  <slot />

  {#if name === \\"Batman\\"}
    <svelte:self name=\\"Bruce\\">
      <div>Wayne</div>
    </svelte:self>
  {/if}
</div>
"
`;

exports[`Svelte showWithFor 1`] = `
"<script lang=\\"ts\\">
  export let conditionA: boolean;
  export let items: string[];
</script>

{#if conditionA}
  {#each items as item, idx (idx)}
    <div>{item}</div>
  {/each}
{:else}
  <div>else-condition-A</div>
{/if}
"
`;

exports[`Svelte subComponent 1`] = `
"<script lang=\\"ts\\">
  import Foo from \\"./foo-sub-component.svelte\\";
</script>

<Foo />
"
`;

exports[`Svelte typeDependency 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  import type { Foo as Foo2 } from \\"./type-export\\";

  export type TypeDependencyProps = {
    foo: Foo;
    foo2: Foo2;
  };
</script>

<script lang=\\"ts\\">
  export let foo;
</script>

<div>{foo}</div>
"
`;
