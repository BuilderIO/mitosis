// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Vue Basic 1`] = `
"<script lang=\\"typescript\\">
  import onChange from \\"on-change\\";

  name = \\"Steve\\";
</script>

<div><input bind:value={state.name} />
  Hello! I can run in React, Vue, Solid, or Liquid!</div>
"
`;

exports[`Vue Button 1`] = `
"<script lang=\\"typescript\\">
  export interface ButtonProps {
    attributes?: any;
    text?: string;
    link?: string;
    openLinkInNewTab?: boolean;
  }

  let link;
  let attributes;
  let openLinkInNewTab;
  let text;
</script>

{#if link}
  <a
    {...attributes}
    href={link}
    target={openLinkInNewTab ? '_blank' : undefined}>
    {text}
  </a>
{/if}

{#if !link}<button {...attributes} type=\\"button\\"> {text} </button>{/if}
"
`;

exports[`Vue Form block 1`] = `
"<script lang=\\"typescript\\">
  import { BuilderBlockComponent as BuilderBlock } from \\"@fake\\";
  import { Builder, builder } from \\"@builder.io/sdk\\";
  import { BuilderBlocks } from \\"@fake\\";
  import { set } from \\"@fake\\";
  import { get } from \\"@fake\\";

  export interface FormProps {
    attributes?: any;
    name?: string;
    action?: string;
    validate?: boolean;
    method?: string;
    builderBlock?: BuilderElement;
    sendSubmissionsTo?: string;
    sendSubmissionsToEmail?: string;
    sendWithJs?: boolean;
    contentType?: string;
    customHeaders?: {
      [key: string]: string;
    };
    successUrl?: string;
    previewState?: FormState;
    successMessage?: BuilderElement[];
    errorMessage?: BuilderElement[];
    sendingMessage?: BuilderElement[];
    resetFormOnSubmit?: boolean;
    errorMessagePath?: string;
  }
  export type FormState = \\"unsubmitted\\" | \\"sending\\" | \\"success\\" | \\"error\\";

  import onChange from \\"on-change\\";
  let formRef;
  let previewState;
  let sendWithJs;
  let sendSubmissionsTo;
  let action;
  let customHeaders;
  let contentType;
  let sendSubmissionsToEmail;
  let name;
  let method;
  let errorMessagePath;
  let resetFormOnSubmit;
  let successUrl;
  let validate;
  let attributes;
  let builderBlock;
  let errorMessage;
  let sendingMessage;
  let successMessage;

  function onSubmit(
    event: Event & {
      currentTarget: HTMLFormElement;
    }
  ) {
    const sendWithJs = sendWithJs || sendSubmissionsTo === \\"email\\";

    if (sendSubmissionsTo === \\"zapier\\") {
      event.preventDefault();
    } else if (sendWithJs) {
      if (!(action || sendSubmissionsTo === \\"email\\")) {
        event.preventDefault();
        return;
      }

      event.preventDefault();
      const el = event.currentTarget;
      const headers = customHeaders || {};
      let body: any;
      const formData = new FormData(el); // TODO: maybe support null

      const formPairs: {
        key: string;
        value: File | boolean | number | string | FileList;
      }[] = Array.from(
        event.currentTarget.querySelectorAll(\\"input,select,textarea\\")
      )
        .filter((el) => !!(el as HTMLInputElement).name)
        .map((el) => {
          let value: any;
          const key = (el as HTMLImageElement).name;

          if (el instanceof HTMLInputElement) {
            if (el.type === \\"radio\\") {
              if (el.checked) {
                value = el.name;
                return {
                  key,
                  value,
                };
              }
            } else if (el.type === \\"checkbox\\") {
              value = el.checked;
            } else if (el.type === \\"number\\" || el.type === \\"range\\") {
              const num = el.valueAsNumber;

              if (!isNaN(num)) {
                value = num;
              }
            } else if (el.type === \\"file\\") {
              // TODO: one vs multiple files
              value = el.files;
            } else {
              value = el.value;
            }
          } else {
            value = (el as HTMLInputElement).value;
          }

          return {
            key,
            value,
          };
        });
      let contentType = contentType;

      if (sendSubmissionsTo === \\"email\\") {
        contentType = \\"multipart/form-data\\";
      }

      Array.from(formPairs).forEach(({ value }) => {
        if (
          value instanceof File ||
          (Array.isArray(value) && value[0] instanceof File) ||
          value instanceof FileList
        ) {
          contentType = \\"multipart/form-data\\";
        }
      }); // TODO: send as urlEncoded or multipart by default
      // because of ease of use and reliability in browser API
      // for encoding the form?

      if (contentType !== \\"application/json\\") {
        body = formData;
      } else {
        // Json
        const json = {};
        Array.from(formPairs).forEach(({ value, key }) => {
          set(json, key, value);
        });
        body = JSON.stringify(json);
      }

      if (contentType && contentType !== \\"multipart/form-data\\") {
        if (
          // Zapier doesn't allow content-type header to be sent from browsers
          !(sendWithJs && action?.includes(\\"zapier.com\\"))
        ) {
          headers[\\"content-type\\"] = contentType;
        }
      }

      const presubmitEvent = new CustomEvent(\\"presubmit\\", {
        detail: {
          body,
        },
      });

      if (formRef) {
        formRef.dispatchEvent(presubmitEvent);

        if (presubmitEvent.defaultPrevented) {
          return;
        }
      }

      state.state = \\"sending\\";
      const formUrl = \`\${
        builder.env === \\"dev\\" ? \\"http://localhost:5000\\" : \\"https://builder.io\\"
      }/api/v1/form-submit?apiKey=\${builder.apiKey}&to=\${btoa(
        sendSubmissionsToEmail || \\"\\"
      )}&name=\${encodeURIComponent(name || \\"\\")}\`;
      fetch(
        sendSubmissionsTo === \\"email\\" ? formUrl : action!, // TODO: throw error if no action URL
        {
          body,
          headers,
          method: method || \\"post\\",
        }
      ).then(
        async (res) => {
          let body;
          const contentType = res.headers.get(\\"content-type\\");

          if (contentType && contentType.indexOf(\\"application/json\\") !== -1) {
            body = await res.json();
          } else {
            body = await res.text();
          }

          if (!res.ok && errorMessagePath) {
            // TODO: allow supplying an error formatter function
            let message = get(body, errorMessagePath);

            if (message) {
              if (typeof message !== \\"string\\") {
                // TODO: ideally convert json to yaml so it woul dbe like
                // error: - email has been taken
                message = JSON.stringify(message);
              }

              state.formErrorMessage = message;
            }
          }

          state.responseData = body;
          state.state = res.ok ? \\"success\\" : \\"error\\";

          if (res.ok) {
            const submitSuccessEvent = new CustomEvent(\\"submit:success\\", {
              detail: {
                res,
                body,
              },
            });

            if (formRef) {
              formRef.dispatchEvent(submitSuccessEvent);

              if (submitSuccessEvent.defaultPrevented) {
                return;
              } // TODO: option to turn this on/off?

              if (resetFormOnSubmit !== false) {
                formRef.reset();
              }
            } // TODO: client side route event first that can be preventDefaulted

            if (successUrl) {
              if (formRef) {
                const event = new CustomEvent(\\"route\\", {
                  detail: {
                    url: successUrl,
                  },
                });
                formRef.dispatchEvent(event);

                if (!event.defaultPrevented) {
                  location.href = successUrl;
                }
              } else {
                location.href = successUrl;
              }
            }
          }
        },
        (err) => {
          const submitErrorEvent = new CustomEvent(\\"submit:error\\", {
            detail: {
              error: err,
            },
          });

          if (formRef) {
            formRef.dispatchEvent(submitErrorEvent);

            if (submitErrorEvent.defaultPrevented) {
              return;
            }
          }

          state.responseData = err;
          state.state = \\"error\\";
        }
      );
    }
  }

  $: submissionState = () => {
    return (Builder.isEditing && previewState) || state.state;
  };

  state = \\"unsubmitted\\";
  responseData = null;
  formErrorMessage = \\"\\";
</script>

<style>
  .pre-1 {
    padding: 10px;
    color: red;
    textalign: center;
  }
</style>

<form
  {...attributes}
  {validate}
  bind:this={formRef}
  action={!sendWithJs && action}
  {method}
  {name}
  on:submit={(event) => state.onSubmit(event)}>
  {#if builderBlock && builderBlock.children}
    {#each builderBlock?.children as block}
      <BuilderBlockComponent key={block.id} {block} />
    {/each}
  {/if}

  {#if state.submissionState === 'error'}
    <BuilderBlocks dataPath=\\"errorMessage\\" blocks={errorMessage} />
  {/if}

  {#if state.submissionState === 'sending'}
    <BuilderBlocks dataPath=\\"sendingMessage\\" blocks={sendingMessage} />
  {/if}

  {#if state.submissionState === 'error' && state.responseData}
    <pre
      class=\\"builder-form-error-text pre-1\\">
        
{JSON.stringify(state.responseData, null, 2)}

      </pre>
  {/if}

  {#if state.submissionState === 'success'}
    <BuilderBlocks dataPath=\\"successMessage\\" blocks={successMessage} />
  {/if}
</form>
"
`;

exports[`Vue Img 1`] = `
"<script lang=\\"typescript\\">
  import { Builder } from \\"@builder.io/sdk\\";

  export interface ImgProps {
    attributes?: any;
    imgSrc?: string;
    altText?: string;
    backgroundSize?: \\"cover\\" | \\"contain\\";
    backgroundPosition?:
      | \\"center\\"
      | \\"top\\"
      | \\"left\\"
      | \\"right\\"
      | \\"bottom\\"
      | \\"top left\\"
      | \\"top right\\"
      | \\"bottom left\\"
      | \\"bottom right\\";
  }

  let backgroundSize;
  let backgroundPosition;
  let attributes;
  let altText;
</script>

<img
  {...attributes}
  style={{ objectFit: backgroundSize || 'cover', objectPosition: backgroundPosition || 'center' }}
  key={(Builder.isEditing && imgSrc) || 'default-key'}
  alt={altText}
  src={imgSrc} />
"
`;

exports[`Vue Input block 1`] = `
"<script lang=\\"typescript\\">
  import { Builder } from \\"@builder.io/sdk\\";

  export interface FormInputProps {
    type?: string;
    attributes?: any;
    name?: string;
    value?: string;
    placeholder?: string;
    defaultValue?: string;
    required?: boolean;
  }

  let attributes;
  let defaultValue;
  let placeholder;
  let type;
  let name;
  let value;
  let required;
</script>

<input
  {...attributes}
  key={Builder.isEditing && defaultValue ? defaultValue : 'default-key'}
  {placeholder}
  {type}
  {name}
  {value}
  {defaultValue}
  {required} />
"
`;

exports[`Vue Select block 1`] = `
"<script lang=\\"typescript\\">
  import { Builder } from \\"@builder.io/sdk\\";

  export interface FormSelectProps {
    options?: {
      name?: string;
      value: string;
    }[];
    attributes?: any;
    name?: string;
    value?: string;
    defaultValue?: string;
  }

  let attributes;
  let value;
  let defaultValue;
  let name;
  let options;
</script>

<select
  {...attributes}
  {value}
  key={Builder.isEditing && defaultValue ? defaultValue : 'default-key'}
  {defaultValue}
  {name}>
  {#each options as option}
    <option value={option.value}>{option.name || option.value}</option>
  {/each}
</select>
"
`;

exports[`Vue Submit button block 1`] = `
"<script lang=\\"typescript\\">
  export interface ButtonProps {
    attributes?: any;
    text?: string;
  }

  let attributes;
  let text;
</script>

<button {...attributes} type=\\"submit\\"> {text} </button>
"
`;

exports[`Vue Textarea 1`] = `
"<script lang=\\"typescript\\">
  export interface TextareaProps {
    attributes?: any;
    name?: string;
    value?: string;
    defaultValue?: string;
    placeholder?: string;
  }

  let attributes;
  let placeholder;
  let name;
  let value;
  let defaultValue;
</script>

<textarea {...attributes} {placeholder} {name} {value} {defaultValue} />
"
`;
