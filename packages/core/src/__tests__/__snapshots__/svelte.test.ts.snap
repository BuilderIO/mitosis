// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Svelte > jsx > Javascript Test > AdvancedRef 1`] = `
"<script>
  export let showInput;

  function onBlur() {
    // Maintain focus
    inputRef.focus();
  }

  function lowerCaseName() {
    return name.toLowerCase();
  }

  let inputRef;
  let inputNoArgRef;

  let name = \\"PatrickJS\\";

  function onUpdateFn_0(..._args) {
    console.log(\\"Received an update\\");
  }

  $: onUpdateFn_0(...[inputRef, inputNoArgRef]);
</script>

<div>
  {#if showInput}
    <input
      class=\\"input\\"
      bind:this={inputRef}
      on:blur={(event) => {
        onBlur();
      }}
      bind:value={name}
    />
    <label for=\\"cars\\" bind:this={inputNoArgRef}> Choose a car: </label>
    <select name=\\"cars\\" id=\\"cars\\"
      ><option value=\\"supra\\">GR Supra</option><option value=\\"86\\">GR 86</option
      ></select
    >
  {/if}
  Hello
  {lowerCaseName()}! I can run in React, Qwik, Vue, Solid, or Web Component!
</div>

<style>
  .input {
    color: red;
  }
</style>"
`;

exports[`Svelte > jsx > Javascript Test > Basic 1`] = `
"<script>
  export const DEFAULT_VALUES = {
    name: \\"Steve\\",
  };

  function underscore_fn_name() {
    return \\"bar\\";
  }

  let name = \\"Steve\\";
  let age = 1;
  let sports = [\\"\\"];
</script>

<div class=\\"test div\\">
  <input
    value={DEFAULT_VALUES.name || name}
    on:change={(myEvent) => {
      name = myEvent.target.value;
    }}
  />
  Hello! I can run in React, Vue, Solid, or Liquid!
</div>

<style>
  .div {
    padding: 10px;
  }
</style>"
`;

exports[`Svelte > jsx > Javascript Test > Basic 2`] = `
"<script>
  let name = \\"PatrickJS\\";
  let names = [\\"Steve\\", \\"PatrickJS\\"];
</script>

<div>
  {#each names as person}
    {#if person === name}
      <input
        value={name}
        on:change={(event) => {
          name = event.target.value + \\" and \\" + person;
        }}
      />

      Hello
      {person}
      ! I can run in Qwik, Web Component, React, Vue, Solid, or Liquid!
    {/if}
  {/each}
</div>"
`;

exports[`Svelte > jsx > Javascript Test > Basic Context 1`] = `
"<script>
  import { getContext, onMount, setContext } from \\"svelte\\";

  import { Injector, MyService, createInjector } from \\"@dummy/injection-js\\";

  let myService = getContext(MyService.key);

  function onChange() {
    const change = myService.method(\\"change\\");
    console.log(change);
  }

  let name = \\"PatrickJS\\";
  const hi = myService.method(\\"hi\\");
  console.log(hi);

  onMount(() => {
    const bye = myService.method(\\"hi\\");
    console.log(bye);
  });

  setContext(Injector.key, createInjector());
</script>

<div>
  {myService.method(\\"hello\\") + name}
  Hello! I can run in React, Vue, Solid, or Liquid!
  <input on:change={onChange} />
</div>"
`;

exports[`Svelte > jsx > Javascript Test > Basic OnMount Update 1`] = `
"<script>
  import { onMount } from \\"svelte\\";

  export let bye;
  export let hi;

  let name = \\"PatrickJS\\";
  let names = [\\"Steve\\", \\"PatrickJS\\"];
  name = \\"PatrickJS onInit\\" + hi;

  onMount(() => {
    name = \\"PatrickJS onMount\\" + bye;
  });
</script>

<div>Hello {name}</div>"
`;

exports[`Svelte > jsx > Javascript Test > Basic Outputs 1`] = `
"<script>
  import { onMount } from \\"svelte\\";

  export let onMessage;
  export let onEvent;
  export let message;

  let name = \\"PatrickJS\\";

  onMount(() => {
    onMessage(name);
    onEvent(message);
  });
</script>

<div />"
`;

exports[`Svelte > jsx > Javascript Test > Basic Outputs Meta 1`] = `
"<script>
  import { onMount } from \\"svelte\\";

  export let onMessage;
  export let onEvent;
  export let message;

  let name = \\"PatrickJS\\";

  onMount(() => {
    onMessage(name);
    onEvent(message);
  });
</script>

<div />"
`;

exports[`Svelte > jsx > Javascript Test > BasicAttribute 1`] = `"<input autocapitalize=\\"on\\" autocomplete=\\"on\\" spellcheck={true} />"`;

exports[`Svelte > jsx > Javascript Test > BasicBooleanAttribute 1`] = `
"<script>
  import MyBooleanAttributeComponent from \\"./basic-boolean-attribute-component.raw\\";

  export let type;
</script>

<div>
  {#if $$slots.default}
    <slot />
    {type}
  {/if}<MyBooleanAttributeComponent toggle={true} /><MyBooleanAttributeComponent
    toggle={true}
  /><MyBooleanAttributeComponent list={null} />
</div>"
`;

exports[`Svelte > jsx > Javascript Test > BasicChildComponent 1`] = `
"<script>
  import MyBasicOnMountUpdateComponent from \\"./basic-onMount-update.raw\\";
  import MyBasicComponent from \\"./basic.raw\\";

  let name = \\"Steve\\";
  let dev = \\"PatrickJS\\";
</script>

<div>
  <MyBasicComponent id={dev} />
  <div><MyBasicOnMountUpdateComponent hi={name} bye={dev} /></div>
</div>"
`;

exports[`Svelte > jsx > Javascript Test > BasicFor 1`] = `
"<script>
  import { onMount } from \\"svelte\\";

  let name = \\"PatrickJS\\";
  let names = [\\"Steve\\", \\"PatrickJS\\"];

  onMount(() => {
    console.log(\\"onMount code\\");
  });
</script>

<div>
  {#each names as person}
    <input
      value={name}
      on:change={(event) => {
        name = event.target.value + \\" and \\" + person;
      }}
    />

    Hello
    {person}
    ! I can run in Qwik, Web Component, React, Vue, Solid, or Liquid!
  {/each}
</div>"
`;

exports[`Svelte > jsx > Javascript Test > BasicRef 1`] = `
"<script>
  export let showInput;

  function onBlur() {
    // Maintain focus
    inputRef.focus();
  }

  function lowerCaseName() {
    return name.toLowerCase();
  }

  let inputRef;
  let inputNoArgRef;

  let name = \\"PatrickJS\\";
</script>

<div>
  {#if showInput}
    <input
      class=\\"input\\"
      bind:this={inputRef}
      on:blur={(event) => {
        onBlur();
      }}
      bind:value={name}
    />
    <label for=\\"cars\\" bind:this={inputNoArgRef}> Choose a car: </label>
    <select name=\\"cars\\" id=\\"cars\\"
      ><option value=\\"supra\\">GR Supra</option><option value=\\"86\\">GR 86</option
      ></select
    >
  {/if}
  Hello
  {lowerCaseName()}! I can run in React, Qwik, Vue, Solid, or Web Component!
</div>

<style>
  .input {
    color: red;
  }
</style>"
`;

exports[`Svelte > jsx > Javascript Test > BasicRefAssignment 1`] = `
"<script>
  function handlerClick(event) {
    event.preventDefault();
    console.log(\\"current value\\", holdValueRef);
    holdValueRef = holdValueRef + \\"JS\\";
  }
</script>

<div>
  <button
    on:click={(evt) => {
      handlerClick(evt);
    }}>Click</button
  >
</div>"
`;

exports[`Svelte > jsx > Javascript Test > BasicRefPrevious 1`] = `
"<script>
  export function usePrevious(value) {
    // The ref object is a generic container whose current property is mutable ...
    // ... and can hold any value, similar to an instance property on a class
    let ref = useRef(null); // Store current value in ref

    onUpdate(() => {
      ref = value;
    }, [value]); // Only re-run if value changes
    // Return previous value (happens before update in useEffect above)

    return ref;
  }

  let count = 0;

  function onUpdateFn_0(..._args) {
    prevCount = count;
  }

  $: onUpdateFn_0(...[count]);
</script>

<div>
  <h1>
    Now: {count}, before: {prevCount}
  </h1>
  <button
    on:click={(event) => {
      count += 1;
    }}>Increment</button
  >
</div>"
`;

exports[`Svelte > jsx > Javascript Test > Button 1`] = `
"<script>
  export let link;
  export let attributes;
  export let openLinkInNewTab;
  export let text;
</script>

<div>
  {#if link}
    <a
      {...attributes}
      href={link}
      target={openLinkInNewTab ? \\"_blank\\" : undefined}>{text}</a
    >
  {/if}
  {#if !link}
    <button type=\\"button\\" {...attributes}>{text}</button>
  {/if}
</div>"
`;

exports[`Svelte > jsx > Javascript Test > Columns 1`] = `
"<script>
  export let columns;
  export let space;

  function getColumns() {
    return columns || [];
  }

  function getGutterSize() {
    return typeof space === \\"number\\" ? space || 0 : 20;
  }

  function getWidth(index) {
    const columns = getColumns();
    return (columns[index] && columns[index].width) || 100 / columns.length;
  }

  function getColumnCssWidth(index) {
    const columns = getColumns();
    const gutterSize = getGutterSize();
    const subtractWidth = (gutterSize * (columns.length - 1)) / columns.length;
    return \`calc(\${getWidth(index)}% - \${subtractWidth}px)\`;
  }
</script>

<div class=\\"builder-columns div\\">
  {#each columns as column, index}
    <div class=\\"builder-column div-2\\">{column.content}{index}</div>
  {/each}
</div>

<style>
  .div {
    display: flex;
    flex-direction: column;
    align-items: stretch;
    line-height: normal;
  }
  @media (max-width: 999px) {
    .div {
      flex-direction: row;
    }
  }
  @media (max-width: 639px) {
    .div {
      flex-direction: row-reverse;
    }
  }
  .div-2 {
    flex-grow: 1;
  }
</style>"
`;

exports[`Svelte > jsx > Javascript Test > ContentSlotHtml 1`] = `
"<div>
  <slot name=\\"testing\\" />
  <div><hr /></div>
  <div><slot /></div>
</div>"
`;

exports[`Svelte > jsx > Javascript Test > ContentSlotJSX 1`] = `
"<script>
  export let attributes;
  export let content = \\"\\";

  function show() {
    $$slots.content ? 1 : \\"\\";
  }
  $: cls = () => {
    return $$slots.content && $$slots.default ? \`\${name}-content\` : \\"\\";
  };

  let name = \\"king\\";
  let showContent = false;
</script>

{#if $$slots.reference}
  <div
    name={$$slots.content ? \\"name1\\" : \\"name2\\"}
    title={$$slots.content ? \\"title1\\" : \\"title2\\"}
    {...attributes}
    on:click={(event) => {
      show();
    }}
    class={cls()}
  >
    {#if showContent && $$slots.content}
      <slot name=\\"content\\">{content}</slot>
    {/if}
    <div><hr /></div>
    <div><slot /></div>
  </div>
{/if}"
`;

exports[`Svelte > jsx > Javascript Test > CustomCode 1`] = `
"<script>
  import { onMount } from \\"svelte\\";

  export let replaceNodes;
  export let code;

  function findAndRunScripts() {
    // TODO: Move this function to standalone one in '@builder.io/utils'
    if (elem && typeof window !== \\"undefined\\") {
      /** @type {HTMLScriptElement[]} */
      const scripts = elem.getElementsByTagName(\\"script\\");

      for (let i = 0; i < scripts.length; i++) {
        const script = scripts[i];

        if (script.src) {
          if (scriptsInserted.includes(script.src)) {
            continue;
          }

          scriptsInserted.push(script.src);
          const newScript = document.createElement(\\"script\\");
          newScript.async = true;
          newScript.src = script.src;
          document.head.appendChild(newScript);
        } else if (
          !script.type ||
          [
            \\"text/javascript\\",
            \\"application/javascript\\",
            \\"application/ecmascript\\",
          ].includes(script.type)
        ) {
          if (scriptsRun.includes(script.innerText)) {
            continue;
          }

          try {
            scriptsRun.push(script.innerText);
            new Function(script.innerText)();
          } catch (error) {
            console.warn(\\"\`CustomCode\`: Error running script:\\", error);
          }
        }
      }
    }
  }

  let elem;

  let scriptsInserted = [];
  let scriptsRun = [];

  onMount(() => {
    findAndRunScripts();
  });
</script>

<div
  bind:this={elem}
  class={\\"builder-custom-code\\" + (replaceNodes ? \\" replace-nodes\\" : \\"\\")}
>
  {@html code}
</div>"
`;

exports[`Svelte > jsx > Javascript Test > Embed 1`] = `
"<script>
  import { onMount } from \\"svelte\\";

  export let replaceNodes;
  export let code;

  function findAndRunScripts() {
    // TODO: Move this function to standalone one in '@builder.io/utils'
    if (elem && typeof window !== \\"undefined\\") {
      /** @type {HTMLScriptElement[]} */
      const scripts = elem.getElementsByTagName(\\"script\\");

      for (let i = 0; i < scripts.length; i++) {
        const script = scripts[i];

        if (script.src) {
          if (scriptsInserted.includes(script.src)) {
            continue;
          }

          scriptsInserted.push(script.src);
          const newScript = document.createElement(\\"script\\");
          newScript.async = true;
          newScript.src = script.src;
          document.head.appendChild(newScript);
        } else if (
          !script.type ||
          [
            \\"text/javascript\\",
            \\"application/javascript\\",
            \\"application/ecmascript\\",
          ].includes(script.type)
        ) {
          if (scriptsRun.includes(script.innerText)) {
            continue;
          }

          try {
            scriptsRun.push(script.innerText);
            new Function(script.innerText)();
          } catch (error) {
            console.warn(\\"\`CustomCode\`: Error running script:\\", error);
          }
        }
      }
    }
  }

  let elem;

  let scriptsInserted = [];
  let scriptsRun = [];

  onMount(() => {
    findAndRunScripts();
  });
</script>

<div
  bind:this={elem}
  class={\\"builder-custom-code\\" + (replaceNodes ? \\" replace-nodes\\" : \\"\\")}
>
  {@html code}
</div>"
`;

exports[`Svelte > jsx > Javascript Test > Form 1`] = `
"<script>
  import { Builder, builder } from \\"@builder.io/sdk\\";
  import {
    BuilderBlock as BuilderBlockComponent,
    BuilderBlocks,
    get,
    set,
  } from \\"@fake\\";

  export let previewState;
  export let sendWithJs;
  export let sendSubmissionsTo;
  export let action;
  export let customHeaders;
  export let contentType;
  export let sendSubmissionsToEmail;
  export let name;
  export let method;
  export let errorMessagePath;
  export let resetFormOnSubmit;
  export let successUrl;
  export let validate;
  export let attributes;
  export let builderBlock;
  export let errorMessage;
  export let sendingMessage;
  export let successMessage;

  function onSubmit(event) {
    const sendWithJs = sendWithJs || sendSubmissionsTo === \\"email\\";

    if (sendSubmissionsTo === \\"zapier\\") {
      event.preventDefault();
    } else if (sendWithJs) {
      if (!(action || sendSubmissionsTo === \\"email\\")) {
        event.preventDefault();
        return;
      }

      event.preventDefault();
      const el = event.currentTarget;
      const headers = customHeaders || {};
      let body;
      const formData = new FormData(el); // TODO: maybe support null

      const formPairs = Array.from(
        event.currentTarget.querySelectorAll(\\"input,select,textarea\\")
      )
        .filter((el) => !!el.name)
        .map((el) => {
          let value;
          const key = el.name;

          if (el instanceof HTMLInputElement) {
            if (el.type === \\"radio\\") {
              if (el.checked) {
                value = el.name;
                return {
                  key,
                  value,
                };
              }
            } else if (el.type === \\"checkbox\\") {
              value = el.checked;
            } else if (el.type === \\"number\\" || el.type === \\"range\\") {
              const num = el.valueAsNumber;

              if (!isNaN(num)) {
                value = num;
              }
            } else if (el.type === \\"file\\") {
              // TODO: one vs multiple files
              value = el.files;
            } else {
              value = el.value;
            }
          } else {
            value = el.value;
          }

          return {
            key,
            value,
          };
        });
      let contentType = contentType;

      if (sendSubmissionsTo === \\"email\\") {
        contentType = \\"multipart/form-data\\";
      }

      Array.from(formPairs).forEach(({ value }) => {
        if (
          value instanceof File ||
          (Array.isArray(value) && value[0] instanceof File) ||
          value instanceof FileList
        ) {
          contentType = \\"multipart/form-data\\";
        }
      }); // TODO: send as urlEncoded or multipart by default
      // because of ease of use and reliability in browser API
      // for encoding the form?

      if (contentType !== \\"application/json\\") {
        body = formData;
      } else {
        // Json
        const json = {};
        Array.from(formPairs).forEach(({ value, key }) => {
          set(json, key, value);
        });
        body = JSON.stringify(json);
      }

      if (contentType && contentType !== \\"multipart/form-data\\") {
        if (
          /* Zapier doesn't allow content-type header to be sent from browsers */
          !(sendWithJs && action?.includes(\\"zapier.com\\"))
        ) {
          headers[\\"content-type\\"] = contentType;
        }
      }

      const presubmitEvent = new CustomEvent(\\"presubmit\\", {
        detail: {
          body,
        },
      });

      if (formRef) {
        formRef.dispatchEvent(presubmitEvent);

        if (presubmitEvent.defaultPrevented) {
          return;
        }
      }

      formState = \\"sending\\";
      const formUrl = \`\${
        builder.env === \\"dev\\" ? \\"http://localhost:5000\\" : \\"https://builder.io\\"
      }/api/v1/form-submit?apiKey=\${builder.apiKey}&to=\${btoa(
        sendSubmissionsToEmail || \\"\\"
      )}&name=\${encodeURIComponent(name || \\"\\")}\`;
      fetch(
        sendSubmissionsTo === \\"email\\" ? formUrl : action,
        /* TODO: throw error if no action URL */
        {
          body,
          headers,
          method: method || \\"post\\",
        }
      ).then(
        async (res) => {
          let body;
          const contentType = res.headers.get(\\"content-type\\");

          if (contentType && contentType.indexOf(\\"application/json\\") !== -1) {
            body = await res.json();
          } else {
            body = await res.text();
          }

          if (!res.ok && errorMessagePath) {
            /* TODO: allow supplying an error formatter function */
            let message = get(body, errorMessagePath);

            if (message) {
              if (typeof message !== \\"string\\") {
                /* TODO: ideally convert json to yaml so it woul dbe like
           error: - email has been taken */
                message = JSON.stringify(message);
              }

              formErrorMessage = message;
            }
          }

          responseData = body;
          formState = res.ok ? \\"success\\" : \\"error\\";

          if (res.ok) {
            const submitSuccessEvent = new CustomEvent(\\"submit:success\\", {
              detail: {
                res,
                body,
              },
            });

            if (formRef) {
              formRef.dispatchEvent(submitSuccessEvent);

              if (submitSuccessEvent.defaultPrevented) {
                return;
              }
              /* TODO: option to turn this on/off? */

              if (resetFormOnSubmit !== false) {
                formRef.reset();
              }
            }
            /* TODO: client side route event first that can be preventDefaulted */

            if (successUrl) {
              if (formRef) {
                const event = new CustomEvent(\\"route\\", {
                  detail: {
                    url: successUrl,
                  },
                });
                formRef.dispatchEvent(event);

                if (!event.defaultPrevented) {
                  location.href = successUrl;
                }
              } else {
                location.href = successUrl;
              }
            }
          }
        },
        (err) => {
          const submitErrorEvent = new CustomEvent(\\"submit:error\\", {
            detail: {
              error: err,
            },
          });

          if (formRef) {
            formRef.dispatchEvent(submitErrorEvent);

            if (submitErrorEvent.defaultPrevented) {
              return;
            }
          }

          responseData = err;
          formState = \\"error\\";
        }
      );
    }
  }
  $: submissionState = () => {
    return (Builder.isEditing && previewState) || formState;
  };

  let formRef;

  let formState = \\"unsubmitted\\";
  let responseData = null;
  let formErrorMessage = \\"\\";
</script>

<form
  {validate}
  bind:this={formRef}
  action={!sendWithJs && action}
  {method}
  {name}
  on:submit={(event) => {
    onSubmit(event);
  }}
  {...attributes}
>
  {#if builderBlock && builderBlock.children}
    {#each builderBlock?.children as block, index (block.id)}
      <BuilderBlockComponent {block} {index} />
    {/each}
  {/if}
  {#if submissionState() === \\"error\\"}
    <BuilderBlocks dataPath=\\"errorMessage\\" blocks={errorMessage} />
  {/if}
  {#if submissionState() === \\"sending\\"}
    <BuilderBlocks dataPath=\\"sendingMessage\\" blocks={sendingMessage} />
  {/if}
  {#if submissionState() === \\"error\\" && responseData}
    <pre class=\\"builder-form-error-text pre\\">{JSON.stringify(
        responseData,
        null,
        2
      )}</pre>
  {/if}
  {#if submissionState() === \\"success\\"}
    <BuilderBlocks dataPath=\\"successMessage\\" blocks={successMessage} />
  {/if}
</form>

<style>
  .pre {
    padding: 10px;
    color: red;
    text-align: center;
  }
</style>"
`;

exports[`Svelte > jsx > Javascript Test > Image 1`] = `
"<script>
  import { onDestroy, onMount } from \\"svelte\\";

  export let lazy;
  export let altText;
  export let _class;
  export let image;
  export let srcset;
  export let sizes;

  function setLoaded() {
    imageLoaded = true;
  }

  function useLazyLoading() {
    // TODO: Add more checks here, like testing for real web browsers
    return !!lazy && isBrowser();
  }

  function isBrowser() {
    return (
      typeof window !== \\"undefined\\" && window.navigator.product != \\"ReactNative\\"
    );
  }

  let pictureRef;

  let scrollListener = null;
  let imageLoaded = false;
  let load = false;

  onMount(() => {
    if (useLazyLoading()) {
      // throttled scroll capture listener
      const listener = () => {
        if (pictureRef) {
          const rect = pictureRef.getBoundingClientRect();
          const buffer = window.innerHeight / 2;

          if (rect.top < window.innerHeight + buffer) {
            load = true;
            scrollListener = null;
            window.removeEventListener(\\"scroll\\", listener);
          }
        }
      };

      scrollListener = listener;
      window.addEventListener(\\"scroll\\", listener, {
        capture: true,
        passive: true,
      });
      listener();
    }
  });

  onDestroy(() => {
    if (scrollListener) {
      window.removeEventListener(\\"scroll\\", scrollListener);
    }
  });
</script>

<div>
  <picture bind:this={pictureRef}>
    {#if !useLazyLoading() || load}
      <img
        alt={altText}
        aria-role={altText ? \\"presentation\\" : undefined}
        class={\\"builder-image\\" + (_class ? \\" \\" + _class : \\"\\") + \\" img\\"}
        src={image}
        on:load={(event) => {
          setLoaded();
        }}
        {srcset}
        {sizes}
      />
    {/if}<source {srcset} /></picture
  ><slot />
</div>

<style>
  .img {
    opacity: 1;
    transition: opacity 0.2s ease-in-out;
    object-fit: cover;
    object-position: center;
  }
</style>"
`;

exports[`Svelte > jsx > Javascript Test > Image State 1`] = `
"<script>
  let canShow = true;
  let images = [\\"http://example.com/qwik.png\\"];
</script>

<div>
  {#each images as item, itemIndex}
    <img class=\\"custom-class\\" src={item} key={itemIndex} />
  {/each}
</div>"
`;

exports[`Svelte > jsx > Javascript Test > Img 1`] = `
"<script>
  import { Builder } from \\"@builder.io/sdk\\";

  export let backgroundSize;
  export let backgroundPosition;
  export let attributes;
  export let imgSrc;
  export let altText;
  function stringifyStyles(stylesObj) {
    let styles = \\"\\";
    for (let key in stylesObj) {
      const dashedKey = key.replace(/[A-Z]/g, function (match) {
        return \\"-\\" + match.toLowerCase();
      });
      styles += dashedKey + \\":\\" + stylesObj[key] + \\";\\";
    }
    return styles;
  }
</script>

<img
  style={stringifyStyles({
    objectFit: backgroundSize || \\"cover\\",
    objectPosition: backgroundPosition || \\"center\\",
  })}
  {...attributes}
  key={(Builder.isEditing && imgSrc) || \\"default-key\\"}
  alt={altText}
  src={imgSrc}
/>"
`;

exports[`Svelte > jsx > Javascript Test > Input 1`] = `
"<script>
  import { Builder } from \\"@builder.io/sdk\\";

  export let attributes;
  export let defaultValue;
  export let placeholder;
  export let type;
  export let name;
  export let value;
  export let required;
  export let onChange;
</script>

<input
  {...attributes}
  key={Builder.isEditing && defaultValue ? defaultValue : \\"default-key\\"}
  {placeholder}
  {type}
  {name}
  {value}
  {defaultValue}
  {required}
  on:change={(event) => {
    onChange?.(event.target.value);
  }}
/>"
`;

exports[`Svelte > jsx > Javascript Test > InputParent 1`] = `
"<script>
  import FormInputComponent from \\"./input.raw\\";

  function handleChange(value) {
    console.log(value);
  }
</script>

<FormInputComponent
  name=\\"kingzez\\"
  type=\\"text\\"
  onChange={(value) => handleChange(value)}
/>"
`;

exports[`Svelte > jsx > Javascript Test > RawText 1`] = `
"<script>
  export let attributes;
  export let text;
</script>

<span class={attributes?.class || attributes?.className}
  >{@html text || \\"\\"}</span
>"
`;

exports[`Svelte > jsx > Javascript Test > Section 1`] = `
"<script>
  export let attributes;
  export let maxWidth;

  function stringifyStyles(stylesObj) {
    let styles = \\"\\";
    for (let key in stylesObj) {
      const dashedKey = key.replace(/[A-Z]/g, function (match) {
        return \\"-\\" + match.toLowerCase();
      });
      styles += dashedKey + \\":\\" + stylesObj[key] + \\";\\";
    }
    return styles;
  }
</script>

<section
  style={stringifyStyles(
    maxWidth && typeof maxWidth === \\"number\\"
      ? {
          maxWidth: maxWidth,
        }
      : undefined
  )}
  {...attributes}
>
  <slot />
</section>"
`;

exports[`Svelte > jsx > Javascript Test > Section 2`] = `
"<script>
  export let attributes;

  function stringifyStyles(stylesObj) {
    let styles = \\"\\";
    for (let key in stylesObj) {
      const dashedKey = key.replace(/[A-Z]/g, function (match) {
        return \\"-\\" + match.toLowerCase();
      });
      styles += dashedKey + \\":\\" + stylesObj[key] + \\";\\";
    }
    return styles;
  }

  let max = 42;
  let items = [42];
</script>

{#if max}
  {#each items as item}
    <section
      style={stringifyStyles({
        maxWidth: item + max,
      })}
      {...attributes}
    >
      <slot />
    </section>
  {/each}
{/if}"
`;

exports[`Svelte > jsx > Javascript Test > Select 1`] = `
"<script>
  import { Builder } from \\"@builder.io/sdk\\";

  export let attributes;
  export let value;
  export let defaultValue;
  export let name;
  export let options;
</script>

<select
  {...attributes}
  {value}
  key={Builder.isEditing && defaultValue ? defaultValue : \\"default-key\\"}
  {defaultValue}
  {name}
>
  {#each options as option, index}
    <option value={option.value} data-index={index}
      >{option.name || option.value}</option
    >
  {/each}
</select>"
`;

exports[`Svelte > jsx > Javascript Test > SlotDefault 1`] = `"<div><slot><div class=\\"default-slot\\">Default content</div></slot></div>"`;

exports[`Svelte > jsx > Javascript Test > SlotHtml 1`] = `
"<script>
  import ContentSlotCode from \\"./content-slot-jsx.raw\\";
</script>

<div>
  <ContentSlotCode>
    <span #testing>
      <div>Hello</div>
    </span>
  </ContentSlotCode>
</div>"
`;

exports[`Svelte > jsx > Javascript Test > SlotJsx 1`] = `
"<script >




import  ContentSlotCode from './content-slot-jsx.raw';
























</script>

<div ><ContentSlotCode  slotTesting={<div>Hello</div>} ></ContentSlotCode></div>"
`;

exports[`Svelte > jsx > Javascript Test > SlotNamed 1`] = `
"<div>
  <slot name=\\"my-awesome-slot\\" /><slot name=\\"top\\" /><slot name=\\"left\\"
    >Default left</slot
  ><slot>Default Child</slot>
</div>"
`;

exports[`Svelte > jsx > Javascript Test > Stamped.io 1`] = `
"<script>
  import { onMount } from \\"svelte\\";

  import { kebabCase, snakeCase } from \\"lodash\\";

  export let apiKey;
  export let productId;

  function kebabCaseValue() {
    return kebabCase(\\"testThat\\");
  }

  function snakeCaseValue() {
    return snakeCase(\\"testThis\\");
  }

  let reviews = [];
  let name = \\"test\\";
  let showReviewPrompt = false;

  onMount(() => {
    fetch(
      \`https://stamped.io/api/widget/reviews?storeUrl=builder-io.myshopify.com&apiKey=\${
        apiKey || \\"pubkey-8bbDq7W6w4sB3OWeM1HUy2s47702hM\\"
      }&productId=\${productId || \\"2410511106127\\"}\`
    )
      .then((res) => res.json())
      .then((data) => {
        reviews = data.data;
      });
  });
</script>

<div data-user={name}>
  <button
    on:click={(event) => {
      showReviewPrompt = true;
    }}>Write a review</button
  >
  {#if showReviewPrompt || \\"asdf\\"}
    <input placeholder=\\"Email\\" />
    <input placeholder=\\"Title\\" class=\\"input\\" />
    <textarea placeholder=\\"How was your experience?\\" class=\\"textarea\\" />
    <button
      class=\\"button\\"
      on:click={(event) => {
        event.preventDefault();
        showReviewPrompt = false;
      }}
    >
      Submit
    </button>
  {/if}
  {#each reviews as review, index (review.id)}
    <div class=\\"review\\">
      <img class=\\"img\\" src={review.avatar} />
      <div class={showReviewPrompt ? \\"bg-primary\\" : \\"bg-secondary\\"}>
        <div>N: {index}</div>
        <div>{review.author}</div>
        <div>{review.reviewMessage}</div>
      </div>
    </div>
  {/each}
</div>

<style>
  .input {
    display: block;
  }
  .textarea {
    display: block;
  }
  .button {
    display: block;
  }
  .review {
    margin: 10px;
    padding: 10px;
    background: white;
    display: flex;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    -webkit-font-smoothing: antialiased;
  }
  .img {
    height: 30px;
    width: 30px;
    margin-right: 10px;
  }
</style>"
`;

exports[`Svelte > jsx > Javascript Test > Submit 1`] = `
"<script>
  export let attributes;
  export let text;
</script>

<button type=\\"submit\\" {...attributes}>{text}</button>"
`;

exports[`Svelte > jsx > Javascript Test > Text 1`] = `
"<script>
  import { Builder } from \\"@builder.io/sdk\\";

  export let text;
  export let content;

  let name = \\"Decadef20\\";
</script>

<div
  contentEditable={allowEditingText || undefined}
  data-name={{
    test: name || \\"any name\\",
  }}
>
  {@html text || content || name || '<p class=\\"text-lg\\">my name</p>'}
</div>"
`;

exports[`Svelte > jsx > Javascript Test > Textarea 1`] = `
"<script>
  export let attributes;
  export let placeholder;
  export let name;
  export let value;
  export let defaultValue;
</script>

<textarea {...attributes} {placeholder} {name} {value} {defaultValue} />"
`;

exports[`Svelte > jsx > Javascript Test > Video 1`] = `
"<script>
  export let attributes;
  export let fit;
  export let position;
  export let video;
  export let posterImage;
  export let autoPlay;
  export let muted;
  export let controls;
  export let loop;
  function stringifyStyles(stylesObj) {
    let styles = \\"\\";
    for (let key in stylesObj) {
      const dashedKey = key.replace(/[A-Z]/g, function (match) {
        return \\"-\\" + match.toLowerCase();
      });
      styles += dashedKey + \\":\\" + stylesObj[key] + \\";\\";
    }
    return styles;
  }
</script>

<video
  style={stringifyStyles({
    width: \\"100%\\",
    height: \\"100%\\",
    ...attributes?.style,
    objectFit: fit,
    objectPosition: position,
    // Hack to get object fit to work as expected and
    // not have the video overflow
    borderRadius: 1,
  })}
  preload=\\"none\\"
  {...attributes}
  key={video || \\"no-src\\"}
  poster={posterImage}
  autoplay={autoPlay}
  {muted}
  {controls}
  {loop}
/>"
`;

exports[`Svelte > jsx > Javascript Test > arrowFunctionInUseStore 1`] = `
"<script>
  function setName(value) {
    name = value;
  }

  function updateNameWithArrowFn(value) {
    name = value;
  }

  let name = \\"steve\\";
</script>

<div>Hello {name}</div>"
`;

exports[`Svelte > jsx > Javascript Test > basicForNoTagReference 1`] = `
"<script>
  export let actions;

  $: TagNameGetter = () => {
    return \\"span\\";
  };

  let name = \\"VincentW\\";
  let TagName = \\"div\\";
  let tag = \\"span\\";
</script>

<svelte:component this={TagNameGetter()}>
  Hello <svelte:component this={tag}>{name}</svelte:component>
  {#each actions as action}
    <svelte:component this={TagName}
      ><svelte:component this={action.icon} /><span>{action.text}</span
      ></svelte:component
    >
  {/each}
</svelte:component>"
`;

exports[`Svelte > jsx > Javascript Test > basicForwardRef 1`] = `
"<script>
  export let inputRef;

  let name = \\"PatrickJS\\";
</script>

<div><input class=\\"input\\" bind:this={inputRef} bind:value={name} /></div>

<style>
  .input {
    color: red;
  }
</style>"
`;

exports[`Svelte > jsx > Javascript Test > basicForwardRefMetadata 1`] = `
"<script>
  export let inputRef;

  let name = \\"PatrickJS\\";
</script>

<div><input class=\\"input\\" bind:this={inputRef} bind:value={name} /></div>

<style>
  .input {
    color: red;
  }
</style>"
`;

exports[`Svelte > jsx > Javascript Test > basicOnUpdateReturn 1`] = `
"<script>
  let name = \\"PatrickJS\\";

  function onUpdateFn_0(..._args) {
    const controller = new AbortController();
    const signal = controller.signal;
    fetch(\\"https://patrickjs.com/api/resource.json\\", {
      signal,
    })
      .then((response) => response.json())
      .then((data) => {
        name = data.name;
      });
    return () => {
      if (!signal.aborted) {
        controller.abort();
      }
    };
  }

  $: onUpdateFn_0(...[name]);
</script>

<div>Hello! {name}</div>"
`;

exports[`Svelte > jsx > Javascript Test > class + ClassName + css 1`] = `
"<div class=\\"test2 test div\\">
  Hello! I can run in React, Vue, Solid, or Liquid!
</div>

<style>
  .div {
    padding: 10px;
  }
</style>"
`;

exports[`Svelte > jsx > Javascript Test > class + css 1`] = `
"<div class=\\"test div\\">Hello! I can run in React, Vue, Solid, or Liquid!</div>

<style>
  .div {
    padding: 10px;
  }
</style>"
`;

exports[`Svelte > jsx > Javascript Test > className + css 1`] = `
"<div class=\\"test div\\">Hello! I can run in React, Vue, Solid, or Liquid!</div>

<style>
  .div {
    padding: 10px;
  }
</style>"
`;

exports[`Svelte > jsx > Javascript Test > className 1`] = `
"<script>
  let bindings = \\"a binding\\";
</script>

<div>
  <div class=\\"no binding\\">Without Binding</div>
  <div class={bindings}>With binding</div>
</div>"
`;

exports[`Svelte > jsx > Javascript Test > classState 1`] = `
"<script>
  function stringifyStyles(stylesObj) {
    let styles = \\"\\";
    for (let key in stylesObj) {
      const dashedKey = key.replace(/[A-Z]/g, function (match) {
        return \\"-\\" + match.toLowerCase();
      });
      styles += dashedKey + \\":\\" + stylesObj[key] + \\";\\";
    }
    return styles;
  }

  let classState = \\"testClassName\\";
  let styleState = {
    color: \\"red\\",
  };
</script>

<div style={stringifyStyles(styleState)} class={classState + \\" div\\"}>
  Hello! I can run in React, Vue, Solid, or Liquid!
</div>

<style>
  .div {
    padding: 10px;
  }
</style>"
`;

exports[`Svelte > jsx > Javascript Test > componentWithContext 1`] = `
"<script>
  import { getContext, setContext } from \\"svelte\\";

  import Context1 from \\"@dummy/1\\";
  import Context2 from \\"@dummy/2\\";

  export let content;

  let foo = getContext(Context1.key);

  setContext(Context1.key, {
    foo: \\"bar\\",

    content() {
      return content;
    },
  });
  setContext(Context2.key, {
    bar: \\"baz\\",
  });
</script>

{foo.value}"
`;

exports[`Svelte > jsx > Javascript Test > componentWithContextMultiRoot 1`] = `
"<script>
  import { getContext, setContext } from \\"svelte\\";

  import Context1 from \\"@dummy/1\\";
  import Context2 from \\"@dummy/2\\";

  export let content;

  let foo = getContext(Context1.key);

  setContext(Context1.key, {
    foo: \\"bar\\",

    content() {
      return content;
    },
  });
  setContext(Context2.key, {
    bar: \\"baz\\",
  });
</script>

{foo.value}
<div>other</div>"
`;

exports[`Svelte > jsx > Javascript Test > contentState 1`] = `
"<script>
  import { setContext } from \\"svelte\\";

  import BuilderContext from \\"@dummy/context.js\\";

  export let content;
  export let customComponents;

  setContext(BuilderContext.key, {
    content: content,
    registeredComponents: customComponents,
  });
</script>

<div>setting context</div>"
`;

exports[`Svelte > jsx > Javascript Test > defaultProps 1`] = `
"<script>
  export let link = \\"https://builder.io/\\";
  export let attributes;
  export let openLinkInNewTab = false;
  export let text = \\"default text\\";
  export let onClick = () => {
    console.log(\\"hi\\");
  };
  export let buttonText;
</script>

<div>
  {#if link}
    <a
      {...attributes}
      href={link}
      target={openLinkInNewTab ? \\"_blank\\" : undefined}>{text}</a
    >
  {/if}
  {#if !link}
    <button
      type=\\"button\\"
      {...attributes}
      on:click={(event) => {
        onClick(event);
      }}>{buttonText}</button
    >
  {/if}
</div>"
`;

exports[`Svelte > jsx > Javascript Test > defaultPropsOutsideComponent 1`] = `
"<script>
  export let link = \\"https://builder.io/\\";
  export let attributes;
  export let openLinkInNewTab = false;
  export let text = \\"default text\\";
  export let onClick = () => {};
</script>

<div>
  {#if link}
    <a
      {...attributes}
      href={link}
      target={openLinkInNewTab ? \\"_blank\\" : undefined}>{text}</a
    >
  {/if}
  {#if !link}
    <button
      type=\\"button\\"
      {...attributes}
      on:click={(event) => {
        onClick(event);
      }}>{text}</button
    >
  {/if}
</div>"
`;

exports[`Svelte > jsx > Javascript Test > defaultValsWithTypes 1`] = `
"<script>
  const DEFAULT_VALUES = {
    name: \\"Sami\\",
  };

  export let name;
</script>

<div>Hello {name || DEFAULT_VALUES.name}</div>"
`;

exports[`Svelte > jsx > Javascript Test > expressionState 1`] = `
"<script>
  export let componentRef;

  let refToUse = !(componentRef instanceof Function) ? componentRef : null;
</script>

<div>{refToUse}</div>"
`;

exports[`Svelte > jsx > Javascript Test > getterState 1`] = `
"<script>
  export let foo;

  function baz(i) {
    return i + foo2().length;
  }
  $: foo2 = () => {
    return foo + \\"foo\\";
  };

  $: bar = () => {
    return \\"bar\\";
  };
</script>

<div>
  <p>{foo2()}</p>
  <p>{bar()}</p>
  <p>{baz(1)}</p>
</div>"
`;

exports[`Svelte > jsx > Javascript Test > import types 1`] = `
"<script>
  import RenderBlock from \\"./builder-render-block.raw\\";

  export let renderContentProps;

  function getRenderContentProps(block, index) {
    return {
      block: block,
      index: index,
    };
  }
</script>

<RenderBlock {...getRenderContentProps(renderContentProps.block, 0)} />"
`;

exports[`Svelte > jsx > Javascript Test > multipleOnUpdate 1`] = `
"<script>
  import { afterUpdate } from \\"svelte\\";

  afterUpdate(() => {
    console.log(\\"Runs on every update/rerender\\");
  });
  afterUpdate(() => {
    console.log(\\"Runs on every update/rerender as well\\");
  });
</script>

<div />"
`;

exports[`Svelte > jsx > Javascript Test > multipleOnUpdateWithDeps 1`] = `
"<script>
  let a = \\"a\\";
  let b = \\"b\\";
  let c = \\"c\\";
  let d = \\"d\\";

  function onUpdateFn_0(..._args) {
    console.log(\\"Runs when a or b changes\\", a, b);

    if (a === \\"a\\") {
      a = \\"b\\";
    }
  }

  $: onUpdateFn_0(...[a, b]);

  function onUpdateFn_1(..._args) {
    console.log(\\"Runs when c or d changes\\", c, d);

    if (a === \\"a\\") {
      a = \\"b\\";
    }
  }

  $: onUpdateFn_1(...[c, d]);
</script>

<div />"
`;

exports[`Svelte > jsx > Javascript Test > multipleSpreads 1`] = `
"<script>
  let attrs = {
    hello: \\"world\\",
  };
</script>

<input {...attrs} {...$$props} />"
`;

exports[`Svelte > jsx > Javascript Test > nestedShow 1`] = `
"<script>
  export let conditionA;
  export let conditionB;
</script>

{#if conditionA}
  {#if !conditionB}
    <div>if condition A and condition B</div>
  {:else}
    <div>else-condition-B</div>
  {/if}
{:else}
  <div>else-condition-A</div>
{/if}"
`;

exports[`Svelte > jsx > Javascript Test > nestedStyles 1`] = `
"<div class=\\"div\\">Hello world</div>

<style>
  .div {
    display: flex;
    --bar: red;
    color: var(--bar);
  }
  @media (max-width: env(--mobile)) {
    .div {
      display: block;
    }
  }
  .div:hover {
    display: flex;
  }
  .div:active {
    display: inline;
  }
  .div .nested-selector {
    display: grid;
  }
  .div .nested-selector:hover {
    display: block;
  }
  .div.nested-selector:active {
    display: inline-block;
  }
</style>"
`;

exports[`Svelte > jsx > Javascript Test > onEvent 1`] = `
"<script>
  import { onMount } from \\"svelte\\";

  function foo(event) {
    console.log(\\"test2\\");
  }

  function elem_onInitEditingBldr(event) {
    console.log(\\"test\\");
    foo(event);
  }

  let elem;

  onMount(() => {
    elem.dispatchEvent(new CustomEvent(\\"initEditingBldr\\"));
  });
</script>

<div
  class=\\"builder-embed\\"
  bind:this={elem}
  on:initeditingbldr={(event) => {
    elem_onInitEditingBldr(event);
  }}
>
  <div>Test</div>
</div>"
`;

exports[`Svelte > jsx > Javascript Test > onInit & onMount 1`] = `
"<script>
  import { onMount } from \\"svelte\\";

  console.log(\\"onInit\\");

  onMount(() => {
    console.log(\\"onMount\\");
  });
</script>

<div />"
`;

exports[`Svelte > jsx > Javascript Test > onInit 1`] = `
"<script>
  export const defaultValues = {
    name: \\"PatrickJS\\",
  };

  export let name;

  let name = \\"\\";
  name = defaultValues.name || name;
  console.log(\\"set defaults with props\\");
</script>

<div>Default name defined by parent {name}</div>"
`;

exports[`Svelte > jsx > Javascript Test > onMount 1`] = `
"<script>
  import { onDestroy, onMount } from \\"svelte\\";

  onMount(() => {
    console.log(\\"Runs on mount\\");
  });

  onDestroy(() => {
    console.log(\\"Runs on unMount\\");
  });
</script>

<div />"
`;

exports[`Svelte > jsx > Javascript Test > onMountMultiple 1`] = `
"<script>
  import { onMount } from \\"svelte\\";

  onMount(() => {
    console.log(\\"Runs on mount\\");
  });
  onMount(() => {
    console.log(\\"Another one runs on Mount\\");
  });
  onMount(() => {
    console.log(\\"SSR runs on Mount\\");
  });
</script>

<div />"
`;

exports[`Svelte > jsx > Javascript Test > onUpdate 1`] = `
"<script>
  import { afterUpdate } from \\"svelte\\";

  afterUpdate(() => {
    console.log(\\"Runs on every update/rerender\\");
  });
</script>

<div />"
`;

exports[`Svelte > jsx > Javascript Test > onUpdateWithDeps 1`] = `
"<script>
  export let size;

  let a = \\"a\\";
  let b = \\"b\\";

  function onUpdateFn_0(..._args) {
    console.log(\\"Runs when a, b or size changes\\", a, b, size);
  }

  $: onUpdateFn_0(...[a, b, size]);
</script>

<div />"
`;

exports[`Svelte > jsx > Javascript Test > preserveExportOrLocalStatement 1`] = `
"<script>
  const b = 3;
  const foo = () => {};
  export const a = 3;
  export const bar = () => {};
  export function run(value) {}
</script>

<div />"
`;

exports[`Svelte > jsx > Javascript Test > preserveTyping 1`] = `
"<script>
  export let name;
</script>

<div>Hello! I can run in React, Vue, Solid, or Liquid! {name}</div>"
`;

exports[`Svelte > jsx > Javascript Test > propsDestructure 1`] = `
"<script>
  export let type;

  let name = \\"Decadef20\\";
</script>

<div>
  <slot />{type}
  Hello! I can run in React, Vue, Solid, or Liquid!
</div>"
`;

exports[`Svelte > jsx > Javascript Test > propsInterface 1`] = `
"<script>
  export let name;
</script>

<div>Hello! I can run in React, Vue, Solid, or Liquid! {name}</div>"
`;

exports[`Svelte > jsx > Javascript Test > propsType 1`] = `
"<script>
  export let name;
</script>

<div>Hello! I can run in React, Vue, Solid, or Liquid! {name}</div>"
`;

exports[`Svelte > jsx > Javascript Test > referencingFunInsideHook 1`] = `
"<script>
  import { afterUpdate } from \\"svelte\\";

  function foo(params) {}

  function bar() {}

  function zoo() {
    const params = {
      cb: bar,
    };
  }

  afterUpdate(() => {
    foo({
      someOption: bar,
    });
  });
</script>

<div />"
`;

exports[`Svelte > jsx > Javascript Test > renderBlock 1`] = `
"<script>
  import { TARGET } from \\"../../constants/target.js\\";
  import { evaluate } from \\"../../functions/evaluate.js\\";
  import { extractTextStyles } from \\"../../functions/extract-text-styles.js\\";
  import { getBlockActions } from \\"../../functions/get-block-actions.js\\";
  import { getBlockComponentOptions } from \\"../../functions/get-block-component-options.js\\";
  import { getBlockProperties } from \\"../../functions/get-block-properties.js\\";
  import { getBlockTag } from \\"../../functions/get-block-tag.js\\";
  import { getProcessedBlock } from \\"../../functions/get-processed-block.js\\";
  import { getReactNativeBlockStyles } from \\"../../functions/get-react-native-block-styles.js\\";
  import BlockStyles from \\"./block-styles.svelte\\";
  import { isEmptyHtmlElement } from \\"./render-block.helpers.js\\";
  import RenderComponentWithContext from \\"./render-component-with-context.js\\";
  import RenderComponent from \\"./render-component.svelte\\";
  import RenderRepeatedBlock from \\"./render-repeated-block.svelte\\";

  export let block;
  export let context;

  $: component = () => {
    const componentName = getProcessedBlock({
      block: block,
      state: context.state,
      context: context.context,
      shouldEvaluateBindings: false,
    }).component?.name;

    if (!componentName) {
      return null;
    }

    const ref = context.registeredComponents[componentName];

    if (!ref) {
      // TODO: Public doc page with more info about this message
      console.warn(\`
          Could not find a registered component named \\"\${componentName}\\".
          If you registered it, is the file that registered it imported by the file that needs to render it?\`);
      return undefined;
    } else {
      return ref;
    }
  };

  $: tag = () => {
    return getBlockTag(useBlock());
  };

  $: useBlock = () => {
    return repeatItemData()
      ? block
      : getProcessedBlock({
          block: block,
          state: context.state,
          context: context.context,
          shouldEvaluateBindings: true,
        });
  };

  $: actions = () => {
    return getBlockActions({
      block: useBlock(),
      state: context.state,
      context: context.context,
    });
  };

  $: attributes = () => {
    const blockProperties = getBlockProperties(useBlock());
    return {
      ...blockProperties,
      ...(TARGET === \\"reactNative\\"
        ? {
            style: getReactNativeBlockStyles({
              block: useBlock(),
              context: context,
              blockStyles: blockProperties.style,
            }),
          }
        : {}),
    };
  };

  $: shouldWrap = () => {
    return !component?.()?.noWrap;
  };

  $: renderComponentProps = () => {
    return {
      blockChildren: useChildren(),
      componentRef: component?.()?.component,
      componentOptions: {
        ...getBlockComponentOptions(useBlock()),

        /**
         * These attributes are passed to the wrapper element when there is one. If \`noWrap\` is set to true, then
         * they are provided to the component itself directly.
         */
        ...(shouldWrap()
          ? {}
          : {
              attributes: { ...attributes(), ...actions() },
            }),
        customBreakpoints: childrenContext?.()?.content?.meta?.breakpoints,
      },
      context: childrenContext(),
    };
  };

  $: useChildren = () => {
    // TO-DO: When should \`canHaveChildren\` dictate rendering?
    // This is currently commented out because some Builder components (e.g. Box) do not have \`canHaveChildren: true\`,
    // but still receive and need to render children.
    // return state.componentInfo?.canHaveChildren ? useBlock().children : [];
    return useBlock().children ?? [];
  };

  $: childrenWithoutParentComponent = () => {
    /**
     * When there is no \`componentRef\`, there might still be children that need to be rendered. In this case,
     * we render them outside of \`componentRef\`.
     * NOTE: We make sure not to render this if \`repeatItemData\` is non-null, because that means we are rendering an array of
     * blocks, and the children will be repeated within those blocks.
     */
    const shouldRenderChildrenOutsideRef =
      !component?.()?.component && !repeatItemData();
    return shouldRenderChildrenOutsideRef ? useChildren() : [];
  };

  $: repeatItemData = () => {
    /**
     * we don't use \`useBlock()\` here because the processing done within its logic includes evaluating the block's bindings,
     * which will not work if there is a repeat.
     */
    const { repeat, ...blockWithoutRepeat } = block;

    if (!repeat?.collection) {
      return undefined;
    }

    const itemsArray = evaluate({
      code: repeat.collection,
      state: context.state,
      context: context.context,
    });

    if (!Array.isArray(itemsArray)) {
      return undefined;
    }

    const collectionName = repeat.collection.split(\\".\\").pop();
    const itemNameToUse =
      repeat.itemName || (collectionName ? collectionName + \\"Item\\" : \\"item\\");
    const repeatArray = itemsArray.map((item, index) => ({
      context: {
        ...context,
        state: {
          ...context.state,
          $index: index,
          $item: item,
          [itemNameToUse]: item,
          [\`$\${itemNameToUse}Index\`]: index,
        },
      },
      block: blockWithoutRepeat,
    }));
    return repeatArray;
  };

  $: inheritedTextStyles = () => {
    if (TARGET !== \\"reactNative\\") {
      return {};
    }

    const styles = getReactNativeBlockStyles({
      block: useBlock(),
      context: context,
      blockStyles: attributes().style,
    });
    return extractTextStyles(styles);
  };

  $: childrenContext = () => {
    return {
      apiKey: context.apiKey,
      state: context.state,
      content: context.content,
      context: context.context,
      registeredComponents: context.registeredComponents,
      inheritedStyles: inheritedTextStyles(),
    };
  };

  $: renderComponentTag = () => {
    if (TARGET === \\"reactNative\\") {
      return RenderComponentWithContext;
    } else if (TARGET === \\"vue3\\") {
      // vue3 expects a string for the component tag
      return \\"RenderComponent\\";
    } else {
      return RenderComponent;
    }
  };
</script>

{#if shouldWrap()}
  {#if isEmptyHtmlElement(tag())}
    <svelte:component this={tag()} {...attributes()} {...actions()} />
  {/if}

  {#if !isEmptyHtmlElement(tag()) && repeatItemData()}
    {#each repeatItemData() as data, index (index)}
      <RenderRepeatedBlock repeatContext={data.context} block={data.block} />
    {/each}
  {/if}

  {#if !isEmptyHtmlElement(tag()) && !repeatItemData()}
    <svelte:component this={tag()} {...attributes()} {...actions()}
      ><svelte:component
        this={renderComponentTag()}
        {...renderComponentProps()}
      />
      {#each childrenWithoutParentComponent() as child (\\"render-block-\\" + child.id)}
        <svelte:self block={child} context={childrenContext()} />
      {/each}

      {#each childrenWithoutParentComponent() as child (\\"block-style-\\" + child.id)}
        <BlockStyles block={child} context={childrenContext()} />
      {/each}
    </svelte:component>
  {/if}
{:else}
  <svelte:component this={renderComponentTag()} {...renderComponentProps()} />
{/if}"
`;

exports[`Svelte > jsx > Javascript Test > renderContentExample 1`] = `
"<script>
  import { onMount, setContext } from \\"svelte\\";

  import BuilderContext from \\"@dummy/context.js\\";
  import {
    dispatchNewContentToVisualEditor,
    sendComponentsToVisualEditor,
    trackClick,
  } from \\"@dummy/injection-js\\";
  import RenderBlocks from \\"@dummy/RenderBlocks.svelte\\";

  export let customComponents;
  export let content;

  onMount(() => {
    sendComponentsToVisualEditor(customComponents);
  });

  function onUpdateFn_0(..._args) {
    dispatchNewContentToVisualEditor(content);
  }

  $: onUpdateFn_0(...[content]);

  setContext(BuilderContext.key, {
    get content() {
      return 3;
    },

    get registeredComponents() {
      return 4;
    },
  });
</script>

<div
  class=\\"div\\"
  on:click={(event) => {
    trackClick(content.id);
  }}
>
  <RenderBlocks blocks={content.blocks} />
</div>

<style>
  .div {
    display: flex;
    flex-direction: columns;
  }
</style>"
`;

exports[`Svelte > jsx > Javascript Test > rootFragmentMultiNode 1`] = `
"<script>
  export let link;
  export let attributes;
  export let openLinkInNewTab;
  export let text;
</script>

{#if link}
  <a
    {...attributes}
    href={link}
    target={openLinkInNewTab ? \\"_blank\\" : undefined}>{text}</a
  >
{/if}

{#if !link}
  <button type=\\"button\\" {...attributes}>{text}</button>
{/if}"
`;

exports[`Svelte > jsx > Javascript Test > rootShow 1`] = `
"<script>
  export let foo;
</script>

{#if foo === \\"bar\\"}
  <div>Bar</div>
{:else}
  <div>Foo</div>
{/if}"
`;

exports[`Svelte > jsx > Javascript Test > self-referencing component 1`] = `
"<script>
  export let name;
</script>

<div>
  {name}
  {#if name === \\"Batman\\"}
    <svelte:self name=\\"Bruce Wayne\\" />
  {/if}
</div>"
`;

exports[`Svelte > jsx > Javascript Test > self-referencing component with children 1`] = `
"<script>
  export let name;
</script>

<div>
  {name}<slot />
  {#if name === \\"Batman\\"}
    <svelte:self name=\\"Bruce\\"><div>Wayne</div></svelte:self>
  {/if}
</div>"
`;

exports[`Svelte > jsx > Javascript Test > showExpressions 1`] = `
"<script>
  export let conditionA;
  export let conditionB;
</script>

<div>
  {#if conditionA}
    Content0
  {:else}
    ContentA
  {/if}
  {#if conditionA}
    ContentA
  {/if}
  {#if conditionA}{:else}
    ContentA
  {/if}
  {#if conditionA}
    ContentB
  {:else}
    {undefined}
  {/if}
  {#if conditionA}
    {undefined}
  {:else}
    ContentB
  {/if}
  {#if conditionA}
    ContentC
  {/if}
  {#if conditionA}{:else}
    ContentC
  {/if}
  {#if conditionA}
    ContentD
  {/if}
  {#if conditionA}{:else}
    ContentD
  {/if}
  {#if conditionA}
    ContentE
  {:else}
    hello
  {/if}
  {#if conditionA}
    hello
  {:else}
    ContentE
  {/if}
  {#if conditionA}
    ContentF
  {:else}
    123
  {/if}
  {#if conditionA}
    123
  {:else}
    ContentF
  {/if}
  {#if conditionA === \\"Default\\"}
    4mb
  {:else if conditionB === \\"Complete\\"}
    20mb
  {:else}
    9mb
  {/if}
  {#if conditionA === \\"Default\\"}
    {#if conditionB === \\"Complete\\"}
      20mb
    {:else}
      9mb
    {/if}
  {:else}
    4mb
  {/if}
</div>"
`;

exports[`Svelte > jsx > Javascript Test > showWithFor 1`] = `
"<script>
  export let conditionA;
  export let items;
</script>

{#if conditionA}
  {#each items as item, idx (idx)}
    <div>{item}</div>
  {/each}
{:else}
  <div>else-condition-A</div>
{/if}"
`;

exports[`Svelte > jsx > Javascript Test > showWithOtherValues 1`] = `
"<script>
  export let conditionA;
</script>

<div>
  {#if conditionA}
    ContentA
  {/if}
  {#if conditionA}
    ContentB
  {:else}
    {undefined}
  {/if}
  {#if conditionA}
    ContentC
  {/if}
  {#if conditionA}
    ContentD
  {/if}
  {#if conditionA}
    ContentE
  {:else}
    hello
  {/if}
  {#if conditionA}
    ContentF
  {:else}
    123
  {/if}
</div>"
`;

exports[`Svelte > jsx > Javascript Test > showWithRootText 1`] = `
"<script>
  export let conditionA;
</script>

{#if conditionA}
  ContentA
{:else}
  <div>else-condition-A</div>
{/if}"
`;

exports[`Svelte > jsx > Javascript Test > signalsOnUpdate 1`] = `
"<script>
  export let id;
  export let foo;

  function onUpdateFn_0(..._args) {
    console.log(\\"props.id changed\\", id);
    console.log(\\"props.foo.value.bar.baz changed\\", foo.value.bar.baz);
  }

  $: onUpdateFn_0(...[id, foo.value.bar.baz]);
</script>

<div class=\\"test div\\">{id}{foo.value.bar.baz}</div>

<style>
  .div {
    padding: 10px;
  }
</style>"
`;

exports[`Svelte > jsx > Javascript Test > spreadAttrs 1`] = `"<input {...attrs} />"`;

exports[`Svelte > jsx > Javascript Test > spreadNestedProps 1`] = `
"<script>
  export let nested;
</script>

<input {...nested} />"
`;

exports[`Svelte > jsx > Javascript Test > spreadProps 1`] = `"<input {...$$props} />"`;

exports[`Svelte > jsx > Javascript Test > string-literal-store 1`] = `
"<script>
  let foo = 123;
</script>

<div>{foo}</div>"
`;

exports[`Svelte > jsx > Javascript Test > styleClassAndCss 1`] = `
"<script>
  function stringifyStyles(stylesObj) {
    let styles = \\"\\";
    for (let key in stylesObj) {
      const dashedKey = key.replace(/[A-Z]/g, function (match) {
        return \\"-\\" + match.toLowerCase();
      });
      styles += dashedKey + \\":\\" + stylesObj[key] + \\";\\";
    }
    return styles;
  }
</script>

<div
  style={stringifyStyles({
    width: \\"100%\\",
  })}
  class=\\"builder-column div\\"
/>

<style>
  .div {
    display: flex;
    flex-direction: column;
    align-items: stretch;
  }
</style>"
`;

exports[`Svelte > jsx > Javascript Test > stylePropClassAndCss 1`] = `
"<script>
  export let attributes;
  function stringifyStyles(stylesObj) {
    let styles = \\"\\";
    for (let key in stylesObj) {
      const dashedKey = key.replace(/[A-Z]/g, function (match) {
        return \\"-\\" + match.toLowerCase();
      });
      styles += dashedKey + \\":\\" + stylesObj[key] + \\";\\";
    }
    return styles;
  }
</script>

<div
  style={stringifyStyles(attributes.style)}
  class={attributes.classfdsa + \\" div\\"}
/>

<style>
  .div {
    display: flex;
    flex-direction: column;
    align-items: stretch;
  }
</style>"
`;

exports[`Svelte > jsx > Javascript Test > subComponent 1`] = `
"<script>
  import Foo from \\"./foo-sub-component.svelte\\";
</script>

<Foo />"
`;

exports[`Svelte > jsx > Javascript Test > svgComponent 1`] = `
"<svg
  fill=\\"none\\"
  role=\\"img\\"
  viewBox={\\"0 0 \\" + 42 + \\" \\" + 42}
  width={42}
  height={42}
  ><defs
    ><filter id=\\"prefix__filter0_f\\" filterUnits=\\"userSpaceOnUse\\"
      ><feFlood result=\\"BackgroundImageFix\\" /><feBlend
        in=\\"SourceGraphic\\"
        in2=\\"BackgroundImageFix\\"
        result=\\"shape\\"
      /><feGaussianBlur
        result=\\"effect1_foregroundBlur\\"
        stdDeviation={7}
      /></filter
    ></defs
  ></svg
>"
`;

exports[`Svelte > jsx > Javascript Test > typeDependency 1`] = `
"<script>
  export let foo;
</script>

<div>{foo}</div>"
`;

exports[`Svelte > jsx > Javascript Test > use-style 1`] = `
"<button type=\\"button\\">Button</button>

<style>
  button {
    background: blue;
    color: white;
    font-size: 12px;
    outline: 1px solid black;
  }
</style>"
`;

exports[`Svelte > jsx > Javascript Test > use-style-and-css 1`] = `
"<button type=\\"button\\" class=\\"button\\"> Button </button>

<style>
  button {
    font-size: 12px;
    outline: 1px solid black;
  }

  .button {
    background: blue;
    color: white;
  }
</style>"
`;

exports[`Svelte > jsx > Javascript Test > use-style-outside-component 1`] = `
"<button type=\\"button\\">Button</button>

<style>
  button {
    background: blue;
    color: white;
    font-size: 12px;
    outline: 1px solid black;
  }
</style>"
`;

exports[`Svelte > jsx > Javascript Test > useTarget 1`] = `
"<script>
  import { onMount } from \\"svelte\\";

  $: name = () => {
    const prefix = \\"s\\";
    return prefix + \\"foo\\";
  };

  let lastName = \\"bar\\";

  onMount(() => {});
</script>

<div>{name()}</div>"
`;

exports[`Svelte > jsx > Javascript Test > webComponent 1`] = `
"<script>
  import { register } from \\"swiper/element/bundle\\";

  register();
</script>

<svelte:component
  this={swiper - container}
  slides-per-view=\\"3\\"
  navigation=\\"true\\"
  pagination=\\"true\\"
  ><svelte:component this={swiper - slide}>Slide 1</svelte:component
  ><svelte:component this={swiper - slide}>Slide 2</svelte:component
  ><svelte:component this={swiper - slide}>Slide 3</svelte:component
  ></svelte:component
>"
`;

exports[`Svelte > jsx > Remove Internal mitosis package 1`] = `
"<script>
  let name = \\"PatrickJS\\";
</script>

<div>Hello {name}! I can run in React, Qwik, Vue, Solid, or Liquid!</div>"
`;

exports[`Svelte > jsx > Typescript Test > AdvancedRef 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface Props {
    showInput: boolean;
  }
</script>

<script lang=\\"ts\\">
  export let showInput: Props[\\"showInput\\"];

  function onBlur() {
    // Maintain focus
    inputRef.focus();
  }

  function lowerCaseName() {
    return name.toLowerCase();
  }

  let inputRef;
  let inputNoArgRef;

  let name = \\"PatrickJS\\";

  function onUpdateFn_0(..._args: any[]) {
    console.log(\\"Received an update\\");
  }

  $: onUpdateFn_0(...[inputRef, inputNoArgRef]);
</script>

<div>
  {#if showInput}
    <input
      class=\\"input\\"
      bind:this={inputRef}
      on:blur={(event) => {
        onBlur();
      }}
      bind:value={name}
    />
    <label for=\\"cars\\" bind:this={inputNoArgRef}> Choose a car: </label>
    <select name=\\"cars\\" id=\\"cars\\"
      ><option value=\\"supra\\">GR Supra</option><option value=\\"86\\">GR 86</option
      ></select
    >
  {/if}
  Hello
  {lowerCaseName()}! I can run in React, Qwik, Vue, Solid, or Web Component!
</div>

<style>
  .input {
    color: red;
  }
</style>"
`;

exports[`Svelte > jsx > Typescript Test > Basic 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface MyBasicComponentProps {
    id: string;
  }
</script>

<script lang=\\"ts\\">
  export const DEFAULT_VALUES = {
    name: \\"Steve\\",
  };

  function underscore_fn_name() {
    return \\"bar\\";
  }

  let name = \\"Steve\\";
  let age = 1;
  let sports = [\\"\\"];
</script>

<div class=\\"test div\\">
  <input
    value={DEFAULT_VALUES.name || name}
    on:change={(myEvent) => {
      name = myEvent.target.value;
    }}
  />
  Hello! I can run in React, Vue, Solid, or Liquid!
</div>

<style>
  .div {
    padding: 10px;
  }
</style>"
`;

exports[`Svelte > jsx > Typescript Test > Basic 2`] = `
"<script lang=\\"ts\\">
  let name = \\"PatrickJS\\";
  let names = [\\"Steve\\", \\"PatrickJS\\"];
</script>

<div>
  {#each names as person}
    {#if person === name}
      <input
        value={name}
        on:change={(event) => {
          name = event.target.value + \\" and \\" + person;
        }}
      />

      Hello
      {person}
      ! I can run in Qwik, Web Component, React, Vue, Solid, or Liquid!
    {/if}
  {/each}
</div>"
`;

exports[`Svelte > jsx > Typescript Test > Basic Context 1`] = `
"<script lang=\\"ts\\">
  import { getContext, onMount, setContext } from \\"svelte\\";

  import { Injector, MyService, createInjector } from \\"@dummy/injection-js\\";

  let myService = getContext(MyService.key);

  function onChange() {
    const change = myService.method(\\"change\\");
    console.log(change);
  }

  let name = \\"PatrickJS\\";
  const hi = myService.method(\\"hi\\");
  console.log(hi);

  onMount(() => {
    const bye = myService.method(\\"hi\\");
    console.log(bye);
  });

  setContext(Injector.key, createInjector());
</script>

<div>
  {myService.method(\\"hello\\") + name}
  Hello! I can run in React, Vue, Solid, or Liquid!
  <input on:change={onChange} />
</div>"
`;

exports[`Svelte > jsx > Typescript Test > Basic OnMount Update 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface Props {
    hi: string;
    bye: string;
  }
</script>

<script lang=\\"ts\\">
  import { onMount } from \\"svelte\\";

  export let bye: Props[\\"bye\\"];
  export let hi: Props[\\"hi\\"];

  let name = \\"PatrickJS\\";
  let names = [\\"Steve\\", \\"PatrickJS\\"];
  name = \\"PatrickJS onInit\\" + hi;

  onMount(() => {
    name = \\"PatrickJS onMount\\" + bye;
  });
</script>

<div>Hello {name}</div>"
`;

exports[`Svelte > jsx > Typescript Test > Basic Outputs 1`] = `
"<script lang=\\"ts\\">
  import { onMount } from \\"svelte\\";

  export let onMessage;
  export let onEvent;
  export let message;

  let name = \\"PatrickJS\\";

  onMount(() => {
    onMessage(name);
    onEvent(message);
  });
</script>

<div />"
`;

exports[`Svelte > jsx > Typescript Test > Basic Outputs Meta 1`] = `
"<script lang=\\"ts\\">
  import { onMount } from \\"svelte\\";

  export let onMessage;
  export let onEvent;
  export let message;

  let name = \\"PatrickJS\\";

  onMount(() => {
    onMessage(name);
    onEvent(message);
  });
</script>

<div />"
`;

exports[`Svelte > jsx > Typescript Test > BasicAttribute 1`] = `
"<script lang=\\"ts\\">
</script>

<input autocapitalize=\\"on\\" autocomplete=\\"on\\" spellcheck={true} />"
`;

exports[`Svelte > jsx > Typescript Test > BasicBooleanAttribute 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  type Props = {
    children: any;
    type: string;
  };
</script>

<script lang=\\"ts\\">
  import MyBooleanAttributeComponent from \\"./basic-boolean-attribute-component.raw\\";

  export let type: Props[\\"type\\"];
</script>

<div>
  {#if $$slots.default}
    <slot />
    {type}
  {/if}<MyBooleanAttributeComponent toggle={true} /><MyBooleanAttributeComponent
    toggle={true}
  /><MyBooleanAttributeComponent list={null} />
</div>"
`;

exports[`Svelte > jsx > Typescript Test > BasicChildComponent 1`] = `
"<script lang=\\"ts\\">
  import MyBasicOnMountUpdateComponent from \\"./basic-onMount-update.raw\\";
  import MyBasicComponent from \\"./basic.raw\\";

  let name = \\"Steve\\";
  let dev = \\"PatrickJS\\";
</script>

<div>
  <MyBasicComponent id={dev} />
  <div><MyBasicOnMountUpdateComponent hi={name} bye={dev} /></div>
</div>"
`;

exports[`Svelte > jsx > Typescript Test > BasicFor 1`] = `
"<script lang=\\"ts\\">
  import { onMount } from \\"svelte\\";

  let name = \\"PatrickJS\\";
  let names = [\\"Steve\\", \\"PatrickJS\\"];

  onMount(() => {
    console.log(\\"onMount code\\");
  });
</script>

<div>
  {#each names as person}
    <input
      value={name}
      on:change={(event) => {
        name = event.target.value + \\" and \\" + person;
      }}
    />

    Hello
    {person}
    ! I can run in Qwik, Web Component, React, Vue, Solid, or Liquid!
  {/each}
</div>"
`;

exports[`Svelte > jsx > Typescript Test > BasicRef 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface Props {
    showInput: boolean;
  }
</script>

<script lang=\\"ts\\">
  export let showInput: Props[\\"showInput\\"];

  function onBlur() {
    // Maintain focus
    inputRef.focus();
  }

  function lowerCaseName() {
    return name.toLowerCase();
  }

  let inputRef;
  let inputNoArgRef;

  let name = \\"PatrickJS\\";
</script>

<div>
  {#if showInput}
    <input
      class=\\"input\\"
      bind:this={inputRef}
      on:blur={(event) => {
        onBlur();
      }}
      bind:value={name}
    />
    <label for=\\"cars\\" bind:this={inputNoArgRef}> Choose a car: </label>
    <select name=\\"cars\\" id=\\"cars\\"
      ><option value=\\"supra\\">GR Supra</option><option value=\\"86\\">GR 86</option
      ></select
    >
  {/if}
  Hello
  {lowerCaseName()}! I can run in React, Qwik, Vue, Solid, or Web Component!
</div>

<style>
  .input {
    color: red;
  }
</style>"
`;

exports[`Svelte > jsx > Typescript Test > BasicRefAssignment 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface Props {
    showInput: boolean;
  }
</script>

<script lang=\\"ts\\">
  function handlerClick(event: Event) {
    event.preventDefault();
    console.log(\\"current value\\", holdValueRef);
    holdValueRef = holdValueRef + \\"JS\\";
  }
</script>

<div>
  <button
    on:click={(evt) => {
      handlerClick(evt);
    }}>Click</button
  >
</div>"
`;

exports[`Svelte > jsx > Typescript Test > BasicRefPrevious 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface Props {
    showInput: boolean;
  }
</script>

<script lang=\\"ts\\">
  export function usePrevious<T>(value: T) {
    // The ref object is a generic container whose current property is mutable ...
    // ... and can hold any value, similar to an instance property on a class
    let ref = useRef<T>(null); // Store current value in ref

    onUpdate(() => {
      ref = value;
    }, [value]); // Only re-run if value changes
    // Return previous value (happens before update in useEffect above)

    return ref;
  }

  let count = 0;

  function onUpdateFn_0(..._args: any[]) {
    prevCount = count;
  }

  $: onUpdateFn_0(...[count]);
</script>

<div>
  <h1>
    Now: {count}, before: {prevCount}
  </h1>
  <button
    on:click={(event) => {
      count += 1;
    }}>Increment</button
  >
</div>"
`;

exports[`Svelte > jsx > Typescript Test > Button 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface ButtonProps {
    attributes?: any;
    text?: string;
    link?: string;
    openLinkInNewTab?: boolean;
  }
</script>

<script lang=\\"ts\\">
  export let link: ButtonProps[\\"link\\"] = undefined;
  export let attributes: ButtonProps[\\"attributes\\"] = undefined;
  export let openLinkInNewTab: ButtonProps[\\"openLinkInNewTab\\"] = undefined;
  export let text: ButtonProps[\\"text\\"] = undefined;
</script>

<div>
  {#if link}
    <a
      {...attributes}
      href={link}
      target={openLinkInNewTab ? \\"_blank\\" : undefined}>{text}</a
    >
  {/if}
  {#if !link}
    <button type=\\"button\\" {...attributes}>{text}</button>
  {/if}
</div>"
`;

exports[`Svelte > jsx > Typescript Test > Columns 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  type Column = {
    content: any; // TODO: Implement this when support for dynamic CSS lands

    width?: number;
  };

  export interface ColumnProps {
    columns?: Column[]; // TODO: Implement this when support for dynamic CSS lands

    space?: number; // TODO: Implement this when support for dynamic CSS lands

    stackColumnsAt?: \\"tablet\\" | \\"mobile\\" | \\"never\\"; // TODO: Implement this when support for dynamic CSS lands

    reverseColumnsWhenStacked?: boolean;
  }
</script>

<script lang=\\"ts\\">
  export let columns: ColumnProps[\\"columns\\"] = undefined;
  export let space: ColumnProps[\\"space\\"] = undefined;

  function getColumns() {
    return columns || [];
  }

  function getGutterSize() {
    return typeof space === \\"number\\" ? space || 0 : 20;
  }

  function getWidth(index: number) {
    const columns = getColumns();
    return (columns[index] && columns[index].width) || 100 / columns.length;
  }

  function getColumnCssWidth(index: number) {
    const columns = getColumns();
    const gutterSize = getGutterSize();
    const subtractWidth = (gutterSize * (columns.length - 1)) / columns.length;
    return \`calc(\${getWidth(index)}% - \${subtractWidth}px)\`;
  }
</script>

<div class=\\"builder-columns div\\">
  {#each columns as column, index}
    <div class=\\"builder-column div-2\\">{column.content}{index}</div>
  {/each}
</div>

<style>
  .div {
    display: flex;
    flex-direction: column;
    align-items: stretch;
    line-height: normal;
  }
  @media (max-width: 999px) {
    .div {
      flex-direction: row;
    }
  }
  @media (max-width: 639px) {
    .div {
      flex-direction: row-reverse;
    }
  }
  .div-2 {
    flex-grow: 1;
  }
</style>"
`;

exports[`Svelte > jsx > Typescript Test > ContentSlotHtml 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  type Props = {
    [key: string]: string | JSX.Element;
    slotTesting: JSX.Element;
  };
</script>

<script lang=\\"ts\\">
  import type { JSX } from \\"../../../../jsx-runtime\\";
</script>

<div>
  <slot name=\\"testing\\" />
  <div><hr /></div>
  <div><slot /></div>
</div>"
`;

exports[`Svelte > jsx > Typescript Test > ContentSlotJSX 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  type Props = {
    [key: string]: string | JSX.Element;
  };
</script>

<script lang=\\"ts\\">
  import type { JSX } from \\"../../../../jsx-runtime\\";

  export let attributes: Props[\\"attributes\\"];
  export let content: Props[\\"content\\"] = \\"\\";

  function show() {
    $$slots.content ? 1 : \\"\\";
  }
  $: cls = () => {
    return $$slots.content && $$slots.default ? \`\${name}-content\` : \\"\\";
  };

  let name = \\"king\\";
  let showContent = false;
</script>

{#if $$slots.reference}
  <div
    name={$$slots.content ? \\"name1\\" : \\"name2\\"}
    title={$$slots.content ? \\"title1\\" : \\"title2\\"}
    {...attributes}
    on:click={(event) => {
      show();
    }}
    class={cls()}
  >
    {#if showContent && $$slots.content}
      <slot name=\\"content\\">{content}</slot>
    {/if}
    <div><hr /></div>
    <div><slot /></div>
  </div>
{/if}"
`;

exports[`Svelte > jsx > Typescript Test > CustomCode 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface CustomCodeProps {
    code: string;
    replaceNodes?: boolean;
  }
</script>

<script lang=\\"ts\\">
  import { onMount } from \\"svelte\\";

  export let replaceNodes: CustomCodeProps[\\"replaceNodes\\"] = undefined;
  export let code: CustomCodeProps[\\"code\\"];

  function findAndRunScripts() {
    // TODO: Move this function to standalone one in '@builder.io/utils'
    if (elem && typeof window !== \\"undefined\\") {
      /** @type {HTMLScriptElement[]} */
      const scripts = elem.getElementsByTagName(\\"script\\");

      for (let i = 0; i < scripts.length; i++) {
        const script = scripts[i];

        if (script.src) {
          if (scriptsInserted.includes(script.src)) {
            continue;
          }

          scriptsInserted.push(script.src);
          const newScript = document.createElement(\\"script\\");
          newScript.async = true;
          newScript.src = script.src;
          document.head.appendChild(newScript);
        } else if (
          !script.type ||
          [
            \\"text/javascript\\",
            \\"application/javascript\\",
            \\"application/ecmascript\\",
          ].includes(script.type)
        ) {
          if (scriptsRun.includes(script.innerText)) {
            continue;
          }

          try {
            scriptsRun.push(script.innerText);
            new Function(script.innerText)();
          } catch (error) {
            console.warn(\\"\`CustomCode\`: Error running script:\\", error);
          }
        }
      }
    }
  }

  let elem;

  let scriptsInserted = [];
  let scriptsRun = [];

  onMount(() => {
    findAndRunScripts();
  });
</script>

<div
  bind:this={elem}
  class={\\"builder-custom-code\\" + (replaceNodes ? \\" replace-nodes\\" : \\"\\")}
>
  {@html code}
</div>"
`;

exports[`Svelte > jsx > Typescript Test > Embed 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface CustomCodeProps {
    code: string;
    replaceNodes?: boolean;
  }
</script>

<script lang=\\"ts\\">
  import { onMount } from \\"svelte\\";

  export let replaceNodes: CustomCodeProps[\\"replaceNodes\\"] = undefined;
  export let code: CustomCodeProps[\\"code\\"];

  function findAndRunScripts() {
    // TODO: Move this function to standalone one in '@builder.io/utils'
    if (elem && typeof window !== \\"undefined\\") {
      /** @type {HTMLScriptElement[]} */
      const scripts = elem.getElementsByTagName(\\"script\\");

      for (let i = 0; i < scripts.length; i++) {
        const script = scripts[i];

        if (script.src) {
          if (scriptsInserted.includes(script.src)) {
            continue;
          }

          scriptsInserted.push(script.src);
          const newScript = document.createElement(\\"script\\");
          newScript.async = true;
          newScript.src = script.src;
          document.head.appendChild(newScript);
        } else if (
          !script.type ||
          [
            \\"text/javascript\\",
            \\"application/javascript\\",
            \\"application/ecmascript\\",
          ].includes(script.type)
        ) {
          if (scriptsRun.includes(script.innerText)) {
            continue;
          }

          try {
            scriptsRun.push(script.innerText);
            new Function(script.innerText)();
          } catch (error) {
            console.warn(\\"\`CustomCode\`: Error running script:\\", error);
          }
        }
      }
    }
  }

  let elem;

  let scriptsInserted = [];
  let scriptsRun = [];

  onMount(() => {
    findAndRunScripts();
  });
</script>

<div
  bind:this={elem}
  class={\\"builder-custom-code\\" + (replaceNodes ? \\" replace-nodes\\" : \\"\\")}
>
  {@html code}
</div>"
`;

exports[`Svelte > jsx > Typescript Test > Form 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface FormProps {
    attributes?: any;
    name?: string;
    action?: string;
    validate?: boolean;
    method?: string;
    builderBlock?: BuilderElement;
    sendSubmissionsTo?: string;
    sendSubmissionsToEmail?: string;
    sendWithJs?: boolean;
    contentType?: string;
    customHeaders?: {
      [key: string]: string;
    };
    successUrl?: string;
    previewState?: FormState;
    successMessage?: BuilderElement[];
    errorMessage?: BuilderElement[];
    sendingMessage?: BuilderElement[];
    resetFormOnSubmit?: boolean;
    errorMessagePath?: string;
  }

  export type FormState = \\"unsubmitted\\" | \\"sending\\" | \\"success\\" | \\"error\\";
</script>

<script lang=\\"ts\\">
  import { Builder, BuilderElement, builder } from \\"@builder.io/sdk\\";
  import {
    BuilderBlock as BuilderBlockComponent,
    BuilderBlocks,
    get,
    set,
  } from \\"@fake\\";

  export let previewState: FormProps[\\"previewState\\"] = undefined;
  export let sendWithJs: FormProps[\\"sendWithJs\\"] = undefined;
  export let sendSubmissionsTo: FormProps[\\"sendSubmissionsTo\\"] = undefined;
  export let action: FormProps[\\"action\\"] = undefined;
  export let customHeaders: FormProps[\\"customHeaders\\"] = undefined;
  export let contentType: FormProps[\\"contentType\\"] = undefined;
  export let sendSubmissionsToEmail: FormProps[\\"sendSubmissionsToEmail\\"] =
    undefined;
  export let name: FormProps[\\"name\\"] = undefined;
  export let method: FormProps[\\"method\\"] = undefined;
  export let errorMessagePath: FormProps[\\"errorMessagePath\\"] = undefined;
  export let resetFormOnSubmit: FormProps[\\"resetFormOnSubmit\\"] = undefined;
  export let successUrl: FormProps[\\"successUrl\\"] = undefined;
  export let validate: FormProps[\\"validate\\"] = undefined;
  export let attributes: FormProps[\\"attributes\\"] = undefined;
  export let builderBlock: FormProps[\\"builderBlock\\"] = undefined;
  export let errorMessage: FormProps[\\"errorMessage\\"] = undefined;
  export let sendingMessage: FormProps[\\"sendingMessage\\"] = undefined;
  export let successMessage: FormProps[\\"successMessage\\"] = undefined;

  function onSubmit(
    event: Event & {
      currentTarget: HTMLFormElement;
    }
  ) {
    const sendWithJs = sendWithJs || sendSubmissionsTo === \\"email\\";

    if (sendSubmissionsTo === \\"zapier\\") {
      event.preventDefault();
    } else if (sendWithJs) {
      if (!(action || sendSubmissionsTo === \\"email\\")) {
        event.preventDefault();
        return;
      }

      event.preventDefault();
      const el = event.currentTarget;
      const headers = customHeaders || {};
      let body: any;
      const formData = new FormData(el); // TODO: maybe support null

      const formPairs: {
        key: string;
        value: File | boolean | number | string | FileList;
      }[] = Array.from(
        event.currentTarget.querySelectorAll(\\"input,select,textarea\\")
      )
        .filter((el) => !!(el as HTMLInputElement).name)
        .map((el) => {
          let value: any;
          const key = (el as HTMLImageElement).name;

          if (el instanceof HTMLInputElement) {
            if (el.type === \\"radio\\") {
              if (el.checked) {
                value = el.name;
                return {
                  key,
                  value,
                };
              }
            } else if (el.type === \\"checkbox\\") {
              value = el.checked;
            } else if (el.type === \\"number\\" || el.type === \\"range\\") {
              const num = el.valueAsNumber;

              if (!isNaN(num)) {
                value = num;
              }
            } else if (el.type === \\"file\\") {
              // TODO: one vs multiple files
              value = el.files;
            } else {
              value = el.value;
            }
          } else {
            value = (el as HTMLInputElement).value;
          }

          return {
            key,
            value,
          };
        });
      let contentType = contentType;

      if (sendSubmissionsTo === \\"email\\") {
        contentType = \\"multipart/form-data\\";
      }

      Array.from(formPairs).forEach(({ value }) => {
        if (
          value instanceof File ||
          (Array.isArray(value) && value[0] instanceof File) ||
          value instanceof FileList
        ) {
          contentType = \\"multipart/form-data\\";
        }
      }); // TODO: send as urlEncoded or multipart by default
      // because of ease of use and reliability in browser API
      // for encoding the form?

      if (contentType !== \\"application/json\\") {
        body = formData;
      } else {
        // Json
        const json = {};
        Array.from(formPairs).forEach(({ value, key }) => {
          set(json, key, value);
        });
        body = JSON.stringify(json);
      }

      if (contentType && contentType !== \\"multipart/form-data\\") {
        if (
          /* Zapier doesn't allow content-type header to be sent from browsers */
          !(sendWithJs && action?.includes(\\"zapier.com\\"))
        ) {
          headers[\\"content-type\\"] = contentType;
        }
      }

      const presubmitEvent = new CustomEvent(\\"presubmit\\", {
        detail: {
          body,
        },
      });

      if (formRef) {
        formRef.dispatchEvent(presubmitEvent);

        if (presubmitEvent.defaultPrevented) {
          return;
        }
      }

      formState = \\"sending\\";
      const formUrl = \`\${
        builder.env === \\"dev\\" ? \\"http://localhost:5000\\" : \\"https://builder.io\\"
      }/api/v1/form-submit?apiKey=\${builder.apiKey}&to=\${btoa(
        sendSubmissionsToEmail || \\"\\"
      )}&name=\${encodeURIComponent(name || \\"\\")}\`;
      fetch(
        sendSubmissionsTo === \\"email\\" ? formUrl : action!,
        /* TODO: throw error if no action URL */
        {
          body,
          headers,
          method: method || \\"post\\",
        }
      ).then(
        async (res) => {
          let body;
          const contentType = res.headers.get(\\"content-type\\");

          if (contentType && contentType.indexOf(\\"application/json\\") !== -1) {
            body = await res.json();
          } else {
            body = await res.text();
          }

          if (!res.ok && errorMessagePath) {
            /* TODO: allow supplying an error formatter function */
            let message = get(body, errorMessagePath);

            if (message) {
              if (typeof message !== \\"string\\") {
                /* TODO: ideally convert json to yaml so it woul dbe like
           error: - email has been taken */
                message = JSON.stringify(message);
              }

              formErrorMessage = message;
            }
          }

          responseData = body;
          formState = res.ok ? \\"success\\" : \\"error\\";

          if (res.ok) {
            const submitSuccessEvent = new CustomEvent(\\"submit:success\\", {
              detail: {
                res,
                body,
              },
            });

            if (formRef) {
              formRef.dispatchEvent(submitSuccessEvent);

              if (submitSuccessEvent.defaultPrevented) {
                return;
              }
              /* TODO: option to turn this on/off? */

              if (resetFormOnSubmit !== false) {
                formRef.reset();
              }
            }
            /* TODO: client side route event first that can be preventDefaulted */

            if (successUrl) {
              if (formRef) {
                const event = new CustomEvent(\\"route\\", {
                  detail: {
                    url: successUrl,
                  },
                });
                formRef.dispatchEvent(event);

                if (!event.defaultPrevented) {
                  location.href = successUrl;
                }
              } else {
                location.href = successUrl;
              }
            }
          }
        },
        (err) => {
          const submitErrorEvent = new CustomEvent(\\"submit:error\\", {
            detail: {
              error: err,
            },
          });

          if (formRef) {
            formRef.dispatchEvent(submitErrorEvent);

            if (submitErrorEvent.defaultPrevented) {
              return;
            }
          }

          responseData = err;
          formState = \\"error\\";
        }
      );
    }
  }
  $: submissionState = () => {
    return (Builder.isEditing && previewState) || formState;
  };

  let formRef;

  let formState = \\"unsubmitted\\";
  let responseData = null;
  let formErrorMessage = \\"\\";
</script>

<form
  {validate}
  bind:this={formRef}
  action={!sendWithJs && action}
  {method}
  {name}
  on:submit={(event) => {
    onSubmit(event);
  }}
  {...attributes}
>
  {#if builderBlock && builderBlock.children}
    {#each builderBlock?.children as block, index (block.id)}
      <BuilderBlockComponent {block} {index} />
    {/each}
  {/if}
  {#if submissionState() === \\"error\\"}
    <BuilderBlocks dataPath=\\"errorMessage\\" blocks={errorMessage} />
  {/if}
  {#if submissionState() === \\"sending\\"}
    <BuilderBlocks dataPath=\\"sendingMessage\\" blocks={sendingMessage} />
  {/if}
  {#if submissionState() === \\"error\\" && responseData}
    <pre class=\\"builder-form-error-text pre\\">{JSON.stringify(
        responseData,
        null,
        2
      )}</pre>
  {/if}
  {#if submissionState() === \\"success\\"}
    <BuilderBlocks dataPath=\\"successMessage\\" blocks={successMessage} />
  {/if}
</form>

<style>
  .pre {
    padding: 10px;
    color: red;
    text-align: center;
  }
</style>"
`;

exports[`Svelte > jsx > Typescript Test > Image 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  // TODO: AMP Support?
  export interface ImageProps {
    _class?: string;
    image: string;
    sizes?: string;
    lazy?: boolean;
    height?: number;
    width?: number;
    altText?: string;
    backgroundSize?: string;
    backgroundPosition?: string; // TODO: Support generating Builder.io and or Shopify \`srcset\`s when needed

    srcset?: string; // TODO: Implement support for custom aspect ratios

    aspectRatio?: number; // TODO: This might not work as expected in terms of positioning

    children?: any;
  }
</script>

<script lang=\\"ts\\">
  import { onDestroy, onMount } from \\"svelte\\";

  export let lazy: ImageProps[\\"lazy\\"] = undefined;
  export let altText: ImageProps[\\"altText\\"] = undefined;
  export let _class: ImageProps[\\"_class\\"] = undefined;
  export let image: ImageProps[\\"image\\"];
  export let srcset: ImageProps[\\"srcset\\"] = undefined;
  export let sizes: ImageProps[\\"sizes\\"] = undefined;

  function setLoaded() {
    imageLoaded = true;
  }

  function useLazyLoading() {
    // TODO: Add more checks here, like testing for real web browsers
    return !!lazy && isBrowser();
  }

  function isBrowser() {
    return (
      typeof window !== \\"undefined\\" && window.navigator.product != \\"ReactNative\\"
    );
  }

  let pictureRef;

  let scrollListener = null;
  let imageLoaded = false;
  let load = false;

  onMount(() => {
    if (useLazyLoading()) {
      // throttled scroll capture listener
      const listener = () => {
        if (pictureRef) {
          const rect = pictureRef.getBoundingClientRect();
          const buffer = window.innerHeight / 2;

          if (rect.top < window.innerHeight + buffer) {
            load = true;
            scrollListener = null;
            window.removeEventListener(\\"scroll\\", listener);
          }
        }
      };

      scrollListener = listener;
      window.addEventListener(\\"scroll\\", listener, {
        capture: true,
        passive: true,
      });
      listener();
    }
  });

  onDestroy(() => {
    if (scrollListener) {
      window.removeEventListener(\\"scroll\\", scrollListener);
    }
  });
</script>

<div>
  <picture bind:this={pictureRef}>
    {#if !useLazyLoading() || load}
      <img
        alt={altText}
        aria-role={altText ? \\"presentation\\" : undefined}
        class={\\"builder-image\\" + (_class ? \\" \\" + _class : \\"\\") + \\" img\\"}
        src={image}
        on:load={(event) => {
          setLoaded();
        }}
        {srcset}
        {sizes}
      />
    {/if}<source {srcset} /></picture
  ><slot />
</div>

<style>
  .img {
    opacity: 1;
    transition: opacity 0.2s ease-in-out;
    object-fit: cover;
    object-position: center;
  }
</style>"
`;

exports[`Svelte > jsx > Typescript Test > Image State 1`] = `
"<script lang=\\"ts\\">
  let canShow = true;
  let images = [\\"http://example.com/qwik.png\\"];
</script>

<div>
  {#each images as item, itemIndex}
    <img class=\\"custom-class\\" src={item} key={itemIndex} />
  {/each}
</div>"
`;

exports[`Svelte > jsx > Typescript Test > Img 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface ImgProps {
    attributes?: any;
    imgSrc?: string;
    altText?: string;
    backgroundSize?: \\"cover\\" | \\"contain\\";
    backgroundPosition?:
      | \\"center\\"
      | \\"top\\"
      | \\"left\\"
      | \\"right\\"
      | \\"bottom\\"
      | \\"top left\\"
      | \\"top right\\"
      | \\"bottom left\\"
      | \\"bottom right\\";
  }
</script>

<script lang=\\"ts\\">
  import { Builder } from \\"@builder.io/sdk\\";

  export let backgroundSize: ImgProps[\\"backgroundSize\\"] = undefined;
  export let backgroundPosition: ImgProps[\\"backgroundPosition\\"] = undefined;
  export let attributes: ImgProps[\\"attributes\\"] = undefined;
  export let imgSrc: ImgProps[\\"imgSrc\\"] = undefined;
  export let altText: ImgProps[\\"altText\\"] = undefined;
  function stringifyStyles(stylesObj) {
    let styles = \\"\\";
    for (let key in stylesObj) {
      const dashedKey = key.replace(/[A-Z]/g, function (match) {
        return \\"-\\" + match.toLowerCase();
      });
      styles += dashedKey + \\":\\" + stylesObj[key] + \\";\\";
    }
    return styles;
  }
</script>

<img
  style={stringifyStyles({
    objectFit: backgroundSize || \\"cover\\",
    objectPosition: backgroundPosition || \\"center\\",
  })}
  {...attributes}
  key={(Builder.isEditing && imgSrc) || \\"default-key\\"}
  alt={altText}
  src={imgSrc}
/>"
`;

exports[`Svelte > jsx > Typescript Test > Input 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface FormInputProps {
    type?: string;
    attributes?: any;
    name?: string;
    value?: string;
    placeholder?: string;
    defaultValue?: string;
    required?: boolean;
    onChange?: (value: string) => void;
  }
</script>

<script lang=\\"ts\\">
  import { Builder } from \\"@builder.io/sdk\\";

  export let attributes: FormInputProps[\\"attributes\\"] = undefined;
  export let defaultValue: FormInputProps[\\"defaultValue\\"] = undefined;
  export let placeholder: FormInputProps[\\"placeholder\\"] = undefined;
  export let type: FormInputProps[\\"type\\"] = undefined;
  export let name: FormInputProps[\\"name\\"] = undefined;
  export let value: FormInputProps[\\"value\\"] = undefined;
  export let required: FormInputProps[\\"required\\"] = undefined;
  export let onChange: FormInputProps[\\"onChange\\"] = undefined;
</script>

<input
  {...attributes}
  key={Builder.isEditing && defaultValue ? defaultValue : \\"default-key\\"}
  {placeholder}
  {type}
  {name}
  {value}
  {defaultValue}
  {required}
  on:change={(event) => {
    onChange?.(event.target.value);
  }}
/>"
`;

exports[`Svelte > jsx > Typescript Test > InputParent 1`] = `
"<script lang=\\"ts\\">
  import FormInputComponent from \\"./input.raw\\";

  function handleChange(value: string) {
    console.log(value);
  }
</script>

<FormInputComponent
  name=\\"kingzez\\"
  type=\\"text\\"
  onChange={(value) => handleChange(value)}
/>"
`;

exports[`Svelte > jsx > Typescript Test > RawText 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface RawTextProps {
    attributes?: any;
    text?: string; // builderBlock?: any;
  }
</script>

<script lang=\\"ts\\">
  export let attributes: RawTextProps[\\"attributes\\"] = undefined;
  export let text: RawTextProps[\\"text\\"] = undefined;
</script>

<span class={attributes?.class || attributes?.className}
  >{@html text || \\"\\"}</span
>"
`;

exports[`Svelte > jsx > Typescript Test > Section 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface SectionProps {
    maxWidth?: number;
    attributes?: any;
    children?: any;
  }
</script>

<script lang=\\"ts\\">
  export let attributes: SectionProps[\\"attributes\\"] = undefined;
  export let maxWidth: SectionProps[\\"maxWidth\\"] = undefined;

  function stringifyStyles(stylesObj) {
    let styles = \\"\\";
    for (let key in stylesObj) {
      const dashedKey = key.replace(/[A-Z]/g, function (match) {
        return \\"-\\" + match.toLowerCase();
      });
      styles += dashedKey + \\":\\" + stylesObj[key] + \\";\\";
    }
    return styles;
  }
</script>

<section
  style={stringifyStyles(
    maxWidth && typeof maxWidth === \\"number\\"
      ? {
          maxWidth: maxWidth,
        }
      : undefined
  )}
  {...attributes}
>
  <slot />
</section>"
`;

exports[`Svelte > jsx > Typescript Test > Section 2`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface SectionProps {
    maxWidth?: number;
    attributes?: any;
    children?: any;
  }
</script>

<script lang=\\"ts\\">
  export let attributes: SectionProps[\\"attributes\\"] = undefined;

  function stringifyStyles(stylesObj) {
    let styles = \\"\\";
    for (let key in stylesObj) {
      const dashedKey = key.replace(/[A-Z]/g, function (match) {
        return \\"-\\" + match.toLowerCase();
      });
      styles += dashedKey + \\":\\" + stylesObj[key] + \\";\\";
    }
    return styles;
  }

  let max = 42;
  let items = [42];
</script>

{#if max}
  {#each items as item}
    <section
      style={stringifyStyles({
        maxWidth: item + max,
      })}
      {...attributes}
    >
      <slot />
    </section>
  {/each}
{/if}"
`;

exports[`Svelte > jsx > Typescript Test > Select 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface FormSelectProps {
    options?: {
      name?: string;
      value: string;
    }[];
    attributes?: any;
    name?: string;
    value?: string;
    defaultValue?: string;
  }
</script>

<script lang=\\"ts\\">
  import { Builder } from \\"@builder.io/sdk\\";

  export let attributes: FormSelectProps[\\"attributes\\"] = undefined;
  export let value: FormSelectProps[\\"value\\"] = undefined;
  export let defaultValue: FormSelectProps[\\"defaultValue\\"] = undefined;
  export let name: FormSelectProps[\\"name\\"] = undefined;
  export let options: FormSelectProps[\\"options\\"] = undefined;
</script>

<select
  {...attributes}
  {value}
  key={Builder.isEditing && defaultValue ? defaultValue : \\"default-key\\"}
  {defaultValue}
  {name}
>
  {#each options as option, index}
    <option value={option.value} data-index={index}
      >{option.name || option.value}</option
    >
  {/each}
</select>"
`;

exports[`Svelte > jsx > Typescript Test > SlotDefault 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  type Props = {
    [key: string]: string;
  };
</script>

<script lang=\\"ts\\">
</script>

<div><slot><div class=\\"default-slot\\">Default content</div></slot></div>"
`;

exports[`Svelte > jsx > Typescript Test > SlotHtml 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  type Props = {
    [key: string]: string;
  };
</script>

<script lang=\\"ts\\">
  import ContentSlotCode from \\"./content-slot-jsx.raw\\";
</script>

<div>
  <ContentSlotCode>
    <span #testing>
      <div>Hello</div>
    </span>
  </ContentSlotCode>
</div>"
`;

exports[`Svelte > jsx > Typescript Test > SlotJsx 1`] = `
"<script context='module' lang='ts'>
      type Props = {
[key: string]: string;
}

    </script>
    

    
<script lang='ts'>




import  ContentSlotCode from './content-slot-jsx.raw';
























</script>

<div ><ContentSlotCode  slotTesting={<div>Hello</div>} ></ContentSlotCode></div>"
`;

exports[`Svelte > jsx > Typescript Test > SlotNamed 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  type Props = {
    [key: string]: string;
  };
</script>

<script lang=\\"ts\\">
</script>

<div>
  <slot name=\\"my-awesome-slot\\" /><slot name=\\"top\\" /><slot name=\\"left\\"
    >Default left</slot
  ><slot>Default Child</slot>
</div>"
`;

exports[`Svelte > jsx > Typescript Test > Stamped.io 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  type SmileReviewsProps = {
    productId: string;
    apiKey: string;
  };
</script>

<script lang=\\"ts\\">
  import { onMount } from \\"svelte\\";

  import { kebabCase, snakeCase } from \\"lodash\\";

  export let apiKey: SmileReviewsProps[\\"apiKey\\"];
  export let productId: SmileReviewsProps[\\"productId\\"];

  function kebabCaseValue() {
    return kebabCase(\\"testThat\\");
  }

  function snakeCaseValue() {
    return snakeCase(\\"testThis\\");
  }

  let reviews = [];
  let name = \\"test\\";
  let showReviewPrompt = false;

  onMount(() => {
    fetch(
      \`https://stamped.io/api/widget/reviews?storeUrl=builder-io.myshopify.com&apiKey=\${
        apiKey || \\"pubkey-8bbDq7W6w4sB3OWeM1HUy2s47702hM\\"
      }&productId=\${productId || \\"2410511106127\\"}\`
    )
      .then((res) => res.json())
      .then((data) => {
        reviews = data.data;
      });
  });
</script>

<div data-user={name}>
  <button
    on:click={(event) => {
      showReviewPrompt = true;
    }}>Write a review</button
  >
  {#if showReviewPrompt || \\"asdf\\"}
    <input placeholder=\\"Email\\" />
    <input placeholder=\\"Title\\" class=\\"input\\" />
    <textarea placeholder=\\"How was your experience?\\" class=\\"textarea\\" />
    <button
      class=\\"button\\"
      on:click={(event) => {
        event.preventDefault();
        showReviewPrompt = false;
      }}
    >
      Submit
    </button>
  {/if}
  {#each reviews as review, index (review.id)}
    <div class=\\"review\\">
      <img class=\\"img\\" src={review.avatar} />
      <div class={showReviewPrompt ? \\"bg-primary\\" : \\"bg-secondary\\"}>
        <div>N: {index}</div>
        <div>{review.author}</div>
        <div>{review.reviewMessage}</div>
      </div>
    </div>
  {/each}
</div>

<style>
  .input {
    display: block;
  }
  .textarea {
    display: block;
  }
  .button {
    display: block;
  }
  .review {
    margin: 10px;
    padding: 10px;
    background: white;
    display: flex;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    -webkit-font-smoothing: antialiased;
  }
  .img {
    height: 30px;
    width: 30px;
    margin-right: 10px;
  }
</style>"
`;

exports[`Svelte > jsx > Typescript Test > Submit 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface ButtonProps {
    attributes?: any;
    text?: string;
  }
</script>

<script lang=\\"ts\\">
  export let attributes: ButtonProps[\\"attributes\\"] = undefined;
  export let text: ButtonProps[\\"text\\"] = undefined;
</script>

<button type=\\"submit\\" {...attributes}>{text}</button>"
`;

exports[`Svelte > jsx > Typescript Test > Text 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface TextProps {
    attributes?: any;
    rtlMode: boolean;
    text?: string;
    content?: string;
    builderBlock?: any;
  }
</script>

<script lang=\\"ts\\">
  import { Builder } from \\"@builder.io/sdk\\";

  export let text: TextProps[\\"text\\"] = undefined;
  export let content: TextProps[\\"content\\"] = undefined;

  let name = \\"Decadef20\\";
</script>

<div
  contentEditable={allowEditingText || undefined}
  data-name={{
    test: name || \\"any name\\",
  }}
>
  {@html text || content || name || '<p class=\\"text-lg\\">my name</p>'}
</div>"
`;

exports[`Svelte > jsx > Typescript Test > Textarea 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface TextareaProps {
    attributes?: any;
    name?: string;
    value?: string;
    defaultValue?: string;
    placeholder?: string;
  }
</script>

<script lang=\\"ts\\">
  export let attributes: TextareaProps[\\"attributes\\"] = undefined;
  export let placeholder: TextareaProps[\\"placeholder\\"] = undefined;
  export let name: TextareaProps[\\"name\\"] = undefined;
  export let value: TextareaProps[\\"value\\"] = undefined;
  export let defaultValue: TextareaProps[\\"defaultValue\\"] = undefined;
</script>

<textarea {...attributes} {placeholder} {name} {value} {defaultValue} />"
`;

exports[`Svelte > jsx > Typescript Test > Video 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface VideoProps {
    attributes?: any;
    video?: string;
    autoPlay?: boolean;
    controls?: boolean;
    muted?: boolean;
    loop?: boolean;
    playsInline?: boolean;
    aspectRatio?: number;
    width?: number;
    height?: number;
    fit?: \\"contain\\" | \\"cover\\" | \\"fill\\";
    position?:
      | \\"center\\"
      | \\"top\\"
      | \\"left\\"
      | \\"right\\"
      | \\"bottom\\"
      | \\"top left\\"
      | \\"top right\\"
      | \\"bottom left\\"
      | \\"bottom right\\";
    posterImage?: string;
    lazyLoad?: boolean;
  }
</script>

<script lang=\\"ts\\">
  export let attributes: VideoProps[\\"attributes\\"] = undefined;
  export let fit: VideoProps[\\"fit\\"] = undefined;
  export let position: VideoProps[\\"position\\"] = undefined;
  export let video: VideoProps[\\"video\\"] = undefined;
  export let posterImage: VideoProps[\\"posterImage\\"] = undefined;
  export let autoPlay: VideoProps[\\"autoPlay\\"] = undefined;
  export let muted: VideoProps[\\"muted\\"] = undefined;
  export let controls: VideoProps[\\"controls\\"] = undefined;
  export let loop: VideoProps[\\"loop\\"] = undefined;
  function stringifyStyles(stylesObj) {
    let styles = \\"\\";
    for (let key in stylesObj) {
      const dashedKey = key.replace(/[A-Z]/g, function (match) {
        return \\"-\\" + match.toLowerCase();
      });
      styles += dashedKey + \\":\\" + stylesObj[key] + \\";\\";
    }
    return styles;
  }
</script>

<video
  style={stringifyStyles({
    width: \\"100%\\",
    height: \\"100%\\",
    ...attributes?.style,
    objectFit: fit,
    objectPosition: position,
    // Hack to get object fit to work as expected and
    // not have the video overflow
    borderRadius: 1,
  })}
  preload=\\"none\\"
  {...attributes}
  key={video || \\"no-src\\"}
  poster={posterImage}
  autoplay={autoPlay}
  {muted}
  {controls}
  {loop}
/>"
`;

exports[`Svelte > jsx > Typescript Test > arrowFunctionInUseStore 1`] = `
"<script lang=\\"ts\\">
  function setName(value) {
    name = value;
  }

  function updateNameWithArrowFn(value) {
    name = value;
  }

  let name = \\"steve\\";
</script>

<div>Hello {name}</div>"
`;

exports[`Svelte > jsx > Typescript Test > basicForNoTagReference 1`] = `
"<script lang=\\"ts\\">
  export let actions;

  $: TagNameGetter = () => {
    return \\"span\\";
  };

  let name = \\"VincentW\\";
  let TagName = \\"div\\";
  let tag = \\"span\\";
</script>

<svelte:component this={TagNameGetter()}>
  Hello <svelte:component this={tag}>{name}</svelte:component>
  {#each actions as action}
    <svelte:component this={TagName}
      ><svelte:component this={action.icon} /><span>{action.text}</span
      ></svelte:component
    >
  {/each}
</svelte:component>"
`;

exports[`Svelte > jsx > Typescript Test > basicForwardRef 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface Props {
    showInput: boolean;
    inputRef: HTMLInputElement;
  }
</script>

<script lang=\\"ts\\">
  export let inputRef: Props[\\"inputRef\\"];

  let name = \\"PatrickJS\\";
</script>

<div><input class=\\"input\\" bind:this={inputRef} bind:value={name} /></div>

<style>
  .input {
    color: red;
  }
</style>"
`;

exports[`Svelte > jsx > Typescript Test > basicForwardRefMetadata 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface Props {
    showInput: boolean;
    inputRef: HTMLInputElement;
  }
</script>

<script lang=\\"ts\\">
  export let inputRef: Props[\\"inputRef\\"];

  let name = \\"PatrickJS\\";
</script>

<div><input class=\\"input\\" bind:this={inputRef} bind:value={name} /></div>

<style>
  .input {
    color: red;
  }
</style>"
`;

exports[`Svelte > jsx > Typescript Test > basicOnUpdateReturn 1`] = `
"<script lang=\\"ts\\">
  let name = \\"PatrickJS\\";

  function onUpdateFn_0(..._args: any[]) {
    const controller = new AbortController();
    const signal = controller.signal;
    fetch(\\"https://patrickjs.com/api/resource.json\\", {
      signal,
    })
      .then((response) => response.json())
      .then((data) => {
        name = data.name;
      });
    return () => {
      if (!signal.aborted) {
        controller.abort();
      }
    };
  }

  $: onUpdateFn_0(...[name]);
</script>

<div>Hello! {name}</div>"
`;

exports[`Svelte > jsx > Typescript Test > class + ClassName + css 1`] = `
"<script lang=\\"ts\\">
</script>

<div class=\\"test2 test div\\">
  Hello! I can run in React, Vue, Solid, or Liquid!
</div>

<style>
  .div {
    padding: 10px;
  }
</style>"
`;

exports[`Svelte > jsx > Typescript Test > class + css 1`] = `
"<script lang=\\"ts\\">
</script>

<div class=\\"test div\\">Hello! I can run in React, Vue, Solid, or Liquid!</div>

<style>
  .div {
    padding: 10px;
  }
</style>"
`;

exports[`Svelte > jsx > Typescript Test > className + css 1`] = `
"<script lang=\\"ts\\">
</script>

<div class=\\"test div\\">Hello! I can run in React, Vue, Solid, or Liquid!</div>

<style>
  .div {
    padding: 10px;
  }
</style>"
`;

exports[`Svelte > jsx > Typescript Test > className 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  type Props = {
    [key: string]: string | JSX.Element;
    slotTesting: JSX.Element;
  };
</script>

<script lang=\\"ts\\">
  import type { JSX } from \\"../../../../jsx-runtime\\";

  let bindings = \\"a binding\\";
</script>

<div>
  <div class=\\"no binding\\">Without Binding</div>
  <div class={bindings}>With binding</div>
</div>"
`;

exports[`Svelte > jsx > Typescript Test > classState 1`] = `
"<script lang=\\"ts\\">
  function stringifyStyles(stylesObj) {
    let styles = \\"\\";
    for (let key in stylesObj) {
      const dashedKey = key.replace(/[A-Z]/g, function (match) {
        return \\"-\\" + match.toLowerCase();
      });
      styles += dashedKey + \\":\\" + stylesObj[key] + \\";\\";
    }
    return styles;
  }

  let classState = \\"testClassName\\";
  let styleState = {
    color: \\"red\\",
  };
</script>

<div style={stringifyStyles(styleState)} class={classState + \\" div\\"}>
  Hello! I can run in React, Vue, Solid, or Liquid!
</div>

<style>
  .div {
    padding: 10px;
  }
</style>"
`;

exports[`Svelte > jsx > Typescript Test > componentWithContext 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface ComponentWithContextProps {
    content: string;
  }
</script>

<script lang=\\"ts\\">
  import { getContext, setContext } from \\"svelte\\";

  import Context1 from \\"@dummy/1\\";
  import Context2 from \\"@dummy/2\\";

  export let content: ComponentWithContextProps[\\"content\\"];

  let foo = getContext(Context1.key);

  setContext(Context1.key, {
    foo: \\"bar\\",

    content() {
      return content;
    },
  });
  setContext(Context2.key, {
    bar: \\"baz\\",
  });
</script>

{foo.value}"
`;

exports[`Svelte > jsx > Typescript Test > componentWithContextMultiRoot 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface ComponentWithContextProps {
    content: string;
  }
</script>

<script lang=\\"ts\\">
  import { getContext, setContext } from \\"svelte\\";

  import Context1 from \\"@dummy/1\\";
  import Context2 from \\"@dummy/2\\";

  export let content: ComponentWithContextProps[\\"content\\"];

  let foo = getContext(Context1.key);

  setContext(Context1.key, {
    foo: \\"bar\\",

    content() {
      return content;
    },
  });
  setContext(Context2.key, {
    bar: \\"baz\\",
  });
</script>

{foo.value}
<div>other</div>"
`;

exports[`Svelte > jsx > Typescript Test > contentState 1`] = `
"<script lang=\\"ts\\">
  import { setContext } from \\"svelte\\";

  import BuilderContext from \\"@dummy/context.js\\";

  export let content;
  export let customComponents;

  setContext(BuilderContext.key, {
    content: content,
    registeredComponents: customComponents,
  });
</script>

<div>setting context</div>"
`;

exports[`Svelte > jsx > Typescript Test > defaultProps 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface ButtonProps {
    attributes?: any;
    text?: string;
    buttonText?: string; // no default value

    link?: string;
    openLinkInNewTab?: boolean;
    onClick?: () => void;
  }
</script>

<script lang=\\"ts\\">
  export let link: ButtonProps[\\"link\\"] = (undefined = \\"https://builder.io/\\");
  export let attributes: ButtonProps[\\"attributes\\"] = undefined;
  export let openLinkInNewTab: ButtonProps[\\"openLinkInNewTab\\"] = (undefined =
    false);
  export let text: ButtonProps[\\"text\\"] = (undefined = \\"default text\\");
  export let onClick: ButtonProps[\\"onClick\\"] = (undefined = () => {
    console.log(\\"hi\\");
  });
  export let buttonText: ButtonProps[\\"buttonText\\"] = undefined;
</script>

<div>
  {#if link}
    <a
      {...attributes}
      href={link}
      target={openLinkInNewTab ? \\"_blank\\" : undefined}>{text}</a
    >
  {/if}
  {#if !link}
    <button
      type=\\"button\\"
      {...attributes}
      on:click={(event) => {
        onClick(event);
      }}>{buttonText}</button
    >
  {/if}
</div>"
`;

exports[`Svelte > jsx > Typescript Test > defaultPropsOutsideComponent 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface ButtonProps {
    attributes?: any;
    text?: string;
    link?: string;
    openLinkInNewTab?: boolean;
    onClick: () => void;
  }
</script>

<script lang=\\"ts\\">
  export let link: ButtonProps[\\"link\\"] = (undefined = \\"https://builder.io/\\");
  export let attributes: ButtonProps[\\"attributes\\"] = undefined;
  export let openLinkInNewTab: ButtonProps[\\"openLinkInNewTab\\"] = (undefined =
    false);
  export let text: ButtonProps[\\"text\\"] = (undefined = \\"default text\\");
  export let onClick: ButtonProps[\\"onClick\\"] = () => {};
</script>

<div>
  {#if link}
    <a
      {...attributes}
      href={link}
      target={openLinkInNewTab ? \\"_blank\\" : undefined}>{text}</a
    >
  {/if}
  {#if !link}
    <button
      type=\\"button\\"
      {...attributes}
      on:click={(event) => {
        onClick(event);
      }}>{text}</button
    >
  {/if}
</div>"
`;

exports[`Svelte > jsx > Typescript Test > defaultValsWithTypes 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  type Props = {
    name: string;
  };
</script>

<script lang=\\"ts\\">
  const DEFAULT_VALUES: Props = {
    name: \\"Sami\\",
  };

  export let name: Props[\\"name\\"];
</script>

<div>Hello {name || DEFAULT_VALUES.name}</div>"
`;

exports[`Svelte > jsx > Typescript Test > expressionState 1`] = `
"<script lang=\\"ts\\">
  export let componentRef;

  let refToUse = !(componentRef instanceof Function) ? componentRef : null;
</script>

<div>{refToUse}</div>"
`;

exports[`Svelte > jsx > Typescript Test > getterState 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface ButtonProps {
    foo: string;
  }
</script>

<script lang=\\"ts\\">
  export let foo: ButtonProps[\\"foo\\"];

  function baz(i: number) {
    return i + foo2().length;
  }
  $: foo2 = () => {
    return foo + \\"foo\\";
  };

  $: bar = () => {
    return \\"bar\\";
  };
</script>

<div>
  <p>{foo2()}</p>
  <p>{bar()}</p>
  <p>{baz(1)}</p>
</div>"
`;

exports[`Svelte > jsx > Typescript Test > import types 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  type RenderContentProps = {
    options?: GetContentOptions;
    content: BuilderContent;
    renderContentProps: RenderBlockProps;
  };
</script>

<script lang=\\"ts\\">
  import { BuilderContent, GetContentOptions } from \\"@builder.io/sdk\\";
  import RenderBlock, { RenderBlockProps } from \\"./builder-render-block.raw\\";

  export let renderContentProps: RenderContentProps[\\"renderContentProps\\"];

  function getRenderContentProps(block, index) {
    return {
      block: block,
      index: index,
    };
  }
</script>

<RenderBlock {...getRenderContentProps(renderContentProps.block, 0)} />"
`;

exports[`Svelte > jsx > Typescript Test > multipleOnUpdate 1`] = `
"<script lang=\\"ts\\">
  import { afterUpdate } from \\"svelte\\";

  afterUpdate(() => {
    console.log(\\"Runs on every update/rerender\\");
  });
  afterUpdate(() => {
    console.log(\\"Runs on every update/rerender as well\\");
  });
</script>

<div />"
`;

exports[`Svelte > jsx > Typescript Test > multipleOnUpdateWithDeps 1`] = `
"<script lang=\\"ts\\">
  let a = \\"a\\";
  let b = \\"b\\";
  let c = \\"c\\";
  let d = \\"d\\";

  function onUpdateFn_0(..._args: any[]) {
    console.log(\\"Runs when a or b changes\\", a, b);

    if (a === \\"a\\") {
      a = \\"b\\";
    }
  }

  $: onUpdateFn_0(...[a, b]);

  function onUpdateFn_1(..._args: any[]) {
    console.log(\\"Runs when c or d changes\\", c, d);

    if (a === \\"a\\") {
      a = \\"b\\";
    }
  }

  $: onUpdateFn_1(...[c, d]);
</script>

<div />"
`;

exports[`Svelte > jsx > Typescript Test > multipleSpreads 1`] = `
"<script lang=\\"ts\\">
  let attrs = {
    hello: \\"world\\",
  };
</script>

<input {...attrs} {...$$props} />"
`;

exports[`Svelte > jsx > Typescript Test > nestedShow 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  interface Props {
    conditionA: boolean;
    conditionB: boolean;
  }
</script>

<script lang=\\"ts\\">
  export let conditionA: Props[\\"conditionA\\"];
  export let conditionB: Props[\\"conditionB\\"];
</script>

{#if conditionA}
  {#if !conditionB}
    <div>if condition A and condition B</div>
  {:else}
    <div>else-condition-B</div>
  {/if}
{:else}
  <div>else-condition-A</div>
{/if}"
`;

exports[`Svelte > jsx > Typescript Test > nestedStyles 1`] = `
"<script lang=\\"ts\\">
</script>

<div class=\\"div\\">Hello world</div>

<style>
  .div {
    display: flex;
    --bar: red;
    color: var(--bar);
  }
  @media (max-width: env(--mobile)) {
    .div {
      display: block;
    }
  }
  .div:hover {
    display: flex;
  }
  .div:active {
    display: inline;
  }
  .div .nested-selector {
    display: grid;
  }
  .div .nested-selector:hover {
    display: block;
  }
  .div.nested-selector:active {
    display: inline-block;
  }
</style>"
`;

exports[`Svelte > jsx > Typescript Test > onEvent 1`] = `
"<script lang=\\"ts\\">
  import { onMount } from \\"svelte\\";

  function foo(event) {
    console.log(\\"test2\\");
  }

  function elem_onInitEditingBldr(event) {
    console.log(\\"test\\");
    foo(event);
  }

  let elem;

  onMount(() => {
    elem.dispatchEvent(new CustomEvent(\\"initEditingBldr\\"));
  });
</script>

<div
  class=\\"builder-embed\\"
  bind:this={elem}
  on:initeditingbldr={(event) => {
    elem_onInitEditingBldr(event);
  }}
>
  <div>Test</div>
</div>"
`;

exports[`Svelte > jsx > Typescript Test > onInit & onMount 1`] = `
"<script lang=\\"ts\\">
  import { onMount } from \\"svelte\\";

  console.log(\\"onInit\\");

  onMount(() => {
    console.log(\\"onMount\\");
  });
</script>

<div />"
`;

exports[`Svelte > jsx > Typescript Test > onInit 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  type Props = {
    name: string;
  };
</script>

<script lang=\\"ts\\">
  export const defaultValues = {
    name: \\"PatrickJS\\",
  };

  export let name: Props[\\"name\\"];

  let name = \\"\\";
  name = defaultValues.name || name;
  console.log(\\"set defaults with props\\");
</script>

<div>Default name defined by parent {name}</div>"
`;

exports[`Svelte > jsx > Typescript Test > onMount 1`] = `
"<script lang=\\"ts\\">
  import { onDestroy, onMount } from \\"svelte\\";

  onMount(() => {
    console.log(\\"Runs on mount\\");
  });

  onDestroy(() => {
    console.log(\\"Runs on unMount\\");
  });
</script>

<div />"
`;

exports[`Svelte > jsx > Typescript Test > onMountMultiple 1`] = `
"<script lang=\\"ts\\">
  import { onMount } from \\"svelte\\";

  onMount(() => {
    console.log(\\"Runs on mount\\");
  });
  onMount(() => {
    console.log(\\"Another one runs on Mount\\");
  });
  onMount(() => {
    console.log(\\"SSR runs on Mount\\");
  });
</script>

<div />"
`;

exports[`Svelte > jsx > Typescript Test > onUpdate 1`] = `
"<script lang=\\"ts\\">
  import { afterUpdate } from \\"svelte\\";

  afterUpdate(() => {
    console.log(\\"Runs on every update/rerender\\");
  });
</script>

<div />"
`;

exports[`Svelte > jsx > Typescript Test > onUpdateWithDeps 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  type Props = {
    size: string;
  };
</script>

<script lang=\\"ts\\">
  export let size: Props[\\"size\\"];

  let a = \\"a\\";
  let b = \\"b\\";

  function onUpdateFn_0(..._args: any[]) {
    console.log(\\"Runs when a, b or size changes\\", a, b, size);
  }

  $: onUpdateFn_0(...[a, b, size]);
</script>

<div />"
`;

exports[`Svelte > jsx > Typescript Test > preserveExportOrLocalStatement 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  type Types = {
    s: any[];
  };

  interface IPost {
    len: number;
  }

  export interface MyBasicComponentProps {
    id: string;
  }
</script>

<script lang=\\"ts\\">
  const b = 3;
  const foo = () => {};
  export const a = 3;
  export const bar = () => {};
  export function run<T>(value: T) {}
</script>

<div />"
`;

exports[`Svelte > jsx > Typescript Test > preserveTyping 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export type A = \\"test\\";

  export interface C {
    n: \\"test\\";
  }

  type B = \\"test2\\";

  interface D {
    n: \\"test\\";
  }

  export interface MyBasicComponentProps {
    name: string;
    age?: number;
  }
</script>

<script lang=\\"ts\\">
  export let name: MyBasicComponentProps[\\"name\\"];
</script>

<div>Hello! I can run in React, Vue, Solid, or Liquid! {name}</div>"
`;

exports[`Svelte > jsx > Typescript Test > propsDestructure 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  type Props = {
    children: any;
    type: string;
  };
</script>

<script lang=\\"ts\\">
  export let type: Props[\\"type\\"];

  let name = \\"Decadef20\\";
</script>

<div>
  <slot />{type}
  Hello! I can run in React, Vue, Solid, or Liquid!
</div>"
`;

exports[`Svelte > jsx > Typescript Test > propsInterface 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  interface Person {
    name: string;
    age?: number;
  }
</script>

<script lang=\\"ts\\">
  export let name: Person[\\"name\\"];
</script>

<div>Hello! I can run in React, Vue, Solid, or Liquid! {name}</div>"
`;

exports[`Svelte > jsx > Typescript Test > propsType 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  type Person = {
    name: string;
    age?: number;
  };
</script>

<script lang=\\"ts\\">
  export let name: Person[\\"name\\"];
</script>

<div>Hello! I can run in React, Vue, Solid, or Liquid! {name}</div>"
`;

exports[`Svelte > jsx > Typescript Test > referencingFunInsideHook 1`] = `
"<script lang=\\"ts\\">
  import { afterUpdate } from \\"svelte\\";

  function foo(params) {}

  function bar() {}

  function zoo() {
    const params = {
      cb: bar,
    };
  }

  afterUpdate(() => {
    foo({
      someOption: bar,
    });
  });
</script>

<div />"
`;

exports[`Svelte > jsx > Typescript Test > renderBlock 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export type RenderBlockProps = {
    block: BuilderBlock;
    context: BuilderContextInterface;
  };
</script>

<script lang=\\"ts\\">
  import { TARGET } from \\"../../constants/target.js\\";
  import type {
    BuilderContextInterface,
    RegisteredComponent,
  } from \\"../../context/types.js\\";
  import { evaluate } from \\"../../functions/evaluate.js\\";
  import { extractTextStyles } from \\"../../functions/extract-text-styles.js\\";
  import { getBlockActions } from \\"../../functions/get-block-actions.js\\";
  import { getBlockComponentOptions } from \\"../../functions/get-block-component-options.js\\";
  import { getBlockProperties } from \\"../../functions/get-block-properties.js\\";
  import { getBlockTag } from \\"../../functions/get-block-tag.js\\";
  import { getProcessedBlock } from \\"../../functions/get-processed-block.js\\";
  import { getReactNativeBlockStyles } from \\"../../functions/get-react-native-block-styles.js\\";
  import type { BuilderBlock } from \\"../../types/builder-block.js\\";
  import type { Nullable } from \\"../../types/typescript.js\\";
  import BlockStyles from \\"./block-styles.svelte\\";
  import { isEmptyHtmlElement } from \\"./render-block.helpers.js\\";
  import RenderComponentWithContext from \\"./render-component-with-context.js\\";
  import type { RenderComponentProps } from \\"./render-component.svelte\\";
  import RenderComponent from \\"./render-component.svelte\\";
  import RenderRepeatedBlock from \\"./render-repeated-block.svelte\\";
  import type { RepeatData } from \\"./types.js\\";

  export let block: RenderBlockProps[\\"block\\"];
  export let context: RenderBlockProps[\\"context\\"];

  $: component = () => {
    const componentName = getProcessedBlock({
      block: block,
      state: context.state,
      context: context.context,
      shouldEvaluateBindings: false,
    }).component?.name;

    if (!componentName) {
      return null;
    }

    const ref = context.registeredComponents[componentName];

    if (!ref) {
      // TODO: Public doc page with more info about this message
      console.warn(\`
          Could not find a registered component named \\"\${componentName}\\".
          If you registered it, is the file that registered it imported by the file that needs to render it?\`);
      return undefined;
    } else {
      return ref;
    }
  };

  $: tag = () => {
    return getBlockTag(useBlock());
  };

  $: useBlock = () => {
    return repeatItemData()
      ? block
      : getProcessedBlock({
          block: block,
          state: context.state,
          context: context.context,
          shouldEvaluateBindings: true,
        });
  };

  $: actions = () => {
    return getBlockActions({
      block: useBlock(),
      state: context.state,
      context: context.context,
    });
  };

  $: attributes = () => {
    const blockProperties = getBlockProperties(useBlock());
    return {
      ...blockProperties,
      ...(TARGET === \\"reactNative\\"
        ? {
            style: getReactNativeBlockStyles({
              block: useBlock(),
              context: context,
              blockStyles: blockProperties.style,
            }),
          }
        : {}),
    };
  };

  $: shouldWrap = () => {
    return !component?.()?.noWrap;
  };

  $: renderComponentProps = () => {
    return {
      blockChildren: useChildren(),
      componentRef: component?.()?.component,
      componentOptions: {
        ...getBlockComponentOptions(useBlock()),

        /**
         * These attributes are passed to the wrapper element when there is one. If \`noWrap\` is set to true, then
         * they are provided to the component itself directly.
         */
        ...(shouldWrap()
          ? {}
          : {
              attributes: { ...attributes(), ...actions() },
            }),
        customBreakpoints: childrenContext?.()?.content?.meta?.breakpoints,
      },
      context: childrenContext(),
    };
  };

  $: useChildren = () => {
    // TO-DO: When should \`canHaveChildren\` dictate rendering?
    // This is currently commented out because some Builder components (e.g. Box) do not have \`canHaveChildren: true\`,
    // but still receive and need to render children.
    // return state.componentInfo?.canHaveChildren ? useBlock().children : [];
    return useBlock().children ?? [];
  };

  $: childrenWithoutParentComponent = () => {
    /**
     * When there is no \`componentRef\`, there might still be children that need to be rendered. In this case,
     * we render them outside of \`componentRef\`.
     * NOTE: We make sure not to render this if \`repeatItemData\` is non-null, because that means we are rendering an array of
     * blocks, and the children will be repeated within those blocks.
     */
    const shouldRenderChildrenOutsideRef =
      !component?.()?.component && !repeatItemData();
    return shouldRenderChildrenOutsideRef ? useChildren() : [];
  };

  $: repeatItemData = () => {
    /**
     * we don't use \`useBlock()\` here because the processing done within its logic includes evaluating the block's bindings,
     * which will not work if there is a repeat.
     */
    const { repeat, ...blockWithoutRepeat } = block;

    if (!repeat?.collection) {
      return undefined;
    }

    const itemsArray = evaluate({
      code: repeat.collection,
      state: context.state,
      context: context.context,
    });

    if (!Array.isArray(itemsArray)) {
      return undefined;
    }

    const collectionName = repeat.collection.split(\\".\\").pop();
    const itemNameToUse =
      repeat.itemName || (collectionName ? collectionName + \\"Item\\" : \\"item\\");
    const repeatArray = itemsArray.map<RepeatData>((item, index) => ({
      context: {
        ...context,
        state: {
          ...context.state,
          $index: index,
          $item: item,
          [itemNameToUse]: item,
          [\`$\${itemNameToUse}Index\`]: index,
        },
      },
      block: blockWithoutRepeat,
    }));
    return repeatArray;
  };

  $: inheritedTextStyles = () => {
    if (TARGET !== \\"reactNative\\") {
      return {};
    }

    const styles = getReactNativeBlockStyles({
      block: useBlock(),
      context: context,
      blockStyles: attributes().style,
    });
    return extractTextStyles(styles);
  };

  $: childrenContext = () => {
    return {
      apiKey: context.apiKey,
      state: context.state,
      content: context.content,
      context: context.context,
      registeredComponents: context.registeredComponents,
      inheritedStyles: inheritedTextStyles(),
    };
  };

  $: renderComponentTag = () => {
    if (TARGET === \\"reactNative\\") {
      return RenderComponentWithContext;
    } else if (TARGET === \\"vue3\\") {
      // vue3 expects a string for the component tag
      return \\"RenderComponent\\";
    } else {
      return RenderComponent;
    }
  };
</script>

{#if shouldWrap()}
  {#if isEmptyHtmlElement(tag())}
    <svelte:component this={tag()} {...attributes()} {...actions()} />
  {/if}

  {#if !isEmptyHtmlElement(tag()) && repeatItemData()}
    {#each repeatItemData() as data, index (index)}
      <RenderRepeatedBlock repeatContext={data.context} block={data.block} />
    {/each}
  {/if}

  {#if !isEmptyHtmlElement(tag()) && !repeatItemData()}
    <svelte:component this={tag()} {...attributes()} {...actions()}
      ><svelte:component
        this={renderComponentTag()}
        {...renderComponentProps()}
      />
      {#each childrenWithoutParentComponent() as child (\\"render-block-\\" + child.id)}
        <svelte:self block={child} context={childrenContext()} />
      {/each}

      {#each childrenWithoutParentComponent() as child (\\"block-style-\\" + child.id)}
        <BlockStyles block={child} context={childrenContext()} />
      {/each}
    </svelte:component>
  {/if}
{:else}
  <svelte:component this={renderComponentTag()} {...renderComponentProps()} />
{/if}"
`;

exports[`Svelte > jsx > Typescript Test > renderContentExample 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  type Props = {
    customComponents: string[];
    content: {
      blocks: any[];
      id: string;
    };
  };
</script>

<script lang=\\"ts\\">
  import { onMount, setContext } from \\"svelte\\";

  import BuilderContext from \\"@dummy/context.js\\";
  import {
    dispatchNewContentToVisualEditor,
    sendComponentsToVisualEditor,
    trackClick,
  } from \\"@dummy/injection-js\\";
  import RenderBlocks from \\"@dummy/RenderBlocks.svelte\\";

  export let customComponents: Props[\\"customComponents\\"];
  export let content: Props[\\"content\\"];

  onMount(() => {
    sendComponentsToVisualEditor(customComponents);
  });

  function onUpdateFn_0(..._args: any[]) {
    dispatchNewContentToVisualEditor(content);
  }

  $: onUpdateFn_0(...[content]);

  setContext(BuilderContext.key, {
    get content() {
      return 3;
    },

    get registeredComponents() {
      return 4;
    },
  });
</script>

<div
  class=\\"div\\"
  on:click={(event) => {
    trackClick(content.id);
  }}
>
  <RenderBlocks blocks={content.blocks} />
</div>

<style>
  .div {
    display: flex;
    flex-direction: columns;
  }
</style>"
`;

exports[`Svelte > jsx > Typescript Test > rootFragmentMultiNode 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface ButtonProps {
    attributes?: any;
    text?: string;
    link?: string;
    openLinkInNewTab?: boolean;
  }
</script>

<script lang=\\"ts\\">
  export let link: ButtonProps[\\"link\\"] = undefined;
  export let attributes: ButtonProps[\\"attributes\\"] = undefined;
  export let openLinkInNewTab: ButtonProps[\\"openLinkInNewTab\\"] = undefined;
  export let text: ButtonProps[\\"text\\"] = undefined;
</script>

{#if link}
  <a
    {...attributes}
    href={link}
    target={openLinkInNewTab ? \\"_blank\\" : undefined}>{text}</a
  >
{/if}

{#if !link}
  <button type=\\"button\\" {...attributes}>{text}</button>
{/if}"
`;

exports[`Svelte > jsx > Typescript Test > rootShow 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export interface RenderStylesProps {
    foo: string;
  }
</script>

<script lang=\\"ts\\">
  export let foo: RenderStylesProps[\\"foo\\"];
</script>

{#if foo === \\"bar\\"}
  <div>Bar</div>
{:else}
  <div>Foo</div>
{/if}"
`;

exports[`Svelte > jsx > Typescript Test > self-referencing component 1`] = `
"<script lang=\\"ts\\">
  export let name;
</script>

<div>
  {name}
  {#if name === \\"Batman\\"}
    <svelte:self name=\\"Bruce Wayne\\" />
  {/if}
</div>"
`;

exports[`Svelte > jsx > Typescript Test > self-referencing component with children 1`] = `
"<script lang=\\"ts\\">
  export let name;
</script>

<div>
  {name}<slot />
  {#if name === \\"Batman\\"}
    <svelte:self name=\\"Bruce\\"><div>Wayne</div></svelte:self>
  {/if}
</div>"
`;

exports[`Svelte > jsx > Typescript Test > showExpressions 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  interface Props {
    conditionA: boolean;
    conditionB: boolean;
  }
</script>

<script lang=\\"ts\\">
  export let conditionA: Props[\\"conditionA\\"];
  export let conditionB: Props[\\"conditionB\\"];
</script>

<div>
  {#if conditionA}
    Content0
  {:else}
    ContentA
  {/if}
  {#if conditionA}
    ContentA
  {/if}
  {#if conditionA}{:else}
    ContentA
  {/if}
  {#if conditionA}
    ContentB
  {:else}
    {undefined}
  {/if}
  {#if conditionA}
    {undefined}
  {:else}
    ContentB
  {/if}
  {#if conditionA}
    ContentC
  {/if}
  {#if conditionA}{:else}
    ContentC
  {/if}
  {#if conditionA}
    ContentD
  {/if}
  {#if conditionA}{:else}
    ContentD
  {/if}
  {#if conditionA}
    ContentE
  {:else}
    hello
  {/if}
  {#if conditionA}
    hello
  {:else}
    ContentE
  {/if}
  {#if conditionA}
    ContentF
  {:else}
    123
  {/if}
  {#if conditionA}
    123
  {:else}
    ContentF
  {/if}
  {#if conditionA === \\"Default\\"}
    4mb
  {:else if conditionB === \\"Complete\\"}
    20mb
  {:else}
    9mb
  {/if}
  {#if conditionA === \\"Default\\"}
    {#if conditionB === \\"Complete\\"}
      20mb
    {:else}
      9mb
    {/if}
  {:else}
    4mb
  {/if}
</div>"
`;

exports[`Svelte > jsx > Typescript Test > showWithFor 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  interface Props {
    conditionA: boolean;
    items: string[];
  }
</script>

<script lang=\\"ts\\">
  export let conditionA: Props[\\"conditionA\\"];
  export let items: Props[\\"items\\"];
</script>

{#if conditionA}
  {#each items as item, idx (idx)}
    <div>{item}</div>
  {/each}
{:else}
  <div>else-condition-A</div>
{/if}"
`;

exports[`Svelte > jsx > Typescript Test > showWithOtherValues 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  interface Props {
    conditionA: boolean;
  }
</script>

<script lang=\\"ts\\">
  export let conditionA: Props[\\"conditionA\\"];
</script>

<div>
  {#if conditionA}
    ContentA
  {/if}
  {#if conditionA}
    ContentB
  {:else}
    {undefined}
  {/if}
  {#if conditionA}
    ContentC
  {/if}
  {#if conditionA}
    ContentD
  {/if}
  {#if conditionA}
    ContentE
  {:else}
    hello
  {/if}
  {#if conditionA}
    ContentF
  {:else}
    123
  {/if}
</div>"
`;

exports[`Svelte > jsx > Typescript Test > showWithRootText 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  interface Props {
    conditionA: boolean;
  }
</script>

<script lang=\\"ts\\">
  export let conditionA: Props[\\"conditionA\\"];
</script>

{#if conditionA}
  ContentA
{:else}
  <div>else-condition-A</div>
{/if}"
`;

exports[`Svelte > jsx > Typescript Test > signalsOnUpdate 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  type Props = {
    id: Writable<string>;
    foo: Writable<{
      bar: {
        baz: number;
      };
    }>;
  };
</script>

<script lang=\\"ts\\">
  import type { Writable } from \\"svelte/store\\";

  export let id: Props[\\"id\\"];
  export let foo: Props[\\"foo\\"];

  function onUpdateFn_0(..._args: any[]) {
    console.log(\\"props.id changed\\", id);
    console.log(\\"props.foo.value.bar.baz changed\\", $foo.bar.baz);
  }
  $: onUpdateFn_0_foo_bar_baz = $foo.bar.baz;
  $: onUpdateFn_0(...[id, onUpdateFn_0_foo_bar_baz]);
</script>

<div class=\\"test div\\">{id}{$foo.bar.baz}</div>

<style>
  .div {
    padding: 10px;
  }
</style>"
`;

exports[`Svelte > jsx > Typescript Test > spreadAttrs 1`] = `
"<script lang=\\"ts\\">
</script>

<input {...attrs} />"
`;

exports[`Svelte > jsx > Typescript Test > spreadNestedProps 1`] = `
"<script lang=\\"ts\\">
  export let nested;
</script>

<input {...nested} />"
`;

exports[`Svelte > jsx > Typescript Test > spreadProps 1`] = `
"<script lang=\\"ts\\">
</script>

<input {...$$props} />"
`;

exports[`Svelte > jsx > Typescript Test > string-literal-store 1`] = `
"<script lang=\\"ts\\">
  let foo = 123;
</script>

<div>{foo}</div>"
`;

exports[`Svelte > jsx > Typescript Test > styleClassAndCss 1`] = `
"<script lang=\\"ts\\">
  function stringifyStyles(stylesObj) {
    let styles = \\"\\";
    for (let key in stylesObj) {
      const dashedKey = key.replace(/[A-Z]/g, function (match) {
        return \\"-\\" + match.toLowerCase();
      });
      styles += dashedKey + \\":\\" + stylesObj[key] + \\";\\";
    }
    return styles;
  }
</script>

<div
  style={stringifyStyles({
    width: \\"100%\\",
  })}
  class=\\"builder-column div\\"
/>

<style>
  .div {
    display: flex;
    flex-direction: column;
    align-items: stretch;
  }
</style>"
`;

exports[`Svelte > jsx > Typescript Test > stylePropClassAndCss 1`] = `
"<script lang=\\"ts\\">
  export let attributes;
  function stringifyStyles(stylesObj) {
    let styles = \\"\\";
    for (let key in stylesObj) {
      const dashedKey = key.replace(/[A-Z]/g, function (match) {
        return \\"-\\" + match.toLowerCase();
      });
      styles += dashedKey + \\":\\" + stylesObj[key] + \\";\\";
    }
    return styles;
  }
</script>

<div
  style={stringifyStyles(attributes.style)}
  class={attributes.classfdsa + \\" div\\"}
/>

<style>
  .div {
    display: flex;
    flex-direction: column;
    align-items: stretch;
  }
</style>"
`;

exports[`Svelte > jsx > Typescript Test > subComponent 1`] = `
"<script lang=\\"ts\\">
  import Foo from \\"./foo-sub-component.svelte\\";
</script>

<Foo />"
`;

exports[`Svelte > jsx > Typescript Test > svgComponent 1`] = `
"<script lang=\\"ts\\">
</script>

<svg
  fill=\\"none\\"
  role=\\"img\\"
  viewBox={\\"0 0 \\" + 42 + \\" \\" + 42}
  width={42}
  height={42}
  ><defs
    ><filter id=\\"prefix__filter0_f\\" filterUnits=\\"userSpaceOnUse\\"
      ><feFlood result=\\"BackgroundImageFix\\" /><feBlend
        in=\\"SourceGraphic\\"
        in2=\\"BackgroundImageFix\\"
        result=\\"shape\\"
      /><feGaussianBlur
        result=\\"effect1_foregroundBlur\\"
        stdDeviation={7}
      /></filter
    ></defs
  ></svg
>"
`;

exports[`Svelte > jsx > Typescript Test > typeDependency 1`] = `
"<script context=\\"module\\" lang=\\"ts\\">
  export type TypeDependencyProps = {
    foo: Foo;
    foo2: Foo2;
  };
</script>

<script lang=\\"ts\\">
  import type { Foo } from \\"./foo-type\\";
  import type { Foo as Foo2 } from \\"./type-export.svelte\\";

  export let foo: TypeDependencyProps[\\"foo\\"];
</script>

<div>{foo}</div>"
`;

exports[`Svelte > jsx > Typescript Test > use-style 1`] = `
"<script lang=\\"ts\\">
</script>

<button type=\\"button\\">Button</button>

<style>
  button {
    background: blue;
    color: white;
    font-size: 12px;
    outline: 1px solid black;
  }
</style>"
`;

exports[`Svelte > jsx > Typescript Test > use-style-and-css 1`] = `
"<script lang=\\"ts\\">
</script>

<button type=\\"button\\" class=\\"button\\"> Button </button>

<style>
  button {
    font-size: 12px;
    outline: 1px solid black;
  }

  .button {
    background: blue;
    color: white;
  }
</style>"
`;

exports[`Svelte > jsx > Typescript Test > use-style-outside-component 1`] = `
"<script lang=\\"ts\\">
</script>

<button type=\\"button\\">Button</button>

<style>
  button {
    background: blue;
    color: white;
    font-size: 12px;
    outline: 1px solid black;
  }
</style>"
`;

exports[`Svelte > jsx > Typescript Test > useTarget 1`] = `
"<script lang=\\"ts\\">
  import { onMount } from \\"svelte\\";

  $: name = () => {
    const prefix = \\"s\\";
    return prefix + \\"foo\\";
  };

  let lastName = \\"bar\\";

  onMount(() => {});
</script>

<div>{name()}</div>"
`;

exports[`Svelte > jsx > Typescript Test > webComponent 1`] = `
"<script lang=\\"ts\\">
  import { register } from \\"swiper/element/bundle\\";

  register();
</script>

<svelte:component
  this={swiper - container}
  slides-per-view=\\"3\\"
  navigation=\\"true\\"
  pagination=\\"true\\"
  ><svelte:component this={swiper - slide}>Slide 1</svelte:component
  ><svelte:component this={swiper - slide}>Slide 2</svelte:component
  ><svelte:component this={swiper - slide}>Slide 3</svelte:component
  ></svelte:component
>"
`;

exports[`Svelte > svelte > Javascript Test > basic 1`] = `
"<script>
  let name = \\"Steve\\";
</script>

<div>
  <input bind:value={name} />
  Hello! I can run in React, Vue, Solid, or Liquid!
</div>"
`;

exports[`Svelte > svelte > Javascript Test > bindGroup 1`] = `
"<script>
  let tortilla = \\"Plain\\";
  let fillings = [];
</script>

<div>
  <input
    type=\\"radio\\"
    value=\\"Plain\\"
    checked={tortilla === \\"Plain\\"}
    on:change={(event) => {
      tortilla = event.target.value;
    }}
  /><input
    type=\\"radio\\"
    value=\\"Whole wheat\\"
    checked={tortilla === \\"Whole wheat\\"}
    on:change={(event) => {
      tortilla = event.target.value;
    }}
  /><input
    type=\\"radio\\"
    value=\\"Spinach\\"
    checked={tortilla === \\"Spinach\\"}
    on:change={(event) => {
      tortilla = event.target.value;
    }}
  /><br /><br /><input
    type=\\"checkbox\\"
    value=\\"Rice\\"
    checked={fillings === \\"Rice\\"}
    on:change={(event) => {
      fillings = event.target.value;
    }}
  /><input
    type=\\"checkbox\\"
    value=\\"Beans\\"
    checked={fillings === \\"Beans\\"}
    on:change={(event) => {
      fillings = event.target.value;
    }}
  /><input
    type=\\"checkbox\\"
    value=\\"Cheese\\"
    checked={fillings === \\"Cheese\\"}
    on:change={(event) => {
      fillings = event.target.value;
    }}
  /><input
    type=\\"checkbox\\"
    value=\\"Guac (extra)\\"
    checked={fillings === \\"Guac (extra)\\"}
    on:change={(event) => {
      fillings = event.target.value;
    }}
  />
  <p>Tortilla: {tortilla}</p>
  <p>Fillings: {fillings}</p>
</div>"
`;

exports[`Svelte > svelte > Javascript Test > bindProperty 1`] = `
"<script>
  let value = \\"hello\\";
</script>

<input {value} />"
`;

exports[`Svelte > svelte > Javascript Test > classDirective 1`] = `
"<script>
  export let disabled;

  let focus = true;
</script>

<input
  class={\`form-input \${disabled ? \\"disabled\\" : \\"\\"} \${focus ? \\"focus\\" : \\"\\"}\`}
/>"
`;

exports[`Svelte > svelte > Javascript Test > context 1`] = `
"<script>
  import { getContext, setContext } from \\"svelte\\";

  let disabled = getContext(\\"disabled\\".key);

  let activeTab = 0;

  setContext(\\"activeTab\\", activeTab);
</script>

<div>{activeTab}</div>"
`;

exports[`Svelte > svelte > Javascript Test > each 1`] = `
"<script>
  let numbers = [\\"one\\", \\"two\\", \\"three\\"];
</script>

<ul>
  {#each numbers as num}
    <li>{num}</li>
  {/each}
</ul>"
`;

exports[`Svelte > svelte > Javascript Test > eventHandlers 1`] = `
"<script>
  function log(msg = \\"hello\\") {
    console.log(msg);
  }
</script>

<div>
  <button
    on:click={(a) => {
      log(\\"hi\\");
    }}>Log</button
  ><button
    on:click={(event) => {
      log(event);
    }}>Log</button
  ><button
    on:click={(event) => {
      log(event);
    }}>Log</button
  >
</div>"
`;

exports[`Svelte > svelte > Javascript Test > html 1`] = `
"<script>
  let html = \\"<b>bold</b>\\";
</script>

<div>{@html html}</div>"
`;

exports[`Svelte > svelte > Javascript Test > ifElse 1`] = `
"<script>
  function toggle() {
    show = !show;
  }

  let show = true;
</script>

{#if show}
  <button
    on:click={(event) => {
      toggle(event);
    }}
  >
    Hide
  </button>
{:else}
  <button
    on:click={(event) => {
      toggle(event);
    }}
  >
    Show
  </button>
{/if}"
`;

exports[`Svelte > svelte > Javascript Test > imports 1`] = `
"<script>
  import Button from \\"./Button.svelte\\";

  let disabled = false;
</script>

<div><Button type=\\"button\\" {disabled}><slot /></Button></div>"
`;

exports[`Svelte > svelte > Javascript Test > lifecycleHooks 1`] = `
"<script>
  import { afterUpdate, onDestroy, onMount } from \\"svelte\\";

  onMount(() => {
    console.log(\\"onMount\\");
  });

  afterUpdate(() => {
    console.log(\\"onAfterUpdate\\");
  });

  onDestroy(() => {
    console.log(\\"onDestroy\\");
  });
</script>

<div />"
`;

exports[`Svelte > svelte > Javascript Test > reactive 1`] = `
"<script>
  $: lowercaseName = () => {
    return name.toLowerCase();
  };

  let name = \\"Steve\\";
</script>

<div>
  <input value={name} />
  Lowercase: {lowercaseName()}
</div>"
`;

exports[`Svelte > svelte > Javascript Test > reactiveWithFn 1`] = `
"<script>
  function calculateResult(a_, b_) {
    result = a_ * b_;
  }

  let a = 2;
  let b = 5;
  let result = null;

  function onUpdateFn_0(..._args) {
    calculateResult(a, b);
  }

  $: onUpdateFn_0(...[a, b]);
</script>

<div>
  <input type=\\"number\\" bind:value={a} /><input type=\\"number\\" bind:value={b} />
  Result: {result}
</div>"
`;

exports[`Svelte > svelte > Javascript Test > slots 1`] = `"<div><slot>default</slot><slot name=\\"test\\"><div>default</div></slot></div>"`;

exports[`Svelte > svelte > Javascript Test > style 1`] = `
"<input class=\\"form-input\\" />

<style>
  input {
    color: red;
    font-size: 12px;
  }

  .form-input:focus {
    outline: 1px solid blue;
  }
</style>"
`;

exports[`Svelte > svelte > Javascript Test > textExpressions 1`] = `
"<script>
  let a = 5;
  let b = 12;
</script>

<div>
  normal:
  {a + b}<br />
  conditional
  {a > 2 ? \\"hello\\" : \\"bye\\"}
</div>"
`;

exports[`Svelte > svelte > Typescript Test > basic 1`] = `
"<script lang=\\"ts\\">
  let name = \\"Steve\\";
</script>

<div>
  <input bind:value={name} />
  Hello! I can run in React, Vue, Solid, or Liquid!
</div>"
`;

exports[`Svelte > svelte > Typescript Test > bindGroup 1`] = `
"<script lang=\\"ts\\">
  let tortilla = \\"Plain\\";
  let fillings = [];
</script>

<div>
  <input
    type=\\"radio\\"
    value=\\"Plain\\"
    checked={tortilla === \\"Plain\\"}
    on:change={(event) => {
      tortilla = event.target.value;
    }}
  /><input
    type=\\"radio\\"
    value=\\"Whole wheat\\"
    checked={tortilla === \\"Whole wheat\\"}
    on:change={(event) => {
      tortilla = event.target.value;
    }}
  /><input
    type=\\"radio\\"
    value=\\"Spinach\\"
    checked={tortilla === \\"Spinach\\"}
    on:change={(event) => {
      tortilla = event.target.value;
    }}
  /><br /><br /><input
    type=\\"checkbox\\"
    value=\\"Rice\\"
    checked={fillings === \\"Rice\\"}
    on:change={(event) => {
      fillings = event.target.value;
    }}
  /><input
    type=\\"checkbox\\"
    value=\\"Beans\\"
    checked={fillings === \\"Beans\\"}
    on:change={(event) => {
      fillings = event.target.value;
    }}
  /><input
    type=\\"checkbox\\"
    value=\\"Cheese\\"
    checked={fillings === \\"Cheese\\"}
    on:change={(event) => {
      fillings = event.target.value;
    }}
  /><input
    type=\\"checkbox\\"
    value=\\"Guac (extra)\\"
    checked={fillings === \\"Guac (extra)\\"}
    on:change={(event) => {
      fillings = event.target.value;
    }}
  />
  <p>Tortilla: {tortilla}</p>
  <p>Fillings: {fillings}</p>
</div>"
`;

exports[`Svelte > svelte > Typescript Test > bindProperty 1`] = `
"<script lang=\\"ts\\">
  let value = \\"hello\\";
</script>

<input {value} />"
`;

exports[`Svelte > svelte > Typescript Test > classDirective 1`] = `
"<script lang=\\"ts\\">
  export let disabled;

  let focus = true;
</script>

<input
  class={\`form-input \${disabled ? \\"disabled\\" : \\"\\"} \${focus ? \\"focus\\" : \\"\\"}\`}
/>"
`;

exports[`Svelte > svelte > Typescript Test > context 1`] = `
"<script lang=\\"ts\\">
  import { getContext, setContext } from \\"svelte\\";

  let disabled = getContext(\\"disabled\\".key);

  let activeTab = 0;

  setContext(\\"activeTab\\", activeTab);
</script>

<div>{activeTab}</div>"
`;

exports[`Svelte > svelte > Typescript Test > each 1`] = `
"<script lang=\\"ts\\">
  let numbers = [\\"one\\", \\"two\\", \\"three\\"];
</script>

<ul>
  {#each numbers as num}
    <li>{num}</li>
  {/each}
</ul>"
`;

exports[`Svelte > svelte > Typescript Test > eventHandlers 1`] = `
"<script lang=\\"ts\\">
  function log(msg = \\"hello\\") {
    console.log(msg);
  }
</script>

<div>
  <button
    on:click={(a) => {
      log(\\"hi\\");
    }}>Log</button
  ><button
    on:click={(event) => {
      log(event);
    }}>Log</button
  ><button
    on:click={(event) => {
      log(event);
    }}>Log</button
  >
</div>"
`;

exports[`Svelte > svelte > Typescript Test > html 1`] = `
"<script lang=\\"ts\\">
  let html = \\"<b>bold</b>\\";
</script>

<div>{@html html}</div>"
`;

exports[`Svelte > svelte > Typescript Test > ifElse 1`] = `
"<script lang=\\"ts\\">
  function toggle() {
    show = !show;
  }

  let show = true;
</script>

{#if show}
  <button
    on:click={(event) => {
      toggle(event);
    }}
  >
    Hide
  </button>
{:else}
  <button
    on:click={(event) => {
      toggle(event);
    }}
  >
    Show
  </button>
{/if}"
`;

exports[`Svelte > svelte > Typescript Test > imports 1`] = `
"<script lang=\\"ts\\">
  import Button from \\"./Button.svelte\\";

  let disabled = false;
</script>

<div><Button type=\\"button\\" {disabled}><slot /></Button></div>"
`;

exports[`Svelte > svelte > Typescript Test > lifecycleHooks 1`] = `
"<script lang=\\"ts\\">
  import { afterUpdate, onDestroy, onMount } from \\"svelte\\";

  onMount(() => {
    console.log(\\"onMount\\");
  });

  afterUpdate(() => {
    console.log(\\"onAfterUpdate\\");
  });

  onDestroy(() => {
    console.log(\\"onDestroy\\");
  });
</script>

<div />"
`;

exports[`Svelte > svelte > Typescript Test > reactive 1`] = `
"<script lang=\\"ts\\">
  $: lowercaseName = () => {
    return name.toLowerCase();
  };

  let name = \\"Steve\\";
</script>

<div>
  <input value={name} />
  Lowercase: {lowercaseName()}
</div>"
`;

exports[`Svelte > svelte > Typescript Test > reactiveWithFn 1`] = `
"<script lang=\\"ts\\">
  function calculateResult(a_, b_) {
    result = a_ * b_;
  }

  let a = 2;
  let b = 5;
  let result = null;

  function onUpdateFn_0(..._args: any[]) {
    calculateResult(a, b);
  }

  $: onUpdateFn_0(...[a, b]);
</script>

<div>
  <input type=\\"number\\" bind:value={a} /><input type=\\"number\\" bind:value={b} />
  Result: {result}
</div>"
`;

exports[`Svelte > svelte > Typescript Test > slots 1`] = `
"<script lang=\\"ts\\">
</script>

<div><slot>default</slot><slot name=\\"test\\"><div>default</div></slot></div>"
`;

exports[`Svelte > svelte > Typescript Test > style 1`] = `
"<script lang=\\"ts\\">
</script>

<input class=\\"form-input\\" />

<style>
  input {
    color: red;
    font-size: 12px;
  }

  .form-input:focus {
    outline: 1px solid blue;
  }
</style>"
`;

exports[`Svelte > svelte > Typescript Test > textExpressions 1`] = `
"<script lang=\\"ts\\">
  let a = 5;
  let b = 12;
</script>

<div>
  normal:
  {a + b}<br />
  conditional
  {a > 2 ? \\"hello\\" : \\"bye\\"}
</div>"
`;
