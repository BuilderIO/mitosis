// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`webcomponent Javascript Test AdvancedRef 1`] = `
"export interface Props {
  showInput: boolean;
}

/**
 * Usage:
 *
 *  <my-basic-ref-component></my-basic-ref-component>
 *
 */
class MyBasicRefComponent extends HTMLElement {
  get _inputRef() {
    return this._root.querySelector(
      \\"[data-ref='MyBasicRefComponent-inputRef']\\"
    );
  }

  get _inputNoArgRef() {
    return this._root.querySelector(
      \\"[data-ref='MyBasicRefComponent-inputNoArgRef']\\"
    );
  }

  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      name: \\"PatrickJS\\",
      onBlur: function onBlur() {
        // Maintain focus
        self._inputRef.focus();
      },
      lowerCaseName: function lowerCaseName() {
        return self.state.name.toLowerCase();
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"showInput\\"];

    this.updateDeps = [[self._inputRef, self._inputNoArgRef]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'blur' event on input-my-basic-ref-component-1
    this.onInputMyBasicRefComponent1Blur = (event) => {
      this.state.onBlur();
    };

    // Event handler for 'input' event on input-my-basic-ref-component-1
    this.onInputMyBasicRefComponent1Input = (event) => {
      this.state.name = event.target.value;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"show-my-basic-ref-component\\">
          <input
            class=\\"input\\"
            data-el=\\"input-my-basic-ref-component-1\\"
            data-dom-state=\\"MyBasicRefComponent-input-my-basic-ref-component-1\\"
            data-ref=\\"MyBasicRefComponent-inputRef\\"
          />
      
          <label
            for=\\"cars\\"
            data-el=\\"label-my-basic-ref-component-1\\"
            data-ref=\\"MyBasicRefComponent-inputNoArgRef\\"
          >
            Choose a car:
          </label>
      
          <select
            name=\\"cars\\"
            id=\\"cars\\"
            data-dom-state=\\"MyBasicRefComponent-select-my-basic-ref-component-1\\"
          >
            <option value=\\"supra\\">GR Supra</option>
      
            <option value=\\"86\\">GR 86</option>
          </select>
        </template>
      
        Hello
      
        <template data-el=\\"div-my-basic-ref-component-1\\">
          <!-- state.lowerCaseName() -->
        </template>
        ! I can run in React, Qwik, Vue, Solid, or Web Component!
      </div>
      <style>
        .input {
          color: red;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {
    const self = this;

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        console.log(\\"Received an update\\");
        self.updateDeps[0] = __next;
      }
    })(self.updateDeps[0], [self._inputRef, self._inputNoArgRef]);
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-my-basic-ref-component']\\")
      .forEach((el) => {
        const whenCondition = this.props.showInput;
        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-ref-component-1']\\")
      .forEach((el) => {
        el.value = this.state.name;

        el.removeEventListener(\\"blur\\", this.onInputMyBasicRefComponent1Blur);
        el.addEventListener(\\"blur\\", this.onInputMyBasicRefComponent1Blur);

        el.removeEventListener(\\"input\\", this.onInputMyBasicRefComponent1Input);
        el.addEventListener(\\"input\\", this.onInputMyBasicRefComponent1Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-ref-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.lowerCaseName());
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-ref-component\\", MyBasicRefComponent);
"
`;

exports[`webcomponent Javascript Test Basic 1`] = `
"export interface MyBasicComponentProps {
  id: string;
}

export const DEFAULT_VALUES = {
  name: \\"Steve\\",
};

/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      name: \\"Steve\\",
      underscore_fn_name() {
        return \\"bar\\";
      },
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-basic-component-1
    this.onInputMyBasicComponent1Input = (myEvent) => {
      this.state.name = myEvent.target.value;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div class=\\"test div\\">
        <input
          data-el=\\"input-my-basic-component-1\\"
          data-dom-state=\\"MyBasicComponent-input-my-basic-component-1\\"
        />
      
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>
      <style>
        .div {
          padding: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-component-1']\\")
      .forEach((el) => {
        el.value = DEFAULT_VALUES.name || this.state.name;

        el.removeEventListener(\\"input\\", this.onInputMyBasicComponent1Input);
        el.addEventListener(\\"input\\", this.onInputMyBasicComponent1Input);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent Javascript Test Basic 2`] = `
"/**
 * Usage:
 *
 *  <my-basic-for-show-component></my-basic-for-show-component>
 *
 */
class MyBasicForShowComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-basic-for-show-component-1
    this.onInputMyBasicForShowComponent1Input = (event) => {
      const person = this.getScope(event.currentTarget, \\"person\\");

      this.state.name = event.target.value + \\" and \\" + person;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <template data-el=\\"for-my-basic-for-show-component\\">
          <template data-el=\\"show-my-basic-for-show-component\\">
            <input
              data-el=\\"input-my-basic-for-show-component-1\\"
              data-dom-state=\\"MyBasicForShowComponent-input-my-basic-for-show-component-1\\"
            />
      
            Hello
            <template data-el=\\"div-my-basic-for-show-component-1\\">
              <!-- person -->
            </template>
            ! I can run in Qwik, Web Component, React, Vue, Solid, or Liquid!
          </template>
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='for-my-basic-for-show-component']\\")
      .forEach((el) => {
        let array = this.state.names;
        this.renderLoop(el, array, \\"person\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='show-my-basic-for-show-component']\\")
      .forEach((el) => {
        const person = this.getScope(el, \\"person\\");
        const whenCondition = person === this.state.name;
        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-for-show-component-1']\\")
      .forEach((el) => {
        el.value = this.state.name;

        el.removeEventListener(
          \\"input\\",
          this.onInputMyBasicForShowComponent1Input
        );
        el.addEventListener(\\"input\\", this.onInputMyBasicForShowComponent1Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-for-show-component-1']\\")
      .forEach((el) => {
        const person = this.getScope(el, \\"person\\");
        this.renderTextNode(el, person);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"my-basic-for-show-component\\", MyBasicForShowComponent);
"
`;

exports[`webcomponent Javascript Test Basic Context 1`] = `
"import { Injector, createInjector, MyService } from \\"@dummy/injection-js\\";

/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;
    this.context = createInjector();

    this.onInitOnce = false;

    this.state = {
      name: \\"PatrickJS\\",
      onChange: function onChange() {
        const change = self.myService.method(\\"change\\");
        console.log(change);
      },
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-basic-component-1
    this.onInputMyBasicComponent1Input = (event) => {
      this.state.onChange;
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.myService = this.getContext(this._root, MyService);

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"div-my-basic-component-1\\">
          <!-- myService.method('hello') + state.name -->
        </template>
      
        Hello! I can run in React, Vue, Solid, or Liquid!
      
        <input
          data-el=\\"input-my-basic-component-1\\"
          data-dom-state=\\"MyBasicComponent-input-my-basic-component-1\\"
        />
      </div>\`;
    this.pendingUpdate = true;
    this.onInit();
    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onInit() {
    if (!this.onInitOnce) {
      const hi = this.myService.method(\\"hi\\");
      console.log(hi);
      this.onInitOnce = true;
    }
  }

  onMount() {
    // onMount
    const bye = this.myService.method(\\"hi\\");
    console.log(bye);
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(
          el,
          this.myService.method(\\"hello\\") + this.state.name
        );
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-component-1']\\")
      .forEach((el) => {
        el.removeEventListener(\\"input\\", this.onInputMyBasicComponent1Input);
        el.addEventListener(\\"input\\", this.onInputMyBasicComponent1Input);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // get Context Helper
  getContext(el, token) {
    do {
      let value;
      if (el?.context?.get) {
        value = el.context.get(token);
      } else if (el?.context?.[token]) {
        value = el.context[token];
      }
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent Javascript Test Basic OnMount Update 1`] = `
"export interface Props {
  hi: string;
  bye: string;
}

/**
 * Usage:
 *
 *  <my-basic-on-mount-update-component></my-basic-on-mount-update-component>
 *
 */
class MyBasicOnMountUpdateComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.onInitOnce = false;

    this.state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"hi\\", \\"bye\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        Hello
        <template data-el=\\"div-my-basic-on-mount-update-component-1\\">
          <!-- state.name -->
        </template>
      </div>\`;
    this.pendingUpdate = true;
    this.onInit();
    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onInit() {
    if (!this.onInitOnce) {
      this.state.name = \\"PatrickJS onInit\\" + this.props.hi;
      this.update();
      this.onInitOnce = true;
    }
  }

  onMount() {
    // onMount
    this.state.name = \\"PatrickJS onMount\\" + this.props.bye;
    this.update();
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-on-mount-update-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(
  \\"my-basic-on-mount-update-component\\",
  MyBasicOnMountUpdateComponent
);
"
`;

exports[`webcomponent Javascript Test Basic Outputs 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-outputs-component></my-basic-outputs-component>
 *
 */
class MyBasicOutputsComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\" };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"onMessage\\", \\"onEvent\\", \\"message\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    this.props.onMessage(this.state.name);
    this.props.onEvent(this.props.message);
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-outputs-component\\", MyBasicOutputsComponent);
"
`;

exports[`webcomponent Javascript Test Basic Outputs Meta 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-outputs-component></my-basic-outputs-component>
 *
 */
class MyBasicOutputsComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\" };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"onMessage\\", \\"onEvent\\", \\"message\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    this.props.onMessage(this.state.name);
    this.props.onEvent(this.props.message);
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-outputs-component\\", MyBasicOutputsComponent);
"
`;

exports[`webcomponent Javascript Test BasicChildComponent 1`] = `
"import MyBasicComponent from \\"./basic.raw\\";
import MyBasicOnMountUpdateComponent from \\"./basic-onMount-update.raw\\";

/**
 * Usage:
 *
 *  <my-basic-child-component></my-basic-child-component>
 *
 */
class MyBasicChildComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"Steve\\", dev: \\"PatrickJS\\" };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <my-basic-component
          data-el=\\"my-basic-component-my-basic-child-component\\"
        ></my-basic-component>
      
        <div>
          <my-basic-on-mount-update-component
            data-el=\\"my-basic-on-mount-update-component-my-basic-child-component\\"
          ></my-basic-on-mount-update-component>
        </div>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(
        \\"[data-el='my-basic-component-my-basic-child-component']\\"
      )
      .forEach((el) => {
        el.setAttribute(\\"id\\", this.state.dev);
      });

    this._root
      .querySelectorAll(
        \\"[data-el='my-basic-on-mount-update-component-my-basic-child-component']\\"
      )
      .forEach((el) => {
        el.setAttribute(\\"hi\\", this.state.name);
        el.hi = this.state.name;

        if (el.props) {
          el.props.hi = this.state.name;
          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.hi = this.state.name;
        }

        el.setAttribute(\\"bye\\", this.state.dev);
        el.bye = this.state.dev;

        if (el.props) {
          el.props.bye = this.state.dev;
          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.bye = this.state.dev;
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-child-component\\", MyBasicChildComponent);
"
`;

exports[`webcomponent Javascript Test BasicFor 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-for-component></my-basic-for-component>
 *
 */
class MyBasicForComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-basic-for-component-1
    this.onInputMyBasicForComponent1Input = (event) => {
      const person = this.getScope(event.currentTarget, \\"person\\");

      this.state.name = event.target.value + \\" and \\" + person;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <template data-el=\\"for-my-basic-for-component\\">
          <input
            data-el=\\"input-my-basic-for-component-1\\"
            data-dom-state=\\"MyBasicForComponent-input-my-basic-for-component-1\\"
          />
      
          Hello
          <template data-el=\\"div-my-basic-for-component-1\\"><!-- person --></template>
          ! I can run in Qwik, Web Component, React, Vue, Solid, or Liquid!
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    console.log(\\"onMount code\\");
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='for-my-basic-for-component']\\")
      .forEach((el) => {
        let array = this.state.names;
        this.renderLoop(el, array, \\"person\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-for-component-1']\\")
      .forEach((el) => {
        el.value = this.state.name;

        el.removeEventListener(\\"input\\", this.onInputMyBasicForComponent1Input);
        el.addEventListener(\\"input\\", this.onInputMyBasicForComponent1Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-for-component-1']\\")
      .forEach((el) => {
        const person = this.getScope(el, \\"person\\");
        this.renderTextNode(el, person);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"my-basic-for-component\\", MyBasicForComponent);
"
`;

exports[`webcomponent Javascript Test BasicRef 1`] = `
"export interface Props {
  showInput: boolean;
}

/**
 * Usage:
 *
 *  <my-basic-ref-component></my-basic-ref-component>
 *
 */
class MyBasicRefComponent extends HTMLElement {
  get _inputRef() {
    return this._root.querySelector(
      \\"[data-ref='MyBasicRefComponent-inputRef']\\"
    );
  }

  get _inputNoArgRef() {
    return this._root.querySelector(
      \\"[data-ref='MyBasicRefComponent-inputNoArgRef']\\"
    );
  }

  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      name: \\"PatrickJS\\",
      onBlur: function onBlur() {
        // Maintain focus
        self._inputRef.focus();
      },
      lowerCaseName: function lowerCaseName() {
        return self.state.name.toLowerCase();
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"showInput\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'blur' event on input-my-basic-ref-component-1
    this.onInputMyBasicRefComponent1Blur = (event) => {
      this.state.onBlur();
    };

    // Event handler for 'input' event on input-my-basic-ref-component-1
    this.onInputMyBasicRefComponent1Input = (event) => {
      this.state.name = event.target.value;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"show-my-basic-ref-component\\">
          <input
            class=\\"input\\"
            data-el=\\"input-my-basic-ref-component-1\\"
            data-dom-state=\\"MyBasicRefComponent-input-my-basic-ref-component-1\\"
            data-ref=\\"MyBasicRefComponent-inputRef\\"
          />
      
          <label
            for=\\"cars\\"
            data-el=\\"label-my-basic-ref-component-1\\"
            data-ref=\\"MyBasicRefComponent-inputNoArgRef\\"
          >
            Choose a car:
          </label>
      
          <select
            name=\\"cars\\"
            id=\\"cars\\"
            data-dom-state=\\"MyBasicRefComponent-select-my-basic-ref-component-1\\"
          >
            <option value=\\"supra\\">GR Supra</option>
      
            <option value=\\"86\\">GR 86</option>
          </select>
        </template>
      
        Hello
      
        <template data-el=\\"div-my-basic-ref-component-1\\">
          <!-- state.lowerCaseName() -->
        </template>
        ! I can run in React, Qwik, Vue, Solid, or Web Component!
      </div>
      <style>
        .input {
          color: red;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-my-basic-ref-component']\\")
      .forEach((el) => {
        const whenCondition = this.props.showInput;
        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-ref-component-1']\\")
      .forEach((el) => {
        el.value = this.state.name;

        el.removeEventListener(\\"blur\\", this.onInputMyBasicRefComponent1Blur);
        el.addEventListener(\\"blur\\", this.onInputMyBasicRefComponent1Blur);

        el.removeEventListener(\\"input\\", this.onInputMyBasicRefComponent1Input);
        el.addEventListener(\\"input\\", this.onInputMyBasicRefComponent1Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-ref-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.lowerCaseName());
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-ref-component\\", MyBasicRefComponent);
"
`;

exports[`webcomponent Javascript Test BasicRefAssignment 1`] = `
"export interface Props {
  showInput: boolean;
}

/**
 * Usage:
 *
 *  <my-basic-ref-assignment-component></my-basic-ref-assignment-component>
 *
 */
class MyBasicRefAssignmentComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      handlerClick: function handlerClick(event) {
        event.preventDefault();
        console.log(\\"current value\\", self._holdValueRef);
        self._holdValueRef = self._holdValueRef + \\"JS\\";
      },
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'click' event on button-my-basic-ref-assignment-component-1
    this.onButtonMyBasicRefAssignmentComponent1Click = (evt) => {
      this.state.handlerClick(evt);
    };

    this._holdValueRef = \\"Patrick\\";

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <button data-el=\\"button-my-basic-ref-assignment-component-1\\">Click</button>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(
        \\"[data-el='button-my-basic-ref-assignment-component-1']\\"
      )
      .forEach((el) => {
        el.removeEventListener(
          \\"click\\",
          this.onButtonMyBasicRefAssignmentComponent1Click
        );
        el.addEventListener(
          \\"click\\",
          this.onButtonMyBasicRefAssignmentComponent1Click
        );
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(
  \\"my-basic-ref-assignment-component\\",
  MyBasicRefAssignmentComponent
);
"
`;

exports[`webcomponent Javascript Test BasicRefPrevious 1`] = `
"export interface Props {
  showInput: boolean;
}

export function usePrevious<T>(value: T) {
  // The ref object is a generic container whose current property is mutable ...
  // ... and can hold any value, similar to an instance property on a class
  let ref = useRef<T>(null); // Store current value in ref

  onUpdate(() => {
    ref = value;
  }, [value]); // Only re-run if value changes
  // Return previous value (happens before update in useEffect above)

  return ref;
}

/**
 * Usage:
 *
 *  <my-previous-component></my-previous-component>
 *
 */
class MyPreviousComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { count: 0 };
    if (!this.props) {
      this.props = {};
    }

    this.updateDeps = [[this.state.count]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'click' event on button-my-previous-component-1
    this.onButtonMyPreviousComponent1Click = (event) => {
      this.state.count += 1;
      this.update();
    };

    this._prevCount = state.count;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <h1>
          Now:
          <template data-el=\\"div-my-previous-component-1\\">
            <!-- state.count -->
          </template>
          , before:
          <template data-el=\\"div-my-previous-component-2\\">
            <!-- self._prevCount -->
          </template>
        </h1>
      
        <button data-el=\\"button-my-previous-component-1\\">Increment</button>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        self._prevCount = self.state.count;
        self.updateDeps[0] = __next;
      }
    })(self.updateDeps[0], [self.state.count]);
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-previous-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.count);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-previous-component-2']\\")
      .forEach((el) => {
        this.renderTextNode(el, self._prevCount);
      });

    this._root
      .querySelectorAll(\\"[data-el='button-my-previous-component-1']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onButtonMyPreviousComponent1Click);
        el.addEventListener(\\"click\\", this.onButtonMyPreviousComponent1Click);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-previous-component\\", MyPreviousComponent);
"
`;

exports[`webcomponent Javascript Test Button 1`] = `
"export interface ButtonProps {
  attributes?: any;
  text?: string;
  link?: string;
  openLinkInNewTab?: boolean;
}

/**
 * Usage:
 *
 *  <button></button>
 *
 */
class Button extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"link\\", \\"attributes\\", \\"openLinkInNewTab\\", \\"text\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"show-button\\">
          <a data-el=\\"a-button-1\\">
            <template data-el=\\"div-button-1\\"><!-- props.text --></template>
          </a>
        </template>
      
        <template data-el=\\"show-button-2\\">
          <button type=\\"button\\" data-el=\\"button-button-1\\">
            <template data-el=\\"div-button-2\\"><!-- props.text --></template>
          </button>
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='show-button']\\").forEach((el) => {
      const whenCondition = this.props.link;
      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='a-button-1']\\").forEach((el) => {
      el.setAttribute(\\"href\\", this.props.link);

      el.setAttribute(
        \\"target\\",
        this.props.openLinkInNewTab ? \\"_blank\\" : undefined
      );
    });

    this._root.querySelectorAll(\\"[data-el='div-button-1']\\").forEach((el) => {
      this.renderTextNode(el, this.props.text);
    });

    this._root.querySelectorAll(\\"[data-el='show-button-2']\\").forEach((el) => {
      const whenCondition = !this.props.link;
      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='div-button-2']\\").forEach((el) => {
      this.renderTextNode(el, this.props.text);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"button\\", Button);
"
`;

exports[`webcomponent Javascript Test Columns 1`] = `
"type Column = {
  content: any; // TODO: Implement this when support for dynamic CSS lands

  width?: number;
};
export interface ColumnProps {
  columns?: Column[]; // TODO: Implement this when support for dynamic CSS lands

  space?: number; // TODO: Implement this when support for dynamic CSS lands

  stackColumnsAt?: \\"tablet\\" | \\"mobile\\" | \\"never\\"; // TODO: Implement this when support for dynamic CSS lands

  reverseColumnsWhenStacked?: boolean;
}

/**
 * Usage:
 *
 *  <column></column>
 *
 */
class Column extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      getColumns() {
        return self.props.columns || [];
      },
      getGutterSize() {
        return typeof self.props.space === \\"number\\"
          ? self.props.space || 0
          : 20;
      },
      getWidth(index) {
        const columns = this.getColumns();
        return (columns[index] && columns[index].width) || 100 / columns.length;
      },
      getColumnCssWidth(index) {
        const columns = this.getColumns();
        const gutterSize = this.getGutterSize();
        const subtractWidth =
          (gutterSize * (columns.length - 1)) / columns.length;
        return \`calc(\${this.getWidth(index)}% - \${subtractWidth}px)\`;
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"columns\\", \\"space\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div class=\\"builder-columns div\\">
        <template data-el=\\"for-column\\">
          <div class=\\"builder-column div-2\\">
            <template data-el=\\"div-column-1\\"><!-- column.content --></template>
      
            <template data-el=\\"div-column-2\\"><!-- index --></template>
          </div>
        </template>
      </div>
      <style>
        .div {
          display: flex;
          flex-direction: column;
          align-items: stretch;
          line-height: normal;
        }
        @media (max-width: 999px) {
          .div {
            flex-direction: row;
          }
        }
        @media (max-width: 639px) {
          .div {
            flex-direction: row-reverse;
          }
        }
        .div-2 {
          flex-grow: 1;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='for-column']\\").forEach((el) => {
      let array = this.props.columns;
      this.renderLoop(el, array, \\"column\\", \\"index\\");
    });

    this._root.querySelectorAll(\\"[data-el='div-column-1']\\").forEach((el) => {
      const column = this.getScope(el, \\"column\\");
      this.renderTextNode(el, column.content);
    });

    this._root.querySelectorAll(\\"[data-el='div-column-2']\\").forEach((el) => {
      const index = this.getScope(el, \\"index\\");
      this.renderTextNode(el, index);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"column\\", Column);
"
`;

exports[`webcomponent Javascript Test ContentSlotHtml 1`] = `
"type Props = {
  [key: string]: string | JSX.Element;
  slotTesting: JSX.Element;
};

/**
 * Usage:
 *
 *  <content-slot-code></content-slot-code>
 *
 */
class ContentSlotCode extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"slotTesting\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <slot data-el=\\"slot-content-slot-code\\"></slot>
      
        <div>
          <hr />
        </div>
      
        <div>
          <slot></slot>
        </div>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='slot-content-slot-code']\\")
      .forEach((el) => {
        el.setAttribute(\\"name\\", this.props.slotTesting);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"content-slot-code\\", ContentSlotCode);
"
`;

exports[`webcomponent Javascript Test ContentSlotJSX 1`] = `
"type Props = {
  [key: string]: string | JSX.Element;
};

/**
 * Usage:
 *
 *  <content-slot-jsx-code></content-slot-jsx-code>
 *
 */
class ContentSlotJsxCode extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"slotTesting\\", \\"children\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"show-content-slot-jsx-code\\">
          <div>
            <template data-el=\\"div-content-slot-jsx-code-1\\">
              <!-- props.slotTesting -->
            </template>
          </div>
        </template>
      
        <div>
          <hr />
        </div>
      
        <div><slot></slot></div>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-content-slot-jsx-code']\\")
      .forEach((el) => {
        const whenCondition = this.props.slotTesting;
        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='div-content-slot-jsx-code-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.slotTesting);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"content-slot-jsx-code\\", ContentSlotJsxCode);
"
`;

exports[`webcomponent Javascript Test CustomCode 1`] = `
"export interface CustomCodeProps {
  code: string;
  replaceNodes?: boolean;
}

/**
 * Usage:
 *
 *  <custom-code></custom-code>
 *
 */
class CustomCode extends HTMLElement {
  get _elem() {
    return this._root.querySelector(\\"[data-ref='CustomCode-elem']\\");
  }

  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      scriptsInserted: [],
      scriptsRun: [],
      findAndRunScripts() {
        // TODO: Move this function to standalone one in '@builder.io/utils'
        if (self._elem && typeof window !== \\"undefined\\") {
          /** @type {HTMLScriptElement[]} */
          const scripts = self._elem.getElementsByTagName(\\"script\\");

          for (let i = 0; i < scripts.length; i++) {
            const script = scripts[i];

            if (script.src) {
              if (self.state.scriptsInserted.includes(script.src)) {
                continue;
              }

              self.state.scriptsInserted.push(script.src);
              const newScript = document.createElement(\\"script\\");
              newScript.async = true;
              newScript.src = script.src;
              document.head.appendChild(newScript);
            } else if (
              !script.type ||
              [
                \\"text/javascript\\",
                \\"application/javascript\\",
                \\"application/ecmascript\\",
              ].includes(script.type)
            ) {
              if (self.state.scriptsRun.includes(script.innerText)) {
                continue;
              }

              try {
                self.state.scriptsRun.push(script.innerText);
                new Function(script.innerText)();
              } catch (error) {
                console.warn(\\"\`CustomCode\`: Error running script:\\", error);
              }
            }
          }
        }
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"replaceNodes\\", \\"code\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div data-el=\\"div-custom-code-1\\" data-ref=\\"CustomCode-elem\\"></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    this.state.findAndRunScripts();
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-custom-code-1']\\")
      .forEach((el) => {
        el.className =
          \\"builder-custom-code\\" +
          (this.props.replaceNodes ? \\" replace-nodes\\" : \\"\\");

        el.innerHTML = this.props.code;
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"custom-code\\", CustomCode);
"
`;

exports[`webcomponent Javascript Test Embed 1`] = `
"export interface CustomCodeProps {
  code: string;
  replaceNodes?: boolean;
}

/**
 * Usage:
 *
 *  <custom-code></custom-code>
 *
 */
class CustomCode extends HTMLElement {
  get _elem() {
    return this._root.querySelector(\\"[data-ref='CustomCode-elem']\\");
  }

  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      scriptsInserted: [],
      scriptsRun: [],
      findAndRunScripts() {
        // TODO: Move this function to standalone one in '@builder.io/utils'
        if (self._elem && typeof window !== \\"undefined\\") {
          /** @type {HTMLScriptElement[]} */
          const scripts = self._elem.getElementsByTagName(\\"script\\");

          for (let i = 0; i < scripts.length; i++) {
            const script = scripts[i];

            if (script.src) {
              if (self.state.scriptsInserted.includes(script.src)) {
                continue;
              }

              self.state.scriptsInserted.push(script.src);
              const newScript = document.createElement(\\"script\\");
              newScript.async = true;
              newScript.src = script.src;
              document.head.appendChild(newScript);
            } else if (
              !script.type ||
              [
                \\"text/javascript\\",
                \\"application/javascript\\",
                \\"application/ecmascript\\",
              ].includes(script.type)
            ) {
              if (self.state.scriptsRun.includes(script.innerText)) {
                continue;
              }

              try {
                self.state.scriptsRun.push(script.innerText);
                new Function(script.innerText)();
              } catch (error) {
                console.warn(\\"\`CustomCode\`: Error running script:\\", error);
              }
            }
          }
        }
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"replaceNodes\\", \\"code\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div data-el=\\"div-custom-code-1\\" data-ref=\\"CustomCode-elem\\"></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    this.state.findAndRunScripts();
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-custom-code-1']\\")
      .forEach((el) => {
        el.className =
          \\"builder-custom-code\\" +
          (this.props.replaceNodes ? \\" replace-nodes\\" : \\"\\");

        el.innerHTML = this.props.code;
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"custom-code\\", CustomCode);
"
`;

exports[`webcomponent Javascript Test Image 1`] = `
"// TODO: AMP Support?
export interface ImageProps {
  _class?: string;
  image: string;
  sizes?: string;
  lazy?: boolean;
  height?: number;
  width?: number;
  altText?: string;
  backgroundSize?: string;
  backgroundPosition?: string; // TODO: Support generating Builder.io and or Shopify \`srcset\`s when needed

  srcset?: string; // TODO: Implement support for custom aspect ratios

  aspectRatio?: number; // TODO: This might not work as expected in terms of positioning

  children?: any;
}

/**
 * Usage:
 *
 *  <image></image>
 *
 */
class Image extends HTMLElement {
  get _pictureRef() {
    return this._root.querySelector(\\"[data-ref='Image-pictureRef']\\");
  }

  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      scrollListener: null,
      imageLoaded: false,
      setLoaded() {
        self.state.imageLoaded = true;
        self.update();
      },
      useLazyLoading() {
        // TODO: Add more checks here, like testing for real web browsers
        return !!self.props.lazy && isBrowser();
      },
      isBrowser: function isBrowser() {
        return (
          typeof window !== \\"undefined\\" &&
          window.navigator.product != \\"ReactNative\\"
        );
      },
      load: false,
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"lazy\\",
      \\"altText\\",
      \\"_class\\",
      \\"image\\",
      \\"srcset\\",
      \\"sizes\\",
      \\"children\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'load' event on img-image-1
    this.onImgImage1Load = (event) => {
      this.state.setLoaded();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  disconnectedCallback() {
    // onUnMount
    if (this.state.scrollListener) {
      window.removeEventListener(\\"scroll\\", this.state.scrollListener);
    }
    this.destroyAnyNodes(); // clean up nodes when component is destroyed
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <picture data-el=\\"picture-image-1\\" data-ref=\\"Image-pictureRef\\">
          <template data-el=\\"show-image\\">
            <img data-el=\\"img-image-1\\" />
          </template>
      
          <source data-el=\\"source-image-1\\" />
        </picture>
      
        <slot></slot>
      </div>
      <style>
        .img {
          opacity: 1;
          transition: opacity 0.2s ease-in-out;
          object-fit: cover;
          object-position: center;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {
    // onMount
    if (this.state.useLazyLoading()) {
      // throttled scroll capture listener
      const listener = () => {
        if (self._pictureRef) {
          const rect = self._pictureRef.getBoundingClientRect();

          const buffer = window.innerHeight / 2;

          if (rect.top < window.innerHeight + buffer) {
            setLoad(true);
            this.state.scrollListener = null;
            this.update();
            window.removeEventListener(\\"scroll\\", listener);
          }
        }
      };

      this.state.scrollListener = listener;
      this.update();
      window.addEventListener(\\"scroll\\", listener, {
        capture: true,
        passive: true,
      });
      listener();
    }
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='show-image']\\").forEach((el) => {
      const whenCondition = !this.state.useLazyLoading() || this.state.load;
      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='img-image-1']\\").forEach((el) => {
      el.setAttribute(\\"alt\\", this.props.altText);

      el.setAttribute(
        \\"aria-role\\",
        this.props.altText ? \\"presentation\\" : undefined
      );

      el.className =
        \\"builder-image\\" +
        (this.props._class ? \\" \\" + this.props._class : \\"\\") +
        \\" img\\";

      el.setAttribute(\\"src\\", this.props.image);

      el.removeEventListener(\\"load\\", this.onImgImage1Load);
      el.addEventListener(\\"load\\", this.onImgImage1Load);

      el.setAttribute(\\"srcset\\", this.props.srcset);

      el.setAttribute(\\"sizes\\", this.props.sizes);
    });

    this._root.querySelectorAll(\\"[data-el='source-image-1']\\").forEach((el) => {
      el.setAttribute(\\"srcset\\", this.props.srcset);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"image\\", Image);
"
`;

exports[`webcomponent Javascript Test Image State 1`] = `
"/**
 * Usage:
 *
 *  <img-state-component></img-state-component>
 *
 */
class ImgStateComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { canShow: true, images: [\\"http://example.com/qwik.png\\"] };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <template data-el=\\"for-img-state-component\\">
          <img class=\\"custom-class\\" data-el=\\"img-img-state-component-1\\" />
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='for-img-state-component']\\")
      .forEach((el) => {
        let array = this.state.images;
        this.renderLoop(el, array, \\"item\\", \\"itemIndex\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='img-img-state-component-1']\\")
      .forEach((el) => {
        const item = this.getScope(el, \\"item\\");
        const itemIndex = this.getScope(el, \\"itemIndex\\");

        el.setAttribute(\\"src\\", item);

        el.key = itemIndex;
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"img-state-component\\", ImgStateComponent);
"
`;

exports[`webcomponent Javascript Test Img 1`] = `
"export interface ImgProps {
  attributes?: any;
  imgSrc?: string;
  altText?: string;
  backgroundSize?: \\"cover\\" | \\"contain\\";
  backgroundPosition?:
    | \\"center\\"
    | \\"top\\"
    | \\"left\\"
    | \\"right\\"
    | \\"bottom\\"
    | \\"top left\\"
    | \\"top right\\"
    | \\"bottom left\\"
    | \\"bottom right\\";
}

import { Builder } from \\"@builder.io/sdk\\";

/**
 * Usage:
 *
 *  <img-component></img-component>
 *
 */
class ImgComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"backgroundSize\\",
      \\"backgroundPosition\\",
      \\"attributes\\",
      \\"imgSrc\\",
      \\"altText\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <img data-el=\\"img-img-component-1\\" />\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='img-img-component-1']\\")
      .forEach((el) => {
        Object.assign(el.style, {
          objectFit: this.props.backgroundSize || \\"cover\\",
          objectPosition: this.props.backgroundPosition || \\"center\\",
        });

        el.key = (Builder.isEditing && this.props.imgSrc) || \\"default-key\\";

        el.setAttribute(\\"alt\\", this.props.altText);

        el.setAttribute(\\"src\\", this.props.imgSrc);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"img-component\\", ImgComponent);
"
`;

exports[`webcomponent Javascript Test Input 1`] = `
"export interface FormInputProps {
  type?: string;
  attributes?: any;
  name?: string;
  value?: string;
  placeholder?: string;
  defaultValue?: string;
  required?: boolean;
}

import { Builder } from \\"@builder.io/sdk\\";

/**
 * Usage:
 *
 *  <form-input-component></form-input-component>
 *
 */
class FormInputComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"attributes\\",
      \\"defaultValue\\",
      \\"placeholder\\",
      \\"type\\",
      \\"name\\",
      \\"value\\",
      \\"required\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <input
        data-el=\\"input-form-input-component-1\\"
        data-dom-state=\\"FormInputComponent-input-form-input-component-1\\"
      />\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-form-input-component-1']\\")
      .forEach((el) => {
        el.key =
          Builder.isEditing && this.props.defaultValue
            ? this.props.defaultValue
            : \\"default-key\\";

        el.setAttribute(\\"placeholder\\", this.props.placeholder);

        el.setAttribute(\\"type\\", this.props.type);

        el.setAttribute(\\"name\\", this.props.name);

        el.value = this.props.value;

        el.setAttribute(\\"defaultValue\\", this.props.defaultValue);

        el.setAttribute(\\"required\\", this.props.required);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"form-input-component\\", FormInputComponent);
"
`;

exports[`webcomponent Javascript Test RawText 1`] = `
"export interface RawTextProps {
  attributes?: any;
  text?: string; // builderBlock?: any;
}

/**
 * Usage:
 *
 *  <raw-text></raw-text>
 *
 */
class RawText extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"attributes\\", \\"text\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <span data-el=\\"span-raw-text-1\\"></span>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='span-raw-text-1']\\").forEach((el) => {
      el.className =
        this.props.attributes?.class || this.props.attributes?.className;

      el.innerHTML = this.props.text || \\"\\";
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"raw-text\\", RawText);
"
`;

exports[`webcomponent Javascript Test Section 1`] = `
"export interface SectionProps {
  maxWidth?: number;
  attributes?: any;
  children?: any;
}

/**
 * Usage:
 *
 *  <section-component></section-component>
 *
 */
class SectionComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"attributes\\", \\"maxWidth\\", \\"children\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <section data-el=\\"section-section-component-1\\">
        <slot></slot>
      </section>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='section-section-component-1']\\")
      .forEach((el) => {
        Object.assign(
          el.style,
          this.props.maxWidth && typeof this.props.maxWidth === \\"number\\"
            ? {
                maxWidth: this.props.maxWidth,
              }
            : undefined
        );
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"section-component\\", SectionComponent);
"
`;

exports[`webcomponent Javascript Test Section 2`] = `
"export interface SectionProps {
  maxWidth?: number;
  attributes?: any;
  children?: any;
}

/**
 * Usage:
 *
 *  <section-state-component></section-state-component>
 *
 */
class SectionStateComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { max: 42, items: [42] };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"attributes\\", \\"children\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"show-section-state-component\\">
        <template data-el=\\"for-section-state-component\\">
          <section data-el=\\"section-section-state-component-1\\">
            <slot></slot>
          </section>
        </template>
      </template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-section-state-component']\\")
      .forEach((el) => {
        const whenCondition = this.state.max;
        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='for-section-state-component']\\")
      .forEach((el) => {
        let array = this.state.items;
        this.renderLoop(el, array, \\"item\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='section-section-state-component-1']\\")
      .forEach((el) => {
        const item = this.getScope(el, \\"item\\");
        Object.assign(el.style, {
          maxWidth: item + this.state.max,
        });
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"section-state-component\\", SectionStateComponent);
"
`;

exports[`webcomponent Javascript Test Select 1`] = `
"export interface FormSelectProps {
  options?: {
    name?: string;
    value: string;
  }[];
  attributes?: any;
  name?: string;
  value?: string;
  defaultValue?: string;
}

import { Builder } from \\"@builder.io/sdk\\";

/**
 * Usage:
 *
 *  <select-component></select-component>
 *
 */
class SelectComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"attributes\\",
      \\"value\\",
      \\"defaultValue\\",
      \\"name\\",
      \\"options\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <select
        data-el=\\"select-select-component-1\\"
        data-dom-state=\\"SelectComponent-select-select-component-1\\"
      >
        <template data-el=\\"for-select-component\\">
          <option data-el=\\"option-select-component-1\\">
            <template data-el=\\"div-select-component-1\\">
              <!-- option.name || option.value -->
            </template>
          </option>
        </template>
      </select>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='select-select-component-1']\\")
      .forEach((el) => {
        el.value = this.props.value;

        el.key =
          Builder.isEditing && this.props.defaultValue
            ? this.props.defaultValue
            : \\"default-key\\";

        el.setAttribute(\\"defaultValue\\", this.props.defaultValue);

        el.setAttribute(\\"name\\", this.props.name);
      });

    this._root
      .querySelectorAll(\\"[data-el='for-select-component']\\")
      .forEach((el) => {
        let array = this.props.options;
        this.renderLoop(el, array, \\"option\\", \\"index\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='option-select-component-1']\\")
      .forEach((el) => {
        const option = this.getScope(el, \\"option\\");
        const index = this.getScope(el, \\"index\\");

        el.value = option.value;

        el.setAttribute(\\"data-index\\", index);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-select-component-1']\\")
      .forEach((el) => {
        const option = this.getScope(el, \\"option\\");
        this.renderTextNode(el, option.name || option.value);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"select-component\\", SelectComponent);
"
`;

exports[`webcomponent Javascript Test SlotHtml 1`] = `
"type Props = {
  [key: string]: string;
};

import ContentSlotCode from \\"./content-slot-jsx.raw\\";

/**
 * Usage:
 *
 *  <slot-code></slot-code>
 *
 */
class SlotCode extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <content-slot-code>
          <slot data-el=\\"slot-slot-code\\"></slot>
        </content-slot-code>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='slot-slot-code']\\").forEach((el) => {
      el.setAttribute(\\"testing\\", <div>Hello</div>);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"slot-code\\", SlotCode);
"
`;

exports[`webcomponent Javascript Test SlotJsx 1`] = `
"type Props = {
  [key: string]: string;
};

import ContentSlotCode from \\"./content-slot-jsx.raw\\";

/**
 * Usage:
 *
 *  <slot-code></slot-code>
 *
 */
class SlotCode extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <content-slot-code data-el=\\"content-slot-code-slot-code\\"></content-slot-code>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='content-slot-code-slot-code']\\")
      .forEach((el) => {
        el.setAttribute(\\"slotTesting\\", <div>Hello</div>);
        el.slotTesting = <div>Hello</div>;

        if (el.props) {
          el.props.slotTesting = <div>Hello</div>;
          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.slotTesting = <div>Hello</div>;
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"slot-code\\", SlotCode);
"
`;

exports[`webcomponent Javascript Test Stamped.io 1`] = `
"type SmileReviewsProps = {
  productId: string;
  apiKey: string;
};

import { kebabCase } from \\"lodash\\";
import { snakeCase } from \\"lodash\\";

/**
 * Usage:
 *
 *  <smile-reviews></smile-reviews>
 *
 */
class SmileReviews extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      reviews: [],
      name: \\"test\\",
      showReviewPrompt: false,
      kebabCaseValue() {
        return kebabCase(\\"testThat\\");
      },
      snakeCaseValue() {
        return snakeCase(\\"testThis\\");
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"apiKey\\", \\"productId\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'click' event on button-smile-reviews-1
    this.onButtonSmileReviews1Click = (event) => {
      this.state.showReviewPrompt = true;
      this.update();
    };

    // Event handler for 'click' event on button-smile-reviews-2
    this.onButtonSmileReviews2Click = (event) => {
      event.preventDefault();
      this.state.showReviewPrompt = false;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div data-el=\\"div-smile-reviews-1\\">
        <button data-el=\\"button-smile-reviews-1\\">Write a review</button>
      
        <template data-el=\\"show-smile-reviews\\">
          <input
            placeholder=\\"Email\\"
            data-dom-state=\\"SmileReviews-input-smile-reviews-1\\"
          />
      
          <input
            placeholder=\\"Title\\"
            class=\\"input\\"
            data-dom-state=\\"SmileReviews-input-smile-reviews-2\\"
          />
      
          <textarea
            placeholder=\\"How was your experience?\\"
            class=\\"textarea\\"
            data-dom-state=\\"SmileReviews-textarea-smile-reviews-1\\"
          ></textarea>
      
          <button class=\\"button\\" data-el=\\"button-smile-reviews-2\\">Submit</button>
        </template>
      
        <template data-el=\\"for-smile-reviews\\">
          <div class=\\"review\\" data-el=\\"div-smile-reviews-2\\">
            <img class=\\"img\\" data-el=\\"img-smile-reviews-1\\" />
      
            <div data-el=\\"div-smile-reviews-3\\">
              <div>
                N:
                <template data-el=\\"div-smile-reviews-4\\"><!-- index --></template>
              </div>
      
              <div>
                <template data-el=\\"div-smile-reviews-5\\">
                  <!-- review.author -->
                </template>
              </div>
      
              <div>
                <template data-el=\\"div-smile-reviews-6\\">
                  <!-- review.reviewMessage -->
                </template>
              </div>
            </div>
          </div>
        </template>
      </div>
      <style>
        .input {
          display: block;
        }
        .textarea {
          display: block;
        }
        .button {
          display: block;
        }
        .review {
          margin: 10px;
          padding: 10px;
          background: white;
          display: flex;
          border-radius: 5px;
          box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .img {
          height: 30px;
          width: 30px;
          margin-right: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {
    // onMount
    fetch(
      \`https://stamped.io/api/widget/reviews?storeUrl=builder-io.myshopify.com&apiKey=\${
        this.props.apiKey || \\"pubkey-8bbDq7W6w4sB3OWeM1HUy2s47702hM\\"
      }&productId=\${this.props.productId || \\"2410511106127\\"}\`
    )
      .then((res) => res.json())
      .then((data) => {
        this.state.reviews = data.data;
        this.update();
      });
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-1']\\")
      .forEach((el) => {
        el.setAttribute(\\"data-user\\", this.state.name);
      });

    this._root
      .querySelectorAll(\\"[data-el='button-smile-reviews-1']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onButtonSmileReviews1Click);
        el.addEventListener(\\"click\\", this.onButtonSmileReviews1Click);
      });

    this._root
      .querySelectorAll(\\"[data-el='show-smile-reviews']\\")
      .forEach((el) => {
        const whenCondition = this.state.showReviewPrompt;
        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='button-smile-reviews-2']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onButtonSmileReviews2Click);
        el.addEventListener(\\"click\\", this.onButtonSmileReviews2Click);
      });

    this._root
      .querySelectorAll(\\"[data-el='for-smile-reviews']\\")
      .forEach((el) => {
        let array = this.state.reviews;
        this.renderLoop(el, array, \\"review\\", \\"index\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-2']\\")
      .forEach((el) => {
        const review = this.getScope(el, \\"review\\");

        el.key = review.id;
      });

    this._root
      .querySelectorAll(\\"[data-el='img-smile-reviews-1']\\")
      .forEach((el) => {
        const review = this.getScope(el, \\"review\\");

        el.setAttribute(\\"src\\", review.avatar);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-3']\\")
      .forEach((el) => {
        el.className = this.state.showReviewPrompt
          ? \\"bg-primary\\"
          : \\"bg-secondary\\";
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-4']\\")
      .forEach((el) => {
        const index = this.getScope(el, \\"index\\");
        this.renderTextNode(el, index);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-5']\\")
      .forEach((el) => {
        const review = this.getScope(el, \\"review\\");
        this.renderTextNode(el, review.author);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-6']\\")
      .forEach((el) => {
        const review = this.getScope(el, \\"review\\");
        this.renderTextNode(el, review.reviewMessage);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"smile-reviews\\", SmileReviews);
"
`;

exports[`webcomponent Javascript Test Submit 1`] = `
"export interface ButtonProps {
  attributes?: any;
  text?: string;
}

/**
 * Usage:
 *
 *  <submit-button></submit-button>
 *
 */
class SubmitButton extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"attributes\\", \\"text\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <button type=\\"submit\\" data-el=\\"button-submit-button-1\\">
        <template data-el=\\"div-submit-button-1\\"><!-- props.text --></template>
      </button>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-submit-button-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.text);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"submit-button\\", SubmitButton);
"
`;

exports[`webcomponent Javascript Test Text 1`] = `
"export interface TextProps {
  attributes?: any;
  rtlMode: boolean;
  text?: string;
  content?: string;
  builderBlock?: any;
}

import { Builder } from \\"@builder.io/sdk\\";

/**
 * Usage:
 *
 *  <text></text>
 *
 */
class Text extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"Decadef20\\" };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"text\\", \\"content\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div data-el=\\"div-text-1\\"></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='div-text-1']\\").forEach((el) => {
      el.setAttribute(\\"contentEditable\\", allowEditingText || undefined);

      el.setAttribute(\\"data-name\\", {
        test: this.state.name || \\"any name\\",
      });

      el.innerHTML =
        this.props.text ||
        this.props.content ||
        this.state.name ||
        '<p class=\\"text-lg\\">my name</p>';
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"text\\", Text);
"
`;

exports[`webcomponent Javascript Test Textarea 1`] = `
"export interface TextareaProps {
  attributes?: any;
  name?: string;
  value?: string;
  defaultValue?: string;
  placeholder?: string;
}

/**
 * Usage:
 *
 *  <textarea></textarea>
 *
 */
class Textarea extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"attributes\\",
      \\"placeholder\\",
      \\"name\\",
      \\"value\\",
      \\"defaultValue\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <textarea
        data-el=\\"textarea-textarea-1\\"
        data-dom-state=\\"Textarea-textarea-textarea-1\\"
      ></textarea>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='textarea-textarea-1']\\")
      .forEach((el) => {
        el.setAttribute(\\"placeholder\\", this.props.placeholder);

        el.setAttribute(\\"name\\", this.props.name);

        el.value = this.props.value;

        el.setAttribute(\\"defaultValue\\", this.props.defaultValue);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"textarea\\", Textarea);
"
`;

exports[`webcomponent Javascript Test Video 1`] = `
"export interface VideoProps {
  attributes?: any;
  video?: string;
  autoPlay?: boolean;
  controls?: boolean;
  muted?: boolean;
  loop?: boolean;
  playsInline?: boolean;
  aspectRatio?: number;
  width?: number;
  height?: number;
  fit?: \\"contain\\" | \\"cover\\" | \\"fill\\";
  position?:
    | \\"center\\"
    | \\"top\\"
    | \\"left\\"
    | \\"right\\"
    | \\"bottom\\"
    | \\"top left\\"
    | \\"top right\\"
    | \\"bottom left\\"
    | \\"bottom right\\";
  posterImage?: string;
  lazyLoad?: boolean;
}

/**
 * Usage:
 *
 *  <video></video>
 *
 */
class Video extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"attributes\\",
      \\"fit\\",
      \\"position\\",
      \\"video\\",
      \\"posterImage\\",
      \\"autoPlay\\",
      \\"muted\\",
      \\"controls\\",
      \\"loop\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <video preload=\\"none\\" data-el=\\"video-video-1\\"></video>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='video-video-1']\\").forEach((el) => {
      Object.assign(el.style, {
        width: \\"100%\\",
        height: \\"100%\\",
        ...this.props.attributes?.style,
        objectFit: this.props.fit,
        objectPosition: this.props.position,
        // Hack to get object fit to work as expected and
        // not have the video overflow
        borderRadius: 1,
      });

      el.key = this.props.video || \\"no-src\\";

      el.setAttribute(\\"poster\\", this.props.posterImage);

      el.setAttribute(\\"autoplay\\", this.props.autoPlay);

      el.setAttribute(\\"muted\\", this.props.muted);

      el.setAttribute(\\"controls\\", this.props.controls);

      el.setAttribute(\\"loop\\", this.props.loop);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"video\\", Video);
"
`;

exports[`webcomponent Javascript Test basicForwardRef 1`] = `
"export interface Props {
  showInput: boolean;
  inputRef: HTMLInputElement;
}

/**
 * Usage:
 *
 *  <my-basic-forward-ref-component></my-basic-forward-ref-component>
 *
 */
class MyBasicForwardRefComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\" };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-basic-forward-ref-component-1
    this.onInputMyBasicForwardRefComponent1Input = (event) => {
      this.state.name = event.target.value;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <input
          class=\\"input\\"
          data-el=\\"input-my-basic-forward-ref-component-1\\"
          data-dom-state=\\"MyBasicForwardRefComponent-input-my-basic-forward-ref-component-1\\"
        />
      </div>
      <style>
        .input {
          color: red;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-forward-ref-component-1']\\")
      .forEach((el) => {
        el.value = this.state.name;

        el.removeEventListener(
          \\"input\\",
          this.onInputMyBasicForwardRefComponent1Input
        );
        el.addEventListener(
          \\"input\\",
          this.onInputMyBasicForwardRefComponent1Input
        );
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(
  \\"my-basic-forward-ref-component\\",
  MyBasicForwardRefComponent
);
"
`;

exports[`webcomponent Javascript Test basicForwardRefMetadata 1`] = `
"export interface Props {
  showInput: boolean;
  inputRef: HTMLInputElement;
}

/**
 * Usage:
 *
 *  <my-basic-forward-ref-component></my-basic-forward-ref-component>
 *
 */
class MyBasicForwardRefComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\" };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-basic-forward-ref-component-1
    this.onInputMyBasicForwardRefComponent1Input = (event) => {
      this.state.name = event.target.value;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <input
          class=\\"input\\"
          data-el=\\"input-my-basic-forward-ref-component-1\\"
          data-dom-state=\\"MyBasicForwardRefComponent-input-my-basic-forward-ref-component-1\\"
        />
      </div>
      <style>
        .input {
          color: red;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-forward-ref-component-1']\\")
      .forEach((el) => {
        el.value = this.state.name;

        el.removeEventListener(
          \\"input\\",
          this.onInputMyBasicForwardRefComponent1Input
        );
        el.addEventListener(
          \\"input\\",
          this.onInputMyBasicForwardRefComponent1Input
        );
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(
  \\"my-basic-forward-ref-component\\",
  MyBasicForwardRefComponent
);
"
`;

exports[`webcomponent Javascript Test basicOnUpdateReturn 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-on-update-return-component></my-basic-on-update-return-component>
 *
 */
class MyBasicOnUpdateReturnComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\" };
    if (!this.props) {
      this.props = {};
    }

    this.updateDeps = [[this.state.name]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        Hello!
        <template data-el=\\"div-my-basic-on-update-return-component-1\\">
          <!-- state.name -->
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        const controller = new AbortController();
        const signal = controller.signal;
        fetch(\\"https://patrickjs.com/api/resource.json\\", {
          signal,
        })
          .then((response) => response.json())
          .then((data) => {
            self.state.name = data.name;
          });
        return () => {
          if (!signal.aborted) {
            controller.abort();
          }
        };
        self.updateDeps[0] = __next;
      }
    })(self.updateDeps[0], [self.state.name]);
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-on-update-return-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(
  \\"my-basic-on-update-return-component\\",
  MyBasicOnUpdateReturnComponent
);
"
`;

exports[`webcomponent Javascript Test class + ClassName + css 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div class=\\"test2 test div\\">
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>
      <style>
        .div {
          padding: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent Javascript Test class + css 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div class=\\"test div\\">Hello! I can run in React, Vue, Solid, or Liquid!</div>
      <style>
        .div {
          padding: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent Javascript Test className + css 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div class=\\"test div\\">Hello! I can run in React, Vue, Solid, or Liquid!</div>
      <style>
        .div {
          padding: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent Javascript Test className 1`] = `
"type Props = {
  [key: string]: string | JSX.Element;
  slotTesting: JSX.Element;
};

/**
 * Usage:
 *
 *  <class-name-code></class-name-code>
 *
 */
class ClassNameCode extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { bindings: \\"a binding\\" };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <div class=\\"no binding\\">Without Binding</div>
      
        <div data-el=\\"div-class-name-code-1\\">With binding</div>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-class-name-code-1']\\")
      .forEach((el) => {
        el.className = this.state.bindings;
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"class-name-code\\", ClassNameCode);
"
`;

exports[`webcomponent Javascript Test classState 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      classState: \\"testClassName\\",
      styleState: {
        color: \\"red\\",
      },
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div data-el=\\"div-my-basic-component-1\\">
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>
      <style>
        .div {
          padding: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-1']\\")
      .forEach((el) => {
        el.className = this.state.classState + \\" div\\";

        Object.assign(el.style, this.state.styleState);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent Javascript Test defaultProps 1`] = `
"export interface ButtonProps {
  attributes?: any;
  text?: string;
  link?: string;
  openLinkInNewTab?: boolean;
}

/**
 * Usage:
 *
 *  <button></button>
 *
 */
class Button extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"link\\", \\"attributes\\", \\"openLinkInNewTab\\", \\"text\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"show-button\\">
          <a data-el=\\"a-button-1\\">
            <template data-el=\\"div-button-1\\"><!-- props.text --></template>
          </a>
        </template>
      
        <template data-el=\\"show-button-2\\">
          <button type=\\"button\\" data-el=\\"button-button-1\\">
            <template data-el=\\"div-button-2\\"><!-- props.text --></template>
          </button>
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='show-button']\\").forEach((el) => {
      const whenCondition = this.props.link;
      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='a-button-1']\\").forEach((el) => {
      el.setAttribute(\\"href\\", this.props.link);

      el.setAttribute(
        \\"target\\",
        this.props.openLinkInNewTab ? \\"_blank\\" : undefined
      );
    });

    this._root.querySelectorAll(\\"[data-el='div-button-1']\\").forEach((el) => {
      this.renderTextNode(el, this.props.text);
    });

    this._root.querySelectorAll(\\"[data-el='show-button-2']\\").forEach((el) => {
      const whenCondition = !this.props.link;
      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='div-button-2']\\").forEach((el) => {
      this.renderTextNode(el, this.props.text);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"button\\", Button);
"
`;

exports[`webcomponent Javascript Test defaultValsWithTypes 1`] = `
"type Props = {
  name: string;
};

const DEFAULT_VALUES: Props = {
  name: \\"Sami\\",
};

/**
 * Usage:
 *
 *  <component-with-types></component-with-types>
 *
 */
class ComponentWithTypes extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"name\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        Hello
        <template data-el=\\"div-component-with-types-1\\">
          <!-- props.name || DEFAULT_VALUES.name -->
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-component-with-types-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.name || DEFAULT_VALUES.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"component-with-types\\", ComponentWithTypes);
"
`;

exports[`webcomponent Javascript Test import types 1`] = `
"type RenderContentProps = {
  options?: GetContentOptions;
  content: BuilderContent;
  renderContentProps: RenderBlockProps;
};

import RenderBlock from \\"./builder-render-block.raw\\";

/**
 * Usage:
 *
 *  <render-content></render-content>
 *
 */
class RenderContent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      getRenderContentProps(block, index) {
        return {
          block: block,
          index: index,
        };
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"renderContentProps\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <render-block data-el=\\"render-block-render-content\\"></render-block>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"render-content\\", RenderContent);
"
`;

exports[`webcomponent Javascript Test multipleOnUpdate 1`] = `
"/**
 * Usage:
 *
 *  <multiple-on-update></multiple-on-update>
 *
 */
class MultipleOnUpdate extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.updateDeps = [[], []];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    console.log(\\"Runs on every update/rerender\\");

    console.log(\\"Runs on every update/rerender as well\\");
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"multiple-on-update\\", MultipleOnUpdate);
"
`;

exports[`webcomponent Javascript Test multipleOnUpdateWithDeps 1`] = `
"/**
 * Usage:
 *
 *  <multiple-on-update-with-deps></multiple-on-update-with-deps>
 *
 */
class MultipleOnUpdateWithDeps extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { a: \\"a\\", b: \\"b\\", c: \\"c\\", d: \\"d\\" };
    if (!this.props) {
      this.props = {};
    }

    this.updateDeps = [
      [this.state.a, this.state.b],
      [this.state.c, this.state.d],
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        console.log(\\"Runs when a or b changes\\", self.state.a, self.state.b);

        if (self.state.a === \\"a\\") {
          self.state.a = \\"b\\";
        }
        self.updateDeps[0] = __next;
      }
    })(self.updateDeps[0], [self.state.a, self.state.b]);

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        console.log(\\"Runs when c or d changes\\", self.state.c, self.state.d);

        if (self.state.a === \\"a\\") {
          self.state.a = \\"b\\";
        }
        self.updateDeps[1] = __next;
      }
    })(self.updateDeps[1], [self.state.c, self.state.d]);
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"multiple-on-update-with-deps\\", MultipleOnUpdateWithDeps);
"
`;

exports[`webcomponent Javascript Test nestedShow 1`] = `
"interface Props {
  conditionA: boolean;
  conditionB: boolean;
}

/**
 * Usage:
 *
 *  <nested-show></nested-show>
 *
 */
class NestedShow extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"conditionA\\", \\"conditionB\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"show-nested-show\\">
        <template data-el=\\"show-nested-show-2\\">
          <div>if condition A and condition B</div>
        </template>
      </template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-nested-show']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;
        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-nested-show-2']\\")
      .forEach((el) => {
        const whenCondition = !this.props.conditionB;
        if (whenCondition) {
          this.showContent(el);
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"nested-show\\", NestedShow);
"
`;

exports[`webcomponent Javascript Test nestedStyles 1`] = `
"/**
 * Usage:
 *
 *  <nested-styles></nested-styles>
 *
 */
class NestedStyles extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div class=\\"div\\">Hello world</div>
      <style>
        .div {
          display: flex;
          foo: var(--bar);
        }
        @media (max-width: env(--mobile)) {
          .div {
            display: block;
          }
        }
        .div:hover {
          display: flex;
        }
        .div .nested-selector {
          display: grid;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"nested-styles\\", NestedStyles);
"
`;

exports[`webcomponent Javascript Test onInit & onMount 1`] = `
"/**
 * Usage:
 *
 *  <on-init></on-init>
 *
 */
class OnInit extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.onInitOnce = false;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;
    this.onInit();
    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onInit() {
    if (!this.onInitOnce) {
      console.log(\\"onInit\\");
      this.onInitOnce = true;
    }
  }

  onMount() {
    // onMount
    console.log(\\"onMount\\");
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"on-init\\", OnInit);
"
`;

exports[`webcomponent Javascript Test onInit 1`] = `
"type Props = {
  name: string;
};

export const defaultValues = {
  name: \\"PatrickJS\\",
};

/**
 * Usage:
 *
 *  <on-init></on-init>
 *
 */
class OnInit extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.onInitOnce = false;

    this.state = { name: \\"\\" };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"name\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        Default name defined by parent
        <template data-el=\\"div-on-init-1\\"><!-- state.name --></template>
      </div>\`;
    this.pendingUpdate = true;
    this.onInit();
    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onInit() {
    if (!this.onInitOnce) {
      this.state.name = defaultValues.name || this.props.name;
      this.update();
      console.log(\\"set defaults with props\\");
      this.onInitOnce = true;
    }
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='div-on-init-1']\\").forEach((el) => {
      this.renderTextNode(el, this.state.name);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"on-init\\", OnInit);
"
`;

exports[`webcomponent Javascript Test onMount 1`] = `
"/**
 * Usage:
 *
 *  <comp></comp>
 *
 */
class Comp extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  disconnectedCallback() {
    // onUnMount
    console.log(\\"Runs on unMount\\");
    this.destroyAnyNodes(); // clean up nodes when component is destroyed
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    console.log(\\"Runs on mount\\");
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"comp\\", Comp);
"
`;

exports[`webcomponent Javascript Test onUpdate 1`] = `
"/**
 * Usage:
 *
 *  <on-update></on-update>
 *
 */
class OnUpdate extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.updateDeps = [[]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    console.log(\\"Runs on every update/rerender\\");
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"on-update\\", OnUpdate);
"
`;

exports[`webcomponent Javascript Test onUpdateWithDeps 1`] = `
"type Props = {
  size: string;
};

/**
 * Usage:
 *
 *  <on-update-with-deps></on-update-with-deps>
 *
 */
class OnUpdateWithDeps extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { a: \\"a\\", b: \\"b\\" };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"size\\"];

    this.updateDeps = [[this.state.a, this.state.b, this.props.size]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        console.log(
          \\"Runs when a, b or size changes\\",
          self.state.a,
          self.state.b,
          self.props.size
        );
        self.updateDeps[0] = __next;
      }
    })(self.updateDeps[0], [self.state.a, self.state.b, self.props.size]);
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"on-update-with-deps\\", OnUpdateWithDeps);
"
`;

exports[`webcomponent Javascript Test preserveExportOrLocalStatement 1`] = `
"type Types = {
  s: any[];
};
interface IPost {
  len: number;
}
export interface MyBasicComponentProps {
  id: string;
}

const b = 3;
const foo = () => {};
export const a = 3;
export const bar = () => {};
export function run<T>(value: T) {}

/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent Javascript Test preserveTyping 1`] = `
"export type A = \\"test\\";
export interface C {
  n: \\"test\\";
}
type B = \\"test2\\";
interface D {
  n: \\"test\\";
}
export interface MyBasicComponentProps {
  name: string;
  age?: number;
}

/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"name\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        Hello! I can run in React, Vue, Solid, or Liquid!
        <template data-el=\\"div-my-basic-component-1\\"><!-- props.name --></template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent Javascript Test propsDestructure 1`] = `
"type Props = {
  children: any;
  type: string;
};

/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"Decadef20\\" };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"children\\", \\"type\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <slot></slot>
      
        <template data-el=\\"div-my-basic-component-2\\"><!-- props.type --></template>
      
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-2']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.type);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent Javascript Test propsInterface 1`] = `
"interface Person {
  name: string;
  age?: number;
}

/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"name\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        Hello! I can run in React, Vue, Solid, or Liquid!
        <template data-el=\\"div-my-basic-component-1\\"><!-- props.name --></template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent Javascript Test propsType 1`] = `
"type Person = {
  name: string;
  age?: number;
};

/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"name\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        Hello! I can run in React, Vue, Solid, or Liquid!
        <template data-el=\\"div-my-basic-component-1\\"><!-- props.name --></template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent Javascript Test rootFragmentMultiNode 1`] = `
"export interface ButtonProps {
  attributes?: any;
  text?: string;
  link?: string;
  openLinkInNewTab?: boolean;
}

/**
 * Usage:
 *
 *  <button></button>
 *
 */
class Button extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"link\\", \\"attributes\\", \\"openLinkInNewTab\\", \\"text\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"show-button\\">
        <a data-el=\\"a-button-1\\">
          <template data-el=\\"div-button-1\\"><!-- props.text --></template>
        </a>
      </template>
      
      <template data-el=\\"show-button-2\\">
        <button type=\\"button\\" data-el=\\"button-button-1\\">
          <template data-el=\\"div-button-2\\"><!-- props.text --></template>
        </button>
      </template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='show-button']\\").forEach((el) => {
      const whenCondition = this.props.link;
      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='a-button-1']\\").forEach((el) => {
      el.setAttribute(\\"href\\", this.props.link);

      el.setAttribute(
        \\"target\\",
        this.props.openLinkInNewTab ? \\"_blank\\" : undefined
      );
    });

    this._root.querySelectorAll(\\"[data-el='div-button-1']\\").forEach((el) => {
      this.renderTextNode(el, this.props.text);
    });

    this._root.querySelectorAll(\\"[data-el='show-button-2']\\").forEach((el) => {
      const whenCondition = !this.props.link;
      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='div-button-2']\\").forEach((el) => {
      this.renderTextNode(el, this.props.text);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"button\\", Button);
"
`;

exports[`webcomponent Javascript Test rootShow 1`] = `
"export interface RenderStylesProps {
  foo: string;
}

/**
 * Usage:
 *
 *  <render-styles></render-styles>
 *
 */
class RenderStyles extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"foo\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"show-render-styles\\">
        <div>Bar</div>
      </template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-render-styles']\\")
      .forEach((el) => {
        const whenCondition = this.props.foo === \\"bar\\";
        if (whenCondition) {
          this.showContent(el);
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"render-styles\\", RenderStyles);
"
`;

exports[`webcomponent Javascript Test self-referencing component 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"name\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"div-my-component-1\\"><!-- props.name --></template>
      
        <template data-el=\\"show-my-component\\">
          <MyComponent name=\\"Bruce Wayne\\"></MyComponent>
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.name);
      });

    this._root
      .querySelectorAll(\\"[data-el='show-my-component']\\")
      .forEach((el) => {
        const whenCondition = this.props.name === \\"Batman\\";
        if (whenCondition) {
          this.showContent(el);
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent Javascript Test self-referencing component with children 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"name\\", \\"children\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"div-my-component-1\\"><!-- props.name --></template>
      
        <slot></slot>
      
        <template data-el=\\"show-my-component\\">
          <MyComponent name=\\"Bruce\\">
            <div>Wayne</div>
          </MyComponent>
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.name);
      });

    this._root
      .querySelectorAll(\\"[data-el='show-my-component']\\")
      .forEach((el) => {
        const whenCondition = this.props.name === \\"Batman\\";
        if (whenCondition) {
          this.showContent(el);
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent Javascript Test showWithFor 1`] = `
"interface Props {
  conditionA: boolean;
  items: string[];
}

/**
 * Usage:
 *
 *  <nested-show></nested-show>
 *
 */
class NestedShow extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"conditionA\\", \\"items\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"show-nested-show\\">
        <template data-el=\\"for-nested-show\\">
          <div data-el=\\"div-nested-show-1\\">
            <template data-el=\\"div-nested-show-2\\"><!-- item --></template>
          </div>
        </template>
      </template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-nested-show']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;
        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root.querySelectorAll(\\"[data-el='for-nested-show']\\").forEach((el) => {
      let array = this.props.items;
      this.renderLoop(el, array, \\"item\\", \\"idx\\");
    });

    this._root
      .querySelectorAll(\\"[data-el='div-nested-show-1']\\")
      .forEach((el) => {
        const idx = this.getScope(el, \\"idx\\");

        el.key = idx;
      });

    this._root
      .querySelectorAll(\\"[data-el='div-nested-show-2']\\")
      .forEach((el) => {
        const item = this.getScope(el, \\"item\\");
        this.renderTextNode(el, item);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"nested-show\\", NestedShow);
"
`;

exports[`webcomponent Javascript Test subComponent 1`] = `
"import Foo from \\"./foo-sub-component.lite\\";

/**
 * Usage:
 *
 *  <sub-component></sub-component>
 *
 */
class SubComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <foo></foo>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"sub-component\\", SubComponent);
"
`;

exports[`webcomponent Javascript Test typeDependency 1`] = `
"import type { Foo } from \\"./foo-type\\";
import type { Foo as Foo2 } from \\"./type-export\\";
export type TypeDependencyProps = {
  foo: Foo;
  foo2: Foo2;
};

/**
 * Usage:
 *
 *  <type-dependency></type-dependency>
 *
 */
class TypeDependency extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"foo\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"div-type-dependency-1\\"><!-- props.foo --></template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-type-dependency-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.foo);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"type-dependency\\", TypeDependency);
"
`;

exports[`webcomponent Remove Internal mitosis package 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\" };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        Hello
        <template data-el=\\"div-my-basic-component-1\\"><!-- state.name --></template>
        ! I can run in React, Qwik, Vue, Solid, or Liquid!
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent Shadow DOM 1`] = `
"type SmileReviewsProps = {
  productId: string;
  apiKey: string;
};

/**
 * Usage:
 *
 *  <smile-reviews></smile-reviews>
 *
 */
class SmileReviews extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { reviews: [], name: \\"test\\", showReviewPrompt: false };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"apiKey\\", \\"productId\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'click' event on button-smile-reviews-1
    this.onButtonSmileReviews1Click = (event) => {
      this.state.showReviewPrompt = true;
      this.update();
    };

    // Event handler for 'click' event on button-smile-reviews-2
    this.onButtonSmileReviews2Click = (event) => {
      this.state.showReviewPrompt = false;
      this.update();
    };

    if (true) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div data-el=\\"div-smile-reviews-1\\">
        <button data-el=\\"button-smile-reviews-1\\">Write a review</button>
      
        <template data-el=\\"show-smile-reviews\\">
          <input
            placeholder=\\"Email\\"
            data-dom-state=\\"SmileReviews-input-smile-reviews-1\\"
          />
      
          <input
            placeholder=\\"Title\\"
            class=\\"input\\"
            data-dom-state=\\"SmileReviews-input-smile-reviews-2\\"
          />
      
          <textarea
            placeholder=\\"How was your experience?\\"
            class=\\"textarea\\"
            data-dom-state=\\"SmileReviews-textarea-smile-reviews-1\\"
          ></textarea>
      
          <button class=\\"button\\" data-el=\\"button-smile-reviews-2\\">Submit</button>
        </template>
      
        <template data-el=\\"for-smile-reviews\\">
          <div class=\\"review\\" data-el=\\"div-smile-reviews-2\\">
            <img class=\\"img\\" data-el=\\"img-smile-reviews-1\\" />
      
            <div data-el=\\"div-smile-reviews-3\\">
              <div>
                N:
                <template data-el=\\"div-smile-reviews-4\\"><!-- index --></template>
              </div>
      
              <div>
                <template data-el=\\"div-smile-reviews-5\\">
                  <!-- review.author -->
                </template>
              </div>
      
              <div>
                <template data-el=\\"div-smile-reviews-6\\">
                  <!-- review.reviewMessage -->
                </template>
              </div>
            </div>
          </div>
        </template>
      </div>
      <style>
        .input {
          display: block;
        }
        .textarea {
          display: block;
        }
        .button {
          display: block;
        }
        .review {
          margin: 10px;
          padding: 10px;
          background: white;
          display: flex;
          border-radius: 5px;
          box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .img {
          height: 30px;
          width: 30px;
          margin-right: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {
    // onMount
    fetch(
      \`https://stamped.io/api/widget/reviews?storeUrl=builder-io.myshopify.com&apiKey=\${
        this.props.apiKey || \\"pubkey-8bbDq7W6w4sB3OWeM1HUy2s47702hM\\"
      }&productId=\${this.props.productId || \\"2410511106127\\"}\`
    )
      .then((res) => res.json())
      .then((data) => {
        this.state.reviews = data.data;
        this.update();
      });
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-1']\\")
      .forEach((el) => {
        el.setAttribute(\\"data-user\\", this.state.name);
      });

    this._root
      .querySelectorAll(\\"[data-el='button-smile-reviews-1']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onButtonSmileReviews1Click);
        el.addEventListener(\\"click\\", this.onButtonSmileReviews1Click);
      });

    this._root
      .querySelectorAll(\\"[data-el='show-smile-reviews']\\")
      .forEach((el) => {
        const whenCondition = this.state.showReviewPrompt;
        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='button-smile-reviews-2']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onButtonSmileReviews2Click);
        el.addEventListener(\\"click\\", this.onButtonSmileReviews2Click);
      });

    this._root
      .querySelectorAll(\\"[data-el='for-smile-reviews']\\")
      .forEach((el) => {
        let array = this.state.reviews;
        this.renderLoop(el, array, \\"review\\", \\"index\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-2']\\")
      .forEach((el) => {
        const review = this.getScope(el, \\"review\\");

        el.key = review.id;
      });

    this._root
      .querySelectorAll(\\"[data-el='img-smile-reviews-1']\\")
      .forEach((el) => {
        const review = this.getScope(el, \\"review\\");

        el.setAttribute(\\"src\\", review.avatar);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-3']\\")
      .forEach((el) => {
        el.className = this.state.showReviewPrompt
          ? \\"bg-primary\\"
          : \\"bg-secondary\\";
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-4']\\")
      .forEach((el) => {
        const index = this.getScope(el, \\"index\\");
        this.renderTextNode(el, index);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-5']\\")
      .forEach((el) => {
        const review = this.getScope(el, \\"review\\");
        this.renderTextNode(el, review.author);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-6']\\")
      .forEach((el) => {
        const review = this.getScope(el, \\"review\\");
        this.renderTextNode(el, review.reviewMessage);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"smile-reviews\\", SmileReviews);
"
`;

exports[`webcomponent Typescript Test AdvancedRef 1`] = `
"export interface Props {
  showInput: boolean;
}

/**
 * Usage:
 *
 *  <my-basic-ref-component></my-basic-ref-component>
 *
 */
class MyBasicRefComponent extends HTMLElement {
  get _inputRef() {
    return this._root.querySelector(
      \\"[data-ref='MyBasicRefComponent-inputRef']\\"
    );
  }

  get _inputNoArgRef() {
    return this._root.querySelector(
      \\"[data-ref='MyBasicRefComponent-inputNoArgRef']\\"
    );
  }

  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      name: \\"PatrickJS\\",
      onBlur: function onBlur() {
        // Maintain focus
        self._inputRef.focus();
      },
      lowerCaseName: function lowerCaseName() {
        return self.state.name.toLowerCase();
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"showInput\\"];

    this.updateDeps = [[self._inputRef, self._inputNoArgRef]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'blur' event on input-my-basic-ref-component-1
    this.onInputMyBasicRefComponent1Blur = (event) => {
      this.state.onBlur();
    };

    // Event handler for 'input' event on input-my-basic-ref-component-1
    this.onInputMyBasicRefComponent1Input = (event) => {
      this.state.name = event.target.value;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"show-my-basic-ref-component\\">
          <input
            class=\\"input\\"
            data-el=\\"input-my-basic-ref-component-1\\"
            data-dom-state=\\"MyBasicRefComponent-input-my-basic-ref-component-1\\"
            data-ref=\\"MyBasicRefComponent-inputRef\\"
          />
      
          <label
            for=\\"cars\\"
            data-el=\\"label-my-basic-ref-component-1\\"
            data-ref=\\"MyBasicRefComponent-inputNoArgRef\\"
          >
            Choose a car:
          </label>
      
          <select
            name=\\"cars\\"
            id=\\"cars\\"
            data-dom-state=\\"MyBasicRefComponent-select-my-basic-ref-component-1\\"
          >
            <option value=\\"supra\\">GR Supra</option>
      
            <option value=\\"86\\">GR 86</option>
          </select>
        </template>
      
        Hello
      
        <template data-el=\\"div-my-basic-ref-component-1\\">
          <!-- state.lowerCaseName() -->
        </template>
        ! I can run in React, Qwik, Vue, Solid, or Web Component!
      </div>
      <style>
        .input {
          color: red;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {
    const self = this;

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        console.log(\\"Received an update\\");
        self.updateDeps[0] = __next;
      }
    })(self.updateDeps[0], [self._inputRef, self._inputNoArgRef]);
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-my-basic-ref-component']\\")
      .forEach((el) => {
        const whenCondition = this.props.showInput;
        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-ref-component-1']\\")
      .forEach((el) => {
        el.value = this.state.name;

        el.removeEventListener(\\"blur\\", this.onInputMyBasicRefComponent1Blur);
        el.addEventListener(\\"blur\\", this.onInputMyBasicRefComponent1Blur);

        el.removeEventListener(\\"input\\", this.onInputMyBasicRefComponent1Input);
        el.addEventListener(\\"input\\", this.onInputMyBasicRefComponent1Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-ref-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.lowerCaseName());
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-ref-component\\", MyBasicRefComponent);
"
`;

exports[`webcomponent Typescript Test Basic 1`] = `
"export interface MyBasicComponentProps {
  id: string;
}

export const DEFAULT_VALUES = {
  name: \\"Steve\\",
};

/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      name: \\"Steve\\",
      underscore_fn_name() {
        return \\"bar\\";
      },
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-basic-component-1
    this.onInputMyBasicComponent1Input = (myEvent) => {
      this.state.name = myEvent.target.value;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div class=\\"test div\\">
        <input
          data-el=\\"input-my-basic-component-1\\"
          data-dom-state=\\"MyBasicComponent-input-my-basic-component-1\\"
        />
      
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>
      <style>
        .div {
          padding: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-component-1']\\")
      .forEach((el) => {
        el.value = DEFAULT_VALUES.name || this.state.name;

        el.removeEventListener(\\"input\\", this.onInputMyBasicComponent1Input);
        el.addEventListener(\\"input\\", this.onInputMyBasicComponent1Input);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent Typescript Test Basic 2`] = `
"/**
 * Usage:
 *
 *  <my-basic-for-show-component></my-basic-for-show-component>
 *
 */
class MyBasicForShowComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-basic-for-show-component-1
    this.onInputMyBasicForShowComponent1Input = (event) => {
      const person = this.getScope(event.currentTarget, \\"person\\");

      this.state.name = event.target.value + \\" and \\" + person;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <template data-el=\\"for-my-basic-for-show-component\\">
          <template data-el=\\"show-my-basic-for-show-component\\">
            <input
              data-el=\\"input-my-basic-for-show-component-1\\"
              data-dom-state=\\"MyBasicForShowComponent-input-my-basic-for-show-component-1\\"
            />
      
            Hello
            <template data-el=\\"div-my-basic-for-show-component-1\\">
              <!-- person -->
            </template>
            ! I can run in Qwik, Web Component, React, Vue, Solid, or Liquid!
          </template>
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='for-my-basic-for-show-component']\\")
      .forEach((el) => {
        let array = this.state.names;
        this.renderLoop(el, array, \\"person\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='show-my-basic-for-show-component']\\")
      .forEach((el) => {
        const person = this.getScope(el, \\"person\\");
        const whenCondition = person === this.state.name;
        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-for-show-component-1']\\")
      .forEach((el) => {
        el.value = this.state.name;

        el.removeEventListener(
          \\"input\\",
          this.onInputMyBasicForShowComponent1Input
        );
        el.addEventListener(\\"input\\", this.onInputMyBasicForShowComponent1Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-for-show-component-1']\\")
      .forEach((el) => {
        const person = this.getScope(el, \\"person\\");
        this.renderTextNode(el, person);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"my-basic-for-show-component\\", MyBasicForShowComponent);
"
`;

exports[`webcomponent Typescript Test Basic Context 1`] = `
"import { Injector, createInjector, MyService } from \\"@dummy/injection-js\\";

/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;
    this.context = createInjector();

    this.onInitOnce = false;

    this.state = {
      name: \\"PatrickJS\\",
      onChange: function onChange() {
        const change = self.myService.method(\\"change\\");
        console.log(change);
      },
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-basic-component-1
    this.onInputMyBasicComponent1Input = (event) => {
      this.state.onChange;
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.myService = this.getContext(this._root, MyService);

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"div-my-basic-component-1\\">
          <!-- myService.method('hello') + state.name -->
        </template>
      
        Hello! I can run in React, Vue, Solid, or Liquid!
      
        <input
          data-el=\\"input-my-basic-component-1\\"
          data-dom-state=\\"MyBasicComponent-input-my-basic-component-1\\"
        />
      </div>\`;
    this.pendingUpdate = true;
    this.onInit();
    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onInit() {
    if (!this.onInitOnce) {
      const hi = this.myService.method(\\"hi\\");
      console.log(hi);
      this.onInitOnce = true;
    }
  }

  onMount() {
    // onMount
    const bye = this.myService.method(\\"hi\\");
    console.log(bye);
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(
          el,
          this.myService.method(\\"hello\\") + this.state.name
        );
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-component-1']\\")
      .forEach((el) => {
        el.removeEventListener(\\"input\\", this.onInputMyBasicComponent1Input);
        el.addEventListener(\\"input\\", this.onInputMyBasicComponent1Input);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // get Context Helper
  getContext(el, token) {
    do {
      let value;
      if (el?.context?.get) {
        value = el.context.get(token);
      } else if (el?.context?.[token]) {
        value = el.context[token];
      }
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent Typescript Test Basic OnMount Update 1`] = `
"export interface Props {
  hi: string;
  bye: string;
}

/**
 * Usage:
 *
 *  <my-basic-on-mount-update-component></my-basic-on-mount-update-component>
 *
 */
class MyBasicOnMountUpdateComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.onInitOnce = false;

    this.state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"hi\\", \\"bye\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        Hello
        <template data-el=\\"div-my-basic-on-mount-update-component-1\\">
          <!-- state.name -->
        </template>
      </div>\`;
    this.pendingUpdate = true;
    this.onInit();
    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onInit() {
    if (!this.onInitOnce) {
      this.state.name = \\"PatrickJS onInit\\" + this.props.hi;
      this.update();
      this.onInitOnce = true;
    }
  }

  onMount() {
    // onMount
    this.state.name = \\"PatrickJS onMount\\" + this.props.bye;
    this.update();
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-on-mount-update-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(
  \\"my-basic-on-mount-update-component\\",
  MyBasicOnMountUpdateComponent
);
"
`;

exports[`webcomponent Typescript Test Basic Outputs 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-outputs-component></my-basic-outputs-component>
 *
 */
class MyBasicOutputsComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\" };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"onMessage\\", \\"onEvent\\", \\"message\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    this.props.onMessage(this.state.name);
    this.props.onEvent(this.props.message);
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-outputs-component\\", MyBasicOutputsComponent);
"
`;

exports[`webcomponent Typescript Test Basic Outputs Meta 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-outputs-component></my-basic-outputs-component>
 *
 */
class MyBasicOutputsComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\" };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"onMessage\\", \\"onEvent\\", \\"message\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    this.props.onMessage(this.state.name);
    this.props.onEvent(this.props.message);
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-outputs-component\\", MyBasicOutputsComponent);
"
`;

exports[`webcomponent Typescript Test BasicChildComponent 1`] = `
"import MyBasicComponent from \\"./basic.raw\\";
import MyBasicOnMountUpdateComponent from \\"./basic-onMount-update.raw\\";

/**
 * Usage:
 *
 *  <my-basic-child-component></my-basic-child-component>
 *
 */
class MyBasicChildComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"Steve\\", dev: \\"PatrickJS\\" };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <my-basic-component
          data-el=\\"my-basic-component-my-basic-child-component\\"
        ></my-basic-component>
      
        <div>
          <my-basic-on-mount-update-component
            data-el=\\"my-basic-on-mount-update-component-my-basic-child-component\\"
          ></my-basic-on-mount-update-component>
        </div>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(
        \\"[data-el='my-basic-component-my-basic-child-component']\\"
      )
      .forEach((el) => {
        el.setAttribute(\\"id\\", this.state.dev);
      });

    this._root
      .querySelectorAll(
        \\"[data-el='my-basic-on-mount-update-component-my-basic-child-component']\\"
      )
      .forEach((el) => {
        el.setAttribute(\\"hi\\", this.state.name);
        el.hi = this.state.name;

        if (el.props) {
          el.props.hi = this.state.name;
          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.hi = this.state.name;
        }

        el.setAttribute(\\"bye\\", this.state.dev);
        el.bye = this.state.dev;

        if (el.props) {
          el.props.bye = this.state.dev;
          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.bye = this.state.dev;
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-child-component\\", MyBasicChildComponent);
"
`;

exports[`webcomponent Typescript Test BasicFor 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-for-component></my-basic-for-component>
 *
 */
class MyBasicForComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-basic-for-component-1
    this.onInputMyBasicForComponent1Input = (event) => {
      const person = this.getScope(event.currentTarget, \\"person\\");

      this.state.name = event.target.value + \\" and \\" + person;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <template data-el=\\"for-my-basic-for-component\\">
          <input
            data-el=\\"input-my-basic-for-component-1\\"
            data-dom-state=\\"MyBasicForComponent-input-my-basic-for-component-1\\"
          />
      
          Hello
          <template data-el=\\"div-my-basic-for-component-1\\"><!-- person --></template>
          ! I can run in Qwik, Web Component, React, Vue, Solid, or Liquid!
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    console.log(\\"onMount code\\");
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='for-my-basic-for-component']\\")
      .forEach((el) => {
        let array = this.state.names;
        this.renderLoop(el, array, \\"person\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-for-component-1']\\")
      .forEach((el) => {
        el.value = this.state.name;

        el.removeEventListener(\\"input\\", this.onInputMyBasicForComponent1Input);
        el.addEventListener(\\"input\\", this.onInputMyBasicForComponent1Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-for-component-1']\\")
      .forEach((el) => {
        const person = this.getScope(el, \\"person\\");
        this.renderTextNode(el, person);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"my-basic-for-component\\", MyBasicForComponent);
"
`;

exports[`webcomponent Typescript Test BasicRef 1`] = `
"export interface Props {
  showInput: boolean;
}

/**
 * Usage:
 *
 *  <my-basic-ref-component></my-basic-ref-component>
 *
 */
class MyBasicRefComponent extends HTMLElement {
  get _inputRef() {
    return this._root.querySelector(
      \\"[data-ref='MyBasicRefComponent-inputRef']\\"
    );
  }

  get _inputNoArgRef() {
    return this._root.querySelector(
      \\"[data-ref='MyBasicRefComponent-inputNoArgRef']\\"
    );
  }

  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      name: \\"PatrickJS\\",
      onBlur: function onBlur() {
        // Maintain focus
        self._inputRef.focus();
      },
      lowerCaseName: function lowerCaseName() {
        return self.state.name.toLowerCase();
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"showInput\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'blur' event on input-my-basic-ref-component-1
    this.onInputMyBasicRefComponent1Blur = (event) => {
      this.state.onBlur();
    };

    // Event handler for 'input' event on input-my-basic-ref-component-1
    this.onInputMyBasicRefComponent1Input = (event) => {
      this.state.name = event.target.value;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"show-my-basic-ref-component\\">
          <input
            class=\\"input\\"
            data-el=\\"input-my-basic-ref-component-1\\"
            data-dom-state=\\"MyBasicRefComponent-input-my-basic-ref-component-1\\"
            data-ref=\\"MyBasicRefComponent-inputRef\\"
          />
      
          <label
            for=\\"cars\\"
            data-el=\\"label-my-basic-ref-component-1\\"
            data-ref=\\"MyBasicRefComponent-inputNoArgRef\\"
          >
            Choose a car:
          </label>
      
          <select
            name=\\"cars\\"
            id=\\"cars\\"
            data-dom-state=\\"MyBasicRefComponent-select-my-basic-ref-component-1\\"
          >
            <option value=\\"supra\\">GR Supra</option>
      
            <option value=\\"86\\">GR 86</option>
          </select>
        </template>
      
        Hello
      
        <template data-el=\\"div-my-basic-ref-component-1\\">
          <!-- state.lowerCaseName() -->
        </template>
        ! I can run in React, Qwik, Vue, Solid, or Web Component!
      </div>
      <style>
        .input {
          color: red;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-my-basic-ref-component']\\")
      .forEach((el) => {
        const whenCondition = this.props.showInput;
        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-ref-component-1']\\")
      .forEach((el) => {
        el.value = this.state.name;

        el.removeEventListener(\\"blur\\", this.onInputMyBasicRefComponent1Blur);
        el.addEventListener(\\"blur\\", this.onInputMyBasicRefComponent1Blur);

        el.removeEventListener(\\"input\\", this.onInputMyBasicRefComponent1Input);
        el.addEventListener(\\"input\\", this.onInputMyBasicRefComponent1Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-ref-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.lowerCaseName());
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-ref-component\\", MyBasicRefComponent);
"
`;

exports[`webcomponent Typescript Test BasicRefAssignment 1`] = `
"export interface Props {
  showInput: boolean;
}

/**
 * Usage:
 *
 *  <my-basic-ref-assignment-component></my-basic-ref-assignment-component>
 *
 */
class MyBasicRefAssignmentComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      handlerClick: function handlerClick(event) {
        event.preventDefault();
        console.log(\\"current value\\", self._holdValueRef);
        self._holdValueRef = self._holdValueRef + \\"JS\\";
      },
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'click' event on button-my-basic-ref-assignment-component-1
    this.onButtonMyBasicRefAssignmentComponent1Click = (evt) => {
      this.state.handlerClick(evt);
    };

    this._holdValueRef = \\"Patrick\\";

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <button data-el=\\"button-my-basic-ref-assignment-component-1\\">Click</button>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(
        \\"[data-el='button-my-basic-ref-assignment-component-1']\\"
      )
      .forEach((el) => {
        el.removeEventListener(
          \\"click\\",
          this.onButtonMyBasicRefAssignmentComponent1Click
        );
        el.addEventListener(
          \\"click\\",
          this.onButtonMyBasicRefAssignmentComponent1Click
        );
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(
  \\"my-basic-ref-assignment-component\\",
  MyBasicRefAssignmentComponent
);
"
`;

exports[`webcomponent Typescript Test BasicRefPrevious 1`] = `
"export interface Props {
  showInput: boolean;
}

export function usePrevious<T>(value: T) {
  // The ref object is a generic container whose current property is mutable ...
  // ... and can hold any value, similar to an instance property on a class
  let ref = useRef<T>(null); // Store current value in ref

  onUpdate(() => {
    ref = value;
  }, [value]); // Only re-run if value changes
  // Return previous value (happens before update in useEffect above)

  return ref;
}

/**
 * Usage:
 *
 *  <my-previous-component></my-previous-component>
 *
 */
class MyPreviousComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { count: 0 };
    if (!this.props) {
      this.props = {};
    }

    this.updateDeps = [[this.state.count]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'click' event on button-my-previous-component-1
    this.onButtonMyPreviousComponent1Click = (event) => {
      this.state.count += 1;
      this.update();
    };

    this._prevCount = state.count;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <h1>
          Now:
          <template data-el=\\"div-my-previous-component-1\\">
            <!-- state.count -->
          </template>
          , before:
          <template data-el=\\"div-my-previous-component-2\\">
            <!-- self._prevCount -->
          </template>
        </h1>
      
        <button data-el=\\"button-my-previous-component-1\\">Increment</button>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        self._prevCount = self.state.count;
        self.updateDeps[0] = __next;
      }
    })(self.updateDeps[0], [self.state.count]);
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-previous-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.count);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-previous-component-2']\\")
      .forEach((el) => {
        this.renderTextNode(el, self._prevCount);
      });

    this._root
      .querySelectorAll(\\"[data-el='button-my-previous-component-1']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onButtonMyPreviousComponent1Click);
        el.addEventListener(\\"click\\", this.onButtonMyPreviousComponent1Click);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-previous-component\\", MyPreviousComponent);
"
`;

exports[`webcomponent Typescript Test Button 1`] = `
"export interface ButtonProps {
  attributes?: any;
  text?: string;
  link?: string;
  openLinkInNewTab?: boolean;
}

/**
 * Usage:
 *
 *  <button></button>
 *
 */
class Button extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"link\\", \\"attributes\\", \\"openLinkInNewTab\\", \\"text\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"show-button\\">
          <a data-el=\\"a-button-1\\">
            <template data-el=\\"div-button-1\\"><!-- props.text --></template>
          </a>
        </template>
      
        <template data-el=\\"show-button-2\\">
          <button type=\\"button\\" data-el=\\"button-button-1\\">
            <template data-el=\\"div-button-2\\"><!-- props.text --></template>
          </button>
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='show-button']\\").forEach((el) => {
      const whenCondition = this.props.link;
      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='a-button-1']\\").forEach((el) => {
      el.setAttribute(\\"href\\", this.props.link);

      el.setAttribute(
        \\"target\\",
        this.props.openLinkInNewTab ? \\"_blank\\" : undefined
      );
    });

    this._root.querySelectorAll(\\"[data-el='div-button-1']\\").forEach((el) => {
      this.renderTextNode(el, this.props.text);
    });

    this._root.querySelectorAll(\\"[data-el='show-button-2']\\").forEach((el) => {
      const whenCondition = !this.props.link;
      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='div-button-2']\\").forEach((el) => {
      this.renderTextNode(el, this.props.text);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"button\\", Button);
"
`;

exports[`webcomponent Typescript Test Columns 1`] = `
"type Column = {
  content: any; // TODO: Implement this when support for dynamic CSS lands

  width?: number;
};
export interface ColumnProps {
  columns?: Column[]; // TODO: Implement this when support for dynamic CSS lands

  space?: number; // TODO: Implement this when support for dynamic CSS lands

  stackColumnsAt?: \\"tablet\\" | \\"mobile\\" | \\"never\\"; // TODO: Implement this when support for dynamic CSS lands

  reverseColumnsWhenStacked?: boolean;
}

/**
 * Usage:
 *
 *  <column></column>
 *
 */
class Column extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      getColumns() {
        return self.props.columns || [];
      },
      getGutterSize() {
        return typeof self.props.space === \\"number\\"
          ? self.props.space || 0
          : 20;
      },
      getWidth(index) {
        const columns = this.getColumns();
        return (columns[index] && columns[index].width) || 100 / columns.length;
      },
      getColumnCssWidth(index) {
        const columns = this.getColumns();
        const gutterSize = this.getGutterSize();
        const subtractWidth =
          (gutterSize * (columns.length - 1)) / columns.length;
        return \`calc(\${this.getWidth(index)}% - \${subtractWidth}px)\`;
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"columns\\", \\"space\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div class=\\"builder-columns div\\">
        <template data-el=\\"for-column\\">
          <div class=\\"builder-column div-2\\">
            <template data-el=\\"div-column-1\\"><!-- column.content --></template>
      
            <template data-el=\\"div-column-2\\"><!-- index --></template>
          </div>
        </template>
      </div>
      <style>
        .div {
          display: flex;
          flex-direction: column;
          align-items: stretch;
          line-height: normal;
        }
        @media (max-width: 999px) {
          .div {
            flex-direction: row;
          }
        }
        @media (max-width: 639px) {
          .div {
            flex-direction: row-reverse;
          }
        }
        .div-2 {
          flex-grow: 1;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='for-column']\\").forEach((el) => {
      let array = this.props.columns;
      this.renderLoop(el, array, \\"column\\", \\"index\\");
    });

    this._root.querySelectorAll(\\"[data-el='div-column-1']\\").forEach((el) => {
      const column = this.getScope(el, \\"column\\");
      this.renderTextNode(el, column.content);
    });

    this._root.querySelectorAll(\\"[data-el='div-column-2']\\").forEach((el) => {
      const index = this.getScope(el, \\"index\\");
      this.renderTextNode(el, index);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"column\\", Column);
"
`;

exports[`webcomponent Typescript Test ContentSlotHtml 1`] = `
"type Props = {
  [key: string]: string | JSX.Element;
  slotTesting: JSX.Element;
};

/**
 * Usage:
 *
 *  <content-slot-code></content-slot-code>
 *
 */
class ContentSlotCode extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"slotTesting\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <slot data-el=\\"slot-content-slot-code\\"></slot>
      
        <div>
          <hr />
        </div>
      
        <div>
          <slot></slot>
        </div>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='slot-content-slot-code']\\")
      .forEach((el) => {
        el.setAttribute(\\"name\\", this.props.slotTesting);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"content-slot-code\\", ContentSlotCode);
"
`;

exports[`webcomponent Typescript Test ContentSlotJSX 1`] = `
"type Props = {
  [key: string]: string | JSX.Element;
};

/**
 * Usage:
 *
 *  <content-slot-jsx-code></content-slot-jsx-code>
 *
 */
class ContentSlotJsxCode extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"slotTesting\\", \\"children\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"show-content-slot-jsx-code\\">
          <div>
            <template data-el=\\"div-content-slot-jsx-code-1\\">
              <!-- props.slotTesting -->
            </template>
          </div>
        </template>
      
        <div>
          <hr />
        </div>
      
        <div><slot></slot></div>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-content-slot-jsx-code']\\")
      .forEach((el) => {
        const whenCondition = this.props.slotTesting;
        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='div-content-slot-jsx-code-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.slotTesting);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"content-slot-jsx-code\\", ContentSlotJsxCode);
"
`;

exports[`webcomponent Typescript Test CustomCode 1`] = `
"export interface CustomCodeProps {
  code: string;
  replaceNodes?: boolean;
}

/**
 * Usage:
 *
 *  <custom-code></custom-code>
 *
 */
class CustomCode extends HTMLElement {
  get _elem() {
    return this._root.querySelector(\\"[data-ref='CustomCode-elem']\\");
  }

  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      scriptsInserted: [],
      scriptsRun: [],
      findAndRunScripts() {
        // TODO: Move this function to standalone one in '@builder.io/utils'
        if (self._elem && typeof window !== \\"undefined\\") {
          /** @type {HTMLScriptElement[]} */
          const scripts = self._elem.getElementsByTagName(\\"script\\");

          for (let i = 0; i < scripts.length; i++) {
            const script = scripts[i];

            if (script.src) {
              if (self.state.scriptsInserted.includes(script.src)) {
                continue;
              }

              self.state.scriptsInserted.push(script.src);
              const newScript = document.createElement(\\"script\\");
              newScript.async = true;
              newScript.src = script.src;
              document.head.appendChild(newScript);
            } else if (
              !script.type ||
              [
                \\"text/javascript\\",
                \\"application/javascript\\",
                \\"application/ecmascript\\",
              ].includes(script.type)
            ) {
              if (self.state.scriptsRun.includes(script.innerText)) {
                continue;
              }

              try {
                self.state.scriptsRun.push(script.innerText);
                new Function(script.innerText)();
              } catch (error) {
                console.warn(\\"\`CustomCode\`: Error running script:\\", error);
              }
            }
          }
        }
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"replaceNodes\\", \\"code\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div data-el=\\"div-custom-code-1\\" data-ref=\\"CustomCode-elem\\"></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    this.state.findAndRunScripts();
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-custom-code-1']\\")
      .forEach((el) => {
        el.className =
          \\"builder-custom-code\\" +
          (this.props.replaceNodes ? \\" replace-nodes\\" : \\"\\");

        el.innerHTML = this.props.code;
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"custom-code\\", CustomCode);
"
`;

exports[`webcomponent Typescript Test Embed 1`] = `
"export interface CustomCodeProps {
  code: string;
  replaceNodes?: boolean;
}

/**
 * Usage:
 *
 *  <custom-code></custom-code>
 *
 */
class CustomCode extends HTMLElement {
  get _elem() {
    return this._root.querySelector(\\"[data-ref='CustomCode-elem']\\");
  }

  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      scriptsInserted: [],
      scriptsRun: [],
      findAndRunScripts() {
        // TODO: Move this function to standalone one in '@builder.io/utils'
        if (self._elem && typeof window !== \\"undefined\\") {
          /** @type {HTMLScriptElement[]} */
          const scripts = self._elem.getElementsByTagName(\\"script\\");

          for (let i = 0; i < scripts.length; i++) {
            const script = scripts[i];

            if (script.src) {
              if (self.state.scriptsInserted.includes(script.src)) {
                continue;
              }

              self.state.scriptsInserted.push(script.src);
              const newScript = document.createElement(\\"script\\");
              newScript.async = true;
              newScript.src = script.src;
              document.head.appendChild(newScript);
            } else if (
              !script.type ||
              [
                \\"text/javascript\\",
                \\"application/javascript\\",
                \\"application/ecmascript\\",
              ].includes(script.type)
            ) {
              if (self.state.scriptsRun.includes(script.innerText)) {
                continue;
              }

              try {
                self.state.scriptsRun.push(script.innerText);
                new Function(script.innerText)();
              } catch (error) {
                console.warn(\\"\`CustomCode\`: Error running script:\\", error);
              }
            }
          }
        }
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"replaceNodes\\", \\"code\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div data-el=\\"div-custom-code-1\\" data-ref=\\"CustomCode-elem\\"></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    this.state.findAndRunScripts();
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-custom-code-1']\\")
      .forEach((el) => {
        el.className =
          \\"builder-custom-code\\" +
          (this.props.replaceNodes ? \\" replace-nodes\\" : \\"\\");

        el.innerHTML = this.props.code;
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"custom-code\\", CustomCode);
"
`;

exports[`webcomponent Typescript Test Image 1`] = `
"// TODO: AMP Support?
export interface ImageProps {
  _class?: string;
  image: string;
  sizes?: string;
  lazy?: boolean;
  height?: number;
  width?: number;
  altText?: string;
  backgroundSize?: string;
  backgroundPosition?: string; // TODO: Support generating Builder.io and or Shopify \`srcset\`s when needed

  srcset?: string; // TODO: Implement support for custom aspect ratios

  aspectRatio?: number; // TODO: This might not work as expected in terms of positioning

  children?: any;
}

/**
 * Usage:
 *
 *  <image></image>
 *
 */
class Image extends HTMLElement {
  get _pictureRef() {
    return this._root.querySelector(\\"[data-ref='Image-pictureRef']\\");
  }

  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      scrollListener: null,
      imageLoaded: false,
      setLoaded() {
        self.state.imageLoaded = true;
        self.update();
      },
      useLazyLoading() {
        // TODO: Add more checks here, like testing for real web browsers
        return !!self.props.lazy && isBrowser();
      },
      isBrowser: function isBrowser() {
        return (
          typeof window !== \\"undefined\\" &&
          window.navigator.product != \\"ReactNative\\"
        );
      },
      load: false,
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"lazy\\",
      \\"altText\\",
      \\"_class\\",
      \\"image\\",
      \\"srcset\\",
      \\"sizes\\",
      \\"children\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'load' event on img-image-1
    this.onImgImage1Load = (event) => {
      this.state.setLoaded();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  disconnectedCallback() {
    // onUnMount
    if (this.state.scrollListener) {
      window.removeEventListener(\\"scroll\\", this.state.scrollListener);
    }
    this.destroyAnyNodes(); // clean up nodes when component is destroyed
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <picture data-el=\\"picture-image-1\\" data-ref=\\"Image-pictureRef\\">
          <template data-el=\\"show-image\\">
            <img data-el=\\"img-image-1\\" />
          </template>
      
          <source data-el=\\"source-image-1\\" />
        </picture>
      
        <slot></slot>
      </div>
      <style>
        .img {
          opacity: 1;
          transition: opacity 0.2s ease-in-out;
          object-fit: cover;
          object-position: center;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {
    // onMount
    if (this.state.useLazyLoading()) {
      // throttled scroll capture listener
      const listener = () => {
        if (self._pictureRef) {
          const rect = self._pictureRef.getBoundingClientRect();

          const buffer = window.innerHeight / 2;

          if (rect.top < window.innerHeight + buffer) {
            setLoad(true);
            this.state.scrollListener = null;
            this.update();
            window.removeEventListener(\\"scroll\\", listener);
          }
        }
      };

      this.state.scrollListener = listener;
      this.update();
      window.addEventListener(\\"scroll\\", listener, {
        capture: true,
        passive: true,
      });
      listener();
    }
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='show-image']\\").forEach((el) => {
      const whenCondition = !this.state.useLazyLoading() || this.state.load;
      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='img-image-1']\\").forEach((el) => {
      el.setAttribute(\\"alt\\", this.props.altText);

      el.setAttribute(
        \\"aria-role\\",
        this.props.altText ? \\"presentation\\" : undefined
      );

      el.className =
        \\"builder-image\\" +
        (this.props._class ? \\" \\" + this.props._class : \\"\\") +
        \\" img\\";

      el.setAttribute(\\"src\\", this.props.image);

      el.removeEventListener(\\"load\\", this.onImgImage1Load);
      el.addEventListener(\\"load\\", this.onImgImage1Load);

      el.setAttribute(\\"srcset\\", this.props.srcset);

      el.setAttribute(\\"sizes\\", this.props.sizes);
    });

    this._root.querySelectorAll(\\"[data-el='source-image-1']\\").forEach((el) => {
      el.setAttribute(\\"srcset\\", this.props.srcset);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"image\\", Image);
"
`;

exports[`webcomponent Typescript Test Image State 1`] = `
"/**
 * Usage:
 *
 *  <img-state-component></img-state-component>
 *
 */
class ImgStateComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { canShow: true, images: [\\"http://example.com/qwik.png\\"] };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <template data-el=\\"for-img-state-component\\">
          <img class=\\"custom-class\\" data-el=\\"img-img-state-component-1\\" />
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='for-img-state-component']\\")
      .forEach((el) => {
        let array = this.state.images;
        this.renderLoop(el, array, \\"item\\", \\"itemIndex\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='img-img-state-component-1']\\")
      .forEach((el) => {
        const item = this.getScope(el, \\"item\\");
        const itemIndex = this.getScope(el, \\"itemIndex\\");

        el.setAttribute(\\"src\\", item);

        el.key = itemIndex;
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"img-state-component\\", ImgStateComponent);
"
`;

exports[`webcomponent Typescript Test Img 1`] = `
"export interface ImgProps {
  attributes?: any;
  imgSrc?: string;
  altText?: string;
  backgroundSize?: \\"cover\\" | \\"contain\\";
  backgroundPosition?:
    | \\"center\\"
    | \\"top\\"
    | \\"left\\"
    | \\"right\\"
    | \\"bottom\\"
    | \\"top left\\"
    | \\"top right\\"
    | \\"bottom left\\"
    | \\"bottom right\\";
}

import { Builder } from \\"@builder.io/sdk\\";

/**
 * Usage:
 *
 *  <img-component></img-component>
 *
 */
class ImgComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"backgroundSize\\",
      \\"backgroundPosition\\",
      \\"attributes\\",
      \\"imgSrc\\",
      \\"altText\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <img data-el=\\"img-img-component-1\\" />\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='img-img-component-1']\\")
      .forEach((el) => {
        Object.assign(el.style, {
          objectFit: this.props.backgroundSize || \\"cover\\",
          objectPosition: this.props.backgroundPosition || \\"center\\",
        });

        el.key = (Builder.isEditing && this.props.imgSrc) || \\"default-key\\";

        el.setAttribute(\\"alt\\", this.props.altText);

        el.setAttribute(\\"src\\", this.props.imgSrc);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"img-component\\", ImgComponent);
"
`;

exports[`webcomponent Typescript Test Input 1`] = `
"export interface FormInputProps {
  type?: string;
  attributes?: any;
  name?: string;
  value?: string;
  placeholder?: string;
  defaultValue?: string;
  required?: boolean;
}

import { Builder } from \\"@builder.io/sdk\\";

/**
 * Usage:
 *
 *  <form-input-component></form-input-component>
 *
 */
class FormInputComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"attributes\\",
      \\"defaultValue\\",
      \\"placeholder\\",
      \\"type\\",
      \\"name\\",
      \\"value\\",
      \\"required\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <input
        data-el=\\"input-form-input-component-1\\"
        data-dom-state=\\"FormInputComponent-input-form-input-component-1\\"
      />\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-form-input-component-1']\\")
      .forEach((el) => {
        el.key =
          Builder.isEditing && this.props.defaultValue
            ? this.props.defaultValue
            : \\"default-key\\";

        el.setAttribute(\\"placeholder\\", this.props.placeholder);

        el.setAttribute(\\"type\\", this.props.type);

        el.setAttribute(\\"name\\", this.props.name);

        el.value = this.props.value;

        el.setAttribute(\\"defaultValue\\", this.props.defaultValue);

        el.setAttribute(\\"required\\", this.props.required);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"form-input-component\\", FormInputComponent);
"
`;

exports[`webcomponent Typescript Test RawText 1`] = `
"export interface RawTextProps {
  attributes?: any;
  text?: string; // builderBlock?: any;
}

/**
 * Usage:
 *
 *  <raw-text></raw-text>
 *
 */
class RawText extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"attributes\\", \\"text\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <span data-el=\\"span-raw-text-1\\"></span>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='span-raw-text-1']\\").forEach((el) => {
      el.className =
        this.props.attributes?.class || this.props.attributes?.className;

      el.innerHTML = this.props.text || \\"\\";
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"raw-text\\", RawText);
"
`;

exports[`webcomponent Typescript Test Section 1`] = `
"export interface SectionProps {
  maxWidth?: number;
  attributes?: any;
  children?: any;
}

/**
 * Usage:
 *
 *  <section-component></section-component>
 *
 */
class SectionComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"attributes\\", \\"maxWidth\\", \\"children\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <section data-el=\\"section-section-component-1\\">
        <slot></slot>
      </section>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='section-section-component-1']\\")
      .forEach((el) => {
        Object.assign(
          el.style,
          this.props.maxWidth && typeof this.props.maxWidth === \\"number\\"
            ? {
                maxWidth: this.props.maxWidth,
              }
            : undefined
        );
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"section-component\\", SectionComponent);
"
`;

exports[`webcomponent Typescript Test Section 2`] = `
"export interface SectionProps {
  maxWidth?: number;
  attributes?: any;
  children?: any;
}

/**
 * Usage:
 *
 *  <section-state-component></section-state-component>
 *
 */
class SectionStateComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { max: 42, items: [42] };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"attributes\\", \\"children\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"show-section-state-component\\">
        <template data-el=\\"for-section-state-component\\">
          <section data-el=\\"section-section-state-component-1\\">
            <slot></slot>
          </section>
        </template>
      </template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-section-state-component']\\")
      .forEach((el) => {
        const whenCondition = this.state.max;
        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='for-section-state-component']\\")
      .forEach((el) => {
        let array = this.state.items;
        this.renderLoop(el, array, \\"item\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='section-section-state-component-1']\\")
      .forEach((el) => {
        const item = this.getScope(el, \\"item\\");
        Object.assign(el.style, {
          maxWidth: item + this.state.max,
        });
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"section-state-component\\", SectionStateComponent);
"
`;

exports[`webcomponent Typescript Test Select 1`] = `
"export interface FormSelectProps {
  options?: {
    name?: string;
    value: string;
  }[];
  attributes?: any;
  name?: string;
  value?: string;
  defaultValue?: string;
}

import { Builder } from \\"@builder.io/sdk\\";

/**
 * Usage:
 *
 *  <select-component></select-component>
 *
 */
class SelectComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"attributes\\",
      \\"value\\",
      \\"defaultValue\\",
      \\"name\\",
      \\"options\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <select
        data-el=\\"select-select-component-1\\"
        data-dom-state=\\"SelectComponent-select-select-component-1\\"
      >
        <template data-el=\\"for-select-component\\">
          <option data-el=\\"option-select-component-1\\">
            <template data-el=\\"div-select-component-1\\">
              <!-- option.name || option.value -->
            </template>
          </option>
        </template>
      </select>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='select-select-component-1']\\")
      .forEach((el) => {
        el.value = this.props.value;

        el.key =
          Builder.isEditing && this.props.defaultValue
            ? this.props.defaultValue
            : \\"default-key\\";

        el.setAttribute(\\"defaultValue\\", this.props.defaultValue);

        el.setAttribute(\\"name\\", this.props.name);
      });

    this._root
      .querySelectorAll(\\"[data-el='for-select-component']\\")
      .forEach((el) => {
        let array = this.props.options;
        this.renderLoop(el, array, \\"option\\", \\"index\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='option-select-component-1']\\")
      .forEach((el) => {
        const option = this.getScope(el, \\"option\\");
        const index = this.getScope(el, \\"index\\");

        el.value = option.value;

        el.setAttribute(\\"data-index\\", index);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-select-component-1']\\")
      .forEach((el) => {
        const option = this.getScope(el, \\"option\\");
        this.renderTextNode(el, option.name || option.value);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"select-component\\", SelectComponent);
"
`;

exports[`webcomponent Typescript Test SlotHtml 1`] = `
"type Props = {
  [key: string]: string;
};

import ContentSlotCode from \\"./content-slot-jsx.raw\\";

/**
 * Usage:
 *
 *  <slot-code></slot-code>
 *
 */
class SlotCode extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <content-slot-code>
          <slot data-el=\\"slot-slot-code\\"></slot>
        </content-slot-code>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='slot-slot-code']\\").forEach((el) => {
      el.setAttribute(\\"testing\\", <div>Hello</div>);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"slot-code\\", SlotCode);
"
`;

exports[`webcomponent Typescript Test SlotJsx 1`] = `
"type Props = {
  [key: string]: string;
};

import ContentSlotCode from \\"./content-slot-jsx.raw\\";

/**
 * Usage:
 *
 *  <slot-code></slot-code>
 *
 */
class SlotCode extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <content-slot-code data-el=\\"content-slot-code-slot-code\\"></content-slot-code>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='content-slot-code-slot-code']\\")
      .forEach((el) => {
        el.setAttribute(\\"slotTesting\\", <div>Hello</div>);
        el.slotTesting = <div>Hello</div>;

        if (el.props) {
          el.props.slotTesting = <div>Hello</div>;
          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.slotTesting = <div>Hello</div>;
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"slot-code\\", SlotCode);
"
`;

exports[`webcomponent Typescript Test Stamped.io 1`] = `
"type SmileReviewsProps = {
  productId: string;
  apiKey: string;
};

import { kebabCase } from \\"lodash\\";
import { snakeCase } from \\"lodash\\";

/**
 * Usage:
 *
 *  <smile-reviews></smile-reviews>
 *
 */
class SmileReviews extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      reviews: [],
      name: \\"test\\",
      showReviewPrompt: false,
      kebabCaseValue() {
        return kebabCase(\\"testThat\\");
      },
      snakeCaseValue() {
        return snakeCase(\\"testThis\\");
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"apiKey\\", \\"productId\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'click' event on button-smile-reviews-1
    this.onButtonSmileReviews1Click = (event) => {
      this.state.showReviewPrompt = true;
      this.update();
    };

    // Event handler for 'click' event on button-smile-reviews-2
    this.onButtonSmileReviews2Click = (event) => {
      event.preventDefault();
      this.state.showReviewPrompt = false;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div data-el=\\"div-smile-reviews-1\\">
        <button data-el=\\"button-smile-reviews-1\\">Write a review</button>
      
        <template data-el=\\"show-smile-reviews\\">
          <input
            placeholder=\\"Email\\"
            data-dom-state=\\"SmileReviews-input-smile-reviews-1\\"
          />
      
          <input
            placeholder=\\"Title\\"
            class=\\"input\\"
            data-dom-state=\\"SmileReviews-input-smile-reviews-2\\"
          />
      
          <textarea
            placeholder=\\"How was your experience?\\"
            class=\\"textarea\\"
            data-dom-state=\\"SmileReviews-textarea-smile-reviews-1\\"
          ></textarea>
      
          <button class=\\"button\\" data-el=\\"button-smile-reviews-2\\">Submit</button>
        </template>
      
        <template data-el=\\"for-smile-reviews\\">
          <div class=\\"review\\" data-el=\\"div-smile-reviews-2\\">
            <img class=\\"img\\" data-el=\\"img-smile-reviews-1\\" />
      
            <div data-el=\\"div-smile-reviews-3\\">
              <div>
                N:
                <template data-el=\\"div-smile-reviews-4\\"><!-- index --></template>
              </div>
      
              <div>
                <template data-el=\\"div-smile-reviews-5\\">
                  <!-- review.author -->
                </template>
              </div>
      
              <div>
                <template data-el=\\"div-smile-reviews-6\\">
                  <!-- review.reviewMessage -->
                </template>
              </div>
            </div>
          </div>
        </template>
      </div>
      <style>
        .input {
          display: block;
        }
        .textarea {
          display: block;
        }
        .button {
          display: block;
        }
        .review {
          margin: 10px;
          padding: 10px;
          background: white;
          display: flex;
          border-radius: 5px;
          box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .img {
          height: 30px;
          width: 30px;
          margin-right: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {
    // onMount
    fetch(
      \`https://stamped.io/api/widget/reviews?storeUrl=builder-io.myshopify.com&apiKey=\${
        this.props.apiKey || \\"pubkey-8bbDq7W6w4sB3OWeM1HUy2s47702hM\\"
      }&productId=\${this.props.productId || \\"2410511106127\\"}\`
    )
      .then((res) => res.json())
      .then((data) => {
        this.state.reviews = data.data;
        this.update();
      });
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-1']\\")
      .forEach((el) => {
        el.setAttribute(\\"data-user\\", this.state.name);
      });

    this._root
      .querySelectorAll(\\"[data-el='button-smile-reviews-1']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onButtonSmileReviews1Click);
        el.addEventListener(\\"click\\", this.onButtonSmileReviews1Click);
      });

    this._root
      .querySelectorAll(\\"[data-el='show-smile-reviews']\\")
      .forEach((el) => {
        const whenCondition = this.state.showReviewPrompt;
        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='button-smile-reviews-2']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onButtonSmileReviews2Click);
        el.addEventListener(\\"click\\", this.onButtonSmileReviews2Click);
      });

    this._root
      .querySelectorAll(\\"[data-el='for-smile-reviews']\\")
      .forEach((el) => {
        let array = this.state.reviews;
        this.renderLoop(el, array, \\"review\\", \\"index\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-2']\\")
      .forEach((el) => {
        const review = this.getScope(el, \\"review\\");

        el.key = review.id;
      });

    this._root
      .querySelectorAll(\\"[data-el='img-smile-reviews-1']\\")
      .forEach((el) => {
        const review = this.getScope(el, \\"review\\");

        el.setAttribute(\\"src\\", review.avatar);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-3']\\")
      .forEach((el) => {
        el.className = this.state.showReviewPrompt
          ? \\"bg-primary\\"
          : \\"bg-secondary\\";
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-4']\\")
      .forEach((el) => {
        const index = this.getScope(el, \\"index\\");
        this.renderTextNode(el, index);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-5']\\")
      .forEach((el) => {
        const review = this.getScope(el, \\"review\\");
        this.renderTextNode(el, review.author);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-6']\\")
      .forEach((el) => {
        const review = this.getScope(el, \\"review\\");
        this.renderTextNode(el, review.reviewMessage);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"smile-reviews\\", SmileReviews);
"
`;

exports[`webcomponent Typescript Test Submit 1`] = `
"export interface ButtonProps {
  attributes?: any;
  text?: string;
}

/**
 * Usage:
 *
 *  <submit-button></submit-button>
 *
 */
class SubmitButton extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"attributes\\", \\"text\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <button type=\\"submit\\" data-el=\\"button-submit-button-1\\">
        <template data-el=\\"div-submit-button-1\\"><!-- props.text --></template>
      </button>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-submit-button-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.text);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"submit-button\\", SubmitButton);
"
`;

exports[`webcomponent Typescript Test Text 1`] = `
"export interface TextProps {
  attributes?: any;
  rtlMode: boolean;
  text?: string;
  content?: string;
  builderBlock?: any;
}

import { Builder } from \\"@builder.io/sdk\\";

/**
 * Usage:
 *
 *  <text></text>
 *
 */
class Text extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"Decadef20\\" };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"text\\", \\"content\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div data-el=\\"div-text-1\\"></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='div-text-1']\\").forEach((el) => {
      el.setAttribute(\\"contentEditable\\", allowEditingText || undefined);

      el.setAttribute(\\"data-name\\", {
        test: this.state.name || \\"any name\\",
      });

      el.innerHTML =
        this.props.text ||
        this.props.content ||
        this.state.name ||
        '<p class=\\"text-lg\\">my name</p>';
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"text\\", Text);
"
`;

exports[`webcomponent Typescript Test Textarea 1`] = `
"export interface TextareaProps {
  attributes?: any;
  name?: string;
  value?: string;
  defaultValue?: string;
  placeholder?: string;
}

/**
 * Usage:
 *
 *  <textarea></textarea>
 *
 */
class Textarea extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"attributes\\",
      \\"placeholder\\",
      \\"name\\",
      \\"value\\",
      \\"defaultValue\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <textarea
        data-el=\\"textarea-textarea-1\\"
        data-dom-state=\\"Textarea-textarea-textarea-1\\"
      ></textarea>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='textarea-textarea-1']\\")
      .forEach((el) => {
        el.setAttribute(\\"placeholder\\", this.props.placeholder);

        el.setAttribute(\\"name\\", this.props.name);

        el.value = this.props.value;

        el.setAttribute(\\"defaultValue\\", this.props.defaultValue);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"textarea\\", Textarea);
"
`;

exports[`webcomponent Typescript Test Video 1`] = `
"export interface VideoProps {
  attributes?: any;
  video?: string;
  autoPlay?: boolean;
  controls?: boolean;
  muted?: boolean;
  loop?: boolean;
  playsInline?: boolean;
  aspectRatio?: number;
  width?: number;
  height?: number;
  fit?: \\"contain\\" | \\"cover\\" | \\"fill\\";
  position?:
    | \\"center\\"
    | \\"top\\"
    | \\"left\\"
    | \\"right\\"
    | \\"bottom\\"
    | \\"top left\\"
    | \\"top right\\"
    | \\"bottom left\\"
    | \\"bottom right\\";
  posterImage?: string;
  lazyLoad?: boolean;
}

/**
 * Usage:
 *
 *  <video></video>
 *
 */
class Video extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"attributes\\",
      \\"fit\\",
      \\"position\\",
      \\"video\\",
      \\"posterImage\\",
      \\"autoPlay\\",
      \\"muted\\",
      \\"controls\\",
      \\"loop\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <video preload=\\"none\\" data-el=\\"video-video-1\\"></video>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='video-video-1']\\").forEach((el) => {
      Object.assign(el.style, {
        width: \\"100%\\",
        height: \\"100%\\",
        ...this.props.attributes?.style,
        objectFit: this.props.fit,
        objectPosition: this.props.position,
        // Hack to get object fit to work as expected and
        // not have the video overflow
        borderRadius: 1,
      });

      el.key = this.props.video || \\"no-src\\";

      el.setAttribute(\\"poster\\", this.props.posterImage);

      el.setAttribute(\\"autoplay\\", this.props.autoPlay);

      el.setAttribute(\\"muted\\", this.props.muted);

      el.setAttribute(\\"controls\\", this.props.controls);

      el.setAttribute(\\"loop\\", this.props.loop);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"video\\", Video);
"
`;

exports[`webcomponent Typescript Test basicForwardRef 1`] = `
"export interface Props {
  showInput: boolean;
  inputRef: HTMLInputElement;
}

/**
 * Usage:
 *
 *  <my-basic-forward-ref-component></my-basic-forward-ref-component>
 *
 */
class MyBasicForwardRefComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\" };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-basic-forward-ref-component-1
    this.onInputMyBasicForwardRefComponent1Input = (event) => {
      this.state.name = event.target.value;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <input
          class=\\"input\\"
          data-el=\\"input-my-basic-forward-ref-component-1\\"
          data-dom-state=\\"MyBasicForwardRefComponent-input-my-basic-forward-ref-component-1\\"
        />
      </div>
      <style>
        .input {
          color: red;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-forward-ref-component-1']\\")
      .forEach((el) => {
        el.value = this.state.name;

        el.removeEventListener(
          \\"input\\",
          this.onInputMyBasicForwardRefComponent1Input
        );
        el.addEventListener(
          \\"input\\",
          this.onInputMyBasicForwardRefComponent1Input
        );
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(
  \\"my-basic-forward-ref-component\\",
  MyBasicForwardRefComponent
);
"
`;

exports[`webcomponent Typescript Test basicForwardRefMetadata 1`] = `
"export interface Props {
  showInput: boolean;
  inputRef: HTMLInputElement;
}

/**
 * Usage:
 *
 *  <my-basic-forward-ref-component></my-basic-forward-ref-component>
 *
 */
class MyBasicForwardRefComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\" };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-basic-forward-ref-component-1
    this.onInputMyBasicForwardRefComponent1Input = (event) => {
      this.state.name = event.target.value;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <input
          class=\\"input\\"
          data-el=\\"input-my-basic-forward-ref-component-1\\"
          data-dom-state=\\"MyBasicForwardRefComponent-input-my-basic-forward-ref-component-1\\"
        />
      </div>
      <style>
        .input {
          color: red;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-forward-ref-component-1']\\")
      .forEach((el) => {
        el.value = this.state.name;

        el.removeEventListener(
          \\"input\\",
          this.onInputMyBasicForwardRefComponent1Input
        );
        el.addEventListener(
          \\"input\\",
          this.onInputMyBasicForwardRefComponent1Input
        );
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(
  \\"my-basic-forward-ref-component\\",
  MyBasicForwardRefComponent
);
"
`;

exports[`webcomponent Typescript Test basicOnUpdateReturn 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-on-update-return-component></my-basic-on-update-return-component>
 *
 */
class MyBasicOnUpdateReturnComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\" };
    if (!this.props) {
      this.props = {};
    }

    this.updateDeps = [[this.state.name]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        Hello!
        <template data-el=\\"div-my-basic-on-update-return-component-1\\">
          <!-- state.name -->
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        const controller = new AbortController();
        const signal = controller.signal;
        fetch(\\"https://patrickjs.com/api/resource.json\\", {
          signal,
        })
          .then((response) => response.json())
          .then((data) => {
            self.state.name = data.name;
          });
        return () => {
          if (!signal.aborted) {
            controller.abort();
          }
        };
        self.updateDeps[0] = __next;
      }
    })(self.updateDeps[0], [self.state.name]);
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-on-update-return-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(
  \\"my-basic-on-update-return-component\\",
  MyBasicOnUpdateReturnComponent
);
"
`;

exports[`webcomponent Typescript Test class + ClassName + css 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div class=\\"test2 test div\\">
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>
      <style>
        .div {
          padding: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent Typescript Test class + css 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div class=\\"test div\\">Hello! I can run in React, Vue, Solid, or Liquid!</div>
      <style>
        .div {
          padding: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent Typescript Test className + css 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div class=\\"test div\\">Hello! I can run in React, Vue, Solid, or Liquid!</div>
      <style>
        .div {
          padding: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent Typescript Test className 1`] = `
"type Props = {
  [key: string]: string | JSX.Element;
  slotTesting: JSX.Element;
};

/**
 * Usage:
 *
 *  <class-name-code></class-name-code>
 *
 */
class ClassNameCode extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { bindings: \\"a binding\\" };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <div class=\\"no binding\\">Without Binding</div>
      
        <div data-el=\\"div-class-name-code-1\\">With binding</div>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-class-name-code-1']\\")
      .forEach((el) => {
        el.className = this.state.bindings;
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"class-name-code\\", ClassNameCode);
"
`;

exports[`webcomponent Typescript Test classState 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      classState: \\"testClassName\\",
      styleState: {
        color: \\"red\\",
      },
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div data-el=\\"div-my-basic-component-1\\">
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>
      <style>
        .div {
          padding: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-1']\\")
      .forEach((el) => {
        el.className = this.state.classState + \\" div\\";

        Object.assign(el.style, this.state.styleState);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent Typescript Test defaultProps 1`] = `
"export interface ButtonProps {
  attributes?: any;
  text?: string;
  link?: string;
  openLinkInNewTab?: boolean;
}

/**
 * Usage:
 *
 *  <button></button>
 *
 */
class Button extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"link\\", \\"attributes\\", \\"openLinkInNewTab\\", \\"text\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"show-button\\">
          <a data-el=\\"a-button-1\\">
            <template data-el=\\"div-button-1\\"><!-- props.text --></template>
          </a>
        </template>
      
        <template data-el=\\"show-button-2\\">
          <button type=\\"button\\" data-el=\\"button-button-1\\">
            <template data-el=\\"div-button-2\\"><!-- props.text --></template>
          </button>
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='show-button']\\").forEach((el) => {
      const whenCondition = this.props.link;
      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='a-button-1']\\").forEach((el) => {
      el.setAttribute(\\"href\\", this.props.link);

      el.setAttribute(
        \\"target\\",
        this.props.openLinkInNewTab ? \\"_blank\\" : undefined
      );
    });

    this._root.querySelectorAll(\\"[data-el='div-button-1']\\").forEach((el) => {
      this.renderTextNode(el, this.props.text);
    });

    this._root.querySelectorAll(\\"[data-el='show-button-2']\\").forEach((el) => {
      const whenCondition = !this.props.link;
      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='div-button-2']\\").forEach((el) => {
      this.renderTextNode(el, this.props.text);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"button\\", Button);
"
`;

exports[`webcomponent Typescript Test defaultValsWithTypes 1`] = `
"type Props = {
  name: string;
};

const DEFAULT_VALUES: Props = {
  name: \\"Sami\\",
};

/**
 * Usage:
 *
 *  <component-with-types></component-with-types>
 *
 */
class ComponentWithTypes extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"name\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        Hello
        <template data-el=\\"div-component-with-types-1\\">
          <!-- props.name || DEFAULT_VALUES.name -->
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-component-with-types-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.name || DEFAULT_VALUES.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"component-with-types\\", ComponentWithTypes);
"
`;

exports[`webcomponent Typescript Test import types 1`] = `
"type RenderContentProps = {
  options?: GetContentOptions;
  content: BuilderContent;
  renderContentProps: RenderBlockProps;
};

import RenderBlock from \\"./builder-render-block.raw\\";

/**
 * Usage:
 *
 *  <render-content></render-content>
 *
 */
class RenderContent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      getRenderContentProps(block, index) {
        return {
          block: block,
          index: index,
        };
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"renderContentProps\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <render-block data-el=\\"render-block-render-content\\"></render-block>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"render-content\\", RenderContent);
"
`;

exports[`webcomponent Typescript Test multipleOnUpdate 1`] = `
"/**
 * Usage:
 *
 *  <multiple-on-update></multiple-on-update>
 *
 */
class MultipleOnUpdate extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.updateDeps = [[], []];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    console.log(\\"Runs on every update/rerender\\");

    console.log(\\"Runs on every update/rerender as well\\");
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"multiple-on-update\\", MultipleOnUpdate);
"
`;

exports[`webcomponent Typescript Test multipleOnUpdateWithDeps 1`] = `
"/**
 * Usage:
 *
 *  <multiple-on-update-with-deps></multiple-on-update-with-deps>
 *
 */
class MultipleOnUpdateWithDeps extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { a: \\"a\\", b: \\"b\\", c: \\"c\\", d: \\"d\\" };
    if (!this.props) {
      this.props = {};
    }

    this.updateDeps = [
      [this.state.a, this.state.b],
      [this.state.c, this.state.d],
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        console.log(\\"Runs when a or b changes\\", self.state.a, self.state.b);

        if (self.state.a === \\"a\\") {
          self.state.a = \\"b\\";
        }
        self.updateDeps[0] = __next;
      }
    })(self.updateDeps[0], [self.state.a, self.state.b]);

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        console.log(\\"Runs when c or d changes\\", self.state.c, self.state.d);

        if (self.state.a === \\"a\\") {
          self.state.a = \\"b\\";
        }
        self.updateDeps[1] = __next;
      }
    })(self.updateDeps[1], [self.state.c, self.state.d]);
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"multiple-on-update-with-deps\\", MultipleOnUpdateWithDeps);
"
`;

exports[`webcomponent Typescript Test nestedShow 1`] = `
"interface Props {
  conditionA: boolean;
  conditionB: boolean;
}

/**
 * Usage:
 *
 *  <nested-show></nested-show>
 *
 */
class NestedShow extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"conditionA\\", \\"conditionB\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"show-nested-show\\">
        <template data-el=\\"show-nested-show-2\\">
          <div>if condition A and condition B</div>
        </template>
      </template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-nested-show']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;
        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-nested-show-2']\\")
      .forEach((el) => {
        const whenCondition = !this.props.conditionB;
        if (whenCondition) {
          this.showContent(el);
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"nested-show\\", NestedShow);
"
`;

exports[`webcomponent Typescript Test nestedStyles 1`] = `
"/**
 * Usage:
 *
 *  <nested-styles></nested-styles>
 *
 */
class NestedStyles extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div class=\\"div\\">Hello world</div>
      <style>
        .div {
          display: flex;
          foo: var(--bar);
        }
        @media (max-width: env(--mobile)) {
          .div {
            display: block;
          }
        }
        .div:hover {
          display: flex;
        }
        .div .nested-selector {
          display: grid;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"nested-styles\\", NestedStyles);
"
`;

exports[`webcomponent Typescript Test onInit & onMount 1`] = `
"/**
 * Usage:
 *
 *  <on-init></on-init>
 *
 */
class OnInit extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.onInitOnce = false;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;
    this.onInit();
    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onInit() {
    if (!this.onInitOnce) {
      console.log(\\"onInit\\");
      this.onInitOnce = true;
    }
  }

  onMount() {
    // onMount
    console.log(\\"onMount\\");
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"on-init\\", OnInit);
"
`;

exports[`webcomponent Typescript Test onInit 1`] = `
"type Props = {
  name: string;
};

export const defaultValues = {
  name: \\"PatrickJS\\",
};

/**
 * Usage:
 *
 *  <on-init></on-init>
 *
 */
class OnInit extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.onInitOnce = false;

    this.state = { name: \\"\\" };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"name\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        Default name defined by parent
        <template data-el=\\"div-on-init-1\\"><!-- state.name --></template>
      </div>\`;
    this.pendingUpdate = true;
    this.onInit();
    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onInit() {
    if (!this.onInitOnce) {
      this.state.name = defaultValues.name || this.props.name;
      this.update();
      console.log(\\"set defaults with props\\");
      this.onInitOnce = true;
    }
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='div-on-init-1']\\").forEach((el) => {
      this.renderTextNode(el, this.state.name);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"on-init\\", OnInit);
"
`;

exports[`webcomponent Typescript Test onMount 1`] = `
"/**
 * Usage:
 *
 *  <comp></comp>
 *
 */
class Comp extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  disconnectedCallback() {
    // onUnMount
    console.log(\\"Runs on unMount\\");
    this.destroyAnyNodes(); // clean up nodes when component is destroyed
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    console.log(\\"Runs on mount\\");
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"comp\\", Comp);
"
`;

exports[`webcomponent Typescript Test onUpdate 1`] = `
"/**
 * Usage:
 *
 *  <on-update></on-update>
 *
 */
class OnUpdate extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.updateDeps = [[]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    console.log(\\"Runs on every update/rerender\\");
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"on-update\\", OnUpdate);
"
`;

exports[`webcomponent Typescript Test onUpdateWithDeps 1`] = `
"type Props = {
  size: string;
};

/**
 * Usage:
 *
 *  <on-update-with-deps></on-update-with-deps>
 *
 */
class OnUpdateWithDeps extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { a: \\"a\\", b: \\"b\\" };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"size\\"];

    this.updateDeps = [[this.state.a, this.state.b, this.props.size]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        console.log(
          \\"Runs when a, b or size changes\\",
          self.state.a,
          self.state.b,
          self.props.size
        );
        self.updateDeps[0] = __next;
      }
    })(self.updateDeps[0], [self.state.a, self.state.b, self.props.size]);
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"on-update-with-deps\\", OnUpdateWithDeps);
"
`;

exports[`webcomponent Typescript Test preserveExportOrLocalStatement 1`] = `
"type Types = {
  s: any[];
};
interface IPost {
  len: number;
}
export interface MyBasicComponentProps {
  id: string;
}

const b = 3;
const foo = () => {};
export const a = 3;
export const bar = () => {};
export function run<T>(value: T) {}

/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent Typescript Test preserveTyping 1`] = `
"export type A = \\"test\\";
export interface C {
  n: \\"test\\";
}
type B = \\"test2\\";
interface D {
  n: \\"test\\";
}
export interface MyBasicComponentProps {
  name: string;
  age?: number;
}

/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"name\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        Hello! I can run in React, Vue, Solid, or Liquid!
        <template data-el=\\"div-my-basic-component-1\\"><!-- props.name --></template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent Typescript Test propsDestructure 1`] = `
"type Props = {
  children: any;
  type: string;
};

/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"Decadef20\\" };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"children\\", \\"type\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <slot></slot>
      
        <template data-el=\\"div-my-basic-component-2\\"><!-- props.type --></template>
      
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-2']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.type);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent Typescript Test propsInterface 1`] = `
"interface Person {
  name: string;
  age?: number;
}

/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"name\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        Hello! I can run in React, Vue, Solid, or Liquid!
        <template data-el=\\"div-my-basic-component-1\\"><!-- props.name --></template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent Typescript Test propsType 1`] = `
"type Person = {
  name: string;
  age?: number;
};

/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"name\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        Hello! I can run in React, Vue, Solid, or Liquid!
        <template data-el=\\"div-my-basic-component-1\\"><!-- props.name --></template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent Typescript Test rootFragmentMultiNode 1`] = `
"export interface ButtonProps {
  attributes?: any;
  text?: string;
  link?: string;
  openLinkInNewTab?: boolean;
}

/**
 * Usage:
 *
 *  <button></button>
 *
 */
class Button extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"link\\", \\"attributes\\", \\"openLinkInNewTab\\", \\"text\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"show-button\\">
        <a data-el=\\"a-button-1\\">
          <template data-el=\\"div-button-1\\"><!-- props.text --></template>
        </a>
      </template>
      
      <template data-el=\\"show-button-2\\">
        <button type=\\"button\\" data-el=\\"button-button-1\\">
          <template data-el=\\"div-button-2\\"><!-- props.text --></template>
        </button>
      </template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='show-button']\\").forEach((el) => {
      const whenCondition = this.props.link;
      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='a-button-1']\\").forEach((el) => {
      el.setAttribute(\\"href\\", this.props.link);

      el.setAttribute(
        \\"target\\",
        this.props.openLinkInNewTab ? \\"_blank\\" : undefined
      );
    });

    this._root.querySelectorAll(\\"[data-el='div-button-1']\\").forEach((el) => {
      this.renderTextNode(el, this.props.text);
    });

    this._root.querySelectorAll(\\"[data-el='show-button-2']\\").forEach((el) => {
      const whenCondition = !this.props.link;
      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='div-button-2']\\").forEach((el) => {
      this.renderTextNode(el, this.props.text);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"button\\", Button);
"
`;

exports[`webcomponent Typescript Test rootShow 1`] = `
"export interface RenderStylesProps {
  foo: string;
}

/**
 * Usage:
 *
 *  <render-styles></render-styles>
 *
 */
class RenderStyles extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"foo\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"show-render-styles\\">
        <div>Bar</div>
      </template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-render-styles']\\")
      .forEach((el) => {
        const whenCondition = this.props.foo === \\"bar\\";
        if (whenCondition) {
          this.showContent(el);
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"render-styles\\", RenderStyles);
"
`;

exports[`webcomponent Typescript Test self-referencing component 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"name\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"div-my-component-1\\"><!-- props.name --></template>
      
        <template data-el=\\"show-my-component\\">
          <MyComponent name=\\"Bruce Wayne\\"></MyComponent>
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.name);
      });

    this._root
      .querySelectorAll(\\"[data-el='show-my-component']\\")
      .forEach((el) => {
        const whenCondition = this.props.name === \\"Batman\\";
        if (whenCondition) {
          this.showContent(el);
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent Typescript Test self-referencing component with children 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"name\\", \\"children\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"div-my-component-1\\"><!-- props.name --></template>
      
        <slot></slot>
      
        <template data-el=\\"show-my-component\\">
          <MyComponent name=\\"Bruce\\">
            <div>Wayne</div>
          </MyComponent>
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.name);
      });

    this._root
      .querySelectorAll(\\"[data-el='show-my-component']\\")
      .forEach((el) => {
        const whenCondition = this.props.name === \\"Batman\\";
        if (whenCondition) {
          this.showContent(el);
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent Typescript Test showWithFor 1`] = `
"interface Props {
  conditionA: boolean;
  items: string[];
}

/**
 * Usage:
 *
 *  <nested-show></nested-show>
 *
 */
class NestedShow extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"conditionA\\", \\"items\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"show-nested-show\\">
        <template data-el=\\"for-nested-show\\">
          <div data-el=\\"div-nested-show-1\\">
            <template data-el=\\"div-nested-show-2\\"><!-- item --></template>
          </div>
        </template>
      </template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-nested-show']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;
        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root.querySelectorAll(\\"[data-el='for-nested-show']\\").forEach((el) => {
      let array = this.props.items;
      this.renderLoop(el, array, \\"item\\", \\"idx\\");
    });

    this._root
      .querySelectorAll(\\"[data-el='div-nested-show-1']\\")
      .forEach((el) => {
        const idx = this.getScope(el, \\"idx\\");

        el.key = idx;
      });

    this._root
      .querySelectorAll(\\"[data-el='div-nested-show-2']\\")
      .forEach((el) => {
        const item = this.getScope(el, \\"item\\");
        this.renderTextNode(el, item);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"nested-show\\", NestedShow);
"
`;

exports[`webcomponent Typescript Test subComponent 1`] = `
"import Foo from \\"./foo-sub-component.lite\\";

/**
 * Usage:
 *
 *  <sub-component></sub-component>
 *
 */
class SubComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <foo></foo>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"sub-component\\", SubComponent);
"
`;

exports[`webcomponent Typescript Test typeDependency 1`] = `
"import type { Foo } from \\"./foo-type\\";
import type { Foo as Foo2 } from \\"./type-export\\";
export type TypeDependencyProps = {
  foo: Foo;
  foo2: Foo2;
};

/**
 * Usage:
 *
 *  <type-dependency></type-dependency>
 *
 */
class TypeDependency extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"foo\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"div-type-dependency-1\\"><!-- props.foo --></template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-type-dependency-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.foo);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"type-dependency\\", TypeDependency);
"
`;
