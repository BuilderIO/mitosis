// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`webcomponent Basic 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = { name: \\"Steve\\" };

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];

    // Event handler for 'input' event on input-1
    this.onInput1Input = (event) => {
      this.state.name = event.target.value;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <input data-name=\\"input-1\\" />
      
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>
      <style></style>\`;
    this.render();

    this.onMount();
    this.onUpdate();
  }

  onMount() {}

  onUpdate() {}

  update() {
    this.render();
    this.onUpdate();
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-name='input-1']\\").forEach((el) => {
      el.value = this.state.name;

      el.removeEventListener(\\"input\\", this.onInput1Input);
      el.addEventListener(\\"input\\", this.onInput1Input);
    });
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent BasicFor 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-for-component></my-basic-for-component>
 *
 */
class MyBasicForComponent extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];

    // Event handler for 'input' event on input-1
    this.onInput1Input = (event) => {
      const person = this.getContext(event.currentTarget, \\"person\\");

      this.state.name = event.target.value + \\" and \\" + person;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <span data-name=\\"for\\"></span>
        <template data-template-for=\\"for\\">
          <input data-name=\\"input-1\\" />
      
          Hello
          <span data-name=\\"div-1\\"><!-- person --></span>
          ! I can run in Qwik, Web Component, React, Vue, Solid, or Liquid!
        </template>
      </div>
      <style></style>\`;
    this.render();

    this.onMount();
    this.onUpdate();
  }

  onMount() {
    // onMount
    console.log(\\"onMount code\\");
  }

  onUpdate() {}

  update() {
    this.render();
    this.onUpdate();
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-name='for']\\").forEach((el) => {
      let array = this.state.names;
      let template = this._root.querySelector('[data-template-for=\\"for\\"]');
      this.renderLoop(el, array, template, \\"person\\", undefined, undefined);
    });

    this._root.querySelectorAll(\\"[data-name='input-1']\\").forEach((el) => {
      el.value = this.state.name;

      el.removeEventListener(\\"input\\", this.onInput1Input);
      el.addEventListener(\\"input\\", this.onInput1Input);
    });

    this._root.querySelectorAll(\\"[data-name='div-1']\\").forEach((el) => {
      const person = this.getContext(el, \\"person\\");
      el.innerText = person;
    });
  }

  // Helper to render loops
  renderLoop(el, array, template, itemName, itemIndex, collectionName) {
    el.innerHTML = \\"\\";
    for (let [index, value] of array.entries()) {
      let tmp = document.createElement(\\"span\\");
      tmp.innerHTML = template.innerHTML;
      Array.from(tmp.children).forEach((child) => {
        if (itemName !== undefined) {
          child[\\"__\\" + itemName] = value;
        }
        if (itemIndex !== undefined) {
          child[\\"__\\" + itemIndex] = index;
        }
        if (collectionName !== undefined) {
          child[\\"__\\" + collectionName] = array;
        }
        el.appendChild(child);
      });
    }
  }

  getContext(el, name) {
    do {
      let value = el[\\"__\\" + name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }
}

customElements.define(\\"my-basic-for-component\\", MyBasicForComponent);
"
`;

exports[`webcomponent Button 1`] = `
"/**
 * Usage:
 *
 *  <button></button>
 *
 */
class Button extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {};
    this.props = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <template data-name=\\"show\\">
        <a data-name=\\"a-1\\">
          <span data-name=\\"div-1\\"><!-- props.text --></span>
        </a>
      </template>
      
      <template data-name=\\"show-2\\">
        <button type=\\"button\\" data-name=\\"button-1\\">
          <span data-name=\\"div-2\\"><!-- props.text --></span>
        </button>
      </template>
      
      <style></style>\`;
    this.render();

    this.onMount();
    this.onUpdate();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    this.render();
    this.onUpdate();
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-name='show']\\").forEach((el) => {
      const whenCondition = this.props.link;
      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-name='a-1']\\").forEach((el) => {
      el.href = this.props.link;

      el.target = this.props.openLinkInNewTab ? \\"_blank\\" : undefined;
    });

    this._root.querySelectorAll(\\"[data-name='div-1']\\").forEach((el) => {
      el.innerText = this.props.text;
    });

    this._root.querySelectorAll(\\"[data-name='show-2']\\").forEach((el) => {
      const whenCondition = !this.props.link;
      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-name='div-2']\\").forEach((el) => {
      el.innerText = this.props.text;
    });
  }
}

customElements.define(\\"button\\", Button);
"
`;

exports[`webcomponent Columns 1`] = `
"/**
 * Usage:
 *
 *  <column></column>
 *
 */
class Column extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {
      getColumns() {
        return self.props.columns || [];
      },
      getGutterSize() {
        return typeof self.props.space === \\"number\\"
          ? self.props.space || 0
          : 20;
      },
      getWidth(index) {
        const columns = this.getColumns();
        return (columns[index] && columns[index].width) || 100 / columns.length;
      },
      getColumnCssWidth(index) {
        const columns = this.getColumns();
        const gutterSize = this.getGutterSize();
        const subtractWidth =
          (gutterSize * (columns.length - 1)) / columns.length;
        return \`calc(\${this.getWidth(index)}% - \${subtractWidth}px)\`;
      },
    };
    this.props = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div class=\\"builder-columns div\\">
        <span data-name=\\"for\\"></span>
        <template data-template-for=\\"for\\">
          <div class=\\"builder-column div-2\\">
            <span data-name=\\"div-1\\"><!-- column.content --></span>
      
            <span data-name=\\"div-2\\"><!-- index --></span>
          </div>
        </template>
      </div>
      <style>
        .div {
          display: flex;
          flex-direction: column;
          align-items: stretch;
          line-height: normal;
        }
        @media (max-width: 999px) {
          .div {
            flex-direction: row;
          }
        }
        @media (max-width: 639px) {
          .div {
            flex-direction: row-reverse;
          }
        }
        .div-2 {
          flex-grow: 1;
        }
      </style>\`;
    this.render();

    this.onMount();
    this.onUpdate();
  }

  onMount() {}

  onUpdate() {}

  update() {
    this.render();
    this.onUpdate();
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-name='for']\\").forEach((el) => {
      let array = this.props.columns;
      let template = this._root.querySelector('[data-template-for=\\"for\\"]');
      this.renderLoop(el, array, template, \\"column\\", \\"index\\", undefined);
    });

    this._root.querySelectorAll(\\"[data-name='div-1']\\").forEach((el) => {
      const column = this.getContext(el, \\"column\\");
      el.innerText = column.content;
    });

    this._root.querySelectorAll(\\"[data-name='div-2']\\").forEach((el) => {
      const index = this.getContext(el, \\"index\\");
      el.innerText = index;
    });
  }

  // Helper to render loops
  renderLoop(el, array, template, itemName, itemIndex, collectionName) {
    el.innerHTML = \\"\\";
    for (let [index, value] of array.entries()) {
      let tmp = document.createElement(\\"span\\");
      tmp.innerHTML = template.innerHTML;
      Array.from(tmp.children).forEach((child) => {
        if (itemName !== undefined) {
          child[\\"__\\" + itemName] = value;
        }
        if (itemIndex !== undefined) {
          child[\\"__\\" + itemIndex] = index;
        }
        if (collectionName !== undefined) {
          child[\\"__\\" + collectionName] = array;
        }
        el.appendChild(child);
      });
    }
  }

  getContext(el, name) {
    do {
      let value = el[\\"__\\" + name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }
}

customElements.define(\\"column\\", Column);
"
`;

exports[`webcomponent Image 1`] = `
"/**
 * Usage:
 *
 *  <image></image>
 *
 */
class Image extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {
      scrollListener: null,
      imageLoaded: false,
      load: false,
      setLoaded() {
        self.state.imageLoaded = true;
        self.update();
      },
      isBrowser() {
        return (
          typeof window !== \\"undefined\\" &&
          window.navigator.product != \\"ReactNative\\"
        );
      },
      useLazyLoading() {
        // TODO: Add more checks here, like testing for real web browsers
        return !!self.props.lazy && self.state.isBrowser();
      },
    };
    this.props = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];

    // Event handler for 'load' event on img-1
    this.onImg1Load = (event) => {
      this.state.setLoaded();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  disconnectedCallback() {
    // onUnMount
    if (this.state.scrollListener) {
      window.removeEventListener(\\"scroll\\", this.state.scrollListener);
    }
    this.destroyAnyNodes(); // clean up nodes when component is destroyed
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <picture data-name=\\"picture-1\\">
        <template data-name=\\"show\\">
          <img class=\\"img\\" data-name=\\"img-1\\" />
        </template>
      
        <source data-name=\\"source-1\\" />
      </picture>
      
      <slot></slot>
      
      <style>
        .img {
          opacity: 1;
          transition: opacity 0.2s ease-in-out;
          object-fit: cover;
          object-position: center;
        }
      </style>\`;
    this.render();

    this.onMount();
    this.onUpdate();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {
    // onMount
    if (this.state.useLazyLoading()) {
      // throttled scroll capture listener
      const listener = () => {
        if (pictureRef) {
          const rect = pictureRef.getBoundingClientRect();
          const buffer = window.innerHeight / 2;

          if (rect.top < window.innerHeight + buffer) {
            this.state.load = true;
            this.update();
            this.state.scrollListener = null;
            this.update();
            window.removeEventListener(\\"scroll\\", listener);
          }
        }
      };

      this.state.scrollListener = listener;
      this.update();
      window.addEventListener(\\"scroll\\", listener, {
        capture: true,
        passive: true,
      });
      listener();
    }
  }

  onUpdate() {}

  update() {
    this.render();
    this.onUpdate();
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-name='show']\\").forEach((el) => {
      const whenCondition = !this.state.useLazyLoading() || this.state.load;
      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-name='img-1']\\").forEach((el) => {
      el.alt = this.props.altText;

      el.setAttribute(
        \\"aria-role\\",
        this.props.altText ? \\"presentation\\" : undefined
      );

      el.className =
        \\"builder-image\\" + (this.props.class ? \\" \\" + this.props.class : \\"\\");

      el.src = this.props.image;

      el.removeEventListener(\\"load\\", this.onImg1Load);
      el.addEventListener(\\"load\\", this.onImg1Load);

      el.srcset = this.props.srcset;

      el.sizes = this.props.sizes;
    });

    this._root.querySelectorAll(\\"[data-name='source-1']\\").forEach((el) => {
      el.srcset = this.props.srcset;
    });
  }
}

customElements.define(\\"image\\", Image);
"
`;

exports[`webcomponent ImageState 1`] = `
"/**
 * Usage:
 *
 *  <img-state-component></img-state-component>
 *
 */
class ImgStateComponent extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = { canShow: true, images: [\\"http://example.com/qwik.png\\"] };

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <span data-name=\\"for\\"></span>
        <template data-template-for=\\"for\\">
          <img data-name=\\"img-1\\" />
        </template>
      </div>
      <style></style>\`;
    this.render();

    this.onMount();
    this.onUpdate();
  }

  onMount() {}

  onUpdate() {}

  update() {
    this.render();
    this.onUpdate();
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-name='for']\\").forEach((el) => {
      let array = this.state.images;
      let template = this._root.querySelector('[data-template-for=\\"for\\"]');
      this.renderLoop(el, array, template, \\"item\\", \\"itemIndex\\", undefined);
    });

    this._root.querySelectorAll(\\"[data-name='img-1']\\").forEach((el) => {
      el.className = \\"custom-class\\";

      var item = this.getContext(el, \\"item\\");
      el.src = item;

      var item = this.getContext(el, \\"item\\");
      var itemIndex = this.getContext(el, \\"itemIndex\\");
      el.key = itemIndex;
    });
  }

  // Helper to render loops
  renderLoop(el, array, template, itemName, itemIndex, collectionName) {
    el.innerHTML = \\"\\";
    for (let [index, value] of array.entries()) {
      let tmp = document.createElement(\\"span\\");
      tmp.innerHTML = template.innerHTML;
      Array.from(tmp.children).forEach((child) => {
        if (itemName !== undefined) {
          child[\\"__\\" + itemName] = value;
        }
        if (itemIndex !== undefined) {
          child[\\"__\\" + itemIndex] = index;
        }
        if (collectionName !== undefined) {
          child[\\"__\\" + collectionName] = array;
        }
        el.appendChild(child);
      });
    }
  }

  getContext(el, name) {
    do {
      let value = el[\\"__\\" + name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }
}

customElements.define(\\"img-state-component\\", ImgStateComponent);
"
`;

exports[`webcomponent Img 1`] = `
"import { Builder } from \\"@builder.io/sdk\\";

/**
 * Usage:
 *
 *  <img-component></img-component>
 *
 */
class ImgComponent extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {};
    this.props = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <img data-name=\\"img-1\\" />
      <style></style>\`;
    this.render();

    this.onMount();
    this.onUpdate();
  }

  onMount() {}

  onUpdate() {}

  update() {
    this.render();
    this.onUpdate();
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-name='img-1']\\").forEach((el) => {
      Object.assign(el.style, {
        objectFit: this.props.backgroundSize || \\"cover\\",
        objectPosition: this.props.backgroundPosition || \\"center\\",
      });

      el.key = (Builder.isEditing && this.props.imgSrc) || \\"default-key\\";

      el.alt = this.props.altText;

      el.src = this.props.imgSrc;
    });
  }
}

customElements.define(\\"img-component\\", ImgComponent);
"
`;

exports[`webcomponent Input block 1`] = `
"import { Builder } from \\"@builder.io/sdk\\";

/**
 * Usage:
 *
 *  <form-input-component></form-input-component>
 *
 */
class FormInputComponent extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {};
    this.props = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <input data-name=\\"input-1\\" />
      <style></style>\`;
    this.render();

    this.onMount();
    this.onUpdate();
  }

  onMount() {}

  onUpdate() {}

  update() {
    this.render();
    this.onUpdate();
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-name='input-1']\\").forEach((el) => {
      el.key =
        Builder.isEditing && this.props.defaultValue
          ? this.props.defaultValue
          : \\"default-key\\";

      el.placeholder = this.props.placeholder;

      el.type = this.props.type;

      el.name = this.props.name;

      el.value = this.props.value;

      el.defaultValue = this.props.defaultValue;

      el.required = this.props.required;
    });
  }
}

customElements.define(\\"form-input-component\\", FormInputComponent);
"
`;

exports[`webcomponent Section 1`] = `
"/**
 * Usage:
 *
 *  <section-component></section-component>
 *
 */
class SectionComponent extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {};
    this.props = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <section data-name=\\"section-1\\">
        <slot></slot>
      </section>
      <style></style>\`;
    this.render();

    this.onMount();
    this.onUpdate();
  }

  onMount() {}

  onUpdate() {}

  update() {
    this.render();
    this.onUpdate();
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-name='section-1']\\").forEach((el) => {
      Object.assign(
        el.style,
        this.props.maxWidth && typeof this.props.maxWidth === \\"number\\"
          ? {
              maxWidth: this.props.maxWidth,
            }
          : undefined
      );
    });
  }
}

customElements.define(\\"section-component\\", SectionComponent);
"
`;

exports[`webcomponent SectionState 1`] = `
"/**
 * Usage:
 *
 *  <section-state-component></section-state-component>
 *
 */
class SectionStateComponent extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = { max: 42, items: [42] };
    this.props = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <template data-name=\\"show\\">
        <span data-name=\\"for\\"></span>
        <template data-template-for=\\"for\\">
          <section data-name=\\"section-1\\">
            <slot></slot>
          </section>
        </template>
      </template>
      <style></style>\`;
    this.render();

    this.onMount();
    this.onUpdate();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    this.render();
    this.onUpdate();
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-name='show']\\").forEach((el) => {
      const whenCondition = this.state.max;
      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-name='for']\\").forEach((el) => {
      let array = this.state.items;
      let template = this._root.querySelector('[data-template-for=\\"for\\"]');
      this.renderLoop(el, array, template, \\"item\\", undefined, undefined);
    });

    this._root.querySelectorAll(\\"[data-name='section-1']\\").forEach((el) => {
      const item = this.getContext(el, \\"item\\");
      Object.assign(el.style, {
        maxWidth: item + this.state.max,
      });
    });
  }

  // Helper to render loops
  renderLoop(el, array, template, itemName, itemIndex, collectionName) {
    el.innerHTML = \\"\\";
    for (let [index, value] of array.entries()) {
      let tmp = document.createElement(\\"span\\");
      tmp.innerHTML = template.innerHTML;
      Array.from(tmp.children).forEach((child) => {
        if (itemName !== undefined) {
          child[\\"__\\" + itemName] = value;
        }
        if (itemIndex !== undefined) {
          child[\\"__\\" + itemIndex] = index;
        }
        if (collectionName !== undefined) {
          child[\\"__\\" + collectionName] = array;
        }
        el.appendChild(child);
      });
    }
  }

  getContext(el, name) {
    do {
      let value = el[\\"__\\" + name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }
}

customElements.define(\\"section-state-component\\", SectionStateComponent);
"
`;

exports[`webcomponent Select block 1`] = `
"import { Builder } from \\"@builder.io/sdk\\";

/**
 * Usage:
 *
 *  <select-component></select-component>
 *
 */
class SelectComponent extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {};
    this.props = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <select data-name=\\"select-1\\">
        <span data-name=\\"for\\"></span>
        <template data-template-for=\\"for\\">
          <option data-name=\\"option-1\\">
            <span data-name=\\"div-1\\"><!-- option.name || option.value --></span>
          </option>
        </template>
      </select>
      <style></style>\`;
    this.render();

    this.onMount();
    this.onUpdate();
  }

  onMount() {}

  onUpdate() {}

  update() {
    this.render();
    this.onUpdate();
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-name='select-1']\\").forEach((el) => {
      el.value = this.props.value;

      el.key =
        Builder.isEditing && this.props.defaultValue
          ? this.props.defaultValue
          : \\"default-key\\";

      el.defaultValue = this.props.defaultValue;

      el.name = this.props.name;
    });

    this._root.querySelectorAll(\\"[data-name='for']\\").forEach((el) => {
      let array = this.props.options;
      let template = this._root.querySelector('[data-template-for=\\"for\\"]');
      this.renderLoop(el, array, template, \\"option\\", \\"index\\", undefined);
    });

    this._root.querySelectorAll(\\"[data-name='option-1']\\").forEach((el) => {
      var option = this.getContext(el, \\"option\\");
      el.value = option.value;

      var index = this.getContext(el, \\"index\\");
      el.setAttribute(\\"data-index\\", index);
    });

    this._root.querySelectorAll(\\"[data-name='div-1']\\").forEach((el) => {
      const option = this.getContext(el, \\"option\\");
      el.innerText = option.name || option.value;
    });
  }

  // Helper to render loops
  renderLoop(el, array, template, itemName, itemIndex, collectionName) {
    el.innerHTML = \\"\\";
    for (let [index, value] of array.entries()) {
      let tmp = document.createElement(\\"span\\");
      tmp.innerHTML = template.innerHTML;
      Array.from(tmp.children).forEach((child) => {
        if (itemName !== undefined) {
          child[\\"__\\" + itemName] = value;
        }
        if (itemIndex !== undefined) {
          child[\\"__\\" + itemIndex] = index;
        }
        if (collectionName !== undefined) {
          child[\\"__\\" + collectionName] = array;
        }
        el.appendChild(child);
      });
    }
  }

  getContext(el, name) {
    do {
      let value = el[\\"__\\" + name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }
}

customElements.define(\\"select-component\\", SelectComponent);
"
`;

exports[`webcomponent Shadow DOM 1`] = `
"/**
 * Usage:
 *
 *  <smile-reviews></smile-reviews>
 *
 */
class SmileReviews extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = { reviews: [], name: \\"test\\", showReviewPrompt: false };
    this.props = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];

    // Event handler for 'click' event on button-1
    this.onButton1Click = (event) => {
      this.state.showReviewPrompt = true;
      this.update();
    };

    // Event handler for 'click' event on button-2
    this.onButton2Click = (event) => {
      this.state.showReviewPrompt = false;
      this.update();
    };

    if (true) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div data-name=\\"div-1\\">
        <button data-name=\\"button-1\\">Write a review</button>
      
        <template data-name=\\"show\\">
          <input placeholder=\\"Email\\" />
      
          <input placeholder=\\"Title\\" class=\\"input\\" />
      
          <textarea
            placeholder=\\"How was your experience?\\"
            class=\\"textarea\\"
          ></textarea>
      
          <button class=\\"button\\" data-name=\\"button-2\\">Submit</button>
        </template>
      
        <span data-name=\\"for\\"></span>
        <template data-template-for=\\"for\\">
          <div class=\\"review\\" data-name=\\"div-2\\">
            <img class=\\"img\\" data-name=\\"img-1\\" />
      
            <div data-name=\\"div-3\\">
              <div>
                N:
                <span data-name=\\"div-4\\"><!-- index --></span>
              </div>
      
              <div>
                <span data-name=\\"div-5\\"><!-- review.author --></span>
              </div>
      
              <div>
                <span data-name=\\"div-6\\"><!-- review.reviewMessage --></span>
              </div>
            </div>
          </div>
        </template>
      </div>
      <style>
        .input {
          display: block;
        }
        .textarea {
          display: block;
        }
        .button {
          display: block;
        }
        .review {
          margin: 10px;
          padding: 10px;
          background: white;
          display: flex;
          border-radius: 5px;
          box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .img {
          height: 30px;
          width: 30px;
          margin-right: 10px;
        }
      </style>\`;
    this.render();

    this.onMount();
    this.onUpdate();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {
    // onMount
    fetch(
      \`https://stamped.io/api/widget/reviews?storeUrl=builder-io.myshopify.com&apiKey=\${
        this.props.apiKey || \\"pubkey-8bbDq7W6w4sB3OWeM1HUy2s47702hM\\"
      }&productId=\${this.props.productId || \\"2410511106127\\"}\`
    )
      .then((res) => res.json())
      .then((data) => {
        this.state.reviews = data.data;
        this.update();
      });
  }

  onUpdate() {}

  update() {
    this.render();
    this.onUpdate();
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-name='div-1']\\").forEach((el) => {
      el.setAttribute(\\"data-user\\", this.state.name);
    });

    this._root.querySelectorAll(\\"[data-name='button-1']\\").forEach((el) => {
      el.removeEventListener(\\"click\\", this.onButton1Click);
      el.addEventListener(\\"click\\", this.onButton1Click);
    });

    this._root.querySelectorAll(\\"[data-name='show']\\").forEach((el) => {
      const whenCondition = this.state.showReviewPrompt;
      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-name='button-2']\\").forEach((el) => {
      el.removeEventListener(\\"click\\", this.onButton2Click);
      el.addEventListener(\\"click\\", this.onButton2Click);
    });

    this._root.querySelectorAll(\\"[data-name='for']\\").forEach((el) => {
      let array = this.state.reviews;
      let template = this._root.querySelector('[data-template-for=\\"for\\"]');
      this.renderLoop(el, array, template, \\"review\\", \\"index\\", undefined);
    });

    this._root.querySelectorAll(\\"[data-name='div-2']\\").forEach((el) => {
      var review = this.getContext(el, \\"review\\");
      el.key = review.id;
    });

    this._root.querySelectorAll(\\"[data-name='img-1']\\").forEach((el) => {
      var review = this.getContext(el, \\"review\\");
      el.src = review.avatar;
    });

    this._root.querySelectorAll(\\"[data-name='div-3']\\").forEach((el) => {
      el.className = this.state.showReviewPrompt
        ? \\"bg-primary\\"
        : \\"bg-secondary\\";
    });

    this._root.querySelectorAll(\\"[data-name='div-4']\\").forEach((el) => {
      const index = this.getContext(el, \\"index\\");
      el.innerText = index;
    });

    this._root.querySelectorAll(\\"[data-name='div-5']\\").forEach((el) => {
      const review = this.getContext(el, \\"review\\");
      el.innerText = review.author;
    });

    this._root.querySelectorAll(\\"[data-name='div-6']\\").forEach((el) => {
      const review = this.getContext(el, \\"review\\");
      el.innerText = review.reviewMessage;
    });
  }

  // Helper to render loops
  renderLoop(el, array, template, itemName, itemIndex, collectionName) {
    el.innerHTML = \\"\\";
    for (let [index, value] of array.entries()) {
      let tmp = document.createElement(\\"span\\");
      tmp.innerHTML = template.innerHTML;
      Array.from(tmp.children).forEach((child) => {
        if (itemName !== undefined) {
          child[\\"__\\" + itemName] = value;
        }
        if (itemIndex !== undefined) {
          child[\\"__\\" + itemIndex] = index;
        }
        if (collectionName !== undefined) {
          child[\\"__\\" + collectionName] = array;
        }
        el.appendChild(child);
      });
    }
  }

  getContext(el, name) {
    do {
      let value = el[\\"__\\" + name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }
}

customElements.define(\\"smile-reviews\\", SmileReviews);
"
`;

exports[`webcomponent Stamped 1`] = `
"import { kebabCase } from \\"lodash\\";
import { snakeCase } from \\"lodash\\";

/**
 * Usage:
 *
 *  <smile-reviews></smile-reviews>
 *
 */
class SmileReviews extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {
      reviews: [],
      name: \\"test\\",
      showReviewPrompt: false,
      kebabCaseValue() {
        return kebabCase(\\"testThat\\");
      },
      snakeCaseValue() {
        return snakeCase(\\"testThis\\");
      },
    };
    this.props = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];

    // Event handler for 'click' event on button-1
    this.onButton1Click = (event) => {
      this.state.showReviewPrompt = true;
      this.update();
    };

    // Event handler for 'click' event on button-2
    this.onButton2Click = (event) => {
      this.state.showReviewPrompt = false;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div data-name=\\"div-1\\">
        <button data-name=\\"button-1\\">Write a review</button>
      
        <template data-name=\\"show\\">
          <input placeholder=\\"Email\\" />
      
          <input placeholder=\\"Title\\" class=\\"input\\" />
      
          <textarea
            placeholder=\\"How was your experience?\\"
            class=\\"textarea\\"
          ></textarea>
      
          <button class=\\"button\\" data-name=\\"button-2\\">Submit</button>
        </template>
      
        <span data-name=\\"for\\"></span>
        <template data-template-for=\\"for\\">
          <div class=\\"review\\" data-name=\\"div-2\\">
            <img class=\\"img\\" data-name=\\"img-1\\" />
      
            <div data-name=\\"div-3\\">
              <div>
                N:
                <span data-name=\\"div-4\\"><!-- index --></span>
              </div>
      
              <div>
                <span data-name=\\"div-5\\"><!-- review.author --></span>
              </div>
      
              <div>
                <span data-name=\\"div-6\\"><!-- review.reviewMessage --></span>
              </div>
            </div>
          </div>
        </template>
      </div>
      <style>
        .input {
          display: block;
        }
        .textarea {
          display: block;
        }
        .button {
          display: block;
        }
        .review {
          margin: 10px;
          padding: 10px;
          background: white;
          display: flex;
          border-radius: 5px;
          box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .img {
          height: 30px;
          width: 30px;
          margin-right: 10px;
        }
      </style>\`;
    this.render();

    this.onMount();
    this.onUpdate();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {
    // onMount
    fetch(
      \`https://stamped.io/api/widget/reviews?storeUrl=builder-io.myshopify.com&apiKey=\${
        this.props.apiKey || \\"pubkey-8bbDq7W6w4sB3OWeM1HUy2s47702hM\\"
      }&productId=\${this.props.productId || \\"2410511106127\\"}\`
    )
      .then((res) => res.json())
      .then((data) => {
        this.state.reviews = data.data;
        this.update();
      });
  }

  onUpdate() {}

  update() {
    this.render();
    this.onUpdate();
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-name='div-1']\\").forEach((el) => {
      el.setAttribute(\\"data-user\\", this.state.name);
    });

    this._root.querySelectorAll(\\"[data-name='button-1']\\").forEach((el) => {
      el.removeEventListener(\\"click\\", this.onButton1Click);
      el.addEventListener(\\"click\\", this.onButton1Click);
    });

    this._root.querySelectorAll(\\"[data-name='show']\\").forEach((el) => {
      const whenCondition = this.state.showReviewPrompt;
      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-name='button-2']\\").forEach((el) => {
      el.removeEventListener(\\"click\\", this.onButton2Click);
      el.addEventListener(\\"click\\", this.onButton2Click);
    });

    this._root.querySelectorAll(\\"[data-name='for']\\").forEach((el) => {
      let array = this.state.reviews;
      let template = this._root.querySelector('[data-template-for=\\"for\\"]');
      this.renderLoop(el, array, template, \\"review\\", \\"index\\", undefined);
    });

    this._root.querySelectorAll(\\"[data-name='div-2']\\").forEach((el) => {
      var review = this.getContext(el, \\"review\\");
      el.key = review.id;
    });

    this._root.querySelectorAll(\\"[data-name='img-1']\\").forEach((el) => {
      var review = this.getContext(el, \\"review\\");
      el.src = review.avatar;
    });

    this._root.querySelectorAll(\\"[data-name='div-3']\\").forEach((el) => {
      el.className = this.state.showReviewPrompt
        ? \\"bg-primary\\"
        : \\"bg-secondary\\";
    });

    this._root.querySelectorAll(\\"[data-name='div-4']\\").forEach((el) => {
      const index = this.getContext(el, \\"index\\");
      el.innerText = index;
    });

    this._root.querySelectorAll(\\"[data-name='div-5']\\").forEach((el) => {
      const review = this.getContext(el, \\"review\\");
      el.innerText = review.author;
    });

    this._root.querySelectorAll(\\"[data-name='div-6']\\").forEach((el) => {
      const review = this.getContext(el, \\"review\\");
      el.innerText = review.reviewMessage;
    });
  }

  // Helper to render loops
  renderLoop(el, array, template, itemName, itemIndex, collectionName) {
    el.innerHTML = \\"\\";
    for (let [index, value] of array.entries()) {
      let tmp = document.createElement(\\"span\\");
      tmp.innerHTML = template.innerHTML;
      Array.from(tmp.children).forEach((child) => {
        if (itemName !== undefined) {
          child[\\"__\\" + itemName] = value;
        }
        if (itemIndex !== undefined) {
          child[\\"__\\" + itemIndex] = index;
        }
        if (collectionName !== undefined) {
          child[\\"__\\" + collectionName] = array;
        }
        el.appendChild(child);
      });
    }
  }

  getContext(el, name) {
    do {
      let value = el[\\"__\\" + name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }
}

customElements.define(\\"smile-reviews\\", SmileReviews);
"
`;

exports[`webcomponent Submit button block 1`] = `
"/**
 * Usage:
 *
 *  <submit-button></submit-button>
 *
 */
class SubmitButton extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {};
    this.props = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <button type=\\"submit\\" data-name=\\"button-1\\">
        <span data-name=\\"div-1\\"><!-- props.text --></span>
      </button>
      <style></style>\`;
    this.render();

    this.onMount();
    this.onUpdate();
  }

  onMount() {}

  onUpdate() {}

  update() {
    this.render();
    this.onUpdate();
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-name='div-1']\\").forEach((el) => {
      el.innerText = this.props.text;
    });
  }
}

customElements.define(\\"submit-button\\", SubmitButton);
"
`;

exports[`webcomponent Text 1`] = `
"import { Builder } from \\"@builder.io/sdk\\";

/**
 * Usage:
 *
 *  <text></text>
 *
 */
class Text extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {};
    this.props = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div data-name=\\"div-1\\"></div>
      <style></style>\`;
    this.render();

    this.onMount();
    this.onUpdate();
  }

  onMount() {}

  onUpdate() {}

  update() {
    this.render();
    this.onUpdate();
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-name='div-1']\\").forEach((el) => {
      el.contentEditable = allowEditingText || undefined;

      el.innerHTML = this.props.text || this.props.content || \\"\\";
    });
  }
}

customElements.define(\\"text\\", Text);
"
`;

exports[`webcomponent Textarea 1`] = `
"/**
 * Usage:
 *
 *  <textarea></textarea>
 *
 */
class Textarea extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {};
    this.props = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <textarea data-name=\\"textarea-1\\"></textarea>
      <style></style>\`;
    this.render();

    this.onMount();
    this.onUpdate();
  }

  onMount() {}

  onUpdate() {}

  update() {
    this.render();
    this.onUpdate();
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-name='textarea-1']\\").forEach((el) => {
      el.placeholder = this.props.placeholder;

      el.name = this.props.name;

      el.value = this.props.value;

      el.defaultValue = this.props.defaultValue;
    });
  }
}

customElements.define(\\"textarea\\", Textarea);
"
`;

exports[`webcomponent Video 1`] = `
"/**
 * Usage:
 *
 *  <video></video>
 *
 */
class Video extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {};
    this.props = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <video preload=\\"none\\" data-name=\\"video-1\\"></video>
      <style></style>\`;
    this.render();

    this.onMount();
    this.onUpdate();
  }

  onMount() {}

  onUpdate() {}

  update() {
    this.render();
    this.onUpdate();
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-name='video-1']\\").forEach((el) => {
      Object.assign(el.style, {
        width: \\"100%\\",
        height: \\"100%\\",
        ...this.props.attributes?.style,
        objectFit: this.props.fit,
        objectPosition: this.props.position,
        // Hack to get object fit to work as expected and
        // not have the video overflow
        borderRadius: 1,
      });

      el.key = this.props.video || \\"no-src\\";

      el.poster = this.props.posterImage;

      el.autoPlay = this.props.autoPlay;

      el.muted = this.props.muted;

      el.controls = this.props.controls;

      el.loop = this.props.loop;
    });
  }
}

customElements.define(\\"video\\", Video);
"
`;

exports[`webcomponent multipleOnUpdate 1`] = `
"
      
    
    
  
      /**
       * Usage:
       * 
       *  <multiple-on-update></multiple-on-update>
       * 
       */
      class MultipleOnUpdate extends HTMLElement {
        constructor() {
          super();
          const self = this;
          
          this.state = {};
          


          // used to keep track of all nodes created by show/for
          this.nodesToDestroy = [];
          

          

          if (undefined) {
            this.attachShadow({ mode: 'open' })
          }
        }


        

        destroyAnyNodes() {
          // destroy current view template refs before rendering again
          this.nodesToDestroy.forEach(el => el.remove());
          this.nodesToDestroy = [];
        }

        get _root() {
          return this.shadowRoot || this;
        }

        connectedCallback() {
          
              this._root.innerHTML = \`
      <div></div>
      <style></style>\`;
              this.render();
              
              this.onMount();
              this.onUpdate();
              
        }
        

        
        

        onMount() {
          
        }

        onUpdate() {
          
      
  console.log('Runs on every update/rerender');
,
  console.log('Runs on every update/rerender as well');
 
       
        }

        update() {
          
          this.render();
          this.onUpdate();
          
        }

        render() {
          // re-rendering needs to ensure that all nodes generated by for/show are refreshed
          this.destroyAnyNodes();
          this.updateBindings();
        }

        updateBindings() {
          
        }

        
      }

      customElements.define('multiple-on-update', MultipleOnUpdate);
    "
`;

exports[`webcomponent multipleOnnUpdateWithDeps 1`] = `
"
      
    
    
  
      /**
       * Usage:
       * 
       *  <multiple-on-update-with-deps></multiple-on-update-with-deps>
       * 
       */
      class MultipleOnUpdateWithDeps extends HTMLElement {
        constructor() {
          super();
          const self = this;
          
          this.state = { a: 'a', b: 'b', c: 'c', d: 'd',};
          


          // used to keep track of all nodes created by show/for
          this.nodesToDestroy = [];
          

          

          if (undefined) {
            this.attachShadow({ mode: 'open' })
          }
        }


        

        destroyAnyNodes() {
          // destroy current view template refs before rendering again
          this.nodesToDestroy.forEach(el => el.remove());
          this.nodesToDestroy = [];
        }

        get _root() {
          return this.shadowRoot || this;
        }

        connectedCallback() {
          
              this._root.innerHTML = \`
      <div></div>
      <style></style>\`;
              this.render();
              
              this.onMount();
              this.onUpdate();
              
        }
        

        
        

        onMount() {
          
        }

        onUpdate() {
          
      
  console.log('Runs when a or b changes', this.state.a, this.state.b);
,
  console.log('Runs when c or d changes', this.state.c, this.state.d);
 
       
        }

        update() {
          
          this.render();
          this.onUpdate();
          
        }

        render() {
          // re-rendering needs to ensure that all nodes generated by for/show are refreshed
          this.destroyAnyNodes();
          this.updateBindings();
        }

        updateBindings() {
          
        }

        
      }

      customElements.define('multiple-on-update-with-deps', MultipleOnUpdateWithDeps);
    "
`;

exports[`webcomponent onInit & onMount 1`] = `
"/**
 * Usage:
 *
 *  <on-init></on-init>
 *
 */
class OnInit extends HTMLElement {
  constructor() {
    super();
    const self = this;
    this.onInitOnce = false;
    this.state = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>
      <style></style>\`;
    this.render();
    this.onInit();
    this.onMount();
    this.onUpdate();
  }

  onInit() {
    if (!this.onInitOnce) {
      console.log(\\"onInit\\");

      this.onInitOnce = true;
    }
  }

  onMount() {
    // onMount
    console.log(\\"onMount\\");
  }

  onUpdate() {}

  update() {
    this.render();
    this.onUpdate();
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}
}

customElements.define(\\"on-init\\", OnInit);
"
`;

exports[`webcomponent onInit 1`] = `
"/**
 * Usage:
 *
 *  <on-init></on-init>
 *
 */
class OnInit extends HTMLElement {
  constructor() {
    super();
    const self = this;
    this.onInitOnce = false;
    this.state = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>
      <style></style>\`;
    this.render();
    this.onInit();
    this.onMount();
    this.onUpdate();
  }

  onInit() {
    if (!this.onInitOnce) {
      console.log(\\"Runs once every update/rerender\\");

      this.onInitOnce = true;
    }
  }

  onMount() {}

  onUpdate() {}

  update() {
    this.render();
    this.onUpdate();
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}
}

customElements.define(\\"on-init\\", OnInit);
"
`;

exports[`webcomponent onMount & onUnMount 1`] = `
"/**
 * Usage:
 *
 *  <comp></comp>
 *
 */
class Comp extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  disconnectedCallback() {
    // onUnMount
    console.log(\\"Runs on unMount\\");
    this.destroyAnyNodes(); // clean up nodes when component is destroyed
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>
      <style></style>\`;
    this.render();

    this.onMount();
    this.onUpdate();
  }

  onMount() {
    // onMount
    console.log(\\"Runs on mount\\");
  }

  onUpdate() {}

  update() {
    this.render();
    this.onUpdate();
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}
}

customElements.define(\\"comp\\", Comp);
"
`;

exports[`webcomponent onUpdate 1`] = `
"/**
 * Usage:
 *
 *  <on-update></on-update>
 *
 */
class OnUpdate extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>
      <style></style>\`;
    this.render();

    this.onMount();
    this.onUpdate();
  }

  onMount() {}

  onUpdate() {
    console.log(\\"Runs on every update/rerender\\");
  }

  update() {
    this.render();
    this.onUpdate();
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}
}

customElements.define(\\"on-update\\", OnUpdate);
"
`;

exports[`webcomponent onUpdateWithDeps 1`] = `
"/**
 * Usage:
 *
 *  <on-update-with-deps></on-update-with-deps>
 *
 */
class OnUpdateWithDeps extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = { a: \\"a\\", b: \\"b\\" };

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>
      <style></style>\`;
    this.render();

    this.onMount();
    this.onUpdate();
  }

  onMount() {}

  onUpdate() {
    console.log(\\"Runs when a or b changes\\", this.state.a, this.state.b);
  }

  update() {
    this.render();
    this.onUpdate();
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}
}

customElements.define(\\"on-update-with-deps\\", OnUpdateWithDeps);
"
`;
