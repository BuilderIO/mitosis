// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`webcomponent > Shadow DOM 1`] = `
"/**
 * Usage:
 *
 *  <smile-reviews></smile-reviews>
 *
 */
class SmileReviews extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { reviews: [], name: \\"test\\", showReviewPrompt: false };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"apiKey\\", \\"productId\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'click' event on button-smile-reviews-1
    this.onButtonSmileReviews1Click = (event) => {
      this.state.showReviewPrompt = true;
      this.update();
    };

    // Event handler for 'click' event on button-smile-reviews-2
    this.onButtonSmileReviews2Click = (event) => {
      this.state.showReviewPrompt = false;
      this.update();
    };

    if (true) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div data-el=\\"div-smile-reviews-1\\">
        <button data-el=\\"button-smile-reviews-1\\">Write a review</button>
        <template data-el=\\"show-smile-reviews\\">
          <input
            placeholder=\\"Email\\"
            data-dom-state=\\"SmileReviews-input-smile-reviews-1\\"
          />
          <input
            placeholder=\\"Title\\"
            class=\\"input-smile-reviews\\"
            data-dom-state=\\"SmileReviews-input-smile-reviews-2\\"
          />
          <textarea
            placeholder=\\"How was your experience?\\"
            class=\\"textarea-smile-reviews\\"
            data-dom-state=\\"SmileReviews-textarea-smile-reviews-1\\"
          ></textarea>
          <button class=\\"button-smile-reviews\\" data-el=\\"button-smile-reviews-2\\">
            Submit
          </button>
        </template>
      
        <template data-el=\\"for-smile-reviews\\">
          <div class=\\"review-smile-reviews\\" data-el=\\"div-smile-reviews-2\\">
            <img class=\\"img-smile-reviews\\" data-el=\\"img-smile-reviews-1\\" />
            <div data-el=\\"div-smile-reviews-3\\">
              <div>
                N:
                <template data-el=\\"div-smile-reviews-4\\"><!-- index --></template>
              </div>
              <div>
                <template data-el=\\"div-smile-reviews-5\\">
                  <!-- review.author -->
                </template>
              </div>
              <div>
                <template data-el=\\"div-smile-reviews-6\\">
                  <!-- review.reviewMessage -->
                </template>
              </div>
            </div>
          </div>
        </template>
      </div>
      <style>
        .input-smile-reviews {
          display: block;
        }
        .textarea-smile-reviews {
          display: block;
        }
        .button-smile-reviews {
          display: block;
        }
        .review-smile-reviews {
          margin: 10px;
          padding: 10px;
          background: white;
          display: flex;
          border-radius: 5px;
          box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .img-smile-reviews {
          height: 30px;
          width: 30px;
          margin-right: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {
    // onMount
    fetch(
      \`https://stamped.io/api/widget/reviews?storeUrl=builder-io.myshopify.com&apiKey=\${
        this.props.apiKey || \\"pubkey-8bbDq7W6w4sB3OWeM1HUy2s47702hM\\"
      }&productId=\${this.props.productId || \\"2410511106127\\"}\`
    )
      .then((res) => res.json())
      .then((data) => {
        this.state.reviews = data.data;
        this.update();
      });
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-1']\\")
      .forEach((el) => {
        el.setAttribute(\\"data-user\\", this.state.name);
      });

    this._root
      .querySelectorAll(\\"[data-el='button-smile-reviews-1']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onButtonSmileReviews1Click);
        el.addEventListener(\\"click\\", this.onButtonSmileReviews1Click);
      });

    this._root
      .querySelectorAll(\\"[data-el='show-smile-reviews']\\")
      .forEach((el) => {
        const whenCondition = this.state.showReviewPrompt;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='button-smile-reviews-2']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onButtonSmileReviews2Click);
        el.addEventListener(\\"click\\", this.onButtonSmileReviews2Click);
      });

    this._root
      .querySelectorAll(\\"[data-el='for-smile-reviews']\\")
      .forEach((el) => {
        let array = this.state.reviews;
        this.renderLoop(el, array, \\"review\\", \\"index\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-2']\\")
      .forEach((el) => {
        const review = this.getScope(el, \\"review\\");
        el.key = review.id;
      });

    this._root
      .querySelectorAll(\\"[data-el='img-smile-reviews-1']\\")
      .forEach((el) => {
        const review = this.getScope(el, \\"review\\");
        el.setAttribute(\\"src\\", review.avatar);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-3']\\")
      .forEach((el) => {
        el.className = this.state.showReviewPrompt
          ? \\"bg-primary\\"
          : \\"bg-secondary\\";
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-4']\\")
      .forEach((el) => {
        const index = this.getScope(el, \\"index\\");
        this.renderTextNode(el, index);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-5']\\")
      .forEach((el) => {
        const review = this.getScope(el, \\"review\\");
        this.renderTextNode(el, review.author);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-6']\\")
      .forEach((el) => {
        const review = this.getScope(el, \\"review\\");
        this.renderTextNode(el, review.reviewMessage);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"smile-reviews\\", SmileReviews);
"
`;

exports[`webcomponent > jsx > Javascript Test > AdvancedRef 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-ref-component></my-basic-ref-component>
 *
 */
class MyBasicRefComponent extends HTMLElement {
  get _inputRef() {
    return this._root.querySelector(
      \\"[data-ref='MyBasicRefComponent-inputRef']\\"
    );
  }

  get _inputNoArgRef() {
    return this._root.querySelector(
      \\"[data-ref='MyBasicRefComponent-inputNoArgRef']\\"
    );
  }

  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      name: \\"PatrickJS\\",
      onBlur: function onBlur() {
        // Maintain focus
        self._inputRef.focus();
      },
      lowerCaseName: function lowerCaseName() {
        return self.state.name.toLowerCase();
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"showInput\\"];

    this.updateDeps = [[self._inputRef, self._inputNoArgRef]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'blur' event on input-my-basic-ref-component-1
    this.onInputMyBasicRefComponent1Blur = (event) => {
      this.state.onBlur();
    };

    // Event handler for 'input' event on input-my-basic-ref-component-1
    this.onInputMyBasicRefComponent1Input = (event) => {
      this.state.name = event.target.value;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"show-my-basic-ref-component\\">
          <input
            class=\\"input-my-basic-ref-component\\"
            data-el=\\"input-my-basic-ref-component-1\\"
            data-dom-state=\\"MyBasicRefComponent-input-my-basic-ref-component-1\\"
            data-ref=\\"MyBasicRefComponent-inputRef\\"
          />
          <label
            for=\\"cars\\"
            data-el=\\"label-my-basic-ref-component-1\\"
            data-ref=\\"MyBasicRefComponent-inputNoArgRef\\"
          >
            Choose a car:
          </label>
          <select
            name=\\"cars\\"
            id=\\"cars\\"
            data-dom-state=\\"MyBasicRefComponent-select-my-basic-ref-component-1\\"
          >
            <option value=\\"supra\\">GR Supra</option>
            <option value=\\"86\\">GR 86</option>
          </select>
        </template>
      
        Hello
      
        <template data-el=\\"div-my-basic-ref-component-1\\">
          <!-- state.lowerCaseName() -->
        </template>
        ! I can run in React, Qwik, Vue, Solid, or Web Component!
      </div>
      <style>
        .input-my-basic-ref-component {
          color: red;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {
    const self = this;

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        console.log(\\"Received an update\\");
        self.updateDeps[0] = __next;
      }
    })(self.updateDeps[0], [self._inputRef, self._inputNoArgRef]);
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-my-basic-ref-component']\\")
      .forEach((el) => {
        const whenCondition = this.props.showInput;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-ref-component-1']\\")
      .forEach((el) => {
        el.value = this.state.name;
        el.removeEventListener(\\"blur\\", this.onInputMyBasicRefComponent1Blur);
        el.addEventListener(\\"blur\\", this.onInputMyBasicRefComponent1Blur);
        el.removeEventListener(\\"input\\", this.onInputMyBasicRefComponent1Input);
        el.addEventListener(\\"input\\", this.onInputMyBasicRefComponent1Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-ref-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.lowerCaseName());
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-ref-component\\", MyBasicRefComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > Basic 1`] = `
"export const DEFAULT_VALUES = {
  name: \\"Steve\\",
};

/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      name: \\"Steve\\",
      underscore_fn_name() {
        return \\"bar\\";
      },
      age: 1,
      sports: [\\"\\"],
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-basic-component-1
    this.onInputMyBasicComponent1Input = (myEvent) => {
      this.state.name = myEvent.target.value;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div class=\\"test div-my-basic-component\\">
        <input
          data-el=\\"input-my-basic-component-1\\"
          data-dom-state=\\"MyBasicComponent-input-my-basic-component-1\\"
        />
      
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>
      <style>
        .div-my-basic-component {
          padding: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-component-1']\\")
      .forEach((el) => {
        el.value = DEFAULT_VALUES.name || this.state.name;
        el.removeEventListener(\\"input\\", this.onInputMyBasicComponent1Input);
        el.addEventListener(\\"input\\", this.onInputMyBasicComponent1Input);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > Basic 2`] = `
"/**
 * Usage:
 *
 *  <my-basic-for-show-component></my-basic-for-show-component>
 *
 */
class MyBasicForShowComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-basic-for-show-component-1
    this.onInputMyBasicForShowComponent1Input = (event) => {
      const person = this.getScope(event.currentTarget, \\"person\\");

      this.state.name = event.target.value + \\" and \\" + person;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <template data-el=\\"for-my-basic-for-show-component\\">
          <template data-el=\\"show-my-basic-for-show-component\\">
            <input
              data-el=\\"input-my-basic-for-show-component-1\\"
              data-dom-state=\\"MyBasicForShowComponent-input-my-basic-for-show-component-1\\"
            />
      
            Hello
            <template data-el=\\"div-my-basic-for-show-component-1\\">
              <!-- person -->
            </template>
            ! I can run in Qwik, Web Component, React, Vue, Solid, or Liquid!
          </template>
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='for-my-basic-for-show-component']\\")
      .forEach((el) => {
        let array = this.state.names;
        this.renderLoop(el, array, \\"person\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='show-my-basic-for-show-component']\\")
      .forEach((el) => {
        const person = this.getScope(el, \\"person\\");
        const whenCondition = person === this.state.name;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-for-show-component-1']\\")
      .forEach((el) => {
        el.value = this.state.name;
        el.removeEventListener(
          \\"input\\",
          this.onInputMyBasicForShowComponent1Input
        );
        el.addEventListener(\\"input\\", this.onInputMyBasicForShowComponent1Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-for-show-component-1']\\")
      .forEach((el) => {
        const person = this.getScope(el, \\"person\\");
        this.renderTextNode(el, person);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"my-basic-for-show-component\\", MyBasicForShowComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > Basic Context 1`] = `
"import { Injector, MyService, createInjector } from \\"@dummy/injection-js\\";

/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;
    this.context = createInjector();

    this.onInitOnce = false;

    this.state = {
      name: \\"PatrickJS\\",
      onChange: function onChange() {
        const change = self.myService.method(\\"change\\");
        console.log(change);
      },
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-basic-component-1
    this.onInputMyBasicComponent1Input = (event) => {
      this.state.onChange;
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.myService = this.getContext(this._root, MyService);

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"div-my-basic-component-1\\">
          <!-- myService.method('hello') + state.name -->
        </template>
      
        Hello! I can run in React, Vue, Solid, or Liquid!
      
        <input
          data-el=\\"input-my-basic-component-1\\"
          data-dom-state=\\"MyBasicComponent-input-my-basic-component-1\\"
        />
      </div>\`;
    this.pendingUpdate = true;
    this.onInit();
    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onInit() {
    if (!this.onInitOnce) {
      const hi = this.myService.method(\\"hi\\");
      console.log(hi);
      this.onInitOnce = true;
    }
  }

  onMount() {
    // onMount
    const bye = this.myService.method(\\"hi\\");
    console.log(bye);
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(
          el,
          this.myService.method(\\"hello\\") + this.state.name
        );
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-component-1']\\")
      .forEach((el) => {
        el.removeEventListener(\\"input\\", this.onInputMyBasicComponent1Input);
        el.addEventListener(\\"input\\", this.onInputMyBasicComponent1Input);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // get Context Helper
  getContext(el, token) {
    do {
      let value;
      if (el?.context?.get) {
        value = el.context.get(token);
      } else if (el?.context?.[token]) {
        value = el.context[token];
      }
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > Basic OnMount Update 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-on-mount-update-component></my-basic-on-mount-update-component>
 *
 */
class MyBasicOnMountUpdateComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.onInitOnce = false;

    this.state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"bye\\", \\"hi\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        Hello
        <template data-el=\\"div-my-basic-on-mount-update-component-1\\">
          <!-- state.name -->
        </template>
      </div>\`;
    this.pendingUpdate = true;
    this.onInit();
    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onInit() {
    if (!this.onInitOnce) {
      this.state.name = \\"PatrickJS onInit\\" + this.props.hi;
      this.update();
      this.onInitOnce = true;
    }
  }

  onMount() {
    // onMount
    this.state.name = \\"PatrickJS onMount\\" + this.props.bye;
    this.update();
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-on-mount-update-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(
  \\"my-basic-on-mount-update-component\\",
  MyBasicOnMountUpdateComponent
);
"
`;

exports[`webcomponent > jsx > Javascript Test > Basic Outputs 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-outputs-component></my-basic-outputs-component>
 *
 */
class MyBasicOutputsComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\" };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"onMessage\\", \\"onEvent\\", \\"message\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    this.props.onMessage(this.state.name);
    this.props.onEvent(this.props.message);
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-outputs-component\\", MyBasicOutputsComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > Basic Outputs Meta 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-outputs-component></my-basic-outputs-component>
 *
 */
class MyBasicOutputsComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\" };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"onMessage\\", \\"onEvent\\", \\"message\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    this.props.onMessage(this.state.name);
    this.props.onEvent(this.props.message);
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-outputs-component\\", MyBasicOutputsComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > BasicAttribute 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <input
        autocapitalize=\\"on\\"
        autocomplete=\\"on\\"
        data-el=\\"input-my-component-1\\"
        data-dom-state=\\"MyComponent-input-my-component-1\\"
      />\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-my-component-1']\\")
      .forEach((el) => {
        el.setAttribute(\\"spellcheck\\", true);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > BasicBooleanAttribute 1`] = `
"import MyBooleanAttributeComponent from \\"./basic-boolean-attribute-component.raw\\";

/**
 * Usage:
 *
 *  <my-boolean-attribute></my-boolean-attribute>
 *
 */
class MyBooleanAttribute extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"children\\", \\"type\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"show-my-boolean-attribute\\">
          <slot></slot>
          <template data-el=\\"div-my-boolean-attribute-2\\">
            <!-- props.type -->
          </template>
        </template>
        <my-boolean-attribute-component
          data-el=\\"my-boolean-attribute-component-my-boolean-attribute\\"
        ></my-boolean-attribute-component>
        <my-boolean-attribute-component
          data-el=\\"my-boolean-attribute-component-my-boolean-attribute-2\\"
        ></my-boolean-attribute-component>
        <my-boolean-attribute-component
          data-el=\\"my-boolean-attribute-component-my-boolean-attribute-3\\"
        ></my-boolean-attribute-component>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-my-boolean-attribute']\\")
      .forEach((el) => {
        const whenCondition = this.props.children;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-boolean-attribute-2']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.type);
      });

    this._root
      .querySelectorAll(
        \\"[data-el='my-boolean-attribute-component-my-boolean-attribute']\\"
      )
      .forEach((el) => {
        el.setAttribute(\\"toggle\\", true);
        el.toggle = true;

        if (el.props) {
          el.props.toggle = true;

          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.toggle = true;
        }
      });

    this._root
      .querySelectorAll(
        \\"[data-el='my-boolean-attribute-component-my-boolean-attribute-2']\\"
      )
      .forEach((el) => {
        el.setAttribute(\\"toggle\\", true);
        el.toggle = true;

        if (el.props) {
          el.props.toggle = true;

          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.toggle = true;
        }
      });

    this._root
      .querySelectorAll(
        \\"[data-el='my-boolean-attribute-component-my-boolean-attribute-3']\\"
      )
      .forEach((el) => {
        el.setAttribute(\\"list\\", null);
        el.list = null;

        if (el.props) {
          el.props.list = null;

          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.list = null;
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-boolean-attribute\\", MyBooleanAttribute);
"
`;

exports[`webcomponent > jsx > Javascript Test > BasicChildComponent 1`] = `
"import MyBasicOnMountUpdateComponent from \\"./basic-onMount-update.raw\\";
import MyBasicComponent from \\"./basic.raw\\";

/**
 * Usage:
 *
 *  <my-basic-child-component></my-basic-child-component>
 *
 */
class MyBasicChildComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"Steve\\", dev: \\"PatrickJS\\" };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <my-basic-component
          data-el=\\"my-basic-component-my-basic-child-component\\"
        ></my-basic-component>
        <div>
          <my-basic-on-mount-update-component
            data-el=\\"my-basic-on-mount-update-component-my-basic-child-component\\"
          ></my-basic-on-mount-update-component>
        </div>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(
        \\"[data-el='my-basic-component-my-basic-child-component']\\"
      )
      .forEach((el) => {
        el.setAttribute(\\"id\\", this.state.dev);
      });

    this._root
      .querySelectorAll(
        \\"[data-el='my-basic-on-mount-update-component-my-basic-child-component']\\"
      )
      .forEach((el) => {
        el.setAttribute(\\"hi\\", this.state.name);
        el.hi = this.state.name;

        if (el.props) {
          el.props.hi = this.state.name;

          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.hi = this.state.name;
        }

        el.setAttribute(\\"bye\\", this.state.dev);
        el.bye = this.state.dev;

        if (el.props) {
          el.props.bye = this.state.dev;

          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.bye = this.state.dev;
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-child-component\\", MyBasicChildComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > BasicFor 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-for-component></my-basic-for-component>
 *
 */
class MyBasicForComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-basic-for-component-1
    this.onInputMyBasicForComponent1Input = (event) => {
      const person = this.getScope(event.currentTarget, \\"person\\");

      this.state.name = event.target.value + \\" and \\" + person;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <template data-el=\\"for-my-basic-for-component\\">
          <input
            data-el=\\"input-my-basic-for-component-1\\"
            data-dom-state=\\"MyBasicForComponent-input-my-basic-for-component-1\\"
          />
      
          Hello
          <template data-el=\\"div-my-basic-for-component-1\\"><!-- person --></template>
          ! I can run in Qwik, Web Component, React, Vue, Solid, or Liquid!
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    console.log(\\"onMount code\\");
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='for-my-basic-for-component']\\")
      .forEach((el) => {
        let array = this.state.names;
        this.renderLoop(el, array, \\"person\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-for-component-1']\\")
      .forEach((el) => {
        el.value = this.state.name;
        el.removeEventListener(\\"input\\", this.onInputMyBasicForComponent1Input);
        el.addEventListener(\\"input\\", this.onInputMyBasicForComponent1Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-for-component-1']\\")
      .forEach((el) => {
        const person = this.getScope(el, \\"person\\");
        this.renderTextNode(el, person);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"my-basic-for-component\\", MyBasicForComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > BasicRef 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-ref-component></my-basic-ref-component>
 *
 */
class MyBasicRefComponent extends HTMLElement {
  get _inputRef() {
    return this._root.querySelector(
      \\"[data-ref='MyBasicRefComponent-inputRef']\\"
    );
  }

  get _inputNoArgRef() {
    return this._root.querySelector(
      \\"[data-ref='MyBasicRefComponent-inputNoArgRef']\\"
    );
  }

  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      name: \\"PatrickJS\\",
      onBlur: function onBlur() {
        // Maintain focus
        self._inputRef.focus();
      },
      lowerCaseName: function lowerCaseName() {
        return self.state.name.toLowerCase();
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"showInput\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'blur' event on input-my-basic-ref-component-1
    this.onInputMyBasicRefComponent1Blur = (event) => {
      this.state.onBlur();
    };

    // Event handler for 'input' event on input-my-basic-ref-component-1
    this.onInputMyBasicRefComponent1Input = (event) => {
      this.state.name = event.target.value;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"show-my-basic-ref-component\\">
          <input
            class=\\"input-my-basic-ref-component\\"
            data-el=\\"input-my-basic-ref-component-1\\"
            data-dom-state=\\"MyBasicRefComponent-input-my-basic-ref-component-1\\"
            data-ref=\\"MyBasicRefComponent-inputRef\\"
          />
          <label
            for=\\"cars\\"
            data-el=\\"label-my-basic-ref-component-1\\"
            data-ref=\\"MyBasicRefComponent-inputNoArgRef\\"
          >
            Choose a car:
          </label>
          <select
            name=\\"cars\\"
            id=\\"cars\\"
            data-dom-state=\\"MyBasicRefComponent-select-my-basic-ref-component-1\\"
          >
            <option value=\\"supra\\">GR Supra</option>
            <option value=\\"86\\">GR 86</option>
          </select>
        </template>
      
        Hello
      
        <template data-el=\\"div-my-basic-ref-component-1\\">
          <!-- state.lowerCaseName() -->
        </template>
        ! I can run in React, Qwik, Vue, Solid, or Web Component!
      </div>
      <style>
        .input-my-basic-ref-component {
          color: red;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-my-basic-ref-component']\\")
      .forEach((el) => {
        const whenCondition = this.props.showInput;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-ref-component-1']\\")
      .forEach((el) => {
        el.value = this.state.name;
        el.removeEventListener(\\"blur\\", this.onInputMyBasicRefComponent1Blur);
        el.addEventListener(\\"blur\\", this.onInputMyBasicRefComponent1Blur);
        el.removeEventListener(\\"input\\", this.onInputMyBasicRefComponent1Input);
        el.addEventListener(\\"input\\", this.onInputMyBasicRefComponent1Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-ref-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.lowerCaseName());
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-ref-component\\", MyBasicRefComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > BasicRefAssignment 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-ref-assignment-component></my-basic-ref-assignment-component>
 *
 */
class MyBasicRefAssignmentComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      handlerClick: function handlerClick(event) {
        event.preventDefault();
        console.log(\\"current value\\", self._holdValueRef);
        self._holdValueRef = self._holdValueRef + \\"JS\\";
      },
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'click' event on button-my-basic-ref-assignment-component-1
    this.onButtonMyBasicRefAssignmentComponent1Click = (evt) => {
      this.state.handlerClick(evt);
    };

    this._holdValueRef = \\"Patrick\\";

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <button data-el=\\"button-my-basic-ref-assignment-component-1\\">Click</button>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(
        \\"[data-el='button-my-basic-ref-assignment-component-1']\\"
      )
      .forEach((el) => {
        el.removeEventListener(
          \\"click\\",
          this.onButtonMyBasicRefAssignmentComponent1Click
        );
        el.addEventListener(
          \\"click\\",
          this.onButtonMyBasicRefAssignmentComponent1Click
        );
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(
  \\"my-basic-ref-assignment-component\\",
  MyBasicRefAssignmentComponent
);
"
`;

exports[`webcomponent > jsx > Javascript Test > BasicRefPrevious 1`] = `
"export function usePrevious(value) {
  // The ref object is a generic container whose current property is mutable ...
  // ... and can hold any value, similar to an instance property on a class
  let ref = useRef(null); // Store current value in ref

  onUpdate(() => {
    ref = value;
  }, [value]); // Only re-run if value changes
  // Return previous value (happens before update in useEffect above)

  return ref;
}

/**
 * Usage:
 *
 *  <my-previous-component></my-previous-component>
 *
 */
class MyPreviousComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { count: 0 };
    if (!this.props) {
      this.props = {};
    }

    this.updateDeps = [[this.state.count]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'click' event on button-my-previous-component-1
    this.onButtonMyPreviousComponent1Click = (event) => {
      this.state.count += 1;
      this.update();
    };

    this._prevCount = state.count;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <h1>
          Now:
          <template data-el=\\"div-my-previous-component-1\\">
            <!-- state.count -->
          </template>
          , before:
          <template data-el=\\"div-my-previous-component-2\\">
            <!-- self._prevCount -->
          </template>
        </h1>
        <button data-el=\\"button-my-previous-component-1\\">Increment</button>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        self._prevCount = self.state.count;
        self.updateDeps[0] = __next;
      }
    })(self.updateDeps[0], [self.state.count]);
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-previous-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.count);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-previous-component-2']\\")
      .forEach((el) => {
        this.renderTextNode(el, self._prevCount);
      });

    this._root
      .querySelectorAll(\\"[data-el='button-my-previous-component-1']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onButtonMyPreviousComponent1Click);
        el.addEventListener(\\"click\\", this.onButtonMyPreviousComponent1Click);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-previous-component\\", MyPreviousComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > Button 1`] = `
"/**
 * Usage:
 *
 *  <button></button>
 *
 */
class Button extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"link\\", \\"attributes\\", \\"openLinkInNewTab\\", \\"text\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"show-button\\">
          <a data-el=\\"a-button-1\\">
            <template data-el=\\"div-button-1\\"><!-- props.text --></template>
          </a>
        </template>
        <template data-el=\\"show-button-2\\">
          <button type=\\"button\\" data-el=\\"button-button-1\\">
            <template data-el=\\"div-button-2\\"><!-- props.text --></template>
          </button>
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='show-button']\\").forEach((el) => {
      const whenCondition = this.props.link;

      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='a-button-1']\\").forEach((el) => {
      el.setAttribute(\\"href\\", this.props.link);
      el.setAttribute(
        \\"target\\",
        this.props.openLinkInNewTab ? \\"_blank\\" : undefined
      );
    });

    this._root.querySelectorAll(\\"[data-el='div-button-1']\\").forEach((el) => {
      this.renderTextNode(el, this.props.text);
    });

    this._root.querySelectorAll(\\"[data-el='show-button-2']\\").forEach((el) => {
      const whenCondition = !this.props.link;

      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='div-button-2']\\").forEach((el) => {
      this.renderTextNode(el, this.props.text);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"button\\", Button);
"
`;

exports[`webcomponent > jsx > Javascript Test > Columns 1`] = `
"/**
 * Usage:
 *
 *  <column></column>
 *
 */
class Column extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      getColumns() {
        return self.props.columns || [];
      },
      getGutterSize() {
        return typeof self.props.space === \\"number\\"
          ? self.props.space || 0
          : 20;
      },
      getWidth(index) {
        const columns = self.state.getColumns();
        return (columns[index] && columns[index].width) || 100 / columns.length;
      },
      getColumnCssWidth(index) {
        const columns = self.state.getColumns();
        const gutterSize = self.state.getGutterSize();
        const subtractWidth =
          (gutterSize * (columns.length - 1)) / columns.length;
        return \`calc(\${self.state.getWidth(index)}% - \${subtractWidth}px)\`;
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"columns\\", \\"space\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div class=\\"builder-columns div-column\\">
        <template data-el=\\"for-column\\">
          <div class=\\"builder-column div-column-2\\">
            <template data-el=\\"div-column-1\\"><!-- column.content --></template>
            <template data-el=\\"div-column-2\\"><!-- index --></template>
          </div>
        </template>
      </div>
      <style>
        .div-column {
          display: flex;
          flex-direction: column;
          align-items: stretch;
          line-height: normal;
        }
        @media (max-width: 999px) {
          .div-column {
            flex-direction: row;
          }
        }
        @media (max-width: 639px) {
          .div-column {
            flex-direction: row-reverse;
          }
        }
        .div-column-2 {
          flex-grow: 1;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='for-column']\\").forEach((el) => {
      let array = this.props.columns;
      this.renderLoop(el, array, \\"column\\", \\"index\\");
    });

    this._root.querySelectorAll(\\"[data-el='div-column-1']\\").forEach((el) => {
      const column = this.getScope(el, \\"column\\");
      this.renderTextNode(el, column.content);
    });

    this._root.querySelectorAll(\\"[data-el='div-column-2']\\").forEach((el) => {
      const index = this.getScope(el, \\"index\\");
      this.renderTextNode(el, index);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"column\\", Column);
"
`;

exports[`webcomponent > jsx > Javascript Test > ContentSlotHtml 1`] = `
"/**
 * Usage:
 *
 *  <content-slot-code></content-slot-code>
 *
 */
class ContentSlotCode extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"slotTesting\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <slot data-el=\\"slot-content-slot-code\\"></slot>
        <div><hr /></div>
        <div><slot></slot></div>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='slot-content-slot-code']\\")
      .forEach((el) => {
        el.setAttribute(\\"name\\", this.props.slotTesting);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"content-slot-code\\", ContentSlotCode);
"
`;

exports[`webcomponent > jsx > Javascript Test > ContentSlotJSX 1`] = `
"/**
 * Usage:
 *
 *  <content-slot-jsx-code></content-slot-jsx-code>
 *
 */
class ContentSlotJsxCode extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      name: \\"king\\",
      showContent: false,
      get cls() {
        return self.props.slotContent && self.props.children
          ? \`\${self.state.name}-content\`
          : \\"\\";
      },
      show() {
        self.props.slotContent ? 1 : \\"\\";
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"slotContent\\",
      \\"children\\",
      \\"slotReference\\",
      \\"attributes\\",
      \\"content\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'click' event on div-content-slot-jsx-code-1
    this.onDivContentSlotJsxCode1Click = (event) => {
      this.state.show();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"show-content-slot-jsx-code\\">
        <div data-el=\\"div-content-slot-jsx-code-1\\">
          <template data-el=\\"show-content-slot-jsx-code-2\\">
            <slot name=\\"content\\">
              <template data-el=\\"div-content-slot-jsx-code-2\\">
                <!-- props.content -->
              </template>
            </slot>
          </template>
          <div><hr /></div>
          <div><slot></slot></div>
        </div>
      </template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-content-slot-jsx-code']\\")
      .forEach((el) => {
        const whenCondition = this.props.slotReference;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='div-content-slot-jsx-code-1']\\")
      .forEach((el) => {
        el.setAttribute(\\"name\\", this.props.slotContent ? \\"name1\\" : \\"name2\\");
        el.setAttribute(\\"title\\", this.props.slotContent ? \\"title1\\" : \\"title2\\");
        el.removeEventListener(\\"click\\", this.onDivContentSlotJsxCode1Click);
        el.addEventListener(\\"click\\", this.onDivContentSlotJsxCode1Click);
        el.className = this.state.cls;
      });

    this._root
      .querySelectorAll(\\"[data-el='show-content-slot-jsx-code-2']\\")
      .forEach((el) => {
        const whenCondition = this.state.showContent && this.props.slotContent;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='div-content-slot-jsx-code-2']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.content);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"content-slot-jsx-code\\", ContentSlotJsxCode);
"
`;

exports[`webcomponent > jsx > Javascript Test > CustomCode 1`] = `
"/**
 * Usage:
 *
 *  <custom-code></custom-code>
 *
 */
class CustomCode extends HTMLElement {
  get _elem() {
    return this._root.querySelector(\\"[data-ref='CustomCode-elem']\\");
  }

  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      scriptsInserted: [],
      scriptsRun: [],
      findAndRunScripts() {
        // TODO: Move this function to standalone one in '@builder.io/utils'
        if (self._elem && typeof window !== \\"undefined\\") {
          /** @type {HTMLScriptElement[]} */
          const scripts = self._elem.getElementsByTagName(\\"script\\");

          for (let i = 0; i < scripts.length; i++) {
            const script = scripts[i];

            if (script.src) {
              if (self.state.scriptsInserted.includes(script.src)) {
                continue;
              }

              self.state.scriptsInserted.push(script.src);
              const newScript = document.createElement(\\"script\\");
              newScript.async = true;
              newScript.src = script.src;
              document.head.appendChild(newScript);
            } else if (
              !script.type ||
              [
                \\"text/javascript\\",
                \\"application/javascript\\",
                \\"application/ecmascript\\",
              ].includes(script.type)
            ) {
              if (self.state.scriptsRun.includes(script.innerText)) {
                continue;
              }

              try {
                self.state.scriptsRun.push(script.innerText);
                new Function(script.innerText)();
              } catch (error) {
                console.warn(\\"\`CustomCode\`: Error running script:\\", error);
              }
            }
          }
        }
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"replaceNodes\\", \\"code\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div data-el=\\"div-custom-code-1\\" data-ref=\\"CustomCode-elem\\"></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    this.state.findAndRunScripts();
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-custom-code-1']\\")
      .forEach((el) => {
        el.className =
          \\"builder-custom-code\\" +
          (this.props.replaceNodes ? \\" replace-nodes\\" : \\"\\");
        el.innerHTML = this.props.code;
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"custom-code\\", CustomCode);
"
`;

exports[`webcomponent > jsx > Javascript Test > Embed 1`] = `
"/**
 * Usage:
 *
 *  <custom-code></custom-code>
 *
 */
class CustomCode extends HTMLElement {
  get _elem() {
    return this._root.querySelector(\\"[data-ref='CustomCode-elem']\\");
  }

  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      scriptsInserted: [],
      scriptsRun: [],
      findAndRunScripts() {
        // TODO: Move this function to standalone one in '@builder.io/utils'
        if (self._elem && typeof window !== \\"undefined\\") {
          /** @type {HTMLScriptElement[]} */
          const scripts = self._elem.getElementsByTagName(\\"script\\");

          for (let i = 0; i < scripts.length; i++) {
            const script = scripts[i];

            if (script.src) {
              if (self.state.scriptsInserted.includes(script.src)) {
                continue;
              }

              self.state.scriptsInserted.push(script.src);
              const newScript = document.createElement(\\"script\\");
              newScript.async = true;
              newScript.src = script.src;
              document.head.appendChild(newScript);
            } else if (
              !script.type ||
              [
                \\"text/javascript\\",
                \\"application/javascript\\",
                \\"application/ecmascript\\",
              ].includes(script.type)
            ) {
              if (self.state.scriptsRun.includes(script.innerText)) {
                continue;
              }

              try {
                self.state.scriptsRun.push(script.innerText);
                new Function(script.innerText)();
              } catch (error) {
                console.warn(\\"\`CustomCode\`: Error running script:\\", error);
              }
            }
          }
        }
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"replaceNodes\\", \\"code\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div data-el=\\"div-custom-code-1\\" data-ref=\\"CustomCode-elem\\"></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    this.state.findAndRunScripts();
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-custom-code-1']\\")
      .forEach((el) => {
        el.className =
          \\"builder-custom-code\\" +
          (this.props.replaceNodes ? \\" replace-nodes\\" : \\"\\");
        el.innerHTML = this.props.code;
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"custom-code\\", CustomCode);
"
`;

exports[`webcomponent > jsx > Javascript Test > Image 1`] = `
"/**
 * Usage:
 *
 *  <image></image>
 *
 */
class Image extends HTMLElement {
  get _pictureRef() {
    return this._root.querySelector(\\"[data-ref='Image-pictureRef']\\");
  }

  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      scrollListener: null,
      imageLoaded: false,
      setLoaded() {
        self.state.imageLoaded = true;
        self.update();
      },
      useLazyLoading() {
        // TODO: Add more checks here, like testing for real web browsers
        return !!self.props.lazy && self.state.isBrowser();
      },
      isBrowser: function isBrowser() {
        return (
          typeof window !== \\"undefined\\" &&
          window.navigator.product != \\"ReactNative\\"
        );
      },
      load: false,
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"lazy\\",
      \\"altText\\",
      \\"_class\\",
      \\"image\\",
      \\"srcset\\",
      \\"sizes\\",
      \\"children\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'load' event on img-image-1
    this.onImgImage1Load = (event) => {
      this.state.setLoaded();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  disconnectedCallback() {
    // onUnMount
    if (this.state.scrollListener) {
      window.removeEventListener(\\"scroll\\", this.state.scrollListener);
    }
    this.destroyAnyNodes(); // clean up nodes when component is destroyed
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <picture data-el=\\"picture-image-1\\" data-ref=\\"Image-pictureRef\\">
          <template data-el=\\"show-image\\"><img data-el=\\"img-image-1\\" /></template>
          <source data-el=\\"source-image-1\\" />
        </picture>
        <slot></slot>
      </div>
      <style>
        .img-image {
          opacity: 1;
          transition: opacity 0.2s ease-in-out;
          object-fit: cover;
          object-position: center;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {
    // onMount
    if (this.state.useLazyLoading()) {
      // throttled scroll capture listener
      const listener = () => {
        if (self._pictureRef) {
          const rect = self._pictureRef.getBoundingClientRect();

          const buffer = window.innerHeight / 2;

          if (rect.top < window.innerHeight + buffer) {
            this.state.load = true;
            this.update();
            this.state.scrollListener = null;
            this.update();
            window.removeEventListener(\\"scroll\\", listener);
          }
        }
      };

      this.state.scrollListener = listener;
      this.update();
      window.addEventListener(\\"scroll\\", listener, {
        capture: true,
        passive: true,
      });
      listener();
    }
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='show-image']\\").forEach((el) => {
      const whenCondition = !this.state.useLazyLoading() || this.state.load;

      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='img-image-1']\\").forEach((el) => {
      el.setAttribute(\\"alt\\", this.props.altText);
      el.setAttribute(
        \\"aria-role\\",
        this.props.altText ? \\"presentation\\" : undefined
      );
      el.className =
        \\"builder-image\\" +
        (this.props._class ? \\" \\" + this.props._class : \\"\\") +
        \\" img-image\\";
      el.setAttribute(\\"src\\", this.props.image);
      el.removeEventListener(\\"load\\", this.onImgImage1Load);
      el.addEventListener(\\"load\\", this.onImgImage1Load);
      el.setAttribute(\\"srcset\\", this.props.srcset);
      el.setAttribute(\\"sizes\\", this.props.sizes);
    });

    this._root.querySelectorAll(\\"[data-el='source-image-1']\\").forEach((el) => {
      el.setAttribute(\\"srcset\\", this.props.srcset);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"image\\", Image);
"
`;

exports[`webcomponent > jsx > Javascript Test > Image State 1`] = `
"/**
 * Usage:
 *
 *  <img-state-component></img-state-component>
 *
 */
class ImgStateComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { canShow: true, images: [\\"http://example.com/qwik.png\\"] };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <template data-el=\\"for-img-state-component\\">
          <img class=\\"custom-class\\" data-el=\\"img-img-state-component-1\\" />
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='for-img-state-component']\\")
      .forEach((el) => {
        let array = this.state.images;
        this.renderLoop(el, array, \\"item\\", \\"itemIndex\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='img-img-state-component-1']\\")
      .forEach((el) => {
        const item = this.getScope(el, \\"item\\");
        const itemIndex = this.getScope(el, \\"itemIndex\\");
        el.setAttribute(\\"src\\", item);
        el.key = itemIndex;
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"img-state-component\\", ImgStateComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > Img 1`] = `
"import { Builder } from \\"@builder.io/sdk\\";

/**
 * Usage:
 *
 *  <img-component></img-component>
 *
 */
class ImgComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"backgroundSize\\",
      \\"backgroundPosition\\",
      \\"attributes\\",
      \\"imgSrc\\",
      \\"altText\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <img data-el=\\"img-img-component-1\\" />\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='img-img-component-1']\\")
      .forEach((el) => {
        Object.assign(el.style, {
          objectFit: this.props.backgroundSize || \\"cover\\",
          objectPosition: this.props.backgroundPosition || \\"center\\",
        });
        el.key = (Builder.isEditing && this.props.imgSrc) || \\"default-key\\";
        el.setAttribute(\\"alt\\", this.props.altText);
        el.setAttribute(\\"src\\", this.props.imgSrc);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"img-component\\", ImgComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > Input 1`] = `
"import { Builder } from \\"@builder.io/sdk\\";

/**
 * Usage:
 *
 *  <form-input-component></form-input-component>
 *
 */
class FormInputComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"attributes\\",
      \\"defaultValue\\",
      \\"placeholder\\",
      \\"type\\",
      \\"name\\",
      \\"value\\",
      \\"required\\",
      \\"onChange\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-form-input-component-1
    this.onInputFormInputComponent1Input = (event) => {
      this.props.onChange?.(event.target.value);
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <input
        data-el=\\"input-form-input-component-1\\"
        data-dom-state=\\"FormInputComponent-input-form-input-component-1\\"
      />\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-form-input-component-1']\\")
      .forEach((el) => {
        el.key =
          Builder.isEditing && this.props.defaultValue
            ? this.props.defaultValue
            : \\"default-key\\";
        el.setAttribute(\\"placeholder\\", this.props.placeholder);
        el.setAttribute(\\"type\\", this.props.type);
        el.setAttribute(\\"name\\", this.props.name);
        el.value = this.props.value;
        el.setAttribute(\\"defaultValue\\", this.props.defaultValue);
        el.setAttribute(\\"required\\", this.props.required);
        el.removeEventListener(\\"input\\", this.onInputFormInputComponent1Input);
        el.addEventListener(\\"input\\", this.onInputFormInputComponent1Input);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"form-input-component\\", FormInputComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > InputParent 1`] = `
"import FormInputComponent from \\"./input.raw\\";

/**
 * Usage:
 *
 *  <stepper></stepper>
 *
 */
class Stepper extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      handleChange(value) {
        console.log(value);
      },
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'change' event on form-input-component-stepper
    this.onFormInputComponentStepperChange = (value) => {
      this.state.handleChange(value);
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <form-input-component
        name=\\"kingzez\\"
        type=\\"text\\"
        data-el=\\"form-input-component-stepper\\"
      ></form-input-component>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='form-input-component-stepper']\\")
      .forEach((el) => {
        el.removeEventListener(
          \\"change\\",
          this.onFormInputComponentStepperChange
        );
        el.addEventListener(\\"change\\", this.onFormInputComponentStepperChange);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"stepper\\", Stepper);
"
`;

exports[`webcomponent > jsx > Javascript Test > RawText 1`] = `
"/**
 * Usage:
 *
 *  <raw-text></raw-text>
 *
 */
class RawText extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"attributes\\", \\"text\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <span data-el=\\"span-raw-text-1\\"></span>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='span-raw-text-1']\\").forEach((el) => {
      el.className =
        this.props.attributes?.class || this.props.attributes?.className;
      el.innerHTML = this.props.text || \\"\\";
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"raw-text\\", RawText);
"
`;

exports[`webcomponent > jsx > Javascript Test > Section 1`] = `
"/**
 * Usage:
 *
 *  <section-component></section-component>
 *
 */
class SectionComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"attributes\\", \\"maxWidth\\", \\"children\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <section data-el=\\"section-section-component-1\\"><slot></slot></section>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='section-section-component-1']\\")
      .forEach((el) => {
        Object.assign(
          el.style,
          this.props.maxWidth && typeof this.props.maxWidth === \\"number\\"
            ? {
                maxWidth: this.props.maxWidth,
              }
            : undefined
        );
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"section-component\\", SectionComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > Section 2`] = `
"/**
 * Usage:
 *
 *  <section-state-component></section-state-component>
 *
 */
class SectionStateComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { max: 42, items: [42] };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"attributes\\", \\"children\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"show-section-state-component\\">
        <template data-el=\\"for-section-state-component\\">
          <section data-el=\\"section-section-state-component-1\\"><slot></slot></section>
        </template>
      </template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-section-state-component']\\")
      .forEach((el) => {
        const whenCondition = this.state.max;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='for-section-state-component']\\")
      .forEach((el) => {
        let array = this.state.items;
        this.renderLoop(el, array, \\"item\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='section-section-state-component-1']\\")
      .forEach((el) => {
        const item = this.getScope(el, \\"item\\");
        Object.assign(el.style, {
          maxWidth: item + this.state.max,
        });
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"section-state-component\\", SectionStateComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > Select 1`] = `
"import { Builder } from \\"@builder.io/sdk\\";

/**
 * Usage:
 *
 *  <select-component></select-component>
 *
 */
class SelectComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"attributes\\",
      \\"value\\",
      \\"defaultValue\\",
      \\"name\\",
      \\"options\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <select
        data-el=\\"select-select-component-1\\"
        data-dom-state=\\"SelectComponent-select-select-component-1\\"
      >
        <template data-el=\\"for-select-component\\">
          <option data-el=\\"option-select-component-1\\">
            <template data-el=\\"div-select-component-1\\">
              <!-- option.name || option.value -->
            </template>
          </option>
        </template>
      </select>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='select-select-component-1']\\")
      .forEach((el) => {
        el.value = this.props.value;
        el.key =
          Builder.isEditing && this.props.defaultValue
            ? this.props.defaultValue
            : \\"default-key\\";
        el.setAttribute(\\"defaultValue\\", this.props.defaultValue);
        el.setAttribute(\\"name\\", this.props.name);
      });

    this._root
      .querySelectorAll(\\"[data-el='for-select-component']\\")
      .forEach((el) => {
        let array = this.props.options;
        this.renderLoop(el, array, \\"option\\", \\"index\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='option-select-component-1']\\")
      .forEach((el) => {
        const option = this.getScope(el, \\"option\\");
        const index = this.getScope(el, \\"index\\");
        el.value = option.value;
        el.setAttribute(\\"data-index\\", index);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-select-component-1']\\")
      .forEach((el) => {
        const option = this.getScope(el, \\"option\\");
        this.renderTextNode(el, option.name || option.value);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"select-component\\", SelectComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > SlotDefault 1`] = `
"/**
 * Usage:
 *
 *  <slot-code></slot-code>
 *
 */
class SlotCode extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <slot><div class=\\"default-slot\\">Default content</div></slot>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"slot-code\\", SlotCode);
"
`;

exports[`webcomponent > jsx > Javascript Test > SlotHtml 1`] = `
"import ContentSlotCode from \\"./content-slot-jsx.raw\\";

/**
 * Usage:
 *
 *  <slot-code></slot-code>
 *
 */
class SlotCode extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <content-slot-code><slot data-el=\\"slot-slot-code\\"></slot></content-slot-code>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='slot-slot-code']\\").forEach((el) => {
      el.setAttribute(\\"testing\\", <div>Hello</div>);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"slot-code\\", SlotCode);
"
`;

exports[`webcomponent > jsx > Javascript Test > SlotJsx 1`] = `
"import ContentSlotCode from \\"./content-slot-jsx.raw\\";

/**
 * Usage:
 *
 *  <slot-code></slot-code>
 *
 */
class SlotCode extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <content-slot-code data-el=\\"content-slot-code-slot-code\\"></content-slot-code>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='content-slot-code-slot-code']\\")
      .forEach((el) => {
        el.setAttribute(\\"slotTesting\\", <div>Hello</div>);
        el.slotTesting = <div>Hello</div>;

        if (el.props) {
          el.props.slotTesting = <div>Hello</div>;

          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.slotTesting = <div>Hello</div>;
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"slot-code\\", SlotCode);
"
`;

exports[`webcomponent > jsx > Javascript Test > SlotNamed 1`] = `
"/**
 * Usage:
 *
 *  <slot-code></slot-code>
 *
 */
class SlotCode extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <slot name=\\"myAwesomeSlot\\"></slot>
        <slot name=\\"top\\"></slot>
        <slot name=\\"left\\">Default left</slot>
        <slot>Default Child</slot>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"slot-code\\", SlotCode);
"
`;

exports[`webcomponent > jsx > Javascript Test > Stamped.io 1`] = `
"import { kebabCase, snakeCase } from \\"lodash\\";

/**
 * Usage:
 *
 *  <smile-reviews></smile-reviews>
 *
 */
class SmileReviews extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      reviews: [],
      name: \\"test\\",
      showReviewPrompt: false,
      kebabCaseValue() {
        return kebabCase(\\"testThat\\");
      },
      snakeCaseValue() {
        return snakeCase(\\"testThis\\");
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"apiKey\\", \\"productId\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'click' event on button-smile-reviews-1
    this.onButtonSmileReviews1Click = (event) => {
      this.state.showReviewPrompt = true;
      this.update();
    };

    // Event handler for 'click' event on button-smile-reviews-2
    this.onButtonSmileReviews2Click = (event) => {
      event.preventDefault();
      this.state.showReviewPrompt = false;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div data-el=\\"div-smile-reviews-1\\">
        <button data-el=\\"button-smile-reviews-1\\">Write a review</button>
        <template data-el=\\"show-smile-reviews\\">
          <input
            placeholder=\\"Email\\"
            data-dom-state=\\"SmileReviews-input-smile-reviews-1\\"
          />
          <input
            placeholder=\\"Title\\"
            class=\\"input-smile-reviews\\"
            data-dom-state=\\"SmileReviews-input-smile-reviews-2\\"
          />
          <textarea
            placeholder=\\"How was your experience?\\"
            class=\\"textarea-smile-reviews\\"
            data-dom-state=\\"SmileReviews-textarea-smile-reviews-1\\"
          ></textarea>
          <button class=\\"button-smile-reviews\\" data-el=\\"button-smile-reviews-2\\">
            Submit
          </button>
        </template>
      
        <template data-el=\\"for-smile-reviews\\">
          <div class=\\"review-smile-reviews\\" data-el=\\"div-smile-reviews-2\\">
            <img class=\\"img-smile-reviews\\" data-el=\\"img-smile-reviews-1\\" />
            <div data-el=\\"div-smile-reviews-3\\">
              <div>
                N:
                <template data-el=\\"div-smile-reviews-4\\"><!-- index --></template>
              </div>
              <div>
                <template data-el=\\"div-smile-reviews-5\\">
                  <!-- review.author -->
                </template>
              </div>
              <div>
                <template data-el=\\"div-smile-reviews-6\\">
                  <!-- review.reviewMessage -->
                </template>
              </div>
            </div>
          </div>
        </template>
      </div>
      <style>
        .input-smile-reviews {
          display: block;
        }
        .textarea-smile-reviews {
          display: block;
        }
        .button-smile-reviews {
          display: block;
        }
        .review-smile-reviews {
          margin: 10px;
          padding: 10px;
          background: white;
          display: flex;
          border-radius: 5px;
          box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
          -webkit-font-smoothing: antialiased;
        }
        .img-smile-reviews {
          height: 30px;
          width: 30px;
          margin-right: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {
    // onMount
    fetch(
      \`https://stamped.io/api/widget/reviews?storeUrl=builder-io.myshopify.com&apiKey=\${
        this.props.apiKey || \\"pubkey-8bbDq7W6w4sB3OWeM1HUy2s47702hM\\"
      }&productId=\${this.props.productId || \\"2410511106127\\"}\`
    )
      .then((res) => res.json())
      .then((data) => {
        this.state.reviews = data.data;
        this.update();
      });
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-1']\\")
      .forEach((el) => {
        el.setAttribute(\\"data-user\\", this.state.name);
      });

    this._root
      .querySelectorAll(\\"[data-el='button-smile-reviews-1']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onButtonSmileReviews1Click);
        el.addEventListener(\\"click\\", this.onButtonSmileReviews1Click);
      });

    this._root
      .querySelectorAll(\\"[data-el='show-smile-reviews']\\")
      .forEach((el) => {
        const whenCondition = this.state.showReviewPrompt || \\"asdf\\";

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='button-smile-reviews-2']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onButtonSmileReviews2Click);
        el.addEventListener(\\"click\\", this.onButtonSmileReviews2Click);
      });

    this._root
      .querySelectorAll(\\"[data-el='for-smile-reviews']\\")
      .forEach((el) => {
        let array = this.state.reviews;
        this.renderLoop(el, array, \\"review\\", \\"index\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-2']\\")
      .forEach((el) => {
        const review = this.getScope(el, \\"review\\");
        el.key = review.id;
      });

    this._root
      .querySelectorAll(\\"[data-el='img-smile-reviews-1']\\")
      .forEach((el) => {
        const review = this.getScope(el, \\"review\\");
        el.setAttribute(\\"src\\", review.avatar);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-3']\\")
      .forEach((el) => {
        el.className = this.state.showReviewPrompt
          ? \\"bg-primary\\"
          : \\"bg-secondary\\";
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-4']\\")
      .forEach((el) => {
        const index = this.getScope(el, \\"index\\");
        this.renderTextNode(el, index);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-5']\\")
      .forEach((el) => {
        const review = this.getScope(el, \\"review\\");
        this.renderTextNode(el, review.author);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-6']\\")
      .forEach((el) => {
        const review = this.getScope(el, \\"review\\");
        this.renderTextNode(el, review.reviewMessage);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"smile-reviews\\", SmileReviews);
"
`;

exports[`webcomponent > jsx > Javascript Test > Submit 1`] = `
"/**
 * Usage:
 *
 *  <submit-button></submit-button>
 *
 */
class SubmitButton extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"attributes\\", \\"text\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <button type=\\"submit\\" data-el=\\"button-submit-button-1\\">
        <template data-el=\\"div-submit-button-1\\"><!-- props.text --></template>
      </button>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-submit-button-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.text);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"submit-button\\", SubmitButton);
"
`;

exports[`webcomponent > jsx > Javascript Test > Text 1`] = `
"import { Builder } from \\"@builder.io/sdk\\";

/**
 * Usage:
 *
 *  <text></text>
 *
 */
class Text extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"Decadef20\\" };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"text\\", \\"content\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div data-el=\\"div-text-1\\"></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='div-text-1']\\").forEach((el) => {
      el.setAttribute(\\"contentEditable\\", allowEditingText || undefined);
      el.setAttribute(\\"data-name\\", {
        test: this.state.name || \\"any name\\",
      });
      el.innerHTML =
        this.props.text ||
        this.props.content ||
        this.state.name ||
        '<p class=\\"text-lg\\">my name</p>';
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"text\\", Text);
"
`;

exports[`webcomponent > jsx > Javascript Test > Textarea 1`] = `
"/**
 * Usage:
 *
 *  <textarea></textarea>
 *
 */
class Textarea extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"attributes\\",
      \\"placeholder\\",
      \\"name\\",
      \\"value\\",
      \\"defaultValue\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <textarea
        data-el=\\"textarea-textarea-1\\"
        data-dom-state=\\"Textarea-textarea-textarea-1\\"
      ></textarea>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='textarea-textarea-1']\\")
      .forEach((el) => {
        el.setAttribute(\\"placeholder\\", this.props.placeholder);
        el.setAttribute(\\"name\\", this.props.name);
        el.value = this.props.value;
        el.setAttribute(\\"defaultValue\\", this.props.defaultValue);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"textarea\\", Textarea);
"
`;

exports[`webcomponent > jsx > Javascript Test > Video 1`] = `
"/**
 * Usage:
 *
 *  <video></video>
 *
 */
class Video extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"attributes\\",
      \\"fit\\",
      \\"position\\",
      \\"video\\",
      \\"posterImage\\",
      \\"autoPlay\\",
      \\"muted\\",
      \\"controls\\",
      \\"loop\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <video preload=\\"none\\" data-el=\\"video-video-1\\"></video>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='video-video-1']\\").forEach((el) => {
      Object.assign(el.style, {
        width: \\"100%\\",
        height: \\"100%\\",
        ...this.props.attributes?.style,
        objectFit: this.props.fit,
        objectPosition: this.props.position,
        // Hack to get object fit to work as expected and
        // not have the video overflow
        borderRadius: 1,
      });
      el.key = this.props.video || \\"no-src\\";
      el.setAttribute(\\"poster\\", this.props.posterImage);
      el.setAttribute(\\"autoplay\\", this.props.autoPlay);
      el.setAttribute(\\"muted\\", this.props.muted);
      el.setAttribute(\\"controls\\", this.props.controls);
      el.setAttribute(\\"loop\\", this.props.loop);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"video\\", Video);
"
`;

exports[`webcomponent > jsx > Javascript Test > arrowFunctionInUseStore 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      name: \\"steve\\",
      setName(value) {
        self.state.name = value;
        self.update();
      },
      updateNameWithArrowFn(value) {
        self.state.name = value;
        self.update();
      },
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        Hello
        <template data-el=\\"div-my-component-1\\"><!-- state.name --></template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > basicForNoTagReference 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-for-no-tag-ref-component></my-basic-for-no-tag-ref-component>
 *
 */
class MyBasicForNoTagRefComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      name: \\"VincentW\\",
      TagName: \\"div\\",
      tag: \\"span\\",
      get TagNameGetter() {
        return \\"span\\";
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"actions\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <state.TagNameGetter>
        Hello
        <state.tag>
          <template data-el=\\"div-my-basic-for-no-tag-ref-component-1\\">
            <!-- state.name -->
          </template>
        </state.tag>
      
        <template data-el=\\"for-my-basic-for-no-tag-ref-component\\">
          <state.TagName>
            <action.icon></action.icon>
            <span>
              <template data-el=\\"div-my-basic-for-no-tag-ref-component-2\\">
                <!-- action.text -->
              </template>
            </span>
          </state.TagName>
        </template>
      </state.TagNameGetter>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-for-no-tag-ref-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.name);
      });

    this._root
      .querySelectorAll(\\"[data-el='for-my-basic-for-no-tag-ref-component']\\")
      .forEach((el) => {
        let array = this.props.actions;
        this.renderLoop(el, array, \\"action\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-for-no-tag-ref-component-2']\\")
      .forEach((el) => {
        const action = this.getScope(el, \\"action\\");
        this.renderTextNode(el, action.text);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(
  \\"my-basic-for-no-tag-ref-component\\",
  MyBasicForNoTagRefComponent
);
"
`;

exports[`webcomponent > jsx > Javascript Test > basicForwardRef 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-forward-ref-component></my-basic-forward-ref-component>
 *
 */
class MyBasicForwardRefComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\" };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-basic-forward-ref-component-1
    this.onInputMyBasicForwardRefComponent1Input = (event) => {
      this.state.name = event.target.value;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <input
          class=\\"input-my-basic-forward-ref-component\\"
          data-el=\\"input-my-basic-forward-ref-component-1\\"
          data-dom-state=\\"MyBasicForwardRefComponent-input-my-basic-forward-ref-component-1\\"
        />
      </div>
      <style>
        .input-my-basic-forward-ref-component {
          color: red;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-forward-ref-component-1']\\")
      .forEach((el) => {
        el.value = this.state.name;
        el.removeEventListener(
          \\"input\\",
          this.onInputMyBasicForwardRefComponent1Input
        );
        el.addEventListener(
          \\"input\\",
          this.onInputMyBasicForwardRefComponent1Input
        );
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(
  \\"my-basic-forward-ref-component\\",
  MyBasicForwardRefComponent
);
"
`;

exports[`webcomponent > jsx > Javascript Test > basicForwardRefMetadata 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-forward-ref-component></my-basic-forward-ref-component>
 *
 */
class MyBasicForwardRefComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\" };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-basic-forward-ref-component-1
    this.onInputMyBasicForwardRefComponent1Input = (event) => {
      this.state.name = event.target.value;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <input
          class=\\"input-my-basic-forward-ref-component\\"
          data-el=\\"input-my-basic-forward-ref-component-1\\"
          data-dom-state=\\"MyBasicForwardRefComponent-input-my-basic-forward-ref-component-1\\"
        />
      </div>
      <style>
        .input-my-basic-forward-ref-component {
          color: red;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-forward-ref-component-1']\\")
      .forEach((el) => {
        el.value = this.state.name;
        el.removeEventListener(
          \\"input\\",
          this.onInputMyBasicForwardRefComponent1Input
        );
        el.addEventListener(
          \\"input\\",
          this.onInputMyBasicForwardRefComponent1Input
        );
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(
  \\"my-basic-forward-ref-component\\",
  MyBasicForwardRefComponent
);
"
`;

exports[`webcomponent > jsx > Javascript Test > basicOnUpdateReturn 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-on-update-return-component></my-basic-on-update-return-component>
 *
 */
class MyBasicOnUpdateReturnComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\" };
    if (!this.props) {
      this.props = {};
    }

    this.updateDeps = [[this.state.name]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        Hello!
        <template data-el=\\"div-my-basic-on-update-return-component-1\\">
          <!-- state.name -->
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        const controller = new AbortController();
        const signal = controller.signal;
        fetch(\\"https://patrickjs.com/api/resource.json\\", {
          signal,
        })
          .then((response) => response.json())
          .then((data) => {
            self.state.name = data.name;
          });
        return () => {
          if (!signal.aborted) {
            controller.abort();
          }
        };
        self.updateDeps[0] = __next;
      }
    })(self.updateDeps[0], [self.state.name]);
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-on-update-return-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(
  \\"my-basic-on-update-return-component\\",
  MyBasicOnUpdateReturnComponent
);
"
`;

exports[`webcomponent > jsx > Javascript Test > class + ClassName + css 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div class=\\"test2 test div-my-basic-component\\">
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>
      <style>
        .div-my-basic-component {
          padding: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > class + css 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div class=\\"test div-my-basic-component\\">
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>
      <style>
        .div-my-basic-component {
          padding: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > className + css 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div class=\\"test div-my-basic-component\\">
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>
      <style>
        .div-my-basic-component {
          padding: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > className 1`] = `
"/**
 * Usage:
 *
 *  <class-name-code></class-name-code>
 *
 */
class ClassNameCode extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { bindings: \\"a binding\\" };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <div class=\\"no binding\\">Without Binding</div>
        <div data-el=\\"div-class-name-code-1\\">With binding</div>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-class-name-code-1']\\")
      .forEach((el) => {
        el.className = this.state.bindings;
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"class-name-code\\", ClassNameCode);
"
`;

exports[`webcomponent > jsx > Javascript Test > classState 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      classState: \\"testClassName\\",
      styleState: {
        color: \\"red\\",
      },
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div data-el=\\"div-my-basic-component-1\\">
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>
      <style>
        .div-my-basic-component {
          padding: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-1']\\")
      .forEach((el) => {
        el.className = this.state.classState + \\" div-my-basic-component\\";
        Object.assign(el.style, this.state.styleState);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > componentWithContext 1`] = `
"import Context1 from \\"@dummy/1\\";
import Context2 from \\"@dummy/2\\";

/**
 * Usage:
 *
 *  <component-with-context></component-with-context>
 *
 */
class ComponentWithContext extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"content\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.foo = this.getContext(this._root, Context1);

    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"div-component-with-context-1\\"><!-- foo.value --></template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-component-with-context-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.foo.value);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // get Context Helper
  getContext(el, token) {
    do {
      let value;
      if (el?.context?.get) {
        value = el.context.get(token);
      } else if (el?.context?.[token]) {
        value = el.context[token];
      }
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }
}

customElements.define(\\"component-with-context\\", ComponentWithContext);
"
`;

exports[`webcomponent > jsx > Javascript Test > componentWithContextMultiRoot 1`] = `
"import Context1 from \\"@dummy/1\\";
import Context2 from \\"@dummy/2\\";

/**
 * Usage:
 *
 *  <component-with-context></component-with-context>
 *
 */
class ComponentWithContext extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"content\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.foo = this.getContext(this._root, Context1);

    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"div-component-with-context-1\\"><!-- foo.value --></template>
      <div>other</div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-component-with-context-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.foo.value);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // get Context Helper
  getContext(el, token) {
    do {
      let value;
      if (el?.context?.get) {
        value = el.context.get(token);
      } else if (el?.context?.[token]) {
        value = el.context[token];
      }
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }
}

customElements.define(\\"component-with-context\\", ComponentWithContext);
"
`;

exports[`webcomponent > jsx > Javascript Test > contentState 1`] = `
"import BuilderContext from \\"@dummy/context.js\\";

/**
 * Usage:
 *
 *  <render-content></render-content>
 *
 */
class RenderContent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"content\\", \\"customComponents\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>setting context</div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"render-content\\", RenderContent);
"
`;

exports[`webcomponent > jsx > Javascript Test > defaultProps 1`] = `
"/**
 * Usage:
 *
 *  <button></button>
 *
 */
class Button extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"link\\",
      \\"attributes\\",
      \\"openLinkInNewTab\\",
      \\"text\\",
      \\"onClick\\",
      \\"buttonText\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'click' event on button-button-1
    this.onButtonButton1Click = (event) => {
      this.props.onClick(event);
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"show-button\\">
          <a data-el=\\"a-button-1\\">
            <template data-el=\\"div-button-1\\"><!-- props.text --></template>
          </a>
        </template>
        <template data-el=\\"show-button-2\\">
          <button type=\\"button\\" data-el=\\"button-button-1\\">
            <template data-el=\\"div-button-2\\"><!-- props.buttonText --></template>
          </button>
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='show-button']\\").forEach((el) => {
      const whenCondition = this.props.link;

      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='a-button-1']\\").forEach((el) => {
      el.setAttribute(\\"href\\", this.props.link);
      el.setAttribute(
        \\"target\\",
        this.props.openLinkInNewTab ? \\"_blank\\" : undefined
      );
    });

    this._root.querySelectorAll(\\"[data-el='div-button-1']\\").forEach((el) => {
      this.renderTextNode(el, this.props.text);
    });

    this._root.querySelectorAll(\\"[data-el='show-button-2']\\").forEach((el) => {
      const whenCondition = !this.props.link;

      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='button-button-1']\\").forEach((el) => {
      el.removeEventListener(\\"click\\", this.onButtonButton1Click);
      el.addEventListener(\\"click\\", this.onButtonButton1Click);
    });

    this._root.querySelectorAll(\\"[data-el='div-button-2']\\").forEach((el) => {
      this.renderTextNode(el, this.props.buttonText);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"button\\", Button);
"
`;

exports[`webcomponent > jsx > Javascript Test > defaultPropsOutsideComponent 1`] = `
"/**
 * Usage:
 *
 *  <button></button>
 *
 */
class Button extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"link\\",
      \\"attributes\\",
      \\"openLinkInNewTab\\",
      \\"text\\",
      \\"onClick\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'click' event on button-button-1
    this.onButtonButton1Click = (event) => {
      this.props.onClick(event);
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"show-button\\">
          <a data-el=\\"a-button-1\\">
            <template data-el=\\"div-button-1\\"><!-- props.text --></template>
          </a>
        </template>
        <template data-el=\\"show-button-2\\">
          <button type=\\"button\\" data-el=\\"button-button-1\\">
            <template data-el=\\"div-button-2\\"><!-- props.text --></template>
          </button>
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='show-button']\\").forEach((el) => {
      const whenCondition = this.props.link;

      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='a-button-1']\\").forEach((el) => {
      el.setAttribute(\\"href\\", this.props.link);
      el.setAttribute(
        \\"target\\",
        this.props.openLinkInNewTab ? \\"_blank\\" : undefined
      );
    });

    this._root.querySelectorAll(\\"[data-el='div-button-1']\\").forEach((el) => {
      this.renderTextNode(el, this.props.text);
    });

    this._root.querySelectorAll(\\"[data-el='show-button-2']\\").forEach((el) => {
      const whenCondition = !this.props.link;

      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='button-button-1']\\").forEach((el) => {
      el.removeEventListener(\\"click\\", this.onButtonButton1Click);
      el.addEventListener(\\"click\\", this.onButtonButton1Click);
    });

    this._root.querySelectorAll(\\"[data-el='div-button-2']\\").forEach((el) => {
      this.renderTextNode(el, this.props.text);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"button\\", Button);
"
`;

exports[`webcomponent > jsx > Javascript Test > defaultValsWithTypes 1`] = `
"const DEFAULT_VALUES = {
  name: \\"Sami\\",
};

/**
 * Usage:
 *
 *  <component-with-types></component-with-types>
 *
 */
class ComponentWithTypes extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"name\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        Hello
        <template data-el=\\"div-component-with-types-1\\">
          <!-- props.name || DEFAULT_VALUES.name -->
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-component-with-types-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.name || DEFAULT_VALUES.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"component-with-types\\", ComponentWithTypes);
"
`;

exports[`webcomponent > jsx > Javascript Test > expressionState 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      refToUse: !(self.props.componentRef instanceof Function)
        ? self.props.componentRef
        : null,
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"componentRef\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"div-my-component-1\\"><!-- state.refToUse --></template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.refToUse);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > getterState 1`] = `
"/**
 * Usage:
 *
 *  <button></button>
 *
 */
class Button extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      get foo2() {
        return self.props.foo + \\"foo\\";
      },
      get bar() {
        return \\"bar\\";
      },
      baz(i) {
        return i + self.state.foo2.length;
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"foo\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <p>
          <template data-el=\\"div-button-1\\"><!-- state.foo2 --></template>
        </p>
        <p>
          <template data-el=\\"div-button-2\\"><!-- state.bar --></template>
        </p>
        <p>
          <template data-el=\\"div-button-3\\"><!-- state.baz(1) --></template>
        </p>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='div-button-1']\\").forEach((el) => {
      this.renderTextNode(el, this.state.foo2);
    });

    this._root.querySelectorAll(\\"[data-el='div-button-2']\\").forEach((el) => {
      this.renderTextNode(el, this.state.bar);
    });

    this._root.querySelectorAll(\\"[data-el='div-button-3']\\").forEach((el) => {
      this.renderTextNode(el, this.state.baz(1));
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"button\\", Button);
"
`;

exports[`webcomponent > jsx > Javascript Test > import types 1`] = `
"import RenderBlock from \\"./builder-render-block.raw\\";

/**
 * Usage:
 *
 *  <render-content></render-content>
 *
 */
class RenderContent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      getRenderContentProps(block, index) {
        return {
          block: block,
          index: index,
        };
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"renderContentProps\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <render-block data-el=\\"render-block-render-content\\"></render-block>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"render-content\\", RenderContent);
"
`;

exports[`webcomponent > jsx > Javascript Test > multipleOnUpdate 1`] = `
"/**
 * Usage:
 *
 *  <multiple-on-update></multiple-on-update>
 *
 */
class MultipleOnUpdate extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.updateDeps = [[], []];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    console.log(\\"Runs on every update/rerender\\");

    console.log(\\"Runs on every update/rerender as well\\");
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"multiple-on-update\\", MultipleOnUpdate);
"
`;

exports[`webcomponent > jsx > Javascript Test > multipleOnUpdateWithDeps 1`] = `
"/**
 * Usage:
 *
 *  <multiple-on-update-with-deps></multiple-on-update-with-deps>
 *
 */
class MultipleOnUpdateWithDeps extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { a: \\"a\\", b: \\"b\\", c: \\"c\\", d: \\"d\\" };
    if (!this.props) {
      this.props = {};
    }

    this.updateDeps = [
      [this.state.a, this.state.b],
      [this.state.c, this.state.d],
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        console.log(\\"Runs when a or b changes\\", self.state.a, self.state.b);

        if (self.state.a === \\"a\\") {
          self.state.a = \\"b\\";
        }
        self.updateDeps[0] = __next;
      }
    })(self.updateDeps[0], [self.state.a, self.state.b]);

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        console.log(\\"Runs when c or d changes\\", self.state.c, self.state.d);

        if (self.state.a === \\"a\\") {
          self.state.a = \\"b\\";
        }
        self.updateDeps[1] = __next;
      }
    })(self.updateDeps[1], [self.state.c, self.state.d]);
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"multiple-on-update-with-deps\\", MultipleOnUpdateWithDeps);
"
`;

exports[`webcomponent > jsx > Javascript Test > multipleSpreads 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      attrs: {
        hello: \\"world\\",
      },
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <input
        data-el=\\"input-my-basic-component-1\\"
        data-dom-state=\\"MyBasicComponent-input-my-basic-component-1\\"
      />\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > nestedShow 1`] = `
"/**
 * Usage:
 *
 *  <nested-show></nested-show>
 *
 */
class NestedShow extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"conditionA\\", \\"conditionB\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"show-nested-show\\">
        <template data-el=\\"show-nested-show-2\\">
          <div>if condition A and condition B</div>
        </template>
      </template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-nested-show']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-nested-show-2']\\")
      .forEach((el) => {
        const whenCondition = !this.props.conditionB;

        if (whenCondition) {
          this.showContent(el);
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"nested-show\\", NestedShow);
"
`;

exports[`webcomponent > jsx > Javascript Test > nestedStyles 1`] = `
"/**
 * Usage:
 *
 *  <nested-styles></nested-styles>
 *
 */
class NestedStyles extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div class=\\"div-nested-styles\\">Hello world</div>
      <style>
        .div-nested-styles {
          display: flex;
          --bar: red;
          color: var(--bar);
        }
        @media (max-width: env(--mobile)) {
          .div-nested-styles {
            display: block;
          }
        }
        .div-nested-styles:hover {
          display: flex;
        }
        .div-nested-styles:active {
          display: inline;
        }
        .div-nested-styles .nested-selector {
          display: grid;
        }
        .div-nested-styles .nested-selector:hover {
          display: block;
        }
        .div-nested-styles.nested-selector:active {
          display: inline-block;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"nested-styles\\", NestedStyles);
"
`;

exports[`webcomponent > jsx > Javascript Test > onEvent 1`] = `
"/**
 * Usage:
 *
 *  <embed></embed>
 *
 */
class Embed extends HTMLElement {
  get _elem() {
    return this._root.querySelector(\\"[data-ref='Embed-elem']\\");
  }

  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      foo(event) {
        console.log(\\"test2\\");
      },
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div class=\\"builder-embed\\" data-el=\\"div-embed-1\\" data-ref=\\"Embed-elem\\">
        <div>Test</div>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    self._elem.dispatchEvent(new CustomEvent(\\"initEditingBldr\\"));
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"embed\\", Embed);
"
`;

exports[`webcomponent > jsx > Javascript Test > onInit & onMount 1`] = `
"/**
 * Usage:
 *
 *  <on-init></on-init>
 *
 */
class OnInit extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.onInitOnce = false;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;
    this.onInit();
    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onInit() {
    if (!this.onInitOnce) {
      console.log(\\"onInit\\");
      this.onInitOnce = true;
    }
  }

  onMount() {
    // onMount
    console.log(\\"onMount\\");
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"on-init\\", OnInit);
"
`;

exports[`webcomponent > jsx > Javascript Test > onInit 1`] = `
"export const defaultValues = {
  name: \\"PatrickJS\\",
};

/**
 * Usage:
 *
 *  <on-init></on-init>
 *
 */
class OnInit extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.onInitOnce = false;

    this.state = { name: \\"\\" };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"name\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        Default name defined by parent
        <template data-el=\\"div-on-init-1\\"><!-- state.name --></template>
      </div>\`;
    this.pendingUpdate = true;
    this.onInit();
    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onInit() {
    if (!this.onInitOnce) {
      this.state.name = defaultValues.name || this.props.name;
      this.update();
      console.log(\\"set defaults with props\\");
      this.onInitOnce = true;
    }
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='div-on-init-1']\\").forEach((el) => {
      this.renderTextNode(el, this.state.name);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"on-init\\", OnInit);
"
`;

exports[`webcomponent > jsx > Javascript Test > onMount 1`] = `
"/**
 * Usage:
 *
 *  <comp></comp>
 *
 */
class Comp extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  disconnectedCallback() {
    // onUnMount
    console.log(\\"Runs on unMount\\");
    this.destroyAnyNodes(); // clean up nodes when component is destroyed
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    console.log(\\"Runs on mount\\");
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"comp\\", Comp);
"
`;

exports[`webcomponent > jsx > Javascript Test > onMountMultiple 1`] = `
"/**
 * Usage:
 *
 *  <comp></comp>
 *
 */
class Comp extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    const onMountHook_0 = () => {
      console.log(\\"Runs on mount\\");
    };

    onMountHook_0();

    const onMountHook_1 = () => {
      console.log(\\"Another one runs on Mount\\");
    };

    onMountHook_1();

    const onMountHook_2 = () => {
      console.log(\\"SSR runs on Mount\\");
    };

    onMountHook_2();
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"comp\\", Comp);
"
`;

exports[`webcomponent > jsx > Javascript Test > onUpdate 1`] = `
"/**
 * Usage:
 *
 *  <on-update></on-update>
 *
 */
class OnUpdate extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.updateDeps = [[]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    console.log(\\"Runs on every update/rerender\\");
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"on-update\\", OnUpdate);
"
`;

exports[`webcomponent > jsx > Javascript Test > onUpdateWithDeps 1`] = `
"/**
 * Usage:
 *
 *  <on-update-with-deps></on-update-with-deps>
 *
 */
class OnUpdateWithDeps extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { a: \\"a\\", b: \\"b\\" };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"size\\"];

    this.updateDeps = [[this.state.a, this.state.b, this.props.size]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        console.log(
          \\"Runs when a, b or size changes\\",
          self.state.a,
          self.state.b,
          self.props.size
        );
        self.updateDeps[0] = __next;
      }
    })(self.updateDeps[0], [self.state.a, self.state.b, self.props.size]);
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"on-update-with-deps\\", OnUpdateWithDeps);
"
`;

exports[`webcomponent > jsx > Javascript Test > preserveExportOrLocalStatement 1`] = `
"const b = 3;
const foo = () => {};
export const a = 3;
export const bar = () => {};
export function run(value) {}

/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > preserveTyping 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"name\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        Hello! I can run in React, Vue, Solid, or Liquid!
        <template data-el=\\"div-my-basic-component-1\\"><!-- props.name --></template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > propsDestructure 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"Decadef20\\" };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"children\\", \\"type\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <slot></slot>
        <template data-el=\\"div-my-basic-component-2\\"><!-- props.type --></template>
      
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-2']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.type);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > propsInterface 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"name\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        Hello! I can run in React, Vue, Solid, or Liquid!
        <template data-el=\\"div-my-basic-component-1\\"><!-- props.name --></template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > propsType 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"name\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        Hello! I can run in React, Vue, Solid, or Liquid!
        <template data-el=\\"div-my-basic-component-1\\"><!-- props.name --></template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > referencingFunInsideHook 1`] = `
"/**
 * Usage:
 *
 *  <on-update></on-update>
 *
 */
class OnUpdate extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      foo: function foo(params) {},
      bar: function bar() {},
      zoo: function zoo() {
        const params = {
          cb: self.state.bar,
        };
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.updateDeps = [[]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    self.state.foo({
      someOption: self.state.bar,
    });
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"on-update\\", OnUpdate);
"
`;

exports[`webcomponent > jsx > Javascript Test > renderBlock 1`] = `
"import { TARGET } from \\"../../constants/target.js\\";
import { evaluate } from \\"../../functions/evaluate.js\\";
import { extractTextStyles } from \\"../../functions/extract-text-styles.js\\";
import { getBlockActions } from \\"../../functions/get-block-actions.js\\";
import { getBlockComponentOptions } from \\"../../functions/get-block-component-options.js\\";
import { getBlockProperties } from \\"../../functions/get-block-properties.js\\";
import { getBlockTag } from \\"../../functions/get-block-tag.js\\";
import { getProcessedBlock } from \\"../../functions/get-processed-block.js\\";
import { getReactNativeBlockStyles } from \\"../../functions/get-react-native-block-styles.js\\";
import BlockStyles from \\"./block-styles.js\\";
import { isEmptyHtmlElement } from \\"./render-block.helpers.js\\";
import RenderComponentWithContext from \\"./render-component-with-context.js\\";
import RenderComponent from \\"./render-component.js\\";
import RenderRepeatedBlock from \\"./render-repeated-block.js\\";

/**
 * Usage:
 *
 *  <render-block></render-block>
 *
 */
class RenderBlock extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      get component() {
        const componentName = getProcessedBlock({
          block: self.props.block,
          state: self.props.context.state,
          context: self.props.context.context,
          shouldEvaluateBindings: false,
        }).component?.name;

        if (!componentName) {
          return null;
        }

        const ref = self.props.context.registeredComponents[componentName];

        if (!ref) {
          // TODO: Public doc page with more info about this message
          console.warn(\`
          Could not find a registered component named \\"\${componentName}\\". 
          If you registered it, is the file that registered it imported by the file that needs to render it?\`);
          return undefined;
        } else {
          return ref;
        }
      },
      get tag() {
        return getBlockTag(self.state.useBlock);
      },
      get useBlock() {
        return self.state.repeatItemData
          ? self.props.block
          : getProcessedBlock({
              block: self.props.block,
              state: self.props.context.state,
              context: self.props.context.context,
              shouldEvaluateBindings: true,
            });
      },
      get actions() {
        return getBlockActions({
          block: self.state.useBlock,
          state: self.props.context.state,
          context: self.props.context.context,
        });
      },
      get attributes() {
        const blockProperties = getBlockProperties(self.state.useBlock);
        return {
          ...blockProperties,
          ...(TARGET === \\"reactNative\\"
            ? {
                style: getReactNativeBlockStyles({
                  block: self.state.useBlock,
                  context: self.props.context,
                  blockStyles: blockProperties.style,
                }),
              }
            : {}),
        };
      },
      get shouldWrap() {
        return !self.state.component?.noWrap;
      },
      get renderComponentProps() {
        return {
          blockChildren: self.state.useChildren,
          componentRef: self.state.component?.component,
          componentOptions: {
            ...getBlockComponentOptions(self.state.useBlock),

            /**
             * These attributes are passed to the wrapper element when there is one. If \`noWrap\` is set to true, then
             * they are provided to the component itself directly.
             */
            ...(self.state.shouldWrap
              ? {}
              : {
                  attributes: {
                    ...self.state.attributes,
                    ...self.state.actions,
                  },
                }),
            customBreakpoints:
              self.state.childrenContext?.content?.meta?.breakpoints,
          },
          context: self.state.childrenContext,
        };
      },
      get useChildren() {
        // TO-DO: When should \`canHaveChildren\` dictate rendering?
        // This is currently commented out because some Builder components (e.g. Box) do not have \`canHaveChildren: true\`,
        // but still receive and need to render children.
        // return state.componentInfo?.canHaveChildren ? state.useBlock.children : [];
        return self.state.useBlock.children ?? [];
      },
      get childrenWithoutParentComponent() {
        /**
         * When there is no \`componentRef\`, there might still be children that need to be rendered. In this case,
         * we render them outside of \`componentRef\`.
         * NOTE: We make sure not to render this if \`repeatItemData\` is non-null, because that means we are rendering an array of
         * blocks, and the children will be repeated within those blocks.
         */
        const shouldRenderChildrenOutsideRef =
          !self.state.component?.component && !self.state.repeatItemData;
        return shouldRenderChildrenOutsideRef ? self.state.useChildren : [];
      },
      get repeatItemData() {
        /**
         * we don't use \`state.useBlock\` here because the processing done within its logic includes evaluating the block's bindings,
         * which will not work if there is a repeat.
         */
        const { repeat, ...blockWithoutRepeat } = self.props.block;

        if (!repeat?.collection) {
          return undefined;
        }

        const itemsArray = evaluate({
          code: repeat.collection,
          state: self.props.context.state,
          context: self.props.context.context,
        });

        if (!Array.isArray(itemsArray)) {
          return undefined;
        }

        const collectionName = repeat.collection.split(\\".\\").pop();
        const itemNameToUse =
          repeat.itemName ||
          (collectionName ? collectionName + \\"Item\\" : \\"item\\");
        const repeatArray = itemsArray.map((item, index) => ({
          context: {
            ...self.props.context,
            state: {
              ...self.props.context.state,
              $index: index,
              $item: item,
              [itemNameToUse]: item,
              [\`$\${itemNameToUse}Index\`]: index,
            },
          },
          block: blockWithoutRepeat,
        }));
        return repeatArray;
      },
      get inheritedTextStyles() {
        if (TARGET !== \\"reactNative\\") {
          return {};
        }

        const styles = getReactNativeBlockStyles({
          block: self.state.useBlock,
          context: self.props.context,
          blockStyles: self.state.attributes.style,
        });
        return extractTextStyles(styles);
      },
      get childrenContext() {
        return {
          apiKey: self.props.context.apiKey,
          state: self.props.context.state,
          content: self.props.context.content,
          context: self.props.context.context,
          registeredComponents: self.props.context.registeredComponents,
          inheritedStyles: self.state.inheritedTextStyles,
        };
      },
      get renderComponentTag() {
        if (TARGET === \\"reactNative\\") {
          return RenderComponentWithContext;
        } else if (TARGET === \\"vue3\\") {
          // vue3 expects a string for the component tag
          return \\"RenderComponent\\";
        } else {
          return RenderComponent;
        }
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"block\\", \\"context\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"show-render-block\\">
        <template data-el=\\"show-render-block-2\\">
          <state.tag data-el=\\"state-tag-render-block\\"></state.tag>
        </template>
        <template data-el=\\"show-render-block-3\\">
          <template data-el=\\"for-render-block\\">
            <render-repeated-block
              data-el=\\"render-repeated-block-render-block\\"
            ></render-repeated-block>
          </template>
        </template>
        <template data-el=\\"show-render-block-4\\">
          <state.tag data-el=\\"state-tag-render-block-2\\">
            <state.renderComponentTag
              data-el=\\"state-render-component-tag-render-block\\"
            ></state.renderComponentTag>
      
            <template data-el=\\"for-render-block-2\\">
              <RenderBlock data-el=\\"render-block-render-block\\"></RenderBlock>
            </template>
      
            <template data-el=\\"for-render-block-3\\">
              <block-styles data-el=\\"block-styles-render-block\\"></block-styles>
            </template>
          </state.tag>
        </template>
      </template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-render-block']\\")
      .forEach((el) => {
        const whenCondition = this.state.shouldWrap;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-render-block-2']\\")
      .forEach((el) => {
        const whenCondition = isEmptyHtmlElement(this.state.tag);

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-render-block-3']\\")
      .forEach((el) => {
        const whenCondition =
          !isEmptyHtmlElement(this.state.tag) && this.state.repeatItemData;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='for-render-block']\\")
      .forEach((el) => {
        let array = this.state.repeatItemData;
        this.renderLoop(el, array, \\"data\\", \\"index\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='render-repeated-block-render-block']\\")
      .forEach((el) => {
        const index = this.getScope(el, \\"index\\");
        const data = this.getScope(el, \\"data\\");
        el.key = index;

        if (el.props) {
          el.props.key = index;

          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.key = index;
        }

        el.setAttribute(\\"repeatContext\\", data.context);
        el.repeatContext = data.context;

        if (el.props) {
          el.props.repeatContext = data.context;

          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.repeatContext = data.context;
        }

        el.setAttribute(\\"block\\", data.block);
        el.block = data.block;

        if (el.props) {
          el.props.block = data.block;

          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.block = data.block;
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-render-block-4']\\")
      .forEach((el) => {
        const whenCondition =
          !isEmptyHtmlElement(this.state.tag) && !this.state.repeatItemData;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='for-render-block-2']\\")
      .forEach((el) => {
        let array = this.state.childrenWithoutParentComponent;
        this.renderLoop(el, array, \\"child\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='render-block-render-block']\\")
      .forEach((el) => {
        const child = this.getScope(el, \\"child\\");
        el.key = \\"render-block-\\" + child.id;
        el.setAttribute(\\"block\\", child);
        el.setAttribute(\\"context\\", this.state.childrenContext);
      });

    this._root
      .querySelectorAll(\\"[data-el='for-render-block-3']\\")
      .forEach((el) => {
        let array = this.state.childrenWithoutParentComponent;
        this.renderLoop(el, array, \\"child\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='block-styles-render-block']\\")
      .forEach((el) => {
        const child = this.getScope(el, \\"child\\");
        el.key = \\"block-style-\\" + child.id;

        if (el.props) {
          el.props.key = \\"block-style-\\" + child.id;

          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.key = \\"block-style-\\" + child.id;
        }

        el.setAttribute(\\"block\\", child);
        el.block = child;

        if (el.props) {
          el.props.block = child;

          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.block = child;
        }

        el.setAttribute(\\"context\\", this.state.childrenContext);
        el.context = this.state.childrenContext;

        if (el.props) {
          el.props.context = this.state.childrenContext;

          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.context = this.state.childrenContext;
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"render-block\\", RenderBlock);
"
`;

exports[`webcomponent > jsx > Javascript Test > renderContentExample 1`] = `
"import BuilderContext from \\"@dummy/context.js\\";
import {
  dispatchNewContentToVisualEditor,
  sendComponentsToVisualEditor,
  trackClick,
} from \\"@dummy/injection-js\\";
import RenderBlocks from \\"@dummy/RenderBlocks.js\\";

/**
 * Usage:
 *
 *  <render-content></render-content>
 *
 */
class RenderContent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"customComponents\\", \\"content\\"];

    this.updateDeps = [[this.props.content]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'click' event on div-render-content-1
    this.onDivRenderContent1Click = (event) => {
      trackClick(this.props.content.id);
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div class=\\"div-render-content\\" data-el=\\"div-render-content-1\\">
        <render-blocks data-el=\\"render-blocks-render-content\\"></render-blocks>
      </div>
      <style>
        .div-render-content {
          display: flex;
          flex-direction: columns;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    sendComponentsToVisualEditor(this.props.customComponents);
  }

  onUpdate() {
    const self = this;

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        dispatchNewContentToVisualEditor(self.props.content);
        self.updateDeps[0] = __next;
      }
    })(self.updateDeps[0], [self.props.content]);
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-render-content-1']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onDivRenderContent1Click);
        el.addEventListener(\\"click\\", this.onDivRenderContent1Click);
      });

    this._root
      .querySelectorAll(\\"[data-el='render-blocks-render-content']\\")
      .forEach((el) => {
        el.setAttribute(\\"blocks\\", this.props.content.blocks);
        el.blocks = this.props.content.blocks;

        if (el.props) {
          el.props.blocks = this.props.content.blocks;

          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.blocks = this.props.content.blocks;
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"render-content\\", RenderContent);
"
`;

exports[`webcomponent > jsx > Javascript Test > rootFragmentMultiNode 1`] = `
"/**
 * Usage:
 *
 *  <button></button>
 *
 */
class Button extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"link\\", \\"attributes\\", \\"openLinkInNewTab\\", \\"text\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"show-button\\">
        <a data-el=\\"a-button-1\\">
          <template data-el=\\"div-button-1\\"><!-- props.text --></template>
        </a>
      </template>
      <template data-el=\\"show-button-2\\">
        <button type=\\"button\\" data-el=\\"button-button-1\\">
          <template data-el=\\"div-button-2\\"><!-- props.text --></template>
        </button>
      </template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='show-button']\\").forEach((el) => {
      const whenCondition = this.props.link;

      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='a-button-1']\\").forEach((el) => {
      el.setAttribute(\\"href\\", this.props.link);
      el.setAttribute(
        \\"target\\",
        this.props.openLinkInNewTab ? \\"_blank\\" : undefined
      );
    });

    this._root.querySelectorAll(\\"[data-el='div-button-1']\\").forEach((el) => {
      this.renderTextNode(el, this.props.text);
    });

    this._root.querySelectorAll(\\"[data-el='show-button-2']\\").forEach((el) => {
      const whenCondition = !this.props.link;

      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='div-button-2']\\").forEach((el) => {
      this.renderTextNode(el, this.props.text);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"button\\", Button);
"
`;

exports[`webcomponent > jsx > Javascript Test > rootShow 1`] = `
"/**
 * Usage:
 *
 *  <render-styles></render-styles>
 *
 */
class RenderStyles extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"foo\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"show-render-styles\\"><div>Bar</div></template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-render-styles']\\")
      .forEach((el) => {
        const whenCondition = this.props.foo === \\"bar\\";

        if (whenCondition) {
          this.showContent(el);
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"render-styles\\", RenderStyles);
"
`;

exports[`webcomponent > jsx > Javascript Test > self-referencing component 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"name\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"div-my-component-1\\"><!-- props.name --></template>
        <template data-el=\\"show-my-component\\">
          <MyComponent name=\\"Bruce Wayne\\"></MyComponent>
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.name);
      });

    this._root
      .querySelectorAll(\\"[data-el='show-my-component']\\")
      .forEach((el) => {
        const whenCondition = this.props.name === \\"Batman\\";

        if (whenCondition) {
          this.showContent(el);
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > self-referencing component with children 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"name\\", \\"children\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"div-my-component-1\\"><!-- props.name --></template>
        <slot></slot>
        <template data-el=\\"show-my-component\\">
          <MyComponent name=\\"Bruce\\"><div>Wayne</div></MyComponent>
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.name);
      });

    this._root
      .querySelectorAll(\\"[data-el='show-my-component']\\")
      .forEach((el) => {
        const whenCondition = this.props.name === \\"Batman\\";

        if (whenCondition) {
          this.showContent(el);
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > showExpressions 1`] = `
"/**
 * Usage:
 *
 *  <show-with-other-values></show-with-other-values>
 *
 */
class ShowWithOtherValues extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"conditionA\\", \\"conditionB\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"show-show-with-other-values\\">Content0</template>
        <template data-el=\\"show-show-with-other-values-2\\">ContentA</template>
        <template data-el=\\"show-show-with-other-values-3\\"></template>
        <template data-el=\\"show-show-with-other-values-4\\">ContentB</template>
        <template data-el=\\"show-show-with-other-values-5\\">
          <template data-el=\\"div-show-with-other-values-1\\">
            <!-- undefined -->
          </template>
        </template>
        <template data-el=\\"show-show-with-other-values-6\\">ContentC</template>
        <template data-el=\\"show-show-with-other-values-7\\"></template>
        <template data-el=\\"show-show-with-other-values-8\\">ContentD</template>
        <template data-el=\\"show-show-with-other-values-9\\"></template>
        <template data-el=\\"show-show-with-other-values-10\\">ContentE</template>
        <template data-el=\\"show-show-with-other-values-11\\">hello</template>
        <template data-el=\\"show-show-with-other-values-12\\">ContentF</template>
        <template data-el=\\"show-show-with-other-values-13\\">123</template>
        <template data-el=\\"show-show-with-other-values-14\\">4mb</template>
        <template data-el=\\"show-show-with-other-values-15\\">
          <template data-el=\\"show-show-with-other-values-16\\">20mb</template>
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-2']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-3']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-4']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-5']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='div-show-with-other-values-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, undefined);
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-6']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-7']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-8']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-9']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-10']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-11']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-12']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-13']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-14']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA === \\"Default\\";

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-15']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA === \\"Default\\";

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-16']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionB === \\"Complete\\";

        if (whenCondition) {
          this.showContent(el);
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"show-with-other-values\\", ShowWithOtherValues);
"
`;

exports[`webcomponent > jsx > Javascript Test > showWithFor 1`] = `
"/**
 * Usage:
 *
 *  <nested-show></nested-show>
 *
 */
class NestedShow extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"conditionA\\", \\"items\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"show-nested-show\\">
        <template data-el=\\"for-nested-show\\">
          <div data-el=\\"div-nested-show-1\\">
            <template data-el=\\"div-nested-show-2\\"><!-- item --></template>
          </div>
        </template>
      </template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-nested-show']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root.querySelectorAll(\\"[data-el='for-nested-show']\\").forEach((el) => {
      let array = this.props.items;
      this.renderLoop(el, array, \\"item\\", \\"idx\\");
    });

    this._root
      .querySelectorAll(\\"[data-el='div-nested-show-1']\\")
      .forEach((el) => {
        const idx = this.getScope(el, \\"idx\\");
        el.key = idx;
      });

    this._root
      .querySelectorAll(\\"[data-el='div-nested-show-2']\\")
      .forEach((el) => {
        const item = this.getScope(el, \\"item\\");
        this.renderTextNode(el, item);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"nested-show\\", NestedShow);
"
`;

exports[`webcomponent > jsx > Javascript Test > showWithOtherValues 1`] = `
"/**
 * Usage:
 *
 *  <show-with-other-values></show-with-other-values>
 *
 */
class ShowWithOtherValues extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"conditionA\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"show-show-with-other-values\\">ContentA</template>
        <template data-el=\\"show-show-with-other-values-2\\">ContentB</template>
        <template data-el=\\"show-show-with-other-values-3\\">ContentC</template>
        <template data-el=\\"show-show-with-other-values-4\\">ContentD</template>
        <template data-el=\\"show-show-with-other-values-5\\">ContentE</template>
        <template data-el=\\"show-show-with-other-values-6\\">ContentF</template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-2']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-3']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-4']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-5']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-6']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"show-with-other-values\\", ShowWithOtherValues);
"
`;

exports[`webcomponent > jsx > Javascript Test > showWithRootText 1`] = `
"/**
 * Usage:
 *
 *  <show-root-text></show-root-text>
 *
 */
class ShowRootText extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"conditionA\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"show-show-root-text\\">ContentA</template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-show-root-text']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"show-root-text\\", ShowRootText);
"
`;

exports[`webcomponent > jsx > Javascript Test > signalsOnUpdate 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"id\\", \\"foo\\"];

    this.updateDeps = [[this.props.id, this.props.foo.value.bar.baz]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div class=\\"test div-my-basic-component\\">
        <template data-el=\\"div-my-basic-component-1\\"><!-- props.id --></template>
        <template data-el=\\"div-my-basic-component-2\\">
          <!-- props.foo.value.bar.baz -->
        </template>
      </div>
      <style>
        .div-my-basic-component {
          padding: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        console.log(\\"props.id changed\\", self.props.id);
        console.log(
          \\"props.foo.value.bar.baz changed\\",
          self.props.foo.value.bar.baz
        );
        self.updateDeps[0] = __next;
      }
    })(self.updateDeps[0], [self.props.id, self.props.foo.value.bar.baz]);
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.id);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-2']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.foo.value.bar.baz);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > spreadAttrs 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <input
        data-el=\\"input-my-basic-component-1\\"
        data-dom-state=\\"MyBasicComponent-input-my-basic-component-1\\"
      />\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > spreadNestedProps 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"nested\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <input
        data-el=\\"input-my-basic-component-1\\"
        data-dom-state=\\"MyBasicComponent-input-my-basic-component-1\\"
      />\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > spreadProps 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <input
        data-el=\\"input-my-basic-component-1\\"
        data-dom-state=\\"MyBasicComponent-input-my-basic-component-1\\"
      />\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > styleClassAndCss 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div class=\\"builder-column div-my-component\\" data-el=\\"div-my-component-1\\"></div>
      <style>
        .div-my-component {
          display: flex;
          flex-direction: column;
          align-items: stretch;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-component-1']\\")
      .forEach((el) => {
        Object.assign(el.style, {
          width: \\"100%\\",
        });
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > stylePropClassAndCss 1`] = `
"/**
 * Usage:
 *
 *  <style-prop-class-and-css></style-prop-class-and-css>
 *
 */
class StylePropClassAndCss extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"attributes\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div data-el=\\"div-style-prop-class-and-css-1\\"></div>
      <style>
        .div-style-prop-class-and-css {
          display: flex;
          flex-direction: column;
          align-items: stretch;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-style-prop-class-and-css-1']\\")
      .forEach((el) => {
        Object.assign(el.style, this.props.attributes.style);
        el.className =
          this.props.attributes.class + \\" div-style-prop-class-and-css\\";
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"style-prop-class-and-css\\", StylePropClassAndCss);
"
`;

exports[`webcomponent > jsx > Javascript Test > subComponent 1`] = `
"import Foo from \\"./foo-sub-component.js\\";

/**
 * Usage:
 *
 *  <sub-component></sub-component>
 *
 */
class SubComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <foo></foo>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"sub-component\\", SubComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > svgComponent 1`] = `
"/**
 * Usage:
 *
 *  <svg-component></svg-component>
 *
 */
class SvgComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <svg fill=\\"none\\" role=\\"img\\" data-el=\\"svg-svg-component-1\\">
        <defs>
          <filter id=\\"prefix__filter0_f\\" filterUnits=\\"userSpaceOnUse\\">
            <feFlood result=\\"BackgroundImageFix\\"></feFlood>
            <feBlend
              in=\\"SourceGraphic\\"
              in2=\\"BackgroundImageFix\\"
              result=\\"shape\\"
            ></feBlend>
            <feGaussianBlur
              result=\\"effect1_foregroundBlur\\"
              data-el=\\"fe-gaussian-blur-svg-component\\"
            ></feGaussianBlur>
          </filter>
        </defs>
      </svg>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='svg-svg-component-1']\\")
      .forEach((el) => {
        el.setAttribute(\\"viewBox\\", \\"0 0 \\" + 42 + \\" \\" + 42);
        el.setAttribute(\\"width\\", 42);
        el.setAttribute(\\"height\\", 42);
      });

    this._root
      .querySelectorAll(\\"[data-el='fe-gaussian-blur-svg-component']\\")
      .forEach((el) => {
        el.setAttribute(\\"stdDeviation\\", 7);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"svg-component\\", SvgComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > typeDependency 1`] = `
"/**
 * Usage:
 *
 *  <type-dependency></type-dependency>
 *
 */
class TypeDependency extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"foo\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"div-type-dependency-1\\"><!-- props.foo --></template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-type-dependency-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.foo);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"type-dependency\\", TypeDependency);
"
`;

exports[`webcomponent > jsx > Javascript Test > use-style 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <button type=\\"button\\">Button</button>
      <style>
        button {
          background: blue;
          color: white;
          font-size: 12px;
          outline: 1px solid black;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > use-style-and-css 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <button type=\\"button\\" class=\\"button-my-component\\">Button</button>
      <style>
        button {
          font-size: 12px;
          outline: 1px solid black;
        }
      
        .button-my-component {
          background: blue;
          color: white;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > use-style-outside-component 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <button type=\\"button\\">Button</button>
      <style>
        button {
          background: blue;
          color: white;
          font-size: 12px;
          outline: 1px solid black;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > useTarget 1`] = `
"/**
 * Usage:
 *
 *  <use-target-component></use-target-component>
 *
 */
class UseTargetComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      get name() {
        const prefix = \\"c\\";
        return prefix + \\"foo\\";
      },
      lastName: \\"bar\\",
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <template data-el=\\"div-use-target-component-1\\"><!-- state.name --></template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-use-target-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"use-target-component\\", UseTargetComponent);
"
`;

exports[`webcomponent > jsx > Javascript Test > webComponent 1`] = `
"import { register } from \\"swiper/element/bundle\\";

/**
 * Usage:
 *
 *  <my-basic-web-component></my-basic-web-component>
 *
 */
class MyBasicWebComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.onInitOnce = false;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <swiper-container slides-per-view=\\"3\\" navigation=\\"true\\" pagination=\\"true\\">
        <swiper-slide>Slide 1</swiper-slide>
        <swiper-slide>Slide 2</swiper-slide>
        <swiper-slide>Slide 3</swiper-slide>
      </swiper-container>\`;
    this.pendingUpdate = true;
    this.onInit();
    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onInit() {
    if (!this.onInitOnce) {
      register();
      this.onInitOnce = true;
    }
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-web-component\\", MyBasicWebComponent);
"
`;

exports[`webcomponent > jsx > Remove Internal mitosis package 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\" };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        Hello
        <template data-el=\\"div-my-basic-component-1\\"><!-- state.name --></template>
        ! I can run in React, Qwik, Vue, Solid, or Liquid!
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > AdvancedRef 1`] = `
"export interface Props {
  showInput: boolean;
}

/**
 * Usage:
 *
 *  <my-basic-ref-component></my-basic-ref-component>
 *
 */
class MyBasicRefComponent extends HTMLElement {
  get _inputRef() {
    return this._root.querySelector(
      \\"[data-ref='MyBasicRefComponent-inputRef']\\"
    );
  }

  get _inputNoArgRef() {
    return this._root.querySelector(
      \\"[data-ref='MyBasicRefComponent-inputNoArgRef']\\"
    );
  }

  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      name: \\"PatrickJS\\",
      onBlur: function onBlur() {
        // Maintain focus
        self._inputRef.focus();
      },
      lowerCaseName: function lowerCaseName() {
        return self.state.name.toLowerCase();
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"showInput\\"];

    this.updateDeps = [[self._inputRef, self._inputNoArgRef]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'blur' event on input-my-basic-ref-component-1
    this.onInputMyBasicRefComponent1Blur = (event) => {
      this.state.onBlur();
    };

    // Event handler for 'input' event on input-my-basic-ref-component-1
    this.onInputMyBasicRefComponent1Input = (event) => {
      this.state.name = event.target.value;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"show-my-basic-ref-component\\">
          <input
            class=\\"input-my-basic-ref-component\\"
            data-el=\\"input-my-basic-ref-component-1\\"
            data-dom-state=\\"MyBasicRefComponent-input-my-basic-ref-component-1\\"
            data-ref=\\"MyBasicRefComponent-inputRef\\"
          />
          <label
            for=\\"cars\\"
            data-el=\\"label-my-basic-ref-component-1\\"
            data-ref=\\"MyBasicRefComponent-inputNoArgRef\\"
          >
            Choose a car:
          </label>
          <select
            name=\\"cars\\"
            id=\\"cars\\"
            data-dom-state=\\"MyBasicRefComponent-select-my-basic-ref-component-1\\"
          >
            <option value=\\"supra\\">GR Supra</option>
            <option value=\\"86\\">GR 86</option>
          </select>
        </template>
      
        Hello
      
        <template data-el=\\"div-my-basic-ref-component-1\\">
          <!-- state.lowerCaseName() -->
        </template>
        ! I can run in React, Qwik, Vue, Solid, or Web Component!
      </div>
      <style>
        .input-my-basic-ref-component {
          color: red;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {
    const self = this;

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        console.log(\\"Received an update\\");
        self.updateDeps[0] = __next;
      }
    })(self.updateDeps[0], [self._inputRef, self._inputNoArgRef]);
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-my-basic-ref-component']\\")
      .forEach((el) => {
        const whenCondition = this.props.showInput;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-ref-component-1']\\")
      .forEach((el) => {
        el.value = this.state.name;
        el.removeEventListener(\\"blur\\", this.onInputMyBasicRefComponent1Blur);
        el.addEventListener(\\"blur\\", this.onInputMyBasicRefComponent1Blur);
        el.removeEventListener(\\"input\\", this.onInputMyBasicRefComponent1Input);
        el.addEventListener(\\"input\\", this.onInputMyBasicRefComponent1Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-ref-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.lowerCaseName());
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-ref-component\\", MyBasicRefComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > Basic 1`] = `
"export interface MyBasicComponentProps {
  id: string;
}

export const DEFAULT_VALUES = {
  name: \\"Steve\\",
};

/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      name: \\"Steve\\",
      underscore_fn_name() {
        return \\"bar\\";
      },
      age: 1,
      sports: [\\"\\"],
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-basic-component-1
    this.onInputMyBasicComponent1Input = (myEvent) => {
      this.state.name = myEvent.target.value;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div class=\\"test div-my-basic-component\\">
        <input
          data-el=\\"input-my-basic-component-1\\"
          data-dom-state=\\"MyBasicComponent-input-my-basic-component-1\\"
        />
      
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>
      <style>
        .div-my-basic-component {
          padding: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-component-1']\\")
      .forEach((el) => {
        el.value = DEFAULT_VALUES.name || this.state.name;
        el.removeEventListener(\\"input\\", this.onInputMyBasicComponent1Input);
        el.addEventListener(\\"input\\", this.onInputMyBasicComponent1Input);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > Basic 2`] = `
"/**
 * Usage:
 *
 *  <my-basic-for-show-component></my-basic-for-show-component>
 *
 */
class MyBasicForShowComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-basic-for-show-component-1
    this.onInputMyBasicForShowComponent1Input = (event) => {
      const person = this.getScope(event.currentTarget, \\"person\\");

      this.state.name = event.target.value + \\" and \\" + person;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <template data-el=\\"for-my-basic-for-show-component\\">
          <template data-el=\\"show-my-basic-for-show-component\\">
            <input
              data-el=\\"input-my-basic-for-show-component-1\\"
              data-dom-state=\\"MyBasicForShowComponent-input-my-basic-for-show-component-1\\"
            />
      
            Hello
            <template data-el=\\"div-my-basic-for-show-component-1\\">
              <!-- person -->
            </template>
            ! I can run in Qwik, Web Component, React, Vue, Solid, or Liquid!
          </template>
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='for-my-basic-for-show-component']\\")
      .forEach((el) => {
        let array = this.state.names;
        this.renderLoop(el, array, \\"person\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='show-my-basic-for-show-component']\\")
      .forEach((el) => {
        const person = this.getScope(el, \\"person\\");
        const whenCondition = person === this.state.name;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-for-show-component-1']\\")
      .forEach((el) => {
        el.value = this.state.name;
        el.removeEventListener(
          \\"input\\",
          this.onInputMyBasicForShowComponent1Input
        );
        el.addEventListener(\\"input\\", this.onInputMyBasicForShowComponent1Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-for-show-component-1']\\")
      .forEach((el) => {
        const person = this.getScope(el, \\"person\\");
        this.renderTextNode(el, person);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"my-basic-for-show-component\\", MyBasicForShowComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > Basic Context 1`] = `
"import { Injector, MyService, createInjector } from \\"@dummy/injection-js\\";

/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;
    this.context = createInjector();

    this.onInitOnce = false;

    this.state = {
      name: \\"PatrickJS\\",
      onChange: function onChange() {
        const change = self.myService.method(\\"change\\");
        console.log(change);
      },
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-basic-component-1
    this.onInputMyBasicComponent1Input = (event) => {
      this.state.onChange;
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.myService = this.getContext(this._root, MyService);

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"div-my-basic-component-1\\">
          <!-- myService.method('hello') + state.name -->
        </template>
      
        Hello! I can run in React, Vue, Solid, or Liquid!
      
        <input
          data-el=\\"input-my-basic-component-1\\"
          data-dom-state=\\"MyBasicComponent-input-my-basic-component-1\\"
        />
      </div>\`;
    this.pendingUpdate = true;
    this.onInit();
    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onInit() {
    if (!this.onInitOnce) {
      const hi = this.myService.method(\\"hi\\");
      console.log(hi);
      this.onInitOnce = true;
    }
  }

  onMount() {
    // onMount
    const bye = this.myService.method(\\"hi\\");
    console.log(bye);
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(
          el,
          this.myService.method(\\"hello\\") + this.state.name
        );
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-component-1']\\")
      .forEach((el) => {
        el.removeEventListener(\\"input\\", this.onInputMyBasicComponent1Input);
        el.addEventListener(\\"input\\", this.onInputMyBasicComponent1Input);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // get Context Helper
  getContext(el, token) {
    do {
      let value;
      if (el?.context?.get) {
        value = el.context.get(token);
      } else if (el?.context?.[token]) {
        value = el.context[token];
      }
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > Basic OnMount Update 1`] = `
"export interface Props {
  hi: string;
  bye: string;
}

/**
 * Usage:
 *
 *  <my-basic-on-mount-update-component></my-basic-on-mount-update-component>
 *
 */
class MyBasicOnMountUpdateComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.onInitOnce = false;

    this.state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"bye\\", \\"hi\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        Hello
        <template data-el=\\"div-my-basic-on-mount-update-component-1\\">
          <!-- state.name -->
        </template>
      </div>\`;
    this.pendingUpdate = true;
    this.onInit();
    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onInit() {
    if (!this.onInitOnce) {
      this.state.name = \\"PatrickJS onInit\\" + this.props.hi;
      this.update();
      this.onInitOnce = true;
    }
  }

  onMount() {
    // onMount
    this.state.name = \\"PatrickJS onMount\\" + this.props.bye;
    this.update();
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-on-mount-update-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(
  \\"my-basic-on-mount-update-component\\",
  MyBasicOnMountUpdateComponent
);
"
`;

exports[`webcomponent > jsx > Typescript Test > Basic Outputs 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-outputs-component></my-basic-outputs-component>
 *
 */
class MyBasicOutputsComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\" };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"onMessage\\", \\"onEvent\\", \\"message\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    this.props.onMessage(this.state.name);
    this.props.onEvent(this.props.message);
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-outputs-component\\", MyBasicOutputsComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > Basic Outputs Meta 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-outputs-component></my-basic-outputs-component>
 *
 */
class MyBasicOutputsComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\" };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"onMessage\\", \\"onEvent\\", \\"message\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    this.props.onMessage(this.state.name);
    this.props.onEvent(this.props.message);
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-outputs-component\\", MyBasicOutputsComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > BasicAttribute 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <input
        autocapitalize=\\"on\\"
        autocomplete=\\"on\\"
        data-el=\\"input-my-component-1\\"
        data-dom-state=\\"MyComponent-input-my-component-1\\"
      />\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-my-component-1']\\")
      .forEach((el) => {
        el.setAttribute(\\"spellcheck\\", true);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > BasicBooleanAttribute 1`] = `
"type Props = {
  children: any;
  type: string;
};

import MyBooleanAttributeComponent from \\"./basic-boolean-attribute-component.raw\\";

/**
 * Usage:
 *
 *  <my-boolean-attribute></my-boolean-attribute>
 *
 */
class MyBooleanAttribute extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"children\\", \\"type\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"show-my-boolean-attribute\\">
          <slot></slot>
          <template data-el=\\"div-my-boolean-attribute-2\\">
            <!-- props.type -->
          </template>
        </template>
        <my-boolean-attribute-component
          data-el=\\"my-boolean-attribute-component-my-boolean-attribute\\"
        ></my-boolean-attribute-component>
        <my-boolean-attribute-component
          data-el=\\"my-boolean-attribute-component-my-boolean-attribute-2\\"
        ></my-boolean-attribute-component>
        <my-boolean-attribute-component
          data-el=\\"my-boolean-attribute-component-my-boolean-attribute-3\\"
        ></my-boolean-attribute-component>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-my-boolean-attribute']\\")
      .forEach((el) => {
        const whenCondition = this.props.children;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-boolean-attribute-2']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.type);
      });

    this._root
      .querySelectorAll(
        \\"[data-el='my-boolean-attribute-component-my-boolean-attribute']\\"
      )
      .forEach((el) => {
        el.setAttribute(\\"toggle\\", true);
        el.toggle = true;

        if (el.props) {
          el.props.toggle = true;

          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.toggle = true;
        }
      });

    this._root
      .querySelectorAll(
        \\"[data-el='my-boolean-attribute-component-my-boolean-attribute-2']\\"
      )
      .forEach((el) => {
        el.setAttribute(\\"toggle\\", true);
        el.toggle = true;

        if (el.props) {
          el.props.toggle = true;

          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.toggle = true;
        }
      });

    this._root
      .querySelectorAll(
        \\"[data-el='my-boolean-attribute-component-my-boolean-attribute-3']\\"
      )
      .forEach((el) => {
        el.setAttribute(\\"list\\", null);
        el.list = null;

        if (el.props) {
          el.props.list = null;

          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.list = null;
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-boolean-attribute\\", MyBooleanAttribute);
"
`;

exports[`webcomponent > jsx > Typescript Test > BasicChildComponent 1`] = `
"import MyBasicOnMountUpdateComponent from \\"./basic-onMount-update.raw\\";
import MyBasicComponent from \\"./basic.raw\\";

/**
 * Usage:
 *
 *  <my-basic-child-component></my-basic-child-component>
 *
 */
class MyBasicChildComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"Steve\\", dev: \\"PatrickJS\\" };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <my-basic-component
          data-el=\\"my-basic-component-my-basic-child-component\\"
        ></my-basic-component>
        <div>
          <my-basic-on-mount-update-component
            data-el=\\"my-basic-on-mount-update-component-my-basic-child-component\\"
          ></my-basic-on-mount-update-component>
        </div>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(
        \\"[data-el='my-basic-component-my-basic-child-component']\\"
      )
      .forEach((el) => {
        el.setAttribute(\\"id\\", this.state.dev);
      });

    this._root
      .querySelectorAll(
        \\"[data-el='my-basic-on-mount-update-component-my-basic-child-component']\\"
      )
      .forEach((el) => {
        el.setAttribute(\\"hi\\", this.state.name);
        el.hi = this.state.name;

        if (el.props) {
          el.props.hi = this.state.name;

          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.hi = this.state.name;
        }

        el.setAttribute(\\"bye\\", this.state.dev);
        el.bye = this.state.dev;

        if (el.props) {
          el.props.bye = this.state.dev;

          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.bye = this.state.dev;
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-child-component\\", MyBasicChildComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > BasicFor 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-for-component></my-basic-for-component>
 *
 */
class MyBasicForComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-basic-for-component-1
    this.onInputMyBasicForComponent1Input = (event) => {
      const person = this.getScope(event.currentTarget, \\"person\\");

      this.state.name = event.target.value + \\" and \\" + person;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <template data-el=\\"for-my-basic-for-component\\">
          <input
            data-el=\\"input-my-basic-for-component-1\\"
            data-dom-state=\\"MyBasicForComponent-input-my-basic-for-component-1\\"
          />
      
          Hello
          <template data-el=\\"div-my-basic-for-component-1\\"><!-- person --></template>
          ! I can run in Qwik, Web Component, React, Vue, Solid, or Liquid!
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    console.log(\\"onMount code\\");
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='for-my-basic-for-component']\\")
      .forEach((el) => {
        let array = this.state.names;
        this.renderLoop(el, array, \\"person\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-for-component-1']\\")
      .forEach((el) => {
        el.value = this.state.name;
        el.removeEventListener(\\"input\\", this.onInputMyBasicForComponent1Input);
        el.addEventListener(\\"input\\", this.onInputMyBasicForComponent1Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-for-component-1']\\")
      .forEach((el) => {
        const person = this.getScope(el, \\"person\\");
        this.renderTextNode(el, person);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"my-basic-for-component\\", MyBasicForComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > BasicRef 1`] = `
"export interface Props {
  showInput: boolean;
}

/**
 * Usage:
 *
 *  <my-basic-ref-component></my-basic-ref-component>
 *
 */
class MyBasicRefComponent extends HTMLElement {
  get _inputRef() {
    return this._root.querySelector(
      \\"[data-ref='MyBasicRefComponent-inputRef']\\"
    );
  }

  get _inputNoArgRef() {
    return this._root.querySelector(
      \\"[data-ref='MyBasicRefComponent-inputNoArgRef']\\"
    );
  }

  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      name: \\"PatrickJS\\",
      onBlur: function onBlur() {
        // Maintain focus
        self._inputRef.focus();
      },
      lowerCaseName: function lowerCaseName() {
        return self.state.name.toLowerCase();
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"showInput\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'blur' event on input-my-basic-ref-component-1
    this.onInputMyBasicRefComponent1Blur = (event) => {
      this.state.onBlur();
    };

    // Event handler for 'input' event on input-my-basic-ref-component-1
    this.onInputMyBasicRefComponent1Input = (event) => {
      this.state.name = event.target.value;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"show-my-basic-ref-component\\">
          <input
            class=\\"input-my-basic-ref-component\\"
            data-el=\\"input-my-basic-ref-component-1\\"
            data-dom-state=\\"MyBasicRefComponent-input-my-basic-ref-component-1\\"
            data-ref=\\"MyBasicRefComponent-inputRef\\"
          />
          <label
            for=\\"cars\\"
            data-el=\\"label-my-basic-ref-component-1\\"
            data-ref=\\"MyBasicRefComponent-inputNoArgRef\\"
          >
            Choose a car:
          </label>
          <select
            name=\\"cars\\"
            id=\\"cars\\"
            data-dom-state=\\"MyBasicRefComponent-select-my-basic-ref-component-1\\"
          >
            <option value=\\"supra\\">GR Supra</option>
            <option value=\\"86\\">GR 86</option>
          </select>
        </template>
      
        Hello
      
        <template data-el=\\"div-my-basic-ref-component-1\\">
          <!-- state.lowerCaseName() -->
        </template>
        ! I can run in React, Qwik, Vue, Solid, or Web Component!
      </div>
      <style>
        .input-my-basic-ref-component {
          color: red;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-my-basic-ref-component']\\")
      .forEach((el) => {
        const whenCondition = this.props.showInput;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-ref-component-1']\\")
      .forEach((el) => {
        el.value = this.state.name;
        el.removeEventListener(\\"blur\\", this.onInputMyBasicRefComponent1Blur);
        el.addEventListener(\\"blur\\", this.onInputMyBasicRefComponent1Blur);
        el.removeEventListener(\\"input\\", this.onInputMyBasicRefComponent1Input);
        el.addEventListener(\\"input\\", this.onInputMyBasicRefComponent1Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-ref-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.lowerCaseName());
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-ref-component\\", MyBasicRefComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > BasicRefAssignment 1`] = `
"export interface Props {
  showInput: boolean;
}

/**
 * Usage:
 *
 *  <my-basic-ref-assignment-component></my-basic-ref-assignment-component>
 *
 */
class MyBasicRefAssignmentComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      handlerClick: function handlerClick(event: Event) {
        event.preventDefault();
        console.log(\\"current value\\", self._holdValueRef);
        self._holdValueRef = self._holdValueRef + \\"JS\\";
      },
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'click' event on button-my-basic-ref-assignment-component-1
    this.onButtonMyBasicRefAssignmentComponent1Click = (evt) => {
      this.state.handlerClick(evt);
    };

    this._holdValueRef = \\"Patrick\\";

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <button data-el=\\"button-my-basic-ref-assignment-component-1\\">Click</button>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(
        \\"[data-el='button-my-basic-ref-assignment-component-1']\\"
      )
      .forEach((el) => {
        el.removeEventListener(
          \\"click\\",
          this.onButtonMyBasicRefAssignmentComponent1Click
        );
        el.addEventListener(
          \\"click\\",
          this.onButtonMyBasicRefAssignmentComponent1Click
        );
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(
  \\"my-basic-ref-assignment-component\\",
  MyBasicRefAssignmentComponent
);
"
`;

exports[`webcomponent > jsx > Typescript Test > BasicRefPrevious 1`] = `
"export interface Props {
  showInput: boolean;
}

export function usePrevious<T>(value: T) {
  // The ref object is a generic container whose current property is mutable ...
  // ... and can hold any value, similar to an instance property on a class
  let ref = useRef<T>(null); // Store current value in ref

  onUpdate(() => {
    ref = value;
  }, [value]); // Only re-run if value changes
  // Return previous value (happens before update in useEffect above)

  return ref;
}

/**
 * Usage:
 *
 *  <my-previous-component></my-previous-component>
 *
 */
class MyPreviousComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { count: 0 };
    if (!this.props) {
      this.props = {};
    }

    this.updateDeps = [[this.state.count]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'click' event on button-my-previous-component-1
    this.onButtonMyPreviousComponent1Click = (event) => {
      this.state.count += 1;
      this.update();
    };

    this._prevCount = state.count;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <h1>
          Now:
          <template data-el=\\"div-my-previous-component-1\\">
            <!-- state.count -->
          </template>
          , before:
          <template data-el=\\"div-my-previous-component-2\\">
            <!-- self._prevCount -->
          </template>
        </h1>
        <button data-el=\\"button-my-previous-component-1\\">Increment</button>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        self._prevCount = self.state.count;
        self.updateDeps[0] = __next;
      }
    })(self.updateDeps[0], [self.state.count]);
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-previous-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.count);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-previous-component-2']\\")
      .forEach((el) => {
        this.renderTextNode(el, self._prevCount);
      });

    this._root
      .querySelectorAll(\\"[data-el='button-my-previous-component-1']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onButtonMyPreviousComponent1Click);
        el.addEventListener(\\"click\\", this.onButtonMyPreviousComponent1Click);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-previous-component\\", MyPreviousComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > Button 1`] = `
"export interface ButtonProps {
  attributes?: any;
  text?: string;
  link?: string;
  openLinkInNewTab?: boolean;
}

/**
 * Usage:
 *
 *  <button></button>
 *
 */
class Button extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"link\\", \\"attributes\\", \\"openLinkInNewTab\\", \\"text\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"show-button\\">
          <a data-el=\\"a-button-1\\">
            <template data-el=\\"div-button-1\\"><!-- props.text --></template>
          </a>
        </template>
        <template data-el=\\"show-button-2\\">
          <button type=\\"button\\" data-el=\\"button-button-1\\">
            <template data-el=\\"div-button-2\\"><!-- props.text --></template>
          </button>
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='show-button']\\").forEach((el) => {
      const whenCondition = this.props.link;

      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='a-button-1']\\").forEach((el) => {
      el.setAttribute(\\"href\\", this.props.link);
      el.setAttribute(
        \\"target\\",
        this.props.openLinkInNewTab ? \\"_blank\\" : undefined
      );
    });

    this._root.querySelectorAll(\\"[data-el='div-button-1']\\").forEach((el) => {
      this.renderTextNode(el, this.props.text);
    });

    this._root.querySelectorAll(\\"[data-el='show-button-2']\\").forEach((el) => {
      const whenCondition = !this.props.link;

      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='div-button-2']\\").forEach((el) => {
      this.renderTextNode(el, this.props.text);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"button\\", Button);
"
`;

exports[`webcomponent > jsx > Typescript Test > Columns 1`] = `
"type Column = {
  content: any; // TODO: Implement this when support for dynamic CSS lands

  width?: number;
};
export interface ColumnProps {
  columns?: Column[]; // TODO: Implement this when support for dynamic CSS lands

  space?: number; // TODO: Implement this when support for dynamic CSS lands

  stackColumnsAt?: \\"tablet\\" | \\"mobile\\" | \\"never\\"; // TODO: Implement this when support for dynamic CSS lands

  reverseColumnsWhenStacked?: boolean;
}

/**
 * Usage:
 *
 *  <column></column>
 *
 */
class Column extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      getColumns() {
        return self.props.columns || [];
      },
      getGutterSize() {
        return typeof self.props.space === \\"number\\"
          ? self.props.space || 0
          : 20;
      },
      getWidth(index: number) {
        const columns = self.state.getColumns();
        return (columns[index] && columns[index].width) || 100 / columns.length;
      },
      getColumnCssWidth(index: number) {
        const columns = self.state.getColumns();
        const gutterSize = self.state.getGutterSize();
        const subtractWidth =
          (gutterSize * (columns.length - 1)) / columns.length;
        return \`calc(\${self.state.getWidth(index)}% - \${subtractWidth}px)\`;
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"columns\\", \\"space\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div class=\\"builder-columns div-column\\">
        <template data-el=\\"for-column\\">
          <div class=\\"builder-column div-column-2\\">
            <template data-el=\\"div-column-1\\"><!-- column.content --></template>
            <template data-el=\\"div-column-2\\"><!-- index --></template>
          </div>
        </template>
      </div>
      <style>
        .div-column {
          display: flex;
          flex-direction: column;
          align-items: stretch;
          line-height: normal;
        }
        @media (max-width: 999px) {
          .div-column {
            flex-direction: row;
          }
        }
        @media (max-width: 639px) {
          .div-column {
            flex-direction: row-reverse;
          }
        }
        .div-column-2 {
          flex-grow: 1;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='for-column']\\").forEach((el) => {
      let array = this.props.columns;
      this.renderLoop(el, array, \\"column\\", \\"index\\");
    });

    this._root.querySelectorAll(\\"[data-el='div-column-1']\\").forEach((el) => {
      const column = this.getScope(el, \\"column\\");
      this.renderTextNode(el, column.content);
    });

    this._root.querySelectorAll(\\"[data-el='div-column-2']\\").forEach((el) => {
      const index = this.getScope(el, \\"index\\");
      this.renderTextNode(el, index);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"column\\", Column);
"
`;

exports[`webcomponent > jsx > Typescript Test > ContentSlotHtml 1`] = `
"type Props = {
  [key: string]: string | JSX.Element;
  slotTesting: JSX.Element;
};

import type { JSX } from \\"../../../../jsx-runtime\\";

/**
 * Usage:
 *
 *  <content-slot-code></content-slot-code>
 *
 */
class ContentSlotCode extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"slotTesting\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <slot data-el=\\"slot-content-slot-code\\"></slot>
        <div><hr /></div>
        <div><slot></slot></div>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='slot-content-slot-code']\\")
      .forEach((el) => {
        el.setAttribute(\\"name\\", this.props.slotTesting);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"content-slot-code\\", ContentSlotCode);
"
`;

exports[`webcomponent > jsx > Typescript Test > ContentSlotJSX 1`] = `
"type Props = {
  [key: string]: string | JSX.Element;
};

import type { JSX } from \\"../../../../jsx-runtime\\";

/**
 * Usage:
 *
 *  <content-slot-jsx-code></content-slot-jsx-code>
 *
 */
class ContentSlotJsxCode extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      name: \\"king\\",
      showContent: false,
      get cls() {
        return self.props.slotContent && self.props.children
          ? \`\${self.state.name}-content\`
          : \\"\\";
      },
      show() {
        self.props.slotContent ? 1 : \\"\\";
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"slotContent\\",
      \\"children\\",
      \\"slotReference\\",
      \\"attributes\\",
      \\"content\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'click' event on div-content-slot-jsx-code-1
    this.onDivContentSlotJsxCode1Click = (event) => {
      this.state.show();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"show-content-slot-jsx-code\\">
        <div data-el=\\"div-content-slot-jsx-code-1\\">
          <template data-el=\\"show-content-slot-jsx-code-2\\">
            <slot name=\\"content\\">
              <template data-el=\\"div-content-slot-jsx-code-2\\">
                <!-- props.content -->
              </template>
            </slot>
          </template>
          <div><hr /></div>
          <div><slot></slot></div>
        </div>
      </template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-content-slot-jsx-code']\\")
      .forEach((el) => {
        const whenCondition = this.props.slotReference;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='div-content-slot-jsx-code-1']\\")
      .forEach((el) => {
        el.setAttribute(\\"name\\", this.props.slotContent ? \\"name1\\" : \\"name2\\");
        el.setAttribute(\\"title\\", this.props.slotContent ? \\"title1\\" : \\"title2\\");
        el.removeEventListener(\\"click\\", this.onDivContentSlotJsxCode1Click);
        el.addEventListener(\\"click\\", this.onDivContentSlotJsxCode1Click);
        el.className = this.state.cls;
      });

    this._root
      .querySelectorAll(\\"[data-el='show-content-slot-jsx-code-2']\\")
      .forEach((el) => {
        const whenCondition = this.state.showContent && this.props.slotContent;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='div-content-slot-jsx-code-2']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.content);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"content-slot-jsx-code\\", ContentSlotJsxCode);
"
`;

exports[`webcomponent > jsx > Typescript Test > CustomCode 1`] = `
"export interface CustomCodeProps {
  code: string;
  replaceNodes?: boolean;
}

/**
 * Usage:
 *
 *  <custom-code></custom-code>
 *
 */
class CustomCode extends HTMLElement {
  get _elem() {
    return this._root.querySelector(\\"[data-ref='CustomCode-elem']\\");
  }

  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      scriptsInserted: [],
      scriptsRun: [],
      findAndRunScripts() {
        // TODO: Move this function to standalone one in '@builder.io/utils'
        if (self._elem && typeof window !== \\"undefined\\") {
          /** @type {HTMLScriptElement[]} */
          const scripts = self._elem.getElementsByTagName(\\"script\\");

          for (let i = 0; i < scripts.length; i++) {
            const script = scripts[i];

            if (script.src) {
              if (self.state.scriptsInserted.includes(script.src)) {
                continue;
              }

              self.state.scriptsInserted.push(script.src);
              const newScript = document.createElement(\\"script\\");
              newScript.async = true;
              newScript.src = script.src;
              document.head.appendChild(newScript);
            } else if (
              !script.type ||
              [
                \\"text/javascript\\",
                \\"application/javascript\\",
                \\"application/ecmascript\\",
              ].includes(script.type)
            ) {
              if (self.state.scriptsRun.includes(script.innerText)) {
                continue;
              }

              try {
                self.state.scriptsRun.push(script.innerText);
                new Function(script.innerText)();
              } catch (error) {
                console.warn(\\"\`CustomCode\`: Error running script:\\", error);
              }
            }
          }
        }
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"replaceNodes\\", \\"code\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div data-el=\\"div-custom-code-1\\" data-ref=\\"CustomCode-elem\\"></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    this.state.findAndRunScripts();
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-custom-code-1']\\")
      .forEach((el) => {
        el.className =
          \\"builder-custom-code\\" +
          (this.props.replaceNodes ? \\" replace-nodes\\" : \\"\\");
        el.innerHTML = this.props.code;
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"custom-code\\", CustomCode);
"
`;

exports[`webcomponent > jsx > Typescript Test > Embed 1`] = `
"export interface CustomCodeProps {
  code: string;
  replaceNodes?: boolean;
}

/**
 * Usage:
 *
 *  <custom-code></custom-code>
 *
 */
class CustomCode extends HTMLElement {
  get _elem() {
    return this._root.querySelector(\\"[data-ref='CustomCode-elem']\\");
  }

  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      scriptsInserted: [],
      scriptsRun: [],
      findAndRunScripts() {
        // TODO: Move this function to standalone one in '@builder.io/utils'
        if (self._elem && typeof window !== \\"undefined\\") {
          /** @type {HTMLScriptElement[]} */
          const scripts = self._elem.getElementsByTagName(\\"script\\");

          for (let i = 0; i < scripts.length; i++) {
            const script = scripts[i];

            if (script.src) {
              if (self.state.scriptsInserted.includes(script.src)) {
                continue;
              }

              self.state.scriptsInserted.push(script.src);
              const newScript = document.createElement(\\"script\\");
              newScript.async = true;
              newScript.src = script.src;
              document.head.appendChild(newScript);
            } else if (
              !script.type ||
              [
                \\"text/javascript\\",
                \\"application/javascript\\",
                \\"application/ecmascript\\",
              ].includes(script.type)
            ) {
              if (self.state.scriptsRun.includes(script.innerText)) {
                continue;
              }

              try {
                self.state.scriptsRun.push(script.innerText);
                new Function(script.innerText)();
              } catch (error) {
                console.warn(\\"\`CustomCode\`: Error running script:\\", error);
              }
            }
          }
        }
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"replaceNodes\\", \\"code\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div data-el=\\"div-custom-code-1\\" data-ref=\\"CustomCode-elem\\"></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    this.state.findAndRunScripts();
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-custom-code-1']\\")
      .forEach((el) => {
        el.className =
          \\"builder-custom-code\\" +
          (this.props.replaceNodes ? \\" replace-nodes\\" : \\"\\");
        el.innerHTML = this.props.code;
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"custom-code\\", CustomCode);
"
`;

exports[`webcomponent > jsx > Typescript Test > Image 1`] = `
"// TODO: AMP Support?
export interface ImageProps {
  _class?: string;
  image: string;
  sizes?: string;
  lazy?: boolean;
  height?: number;
  width?: number;
  altText?: string;
  backgroundSize?: string;
  backgroundPosition?: string; // TODO: Support generating Builder.io and or Shopify \`srcset\`s when needed

  srcset?: string; // TODO: Implement support for custom aspect ratios

  aspectRatio?: number; // TODO: This might not work as expected in terms of positioning

  children?: any;
}

/**
 * Usage:
 *
 *  <image></image>
 *
 */
class Image extends HTMLElement {
  get _pictureRef() {
    return this._root.querySelector(\\"[data-ref='Image-pictureRef']\\");
  }

  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      scrollListener: null,
      imageLoaded: false,
      setLoaded() {
        self.state.imageLoaded = true;
        self.update();
      },
      useLazyLoading() {
        // TODO: Add more checks here, like testing for real web browsers
        return !!self.props.lazy && self.state.isBrowser();
      },
      isBrowser: function isBrowser() {
        return (
          typeof window !== \\"undefined\\" &&
          window.navigator.product != \\"ReactNative\\"
        );
      },
      load: false,
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"lazy\\",
      \\"altText\\",
      \\"_class\\",
      \\"image\\",
      \\"srcset\\",
      \\"sizes\\",
      \\"children\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'load' event on img-image-1
    this.onImgImage1Load = (event) => {
      this.state.setLoaded();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  disconnectedCallback() {
    // onUnMount
    if (this.state.scrollListener) {
      window.removeEventListener(\\"scroll\\", this.state.scrollListener);
    }
    this.destroyAnyNodes(); // clean up nodes when component is destroyed
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <picture data-el=\\"picture-image-1\\" data-ref=\\"Image-pictureRef\\">
          <template data-el=\\"show-image\\"><img data-el=\\"img-image-1\\" /></template>
          <source data-el=\\"source-image-1\\" />
        </picture>
        <slot></slot>
      </div>
      <style>
        .img-image {
          opacity: 1;
          transition: opacity 0.2s ease-in-out;
          object-fit: cover;
          object-position: center;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {
    // onMount
    if (this.state.useLazyLoading()) {
      // throttled scroll capture listener
      const listener = () => {
        if (self._pictureRef) {
          const rect = self._pictureRef.getBoundingClientRect();

          const buffer = window.innerHeight / 2;

          if (rect.top < window.innerHeight + buffer) {
            this.state.load = true;
            this.update();
            this.state.scrollListener = null;
            this.update();
            window.removeEventListener(\\"scroll\\", listener);
          }
        }
      };

      this.state.scrollListener = listener;
      this.update();
      window.addEventListener(\\"scroll\\", listener, {
        capture: true,
        passive: true,
      });
      listener();
    }
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='show-image']\\").forEach((el) => {
      const whenCondition = !this.state.useLazyLoading() || this.state.load;

      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='img-image-1']\\").forEach((el) => {
      el.setAttribute(\\"alt\\", this.props.altText);
      el.setAttribute(
        \\"aria-role\\",
        this.props.altText ? \\"presentation\\" : undefined
      );
      el.className =
        \\"builder-image\\" +
        (this.props._class ? \\" \\" + this.props._class : \\"\\") +
        \\" img-image\\";
      el.setAttribute(\\"src\\", this.props.image);
      el.removeEventListener(\\"load\\", this.onImgImage1Load);
      el.addEventListener(\\"load\\", this.onImgImage1Load);
      el.setAttribute(\\"srcset\\", this.props.srcset);
      el.setAttribute(\\"sizes\\", this.props.sizes);
    });

    this._root.querySelectorAll(\\"[data-el='source-image-1']\\").forEach((el) => {
      el.setAttribute(\\"srcset\\", this.props.srcset);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"image\\", Image);
"
`;

exports[`webcomponent > jsx > Typescript Test > Image State 1`] = `
"/**
 * Usage:
 *
 *  <img-state-component></img-state-component>
 *
 */
class ImgStateComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { canShow: true, images: [\\"http://example.com/qwik.png\\"] };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <template data-el=\\"for-img-state-component\\">
          <img class=\\"custom-class\\" data-el=\\"img-img-state-component-1\\" />
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='for-img-state-component']\\")
      .forEach((el) => {
        let array = this.state.images;
        this.renderLoop(el, array, \\"item\\", \\"itemIndex\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='img-img-state-component-1']\\")
      .forEach((el) => {
        const item = this.getScope(el, \\"item\\");
        const itemIndex = this.getScope(el, \\"itemIndex\\");
        el.setAttribute(\\"src\\", item);
        el.key = itemIndex;
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"img-state-component\\", ImgStateComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > Img 1`] = `
"export interface ImgProps {
  attributes?: any;
  imgSrc?: string;
  altText?: string;
  backgroundSize?: \\"cover\\" | \\"contain\\";
  backgroundPosition?:
    | \\"center\\"
    | \\"top\\"
    | \\"left\\"
    | \\"right\\"
    | \\"bottom\\"
    | \\"top left\\"
    | \\"top right\\"
    | \\"bottom left\\"
    | \\"bottom right\\";
}

import { Builder } from \\"@builder.io/sdk\\";

/**
 * Usage:
 *
 *  <img-component></img-component>
 *
 */
class ImgComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"backgroundSize\\",
      \\"backgroundPosition\\",
      \\"attributes\\",
      \\"imgSrc\\",
      \\"altText\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <img data-el=\\"img-img-component-1\\" />\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='img-img-component-1']\\")
      .forEach((el) => {
        Object.assign(el.style, {
          objectFit: this.props.backgroundSize || \\"cover\\",
          objectPosition: this.props.backgroundPosition || \\"center\\",
        });
        el.key = (Builder.isEditing && this.props.imgSrc) || \\"default-key\\";
        el.setAttribute(\\"alt\\", this.props.altText);
        el.setAttribute(\\"src\\", this.props.imgSrc);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"img-component\\", ImgComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > Input 1`] = `
"export interface FormInputProps {
  type?: string;
  attributes?: any;
  name?: string;
  value?: string;
  placeholder?: string;
  defaultValue?: string;
  required?: boolean;
  onChange?: (value: string) => void;
}

import { Builder } from \\"@builder.io/sdk\\";

/**
 * Usage:
 *
 *  <form-input-component></form-input-component>
 *
 */
class FormInputComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"attributes\\",
      \\"defaultValue\\",
      \\"placeholder\\",
      \\"type\\",
      \\"name\\",
      \\"value\\",
      \\"required\\",
      \\"onChange\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-form-input-component-1
    this.onInputFormInputComponent1Input = (event) => {
      this.props.onChange?.(event.target.value);
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <input
        data-el=\\"input-form-input-component-1\\"
        data-dom-state=\\"FormInputComponent-input-form-input-component-1\\"
      />\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-form-input-component-1']\\")
      .forEach((el) => {
        el.key =
          Builder.isEditing && this.props.defaultValue
            ? this.props.defaultValue
            : \\"default-key\\";
        el.setAttribute(\\"placeholder\\", this.props.placeholder);
        el.setAttribute(\\"type\\", this.props.type);
        el.setAttribute(\\"name\\", this.props.name);
        el.value = this.props.value;
        el.setAttribute(\\"defaultValue\\", this.props.defaultValue);
        el.setAttribute(\\"required\\", this.props.required);
        el.removeEventListener(\\"input\\", this.onInputFormInputComponent1Input);
        el.addEventListener(\\"input\\", this.onInputFormInputComponent1Input);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"form-input-component\\", FormInputComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > InputParent 1`] = `
"import FormInputComponent from \\"./input.raw\\";

/**
 * Usage:
 *
 *  <stepper></stepper>
 *
 */
class Stepper extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      handleChange(value: string) {
        console.log(value);
      },
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'change' event on form-input-component-stepper
    this.onFormInputComponentStepperChange = (value) => {
      this.state.handleChange(value);
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <form-input-component
        name=\\"kingzez\\"
        type=\\"text\\"
        data-el=\\"form-input-component-stepper\\"
      ></form-input-component>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='form-input-component-stepper']\\")
      .forEach((el) => {
        el.removeEventListener(
          \\"change\\",
          this.onFormInputComponentStepperChange
        );
        el.addEventListener(\\"change\\", this.onFormInputComponentStepperChange);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"stepper\\", Stepper);
"
`;

exports[`webcomponent > jsx > Typescript Test > RawText 1`] = `
"export interface RawTextProps {
  attributes?: any;
  text?: string; // builderBlock?: any;
}

/**
 * Usage:
 *
 *  <raw-text></raw-text>
 *
 */
class RawText extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"attributes\\", \\"text\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <span data-el=\\"span-raw-text-1\\"></span>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='span-raw-text-1']\\").forEach((el) => {
      el.className =
        this.props.attributes?.class || this.props.attributes?.className;
      el.innerHTML = this.props.text || \\"\\";
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"raw-text\\", RawText);
"
`;

exports[`webcomponent > jsx > Typescript Test > Section 1`] = `
"export interface SectionProps {
  maxWidth?: number;
  attributes?: any;
  children?: any;
}

/**
 * Usage:
 *
 *  <section-component></section-component>
 *
 */
class SectionComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"attributes\\", \\"maxWidth\\", \\"children\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <section data-el=\\"section-section-component-1\\"><slot></slot></section>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='section-section-component-1']\\")
      .forEach((el) => {
        Object.assign(
          el.style,
          this.props.maxWidth && typeof this.props.maxWidth === \\"number\\"
            ? {
                maxWidth: this.props.maxWidth,
              }
            : undefined
        );
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"section-component\\", SectionComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > Section 2`] = `
"export interface SectionProps {
  maxWidth?: number;
  attributes?: any;
  children?: any;
}

/**
 * Usage:
 *
 *  <section-state-component></section-state-component>
 *
 */
class SectionStateComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { max: 42, items: [42] };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"attributes\\", \\"children\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"show-section-state-component\\">
        <template data-el=\\"for-section-state-component\\">
          <section data-el=\\"section-section-state-component-1\\"><slot></slot></section>
        </template>
      </template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-section-state-component']\\")
      .forEach((el) => {
        const whenCondition = this.state.max;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='for-section-state-component']\\")
      .forEach((el) => {
        let array = this.state.items;
        this.renderLoop(el, array, \\"item\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='section-section-state-component-1']\\")
      .forEach((el) => {
        const item = this.getScope(el, \\"item\\");
        Object.assign(el.style, {
          maxWidth: item + this.state.max,
        });
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"section-state-component\\", SectionStateComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > Select 1`] = `
"export interface FormSelectProps {
  options?: {
    name?: string;
    value: string;
  }[];
  attributes?: any;
  name?: string;
  value?: string;
  defaultValue?: string;
}

import { Builder } from \\"@builder.io/sdk\\";

/**
 * Usage:
 *
 *  <select-component></select-component>
 *
 */
class SelectComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"attributes\\",
      \\"value\\",
      \\"defaultValue\\",
      \\"name\\",
      \\"options\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <select
        data-el=\\"select-select-component-1\\"
        data-dom-state=\\"SelectComponent-select-select-component-1\\"
      >
        <template data-el=\\"for-select-component\\">
          <option data-el=\\"option-select-component-1\\">
            <template data-el=\\"div-select-component-1\\">
              <!-- option.name || option.value -->
            </template>
          </option>
        </template>
      </select>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='select-select-component-1']\\")
      .forEach((el) => {
        el.value = this.props.value;
        el.key =
          Builder.isEditing && this.props.defaultValue
            ? this.props.defaultValue
            : \\"default-key\\";
        el.setAttribute(\\"defaultValue\\", this.props.defaultValue);
        el.setAttribute(\\"name\\", this.props.name);
      });

    this._root
      .querySelectorAll(\\"[data-el='for-select-component']\\")
      .forEach((el) => {
        let array = this.props.options;
        this.renderLoop(el, array, \\"option\\", \\"index\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='option-select-component-1']\\")
      .forEach((el) => {
        const option = this.getScope(el, \\"option\\");
        const index = this.getScope(el, \\"index\\");
        el.value = option.value;
        el.setAttribute(\\"data-index\\", index);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-select-component-1']\\")
      .forEach((el) => {
        const option = this.getScope(el, \\"option\\");
        this.renderTextNode(el, option.name || option.value);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"select-component\\", SelectComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > SlotDefault 1`] = `
"type Props = {
  [key: string]: string;
};

/**
 * Usage:
 *
 *  <slot-code></slot-code>
 *
 */
class SlotCode extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <slot><div class=\\"default-slot\\">Default content</div></slot>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"slot-code\\", SlotCode);
"
`;

exports[`webcomponent > jsx > Typescript Test > SlotHtml 1`] = `
"type Props = {
  [key: string]: string;
};

import ContentSlotCode from \\"./content-slot-jsx.raw\\";

/**
 * Usage:
 *
 *  <slot-code></slot-code>
 *
 */
class SlotCode extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <content-slot-code><slot data-el=\\"slot-slot-code\\"></slot></content-slot-code>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='slot-slot-code']\\").forEach((el) => {
      el.setAttribute(\\"testing\\", <div>Hello</div>);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"slot-code\\", SlotCode);
"
`;

exports[`webcomponent > jsx > Typescript Test > SlotJsx 1`] = `
"type Props = {
  [key: string]: string;
};

import ContentSlotCode from \\"./content-slot-jsx.raw\\";

/**
 * Usage:
 *
 *  <slot-code></slot-code>
 *
 */
class SlotCode extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <content-slot-code data-el=\\"content-slot-code-slot-code\\"></content-slot-code>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='content-slot-code-slot-code']\\")
      .forEach((el) => {
        el.setAttribute(\\"slotTesting\\", <div>Hello</div>);
        el.slotTesting = <div>Hello</div>;

        if (el.props) {
          el.props.slotTesting = <div>Hello</div>;

          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.slotTesting = <div>Hello</div>;
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"slot-code\\", SlotCode);
"
`;

exports[`webcomponent > jsx > Typescript Test > SlotNamed 1`] = `
"type Props = {
  [key: string]: string;
};

/**
 * Usage:
 *
 *  <slot-code></slot-code>
 *
 */
class SlotCode extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <slot name=\\"myAwesomeSlot\\"></slot>
        <slot name=\\"top\\"></slot>
        <slot name=\\"left\\">Default left</slot>
        <slot>Default Child</slot>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"slot-code\\", SlotCode);
"
`;

exports[`webcomponent > jsx > Typescript Test > Stamped.io 1`] = `
"type SmileReviewsProps = {
  productId: string;
  apiKey: string;
};

import { kebabCase, snakeCase } from \\"lodash\\";

/**
 * Usage:
 *
 *  <smile-reviews></smile-reviews>
 *
 */
class SmileReviews extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      reviews: [],
      name: \\"test\\",
      showReviewPrompt: false,
      kebabCaseValue() {
        return kebabCase(\\"testThat\\");
      },
      snakeCaseValue() {
        return snakeCase(\\"testThis\\");
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"apiKey\\", \\"productId\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'click' event on button-smile-reviews-1
    this.onButtonSmileReviews1Click = (event) => {
      this.state.showReviewPrompt = true;
      this.update();
    };

    // Event handler for 'click' event on button-smile-reviews-2
    this.onButtonSmileReviews2Click = (event) => {
      event.preventDefault();
      this.state.showReviewPrompt = false;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div data-el=\\"div-smile-reviews-1\\">
        <button data-el=\\"button-smile-reviews-1\\">Write a review</button>
        <template data-el=\\"show-smile-reviews\\">
          <input
            placeholder=\\"Email\\"
            data-dom-state=\\"SmileReviews-input-smile-reviews-1\\"
          />
          <input
            placeholder=\\"Title\\"
            class=\\"input-smile-reviews\\"
            data-dom-state=\\"SmileReviews-input-smile-reviews-2\\"
          />
          <textarea
            placeholder=\\"How was your experience?\\"
            class=\\"textarea-smile-reviews\\"
            data-dom-state=\\"SmileReviews-textarea-smile-reviews-1\\"
          ></textarea>
          <button class=\\"button-smile-reviews\\" data-el=\\"button-smile-reviews-2\\">
            Submit
          </button>
        </template>
      
        <template data-el=\\"for-smile-reviews\\">
          <div class=\\"review-smile-reviews\\" data-el=\\"div-smile-reviews-2\\">
            <img class=\\"img-smile-reviews\\" data-el=\\"img-smile-reviews-1\\" />
            <div data-el=\\"div-smile-reviews-3\\">
              <div>
                N:
                <template data-el=\\"div-smile-reviews-4\\"><!-- index --></template>
              </div>
              <div>
                <template data-el=\\"div-smile-reviews-5\\">
                  <!-- review.author -->
                </template>
              </div>
              <div>
                <template data-el=\\"div-smile-reviews-6\\">
                  <!-- review.reviewMessage -->
                </template>
              </div>
            </div>
          </div>
        </template>
      </div>
      <style>
        .input-smile-reviews {
          display: block;
        }
        .textarea-smile-reviews {
          display: block;
        }
        .button-smile-reviews {
          display: block;
        }
        .review-smile-reviews {
          margin: 10px;
          padding: 10px;
          background: white;
          display: flex;
          border-radius: 5px;
          box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
          -webkit-font-smoothing: antialiased;
        }
        .img-smile-reviews {
          height: 30px;
          width: 30px;
          margin-right: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {
    // onMount
    fetch(
      \`https://stamped.io/api/widget/reviews?storeUrl=builder-io.myshopify.com&apiKey=\${
        this.props.apiKey || \\"pubkey-8bbDq7W6w4sB3OWeM1HUy2s47702hM\\"
      }&productId=\${this.props.productId || \\"2410511106127\\"}\`
    )
      .then((res) => res.json())
      .then((data) => {
        this.state.reviews = data.data;
        this.update();
      });
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-1']\\")
      .forEach((el) => {
        el.setAttribute(\\"data-user\\", this.state.name);
      });

    this._root
      .querySelectorAll(\\"[data-el='button-smile-reviews-1']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onButtonSmileReviews1Click);
        el.addEventListener(\\"click\\", this.onButtonSmileReviews1Click);
      });

    this._root
      .querySelectorAll(\\"[data-el='show-smile-reviews']\\")
      .forEach((el) => {
        const whenCondition = this.state.showReviewPrompt || \\"asdf\\";

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='button-smile-reviews-2']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onButtonSmileReviews2Click);
        el.addEventListener(\\"click\\", this.onButtonSmileReviews2Click);
      });

    this._root
      .querySelectorAll(\\"[data-el='for-smile-reviews']\\")
      .forEach((el) => {
        let array = this.state.reviews;
        this.renderLoop(el, array, \\"review\\", \\"index\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-2']\\")
      .forEach((el) => {
        const review = this.getScope(el, \\"review\\");
        el.key = review.id;
      });

    this._root
      .querySelectorAll(\\"[data-el='img-smile-reviews-1']\\")
      .forEach((el) => {
        const review = this.getScope(el, \\"review\\");
        el.setAttribute(\\"src\\", review.avatar);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-3']\\")
      .forEach((el) => {
        el.className = this.state.showReviewPrompt
          ? \\"bg-primary\\"
          : \\"bg-secondary\\";
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-4']\\")
      .forEach((el) => {
        const index = this.getScope(el, \\"index\\");
        this.renderTextNode(el, index);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-5']\\")
      .forEach((el) => {
        const review = this.getScope(el, \\"review\\");
        this.renderTextNode(el, review.author);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-smile-reviews-6']\\")
      .forEach((el) => {
        const review = this.getScope(el, \\"review\\");
        this.renderTextNode(el, review.reviewMessage);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"smile-reviews\\", SmileReviews);
"
`;

exports[`webcomponent > jsx > Typescript Test > Submit 1`] = `
"export interface ButtonProps {
  attributes?: any;
  text?: string;
}

/**
 * Usage:
 *
 *  <submit-button></submit-button>
 *
 */
class SubmitButton extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"attributes\\", \\"text\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <button type=\\"submit\\" data-el=\\"button-submit-button-1\\">
        <template data-el=\\"div-submit-button-1\\"><!-- props.text --></template>
      </button>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-submit-button-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.text);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"submit-button\\", SubmitButton);
"
`;

exports[`webcomponent > jsx > Typescript Test > Text 1`] = `
"export interface TextProps {
  attributes?: any;
  rtlMode: boolean;
  text?: string;
  content?: string;
  builderBlock?: any;
}

import { Builder } from \\"@builder.io/sdk\\";

/**
 * Usage:
 *
 *  <text></text>
 *
 */
class Text extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"Decadef20\\" };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"text\\", \\"content\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div data-el=\\"div-text-1\\"></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='div-text-1']\\").forEach((el) => {
      el.setAttribute(\\"contentEditable\\", allowEditingText || undefined);
      el.setAttribute(\\"data-name\\", {
        test: this.state.name || \\"any name\\",
      });
      el.innerHTML =
        this.props.text ||
        this.props.content ||
        this.state.name ||
        '<p class=\\"text-lg\\">my name</p>';
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"text\\", Text);
"
`;

exports[`webcomponent > jsx > Typescript Test > Textarea 1`] = `
"export interface TextareaProps {
  attributes?: any;
  name?: string;
  value?: string;
  defaultValue?: string;
  placeholder?: string;
}

/**
 * Usage:
 *
 *  <textarea></textarea>
 *
 */
class Textarea extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"attributes\\",
      \\"placeholder\\",
      \\"name\\",
      \\"value\\",
      \\"defaultValue\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <textarea
        data-el=\\"textarea-textarea-1\\"
        data-dom-state=\\"Textarea-textarea-textarea-1\\"
      ></textarea>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='textarea-textarea-1']\\")
      .forEach((el) => {
        el.setAttribute(\\"placeholder\\", this.props.placeholder);
        el.setAttribute(\\"name\\", this.props.name);
        el.value = this.props.value;
        el.setAttribute(\\"defaultValue\\", this.props.defaultValue);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"textarea\\", Textarea);
"
`;

exports[`webcomponent > jsx > Typescript Test > Video 1`] = `
"export interface VideoProps {
  attributes?: any;
  video?: string;
  autoPlay?: boolean;
  controls?: boolean;
  muted?: boolean;
  loop?: boolean;
  playsInline?: boolean;
  aspectRatio?: number;
  width?: number;
  height?: number;
  fit?: \\"contain\\" | \\"cover\\" | \\"fill\\";
  position?:
    | \\"center\\"
    | \\"top\\"
    | \\"left\\"
    | \\"right\\"
    | \\"bottom\\"
    | \\"top left\\"
    | \\"top right\\"
    | \\"bottom left\\"
    | \\"bottom right\\";
  posterImage?: string;
  lazyLoad?: boolean;
}

/**
 * Usage:
 *
 *  <video></video>
 *
 */
class Video extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"attributes\\",
      \\"fit\\",
      \\"position\\",
      \\"video\\",
      \\"posterImage\\",
      \\"autoPlay\\",
      \\"muted\\",
      \\"controls\\",
      \\"loop\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <video preload=\\"none\\" data-el=\\"video-video-1\\"></video>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='video-video-1']\\").forEach((el) => {
      Object.assign(el.style, {
        width: \\"100%\\",
        height: \\"100%\\",
        ...this.props.attributes?.style,
        objectFit: this.props.fit,
        objectPosition: this.props.position,
        // Hack to get object fit to work as expected and
        // not have the video overflow
        borderRadius: 1,
      });
      el.key = this.props.video || \\"no-src\\";
      el.setAttribute(\\"poster\\", this.props.posterImage);
      el.setAttribute(\\"autoplay\\", this.props.autoPlay);
      el.setAttribute(\\"muted\\", this.props.muted);
      el.setAttribute(\\"controls\\", this.props.controls);
      el.setAttribute(\\"loop\\", this.props.loop);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"video\\", Video);
"
`;

exports[`webcomponent > jsx > Typescript Test > arrowFunctionInUseStore 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      name: \\"steve\\",
      setName(value) {
        self.state.name = value;
        self.update();
      },
      updateNameWithArrowFn(value) {
        self.state.name = value;
        self.update();
      },
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        Hello
        <template data-el=\\"div-my-component-1\\"><!-- state.name --></template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > basicForNoTagReference 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-for-no-tag-ref-component></my-basic-for-no-tag-ref-component>
 *
 */
class MyBasicForNoTagRefComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      name: \\"VincentW\\",
      TagName: \\"div\\",
      tag: \\"span\\",
      get TagNameGetter() {
        return \\"span\\";
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"actions\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <state.TagNameGetter>
        Hello
        <state.tag>
          <template data-el=\\"div-my-basic-for-no-tag-ref-component-1\\">
            <!-- state.name -->
          </template>
        </state.tag>
      
        <template data-el=\\"for-my-basic-for-no-tag-ref-component\\">
          <state.TagName>
            <action.icon></action.icon>
            <span>
              <template data-el=\\"div-my-basic-for-no-tag-ref-component-2\\">
                <!-- action.text -->
              </template>
            </span>
          </state.TagName>
        </template>
      </state.TagNameGetter>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-for-no-tag-ref-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.name);
      });

    this._root
      .querySelectorAll(\\"[data-el='for-my-basic-for-no-tag-ref-component']\\")
      .forEach((el) => {
        let array = this.props.actions;
        this.renderLoop(el, array, \\"action\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-for-no-tag-ref-component-2']\\")
      .forEach((el) => {
        const action = this.getScope(el, \\"action\\");
        this.renderTextNode(el, action.text);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(
  \\"my-basic-for-no-tag-ref-component\\",
  MyBasicForNoTagRefComponent
);
"
`;

exports[`webcomponent > jsx > Typescript Test > basicForwardRef 1`] = `
"export interface Props {
  showInput: boolean;
  inputRef: HTMLInputElement;
}

/**
 * Usage:
 *
 *  <my-basic-forward-ref-component></my-basic-forward-ref-component>
 *
 */
class MyBasicForwardRefComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\" };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-basic-forward-ref-component-1
    this.onInputMyBasicForwardRefComponent1Input = (event) => {
      this.state.name = event.target.value;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <input
          class=\\"input-my-basic-forward-ref-component\\"
          data-el=\\"input-my-basic-forward-ref-component-1\\"
          data-dom-state=\\"MyBasicForwardRefComponent-input-my-basic-forward-ref-component-1\\"
        />
      </div>
      <style>
        .input-my-basic-forward-ref-component {
          color: red;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-forward-ref-component-1']\\")
      .forEach((el) => {
        el.value = this.state.name;
        el.removeEventListener(
          \\"input\\",
          this.onInputMyBasicForwardRefComponent1Input
        );
        el.addEventListener(
          \\"input\\",
          this.onInputMyBasicForwardRefComponent1Input
        );
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(
  \\"my-basic-forward-ref-component\\",
  MyBasicForwardRefComponent
);
"
`;

exports[`webcomponent > jsx > Typescript Test > basicForwardRefMetadata 1`] = `
"export interface Props {
  showInput: boolean;
  inputRef: HTMLInputElement;
}

/**
 * Usage:
 *
 *  <my-basic-forward-ref-component></my-basic-forward-ref-component>
 *
 */
class MyBasicForwardRefComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\" };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-basic-forward-ref-component-1
    this.onInputMyBasicForwardRefComponent1Input = (event) => {
      this.state.name = event.target.value;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <input
          class=\\"input-my-basic-forward-ref-component\\"
          data-el=\\"input-my-basic-forward-ref-component-1\\"
          data-dom-state=\\"MyBasicForwardRefComponent-input-my-basic-forward-ref-component-1\\"
        />
      </div>
      <style>
        .input-my-basic-forward-ref-component {
          color: red;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-my-basic-forward-ref-component-1']\\")
      .forEach((el) => {
        el.value = this.state.name;
        el.removeEventListener(
          \\"input\\",
          this.onInputMyBasicForwardRefComponent1Input
        );
        el.addEventListener(
          \\"input\\",
          this.onInputMyBasicForwardRefComponent1Input
        );
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(
  \\"my-basic-forward-ref-component\\",
  MyBasicForwardRefComponent
);
"
`;

exports[`webcomponent > jsx > Typescript Test > basicOnUpdateReturn 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-on-update-return-component></my-basic-on-update-return-component>
 *
 */
class MyBasicOnUpdateReturnComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\" };
    if (!this.props) {
      this.props = {};
    }

    this.updateDeps = [[this.state.name]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        Hello!
        <template data-el=\\"div-my-basic-on-update-return-component-1\\">
          <!-- state.name -->
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        const controller = new AbortController();
        const signal = controller.signal;
        fetch(\\"https://patrickjs.com/api/resource.json\\", {
          signal,
        })
          .then((response) => response.json())
          .then((data) => {
            self.state.name = data.name;
          });
        return () => {
          if (!signal.aborted) {
            controller.abort();
          }
        };
        self.updateDeps[0] = __next;
      }
    })(self.updateDeps[0], [self.state.name]);
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-on-update-return-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(
  \\"my-basic-on-update-return-component\\",
  MyBasicOnUpdateReturnComponent
);
"
`;

exports[`webcomponent > jsx > Typescript Test > class + ClassName + css 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div class=\\"test2 test div-my-basic-component\\">
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>
      <style>
        .div-my-basic-component {
          padding: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > class + css 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div class=\\"test div-my-basic-component\\">
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>
      <style>
        .div-my-basic-component {
          padding: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > className + css 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div class=\\"test div-my-basic-component\\">
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>
      <style>
        .div-my-basic-component {
          padding: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > className 1`] = `
"type Props = {
  [key: string]: string | JSX.Element;
  slotTesting: JSX.Element;
};

import type { JSX } from \\"../../../../jsx-runtime\\";

/**
 * Usage:
 *
 *  <class-name-code></class-name-code>
 *
 */
class ClassNameCode extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { bindings: \\"a binding\\" };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <div class=\\"no binding\\">Without Binding</div>
        <div data-el=\\"div-class-name-code-1\\">With binding</div>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-class-name-code-1']\\")
      .forEach((el) => {
        el.className = this.state.bindings;
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"class-name-code\\", ClassNameCode);
"
`;

exports[`webcomponent > jsx > Typescript Test > classState 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      classState: \\"testClassName\\",
      styleState: {
        color: \\"red\\",
      },
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div data-el=\\"div-my-basic-component-1\\">
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>
      <style>
        .div-my-basic-component {
          padding: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-1']\\")
      .forEach((el) => {
        el.className = this.state.classState + \\" div-my-basic-component\\";
        Object.assign(el.style, this.state.styleState);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > componentWithContext 1`] = `
"export interface ComponentWithContextProps {
  content: string;
}

import Context1 from \\"@dummy/1\\";
import Context2 from \\"@dummy/2\\";

/**
 * Usage:
 *
 *  <component-with-context></component-with-context>
 *
 */
class ComponentWithContext extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"content\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.foo = this.getContext(this._root, Context1);

    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"div-component-with-context-1\\"><!-- foo.value --></template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-component-with-context-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.foo.value);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // get Context Helper
  getContext(el, token) {
    do {
      let value;
      if (el?.context?.get) {
        value = el.context.get(token);
      } else if (el?.context?.[token]) {
        value = el.context[token];
      }
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }
}

customElements.define(\\"component-with-context\\", ComponentWithContext);
"
`;

exports[`webcomponent > jsx > Typescript Test > componentWithContextMultiRoot 1`] = `
"export interface ComponentWithContextProps {
  content: string;
}

import Context1 from \\"@dummy/1\\";
import Context2 from \\"@dummy/2\\";

/**
 * Usage:
 *
 *  <component-with-context></component-with-context>
 *
 */
class ComponentWithContext extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"content\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.foo = this.getContext(this._root, Context1);

    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"div-component-with-context-1\\"><!-- foo.value --></template>
      <div>other</div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-component-with-context-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.foo.value);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // get Context Helper
  getContext(el, token) {
    do {
      let value;
      if (el?.context?.get) {
        value = el.context.get(token);
      } else if (el?.context?.[token]) {
        value = el.context[token];
      }
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }
}

customElements.define(\\"component-with-context\\", ComponentWithContext);
"
`;

exports[`webcomponent > jsx > Typescript Test > contentState 1`] = `
"import BuilderContext from \\"@dummy/context.js\\";

/**
 * Usage:
 *
 *  <render-content></render-content>
 *
 */
class RenderContent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"content\\", \\"customComponents\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>setting context</div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"render-content\\", RenderContent);
"
`;

exports[`webcomponent > jsx > Typescript Test > defaultProps 1`] = `
"export interface ButtonProps {
  attributes?: any;
  text?: string;
  buttonText?: string; // no default value

  link?: string;
  openLinkInNewTab?: boolean;
  onClick?: () => void;
}

/**
 * Usage:
 *
 *  <button></button>
 *
 */
class Button extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"link\\",
      \\"attributes\\",
      \\"openLinkInNewTab\\",
      \\"text\\",
      \\"onClick\\",
      \\"buttonText\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'click' event on button-button-1
    this.onButtonButton1Click = (event) => {
      this.props.onClick(event);
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"show-button\\">
          <a data-el=\\"a-button-1\\">
            <template data-el=\\"div-button-1\\"><!-- props.text --></template>
          </a>
        </template>
        <template data-el=\\"show-button-2\\">
          <button type=\\"button\\" data-el=\\"button-button-1\\">
            <template data-el=\\"div-button-2\\"><!-- props.buttonText --></template>
          </button>
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='show-button']\\").forEach((el) => {
      const whenCondition = this.props.link;

      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='a-button-1']\\").forEach((el) => {
      el.setAttribute(\\"href\\", this.props.link);
      el.setAttribute(
        \\"target\\",
        this.props.openLinkInNewTab ? \\"_blank\\" : undefined
      );
    });

    this._root.querySelectorAll(\\"[data-el='div-button-1']\\").forEach((el) => {
      this.renderTextNode(el, this.props.text);
    });

    this._root.querySelectorAll(\\"[data-el='show-button-2']\\").forEach((el) => {
      const whenCondition = !this.props.link;

      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='button-button-1']\\").forEach((el) => {
      el.removeEventListener(\\"click\\", this.onButtonButton1Click);
      el.addEventListener(\\"click\\", this.onButtonButton1Click);
    });

    this._root.querySelectorAll(\\"[data-el='div-button-2']\\").forEach((el) => {
      this.renderTextNode(el, this.props.buttonText);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"button\\", Button);
"
`;

exports[`webcomponent > jsx > Typescript Test > defaultPropsOutsideComponent 1`] = `
"export interface ButtonProps {
  attributes?: any;
  text?: string;
  link?: string;
  openLinkInNewTab?: boolean;
  onClick: () => void;
}

/**
 * Usage:
 *
 *  <button></button>
 *
 */
class Button extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [
      \\"link\\",
      \\"attributes\\",
      \\"openLinkInNewTab\\",
      \\"text\\",
      \\"onClick\\",
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'click' event on button-button-1
    this.onButtonButton1Click = (event) => {
      this.props.onClick(event);
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"show-button\\">
          <a data-el=\\"a-button-1\\">
            <template data-el=\\"div-button-1\\"><!-- props.text --></template>
          </a>
        </template>
        <template data-el=\\"show-button-2\\">
          <button type=\\"button\\" data-el=\\"button-button-1\\">
            <template data-el=\\"div-button-2\\"><!-- props.text --></template>
          </button>
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='show-button']\\").forEach((el) => {
      const whenCondition = this.props.link;

      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='a-button-1']\\").forEach((el) => {
      el.setAttribute(\\"href\\", this.props.link);
      el.setAttribute(
        \\"target\\",
        this.props.openLinkInNewTab ? \\"_blank\\" : undefined
      );
    });

    this._root.querySelectorAll(\\"[data-el='div-button-1']\\").forEach((el) => {
      this.renderTextNode(el, this.props.text);
    });

    this._root.querySelectorAll(\\"[data-el='show-button-2']\\").forEach((el) => {
      const whenCondition = !this.props.link;

      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='button-button-1']\\").forEach((el) => {
      el.removeEventListener(\\"click\\", this.onButtonButton1Click);
      el.addEventListener(\\"click\\", this.onButtonButton1Click);
    });

    this._root.querySelectorAll(\\"[data-el='div-button-2']\\").forEach((el) => {
      this.renderTextNode(el, this.props.text);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"button\\", Button);
"
`;

exports[`webcomponent > jsx > Typescript Test > defaultValsWithTypes 1`] = `
"type Props = {
  name: string;
};

const DEFAULT_VALUES: Props = {
  name: \\"Sami\\",
};

/**
 * Usage:
 *
 *  <component-with-types></component-with-types>
 *
 */
class ComponentWithTypes extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"name\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        Hello
        <template data-el=\\"div-component-with-types-1\\">
          <!-- props.name || DEFAULT_VALUES.name -->
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-component-with-types-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.name || DEFAULT_VALUES.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"component-with-types\\", ComponentWithTypes);
"
`;

exports[`webcomponent > jsx > Typescript Test > expressionState 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      refToUse: !(self.props.componentRef instanceof Function)
        ? self.props.componentRef
        : null,
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"componentRef\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"div-my-component-1\\"><!-- state.refToUse --></template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.refToUse);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > getterState 1`] = `
"export interface ButtonProps {
  foo: string;
}

/**
 * Usage:
 *
 *  <button></button>
 *
 */
class Button extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      get foo2() {
        return self.props.foo + \\"foo\\";
      },
      get bar() {
        return \\"bar\\";
      },
      baz(i: number) {
        return i + self.state.foo2.length;
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"foo\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <p>
          <template data-el=\\"div-button-1\\"><!-- state.foo2 --></template>
        </p>
        <p>
          <template data-el=\\"div-button-2\\"><!-- state.bar --></template>
        </p>
        <p>
          <template data-el=\\"div-button-3\\"><!-- state.baz(1) --></template>
        </p>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='div-button-1']\\").forEach((el) => {
      this.renderTextNode(el, this.state.foo2);
    });

    this._root.querySelectorAll(\\"[data-el='div-button-2']\\").forEach((el) => {
      this.renderTextNode(el, this.state.bar);
    });

    this._root.querySelectorAll(\\"[data-el='div-button-3']\\").forEach((el) => {
      this.renderTextNode(el, this.state.baz(1));
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"button\\", Button);
"
`;

exports[`webcomponent > jsx > Typescript Test > import types 1`] = `
"type RenderContentProps = {
  options?: GetContentOptions;
  content: BuilderContent;
  renderContentProps: RenderBlockProps;
};

import { BuilderContent, GetContentOptions } from \\"@builder.io/sdk\\";
import RenderBlock, { RenderBlockProps } from \\"./builder-render-block.raw\\";

/**
 * Usage:
 *
 *  <render-content></render-content>
 *
 */
class RenderContent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      getRenderContentProps(block, index) {
        return {
          block: block,
          index: index,
        };
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"renderContentProps\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <render-block data-el=\\"render-block-render-content\\"></render-block>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"render-content\\", RenderContent);
"
`;

exports[`webcomponent > jsx > Typescript Test > multipleOnUpdate 1`] = `
"/**
 * Usage:
 *
 *  <multiple-on-update></multiple-on-update>
 *
 */
class MultipleOnUpdate extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.updateDeps = [[], []];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    console.log(\\"Runs on every update/rerender\\");

    console.log(\\"Runs on every update/rerender as well\\");
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"multiple-on-update\\", MultipleOnUpdate);
"
`;

exports[`webcomponent > jsx > Typescript Test > multipleOnUpdateWithDeps 1`] = `
"/**
 * Usage:
 *
 *  <multiple-on-update-with-deps></multiple-on-update-with-deps>
 *
 */
class MultipleOnUpdateWithDeps extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { a: \\"a\\", b: \\"b\\", c: \\"c\\", d: \\"d\\" };
    if (!this.props) {
      this.props = {};
    }

    this.updateDeps = [
      [this.state.a, this.state.b],
      [this.state.c, this.state.d],
    ];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        console.log(\\"Runs when a or b changes\\", self.state.a, self.state.b);

        if (self.state.a === \\"a\\") {
          self.state.a = \\"b\\";
        }
        self.updateDeps[0] = __next;
      }
    })(self.updateDeps[0], [self.state.a, self.state.b]);

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        console.log(\\"Runs when c or d changes\\", self.state.c, self.state.d);

        if (self.state.a === \\"a\\") {
          self.state.a = \\"b\\";
        }
        self.updateDeps[1] = __next;
      }
    })(self.updateDeps[1], [self.state.c, self.state.d]);
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"multiple-on-update-with-deps\\", MultipleOnUpdateWithDeps);
"
`;

exports[`webcomponent > jsx > Typescript Test > multipleSpreads 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      attrs: {
        hello: \\"world\\",
      },
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <input
        data-el=\\"input-my-basic-component-1\\"
        data-dom-state=\\"MyBasicComponent-input-my-basic-component-1\\"
      />\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > nestedShow 1`] = `
"interface Props {
  conditionA: boolean;
  conditionB: boolean;
}

/**
 * Usage:
 *
 *  <nested-show></nested-show>
 *
 */
class NestedShow extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"conditionA\\", \\"conditionB\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"show-nested-show\\">
        <template data-el=\\"show-nested-show-2\\">
          <div>if condition A and condition B</div>
        </template>
      </template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-nested-show']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-nested-show-2']\\")
      .forEach((el) => {
        const whenCondition = !this.props.conditionB;

        if (whenCondition) {
          this.showContent(el);
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"nested-show\\", NestedShow);
"
`;

exports[`webcomponent > jsx > Typescript Test > nestedStyles 1`] = `
"/**
 * Usage:
 *
 *  <nested-styles></nested-styles>
 *
 */
class NestedStyles extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div class=\\"div-nested-styles\\">Hello world</div>
      <style>
        .div-nested-styles {
          display: flex;
          --bar: red;
          color: var(--bar);
        }
        @media (max-width: env(--mobile)) {
          .div-nested-styles {
            display: block;
          }
        }
        .div-nested-styles:hover {
          display: flex;
        }
        .div-nested-styles:active {
          display: inline;
        }
        .div-nested-styles .nested-selector {
          display: grid;
        }
        .div-nested-styles .nested-selector:hover {
          display: block;
        }
        .div-nested-styles.nested-selector:active {
          display: inline-block;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"nested-styles\\", NestedStyles);
"
`;

exports[`webcomponent > jsx > Typescript Test > onEvent 1`] = `
"/**
 * Usage:
 *
 *  <embed></embed>
 *
 */
class Embed extends HTMLElement {
  get _elem() {
    return this._root.querySelector(\\"[data-ref='Embed-elem']\\");
  }

  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      foo(event) {
        console.log(\\"test2\\");
      },
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div class=\\"builder-embed\\" data-el=\\"div-embed-1\\" data-ref=\\"Embed-elem\\">
        <div>Test</div>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    self._elem.dispatchEvent(new CustomEvent(\\"initEditingBldr\\"));
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"embed\\", Embed);
"
`;

exports[`webcomponent > jsx > Typescript Test > onInit & onMount 1`] = `
"/**
 * Usage:
 *
 *  <on-init></on-init>
 *
 */
class OnInit extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.onInitOnce = false;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;
    this.onInit();
    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onInit() {
    if (!this.onInitOnce) {
      console.log(\\"onInit\\");
      this.onInitOnce = true;
    }
  }

  onMount() {
    // onMount
    console.log(\\"onMount\\");
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"on-init\\", OnInit);
"
`;

exports[`webcomponent > jsx > Typescript Test > onInit 1`] = `
"type Props = {
  name: string;
};

export const defaultValues = {
  name: \\"PatrickJS\\",
};

/**
 * Usage:
 *
 *  <on-init></on-init>
 *
 */
class OnInit extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.onInitOnce = false;

    this.state = { name: \\"\\" };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"name\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        Default name defined by parent
        <template data-el=\\"div-on-init-1\\"><!-- state.name --></template>
      </div>\`;
    this.pendingUpdate = true;
    this.onInit();
    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onInit() {
    if (!this.onInitOnce) {
      this.state.name = defaultValues.name || this.props.name;
      this.update();
      console.log(\\"set defaults with props\\");
      this.onInitOnce = true;
    }
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='div-on-init-1']\\").forEach((el) => {
      this.renderTextNode(el, this.state.name);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"on-init\\", OnInit);
"
`;

exports[`webcomponent > jsx > Typescript Test > onMount 1`] = `
"/**
 * Usage:
 *
 *  <comp></comp>
 *
 */
class Comp extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  disconnectedCallback() {
    // onUnMount
    console.log(\\"Runs on unMount\\");
    this.destroyAnyNodes(); // clean up nodes when component is destroyed
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    console.log(\\"Runs on mount\\");
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"comp\\", Comp);
"
`;

exports[`webcomponent > jsx > Typescript Test > onMountMultiple 1`] = `
"/**
 * Usage:
 *
 *  <comp></comp>
 *
 */
class Comp extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    const onMountHook_0 = () => {
      console.log(\\"Runs on mount\\");
    };

    onMountHook_0();

    const onMountHook_1 = () => {
      console.log(\\"Another one runs on Mount\\");
    };

    onMountHook_1();

    const onMountHook_2 = () => {
      console.log(\\"SSR runs on Mount\\");
    };

    onMountHook_2();
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"comp\\", Comp);
"
`;

exports[`webcomponent > jsx > Typescript Test > onUpdate 1`] = `
"/**
 * Usage:
 *
 *  <on-update></on-update>
 *
 */
class OnUpdate extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.updateDeps = [[]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    console.log(\\"Runs on every update/rerender\\");
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"on-update\\", OnUpdate);
"
`;

exports[`webcomponent > jsx > Typescript Test > onUpdateWithDeps 1`] = `
"type Props = {
  size: string;
};

/**
 * Usage:
 *
 *  <on-update-with-deps></on-update-with-deps>
 *
 */
class OnUpdateWithDeps extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { a: \\"a\\", b: \\"b\\" };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"size\\"];

    this.updateDeps = [[this.state.a, this.state.b, this.props.size]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        console.log(
          \\"Runs when a, b or size changes\\",
          self.state.a,
          self.state.b,
          self.props.size
        );
        self.updateDeps[0] = __next;
      }
    })(self.updateDeps[0], [self.state.a, self.state.b, self.props.size]);
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"on-update-with-deps\\", OnUpdateWithDeps);
"
`;

exports[`webcomponent > jsx > Typescript Test > preserveExportOrLocalStatement 1`] = `
"type Types = {
  s: any[];
};
interface IPost {
  len: number;
}
export interface MyBasicComponentProps {
  id: string;
}

const b = 3;
const foo = () => {};
export const a = 3;
export const bar = () => {};
export function run<T>(value: T) {}

/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > preserveTyping 1`] = `
"export type A = \\"test\\";
export interface C {
  n: \\"test\\";
}
type B = \\"test2\\";
interface D {
  n: \\"test\\";
}
export interface MyBasicComponentProps {
  name: string;
  age?: number;
}

/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"name\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        Hello! I can run in React, Vue, Solid, or Liquid!
        <template data-el=\\"div-my-basic-component-1\\"><!-- props.name --></template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > propsDestructure 1`] = `
"type Props = {
  children: any;
  type: string;
};

/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"Decadef20\\" };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"children\\", \\"type\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <slot></slot>
        <template data-el=\\"div-my-basic-component-2\\"><!-- props.type --></template>
      
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-2']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.type);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > propsInterface 1`] = `
"interface Person {
  name: string;
  age?: number;
}

/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"name\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        Hello! I can run in React, Vue, Solid, or Liquid!
        <template data-el=\\"div-my-basic-component-1\\"><!-- props.name --></template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > propsType 1`] = `
"type Person = {
  name: string;
  age?: number;
};

/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"name\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        Hello! I can run in React, Vue, Solid, or Liquid!
        <template data-el=\\"div-my-basic-component-1\\"><!-- props.name --></template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > referencingFunInsideHook 1`] = `
"/**
 * Usage:
 *
 *  <on-update></on-update>
 *
 */
class OnUpdate extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      foo: function foo(params) {},
      bar: function bar() {},
      zoo: function zoo() {
        const params = {
          cb: self.state.bar,
        };
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.updateDeps = [[]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    self.state.foo({
      someOption: self.state.bar,
    });
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"on-update\\", OnUpdate);
"
`;

exports[`webcomponent > jsx > Typescript Test > renderBlock 1`] = `
"export type RenderBlockProps = {
  block: BuilderBlock;
  context: BuilderContextInterface;
};

import { TARGET } from \\"../../constants/target.js\\";
import type {
  BuilderContextInterface,
  RegisteredComponent,
} from \\"../../context/types.js\\";
import { evaluate } from \\"../../functions/evaluate.js\\";
import { extractTextStyles } from \\"../../functions/extract-text-styles.js\\";
import { getBlockActions } from \\"../../functions/get-block-actions.js\\";
import { getBlockComponentOptions } from \\"../../functions/get-block-component-options.js\\";
import { getBlockProperties } from \\"../../functions/get-block-properties.js\\";
import { getBlockTag } from \\"../../functions/get-block-tag.js\\";
import { getProcessedBlock } from \\"../../functions/get-processed-block.js\\";
import { getReactNativeBlockStyles } from \\"../../functions/get-react-native-block-styles.js\\";
import type { BuilderBlock } from \\"../../types/builder-block.js\\";
import type { Nullable } from \\"../../types/typescript.js\\";
import BlockStyles from \\"./block-styles.js\\";
import { isEmptyHtmlElement } from \\"./render-block.helpers.js\\";
import RenderComponentWithContext from \\"./render-component-with-context.js\\";
import type { RenderComponentProps } from \\"./render-component.js\\";
import RenderComponent from \\"./render-component.js\\";
import RenderRepeatedBlock from \\"./render-repeated-block.js\\";
import type { RepeatData } from \\"./types.js\\";

/**
 * Usage:
 *
 *  <render-block></render-block>
 *
 */
class RenderBlock extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      get component() {
        const componentName = getProcessedBlock({
          block: self.props.block,
          state: self.props.context.state,
          context: self.props.context.context,
          shouldEvaluateBindings: false,
        }).component?.name;

        if (!componentName) {
          return null;
        }

        const ref = self.props.context.registeredComponents[componentName];

        if (!ref) {
          // TODO: Public doc page with more info about this message
          console.warn(\`
          Could not find a registered component named \\"\${componentName}\\". 
          If you registered it, is the file that registered it imported by the file that needs to render it?\`);
          return undefined;
        } else {
          return ref;
        }
      },
      get tag() {
        return getBlockTag(self.state.useBlock);
      },
      get useBlock() {
        return self.state.repeatItemData
          ? self.props.block
          : getProcessedBlock({
              block: self.props.block,
              state: self.props.context.state,
              context: self.props.context.context,
              shouldEvaluateBindings: true,
            });
      },
      get actions() {
        return getBlockActions({
          block: self.state.useBlock,
          state: self.props.context.state,
          context: self.props.context.context,
        });
      },
      get attributes() {
        const blockProperties = getBlockProperties(self.state.useBlock);
        return {
          ...blockProperties,
          ...(TARGET === \\"reactNative\\"
            ? {
                style: getReactNativeBlockStyles({
                  block: self.state.useBlock,
                  context: self.props.context,
                  blockStyles: blockProperties.style,
                }),
              }
            : {}),
        };
      },
      get shouldWrap() {
        return !self.state.component?.noWrap;
      },
      get renderComponentProps() {
        return {
          blockChildren: self.state.useChildren,
          componentRef: self.state.component?.component,
          componentOptions: {
            ...getBlockComponentOptions(self.state.useBlock),

            /**
             * These attributes are passed to the wrapper element when there is one. If \`noWrap\` is set to true, then
             * they are provided to the component itself directly.
             */
            ...(self.state.shouldWrap
              ? {}
              : {
                  attributes: {
                    ...self.state.attributes,
                    ...self.state.actions,
                  },
                }),
            customBreakpoints:
              self.state.childrenContext?.content?.meta?.breakpoints,
          },
          context: self.state.childrenContext,
        };
      },
      get useChildren() {
        // TO-DO: When should \`canHaveChildren\` dictate rendering?
        // This is currently commented out because some Builder components (e.g. Box) do not have \`canHaveChildren: true\`,
        // but still receive and need to render children.
        // return state.componentInfo?.canHaveChildren ? state.useBlock.children : [];
        return self.state.useBlock.children ?? [];
      },
      get childrenWithoutParentComponent() {
        /**
         * When there is no \`componentRef\`, there might still be children that need to be rendered. In this case,
         * we render them outside of \`componentRef\`.
         * NOTE: We make sure not to render this if \`repeatItemData\` is non-null, because that means we are rendering an array of
         * blocks, and the children will be repeated within those blocks.
         */
        const shouldRenderChildrenOutsideRef =
          !self.state.component?.component && !self.state.repeatItemData;
        return shouldRenderChildrenOutsideRef ? self.state.useChildren : [];
      },
      get repeatItemData() {
        /**
         * we don't use \`state.useBlock\` here because the processing done within its logic includes evaluating the block's bindings,
         * which will not work if there is a repeat.
         */
        const { repeat, ...blockWithoutRepeat } = self.props.block;

        if (!repeat?.collection) {
          return undefined;
        }

        const itemsArray = evaluate({
          code: repeat.collection,
          state: self.props.context.state,
          context: self.props.context.context,
        });

        if (!Array.isArray(itemsArray)) {
          return undefined;
        }

        const collectionName = repeat.collection.split(\\".\\").pop();
        const itemNameToUse =
          repeat.itemName ||
          (collectionName ? collectionName + \\"Item\\" : \\"item\\");
        const repeatArray = itemsArray.map<RepeatData>((item, index) => ({
          context: {
            ...self.props.context,
            state: {
              ...self.props.context.state,
              $index: index,
              $item: item,
              [itemNameToUse]: item,
              [\`$\${itemNameToUse}Index\`]: index,
            },
          },
          block: blockWithoutRepeat,
        }));
        return repeatArray;
      },
      get inheritedTextStyles() {
        if (TARGET !== \\"reactNative\\") {
          return {};
        }

        const styles = getReactNativeBlockStyles({
          block: self.state.useBlock,
          context: self.props.context,
          blockStyles: self.state.attributes.style,
        });
        return extractTextStyles(styles);
      },
      get childrenContext() {
        return {
          apiKey: self.props.context.apiKey,
          state: self.props.context.state,
          content: self.props.context.content,
          context: self.props.context.context,
          registeredComponents: self.props.context.registeredComponents,
          inheritedStyles: self.state.inheritedTextStyles,
        };
      },
      get renderComponentTag() {
        if (TARGET === \\"reactNative\\") {
          return RenderComponentWithContext;
        } else if (TARGET === \\"vue3\\") {
          // vue3 expects a string for the component tag
          return \\"RenderComponent\\";
        } else {
          return RenderComponent;
        }
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"block\\", \\"context\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"show-render-block\\">
        <template data-el=\\"show-render-block-2\\">
          <state.tag data-el=\\"state-tag-render-block\\"></state.tag>
        </template>
        <template data-el=\\"show-render-block-3\\">
          <template data-el=\\"for-render-block\\">
            <render-repeated-block
              data-el=\\"render-repeated-block-render-block\\"
            ></render-repeated-block>
          </template>
        </template>
        <template data-el=\\"show-render-block-4\\">
          <state.tag data-el=\\"state-tag-render-block-2\\">
            <state.renderComponentTag
              data-el=\\"state-render-component-tag-render-block\\"
            ></state.renderComponentTag>
      
            <template data-el=\\"for-render-block-2\\">
              <RenderBlock data-el=\\"render-block-render-block\\"></RenderBlock>
            </template>
      
            <template data-el=\\"for-render-block-3\\">
              <block-styles data-el=\\"block-styles-render-block\\"></block-styles>
            </template>
          </state.tag>
        </template>
      </template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-render-block']\\")
      .forEach((el) => {
        const whenCondition = this.state.shouldWrap;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-render-block-2']\\")
      .forEach((el) => {
        const whenCondition = isEmptyHtmlElement(this.state.tag);

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-render-block-3']\\")
      .forEach((el) => {
        const whenCondition =
          !isEmptyHtmlElement(this.state.tag) && this.state.repeatItemData;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='for-render-block']\\")
      .forEach((el) => {
        let array = this.state.repeatItemData;
        this.renderLoop(el, array, \\"data\\", \\"index\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='render-repeated-block-render-block']\\")
      .forEach((el) => {
        const index = this.getScope(el, \\"index\\");
        const data = this.getScope(el, \\"data\\");
        el.key = index;

        if (el.props) {
          el.props.key = index;

          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.key = index;
        }

        el.setAttribute(\\"repeatContext\\", data.context);
        el.repeatContext = data.context;

        if (el.props) {
          el.props.repeatContext = data.context;

          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.repeatContext = data.context;
        }

        el.setAttribute(\\"block\\", data.block);
        el.block = data.block;

        if (el.props) {
          el.props.block = data.block;

          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.block = data.block;
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-render-block-4']\\")
      .forEach((el) => {
        const whenCondition =
          !isEmptyHtmlElement(this.state.tag) && !this.state.repeatItemData;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='for-render-block-2']\\")
      .forEach((el) => {
        let array = this.state.childrenWithoutParentComponent;
        this.renderLoop(el, array, \\"child\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='render-block-render-block']\\")
      .forEach((el) => {
        const child = this.getScope(el, \\"child\\");
        el.key = \\"render-block-\\" + child.id;
        el.setAttribute(\\"block\\", child);
        el.setAttribute(\\"context\\", this.state.childrenContext);
      });

    this._root
      .querySelectorAll(\\"[data-el='for-render-block-3']\\")
      .forEach((el) => {
        let array = this.state.childrenWithoutParentComponent;
        this.renderLoop(el, array, \\"child\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='block-styles-render-block']\\")
      .forEach((el) => {
        const child = this.getScope(el, \\"child\\");
        el.key = \\"block-style-\\" + child.id;

        if (el.props) {
          el.props.key = \\"block-style-\\" + child.id;

          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.key = \\"block-style-\\" + child.id;
        }

        el.setAttribute(\\"block\\", child);
        el.block = child;

        if (el.props) {
          el.props.block = child;

          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.block = child;
        }

        el.setAttribute(\\"context\\", this.state.childrenContext);
        el.context = this.state.childrenContext;

        if (el.props) {
          el.props.context = this.state.childrenContext;

          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.context = this.state.childrenContext;
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"render-block\\", RenderBlock);
"
`;

exports[`webcomponent > jsx > Typescript Test > renderContentExample 1`] = `
"type Props = {
  customComponents: string[];
  content: {
    blocks: any[];
    id: string;
  };
};

import BuilderContext from \\"@dummy/context.js\\";
import {
  dispatchNewContentToVisualEditor,
  sendComponentsToVisualEditor,
  trackClick,
} from \\"@dummy/injection-js\\";
import RenderBlocks from \\"@dummy/RenderBlocks.js\\";

/**
 * Usage:
 *
 *  <render-content></render-content>
 *
 */
class RenderContent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"customComponents\\", \\"content\\"];

    this.updateDeps = [[this.props.content]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'click' event on div-render-content-1
    this.onDivRenderContent1Click = (event) => {
      trackClick(this.props.content.id);
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div class=\\"div-render-content\\" data-el=\\"div-render-content-1\\">
        <render-blocks data-el=\\"render-blocks-render-content\\"></render-blocks>
      </div>
      <style>
        .div-render-content {
          display: flex;
          flex-direction: columns;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    sendComponentsToVisualEditor(this.props.customComponents);
  }

  onUpdate() {
    const self = this;

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        dispatchNewContentToVisualEditor(self.props.content);
        self.updateDeps[0] = __next;
      }
    })(self.updateDeps[0], [self.props.content]);
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-render-content-1']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onDivRenderContent1Click);
        el.addEventListener(\\"click\\", this.onDivRenderContent1Click);
      });

    this._root
      .querySelectorAll(\\"[data-el='render-blocks-render-content']\\")
      .forEach((el) => {
        el.setAttribute(\\"blocks\\", this.props.content.blocks);
        el.blocks = this.props.content.blocks;

        if (el.props) {
          el.props.blocks = this.props.content.blocks;

          if (el.update) {
            el.update();
          }
        } else {
          el.props = {};
          el.props.blocks = this.props.content.blocks;
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"render-content\\", RenderContent);
"
`;

exports[`webcomponent > jsx > Typescript Test > rootFragmentMultiNode 1`] = `
"export interface ButtonProps {
  attributes?: any;
  text?: string;
  link?: string;
  openLinkInNewTab?: boolean;
}

/**
 * Usage:
 *
 *  <button></button>
 *
 */
class Button extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"link\\", \\"attributes\\", \\"openLinkInNewTab\\", \\"text\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"show-button\\">
        <a data-el=\\"a-button-1\\">
          <template data-el=\\"div-button-1\\"><!-- props.text --></template>
        </a>
      </template>
      <template data-el=\\"show-button-2\\">
        <button type=\\"button\\" data-el=\\"button-button-1\\">
          <template data-el=\\"div-button-2\\"><!-- props.text --></template>
        </button>
      </template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-el='show-button']\\").forEach((el) => {
      const whenCondition = this.props.link;

      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='a-button-1']\\").forEach((el) => {
      el.setAttribute(\\"href\\", this.props.link);
      el.setAttribute(
        \\"target\\",
        this.props.openLinkInNewTab ? \\"_blank\\" : undefined
      );
    });

    this._root.querySelectorAll(\\"[data-el='div-button-1']\\").forEach((el) => {
      this.renderTextNode(el, this.props.text);
    });

    this._root.querySelectorAll(\\"[data-el='show-button-2']\\").forEach((el) => {
      const whenCondition = !this.props.link;

      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-el='div-button-2']\\").forEach((el) => {
      this.renderTextNode(el, this.props.text);
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"button\\", Button);
"
`;

exports[`webcomponent > jsx > Typescript Test > rootShow 1`] = `
"export interface RenderStylesProps {
  foo: string;
}

/**
 * Usage:
 *
 *  <render-styles></render-styles>
 *
 */
class RenderStyles extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"foo\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"show-render-styles\\"><div>Bar</div></template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-render-styles']\\")
      .forEach((el) => {
        const whenCondition = this.props.foo === \\"bar\\";

        if (whenCondition) {
          this.showContent(el);
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"render-styles\\", RenderStyles);
"
`;

exports[`webcomponent > jsx > Typescript Test > self-referencing component 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"name\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"div-my-component-1\\"><!-- props.name --></template>
        <template data-el=\\"show-my-component\\">
          <MyComponent name=\\"Bruce Wayne\\"></MyComponent>
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.name);
      });

    this._root
      .querySelectorAll(\\"[data-el='show-my-component']\\")
      .forEach((el) => {
        const whenCondition = this.props.name === \\"Batman\\";

        if (whenCondition) {
          this.showContent(el);
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > self-referencing component with children 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"name\\", \\"children\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"div-my-component-1\\"><!-- props.name --></template>
        <slot></slot>
        <template data-el=\\"show-my-component\\">
          <MyComponent name=\\"Bruce\\"><div>Wayne</div></MyComponent>
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.name);
      });

    this._root
      .querySelectorAll(\\"[data-el='show-my-component']\\")
      .forEach((el) => {
        const whenCondition = this.props.name === \\"Batman\\";

        if (whenCondition) {
          this.showContent(el);
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > showExpressions 1`] = `
"interface Props {
  conditionA: boolean;
  conditionB: boolean;
}

/**
 * Usage:
 *
 *  <show-with-other-values></show-with-other-values>
 *
 */
class ShowWithOtherValues extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"conditionA\\", \\"conditionB\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"show-show-with-other-values\\">Content0</template>
        <template data-el=\\"show-show-with-other-values-2\\">ContentA</template>
        <template data-el=\\"show-show-with-other-values-3\\"></template>
        <template data-el=\\"show-show-with-other-values-4\\">ContentB</template>
        <template data-el=\\"show-show-with-other-values-5\\">
          <template data-el=\\"div-show-with-other-values-1\\">
            <!-- undefined -->
          </template>
        </template>
        <template data-el=\\"show-show-with-other-values-6\\">ContentC</template>
        <template data-el=\\"show-show-with-other-values-7\\"></template>
        <template data-el=\\"show-show-with-other-values-8\\">ContentD</template>
        <template data-el=\\"show-show-with-other-values-9\\"></template>
        <template data-el=\\"show-show-with-other-values-10\\">ContentE</template>
        <template data-el=\\"show-show-with-other-values-11\\">hello</template>
        <template data-el=\\"show-show-with-other-values-12\\">ContentF</template>
        <template data-el=\\"show-show-with-other-values-13\\">123</template>
        <template data-el=\\"show-show-with-other-values-14\\">4mb</template>
        <template data-el=\\"show-show-with-other-values-15\\">
          <template data-el=\\"show-show-with-other-values-16\\">20mb</template>
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-2']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-3']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-4']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-5']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='div-show-with-other-values-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, undefined);
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-6']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-7']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-8']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-9']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-10']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-11']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-12']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-13']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-14']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA === \\"Default\\";

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-15']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA === \\"Default\\";

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-16']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionB === \\"Complete\\";

        if (whenCondition) {
          this.showContent(el);
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"show-with-other-values\\", ShowWithOtherValues);
"
`;

exports[`webcomponent > jsx > Typescript Test > showWithFor 1`] = `
"interface Props {
  conditionA: boolean;
  items: string[];
}

/**
 * Usage:
 *
 *  <nested-show></nested-show>
 *
 */
class NestedShow extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"conditionA\\", \\"items\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"show-nested-show\\">
        <template data-el=\\"for-nested-show\\">
          <div data-el=\\"div-nested-show-1\\">
            <template data-el=\\"div-nested-show-2\\"><!-- item --></template>
          </div>
        </template>
      </template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-nested-show']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root.querySelectorAll(\\"[data-el='for-nested-show']\\").forEach((el) => {
      let array = this.props.items;
      this.renderLoop(el, array, \\"item\\", \\"idx\\");
    });

    this._root
      .querySelectorAll(\\"[data-el='div-nested-show-1']\\")
      .forEach((el) => {
        const idx = this.getScope(el, \\"idx\\");
        el.key = idx;
      });

    this._root
      .querySelectorAll(\\"[data-el='div-nested-show-2']\\")
      .forEach((el) => {
        const item = this.getScope(el, \\"item\\");
        this.renderTextNode(el, item);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"nested-show\\", NestedShow);
"
`;

exports[`webcomponent > jsx > Typescript Test > showWithOtherValues 1`] = `
"interface Props {
  conditionA: boolean;
}

/**
 * Usage:
 *
 *  <show-with-other-values></show-with-other-values>
 *
 */
class ShowWithOtherValues extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"conditionA\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"show-show-with-other-values\\">ContentA</template>
        <template data-el=\\"show-show-with-other-values-2\\">ContentB</template>
        <template data-el=\\"show-show-with-other-values-3\\">ContentC</template>
        <template data-el=\\"show-show-with-other-values-4\\">ContentD</template>
        <template data-el=\\"show-show-with-other-values-5\\">ContentE</template>
        <template data-el=\\"show-show-with-other-values-6\\">ContentF</template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-2']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-3']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-4']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-5']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='show-show-with-other-values-6']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"show-with-other-values\\", ShowWithOtherValues);
"
`;

exports[`webcomponent > jsx > Typescript Test > showWithRootText 1`] = `
"interface Props {
  conditionA: boolean;
}

/**
 * Usage:
 *
 *  <show-root-text></show-root-text>
 *
 */
class ShowRootText extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"conditionA\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <template data-el=\\"show-show-root-text\\">ContentA</template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-show-root-text']\\")
      .forEach((el) => {
        const whenCondition = this.props.conditionA;

        if (whenCondition) {
          this.showContent(el);
        }
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"show-root-text\\", ShowRootText);
"
`;

exports[`webcomponent > jsx > Typescript Test > signalsOnUpdate 1`] = `
"type Props = {
  id: string;
  foo: {
    bar: {
      baz: number;
    };
  };
};

/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"id\\", \\"foo\\"];

    this.updateDeps = [[this.props.id, this.props.foo.bar.baz]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div class=\\"test div-my-basic-component\\">
        <template data-el=\\"div-my-basic-component-1\\"><!-- props.id --></template>
        <template data-el=\\"div-my-basic-component-2\\">
          <!-- props.foo.bar.baz -->
        </template>
      </div>
      <style>
        .div-my-basic-component {
          padding: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        console.log(\\"props.id changed\\", self.props.id);
        console.log(\\"props.foo.value.bar.baz changed\\", self.props.foo.bar.baz);
        self.updateDeps[0] = __next;
      }
    })(self.updateDeps[0], [self.props.id, self.props.foo.bar.baz]);
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.id);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-basic-component-2']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.foo.bar.baz);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > spreadAttrs 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <input
        data-el=\\"input-my-basic-component-1\\"
        data-dom-state=\\"MyBasicComponent-input-my-basic-component-1\\"
      />\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > spreadNestedProps 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"nested\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <input
        data-el=\\"input-my-basic-component-1\\"
        data-dom-state=\\"MyBasicComponent-input-my-basic-component-1\\"
      />\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > spreadProps 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <input
        data-el=\\"input-my-basic-component-1\\"
        data-dom-state=\\"MyBasicComponent-input-my-basic-component-1\\"
      />\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > styleClassAndCss 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div class=\\"builder-column div-my-component\\" data-el=\\"div-my-component-1\\"></div>
      <style>
        .div-my-component {
          display: flex;
          flex-direction: column;
          align-items: stretch;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-component-1']\\")
      .forEach((el) => {
        Object.assign(el.style, {
          width: \\"100%\\",
        });
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > stylePropClassAndCss 1`] = `
"/**
 * Usage:
 *
 *  <style-prop-class-and-css></style-prop-class-and-css>
 *
 */
class StylePropClassAndCss extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"attributes\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div data-el=\\"div-style-prop-class-and-css-1\\"></div>
      <style>
        .div-style-prop-class-and-css {
          display: flex;
          flex-direction: column;
          align-items: stretch;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-style-prop-class-and-css-1']\\")
      .forEach((el) => {
        Object.assign(el.style, this.props.attributes.style);
        el.className =
          this.props.attributes.class + \\" div-style-prop-class-and-css\\";
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"style-prop-class-and-css\\", StylePropClassAndCss);
"
`;

exports[`webcomponent > jsx > Typescript Test > subComponent 1`] = `
"import Foo from \\"./foo-sub-component.js\\";

/**
 * Usage:
 *
 *  <sub-component></sub-component>
 *
 */
class SubComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <foo></foo>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"sub-component\\", SubComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > svgComponent 1`] = `
"/**
 * Usage:
 *
 *  <svg-component></svg-component>
 *
 */
class SvgComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <svg fill=\\"none\\" role=\\"img\\" data-el=\\"svg-svg-component-1\\">
        <defs>
          <filter id=\\"prefix__filter0_f\\" filterUnits=\\"userSpaceOnUse\\">
            <feFlood result=\\"BackgroundImageFix\\"></feFlood>
            <feBlend
              in=\\"SourceGraphic\\"
              in2=\\"BackgroundImageFix\\"
              result=\\"shape\\"
            ></feBlend>
            <feGaussianBlur
              result=\\"effect1_foregroundBlur\\"
              data-el=\\"fe-gaussian-blur-svg-component\\"
            ></feGaussianBlur>
          </filter>
        </defs>
      </svg>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='svg-svg-component-1']\\")
      .forEach((el) => {
        el.setAttribute(\\"viewBox\\", \\"0 0 \\" + 42 + \\" \\" + 42);
        el.setAttribute(\\"width\\", 42);
        el.setAttribute(\\"height\\", 42);
      });

    this._root
      .querySelectorAll(\\"[data-el='fe-gaussian-blur-svg-component']\\")
      .forEach((el) => {
        el.setAttribute(\\"stdDeviation\\", 7);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"svg-component\\", SvgComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > typeDependency 1`] = `
"export type TypeDependencyProps = {
  foo: Foo;
  foo2: Foo2;
};

import type { Foo } from \\"./foo-type\\";
import type { Foo as Foo2 } from \\"./type-export.js\\";

/**
 * Usage:
 *
 *  <type-dependency></type-dependency>
 *
 */
class TypeDependency extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"foo\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"div-type-dependency-1\\"><!-- props.foo --></template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-type-dependency-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.foo);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"type-dependency\\", TypeDependency);
"
`;

exports[`webcomponent > jsx > Typescript Test > use-style 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <button type=\\"button\\">Button</button>
      <style>
        button {
          background: blue;
          color: white;
          font-size: 12px;
          outline: 1px solid black;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > use-style-and-css 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <button type=\\"button\\" class=\\"button-my-component\\">Button</button>
      <style>
        button {
          font-size: 12px;
          outline: 1px solid black;
        }
      
        .button-my-component {
          background: blue;
          color: white;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > use-style-outside-component 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <button type=\\"button\\">Button</button>
      <style>
        button {
          background: blue;
          color: white;
          font-size: 12px;
          outline: 1px solid black;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > useTarget 1`] = `
"/**
 * Usage:
 *
 *  <use-target-component></use-target-component>
 *
 */
class UseTargetComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      get name() {
        const prefix = \\"c\\";
        return prefix + \\"foo\\";
      },
      lastName: \\"bar\\",
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <template data-el=\\"div-use-target-component-1\\"><!-- state.name --></template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-use-target-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.name);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"use-target-component\\", UseTargetComponent);
"
`;

exports[`webcomponent > jsx > Typescript Test > webComponent 1`] = `
"import { register } from \\"swiper/element/bundle\\";

/**
 * Usage:
 *
 *  <my-basic-web-component></my-basic-web-component>
 *
 */
class MyBasicWebComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.onInitOnce = false;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <swiper-container slides-per-view=\\"3\\" navigation=\\"true\\" pagination=\\"true\\">
        <swiper-slide>Slide 1</swiper-slide>
        <swiper-slide>Slide 2</swiper-slide>
        <swiper-slide>Slide 3</swiper-slide>
      </swiper-container>\`;
    this.pendingUpdate = true;
    this.onInit();
    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onInit() {
    if (!this.onInitOnce) {
      register();
      this.onInitOnce = true;
    }
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-web-component\\", MyBasicWebComponent);
"
`;

exports[`webcomponent > svelte > Javascript Test > basic 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"Steve\\" };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-component-1
    this.onInputMyComponent1Input = (event) => {
      this.state.name = event.target.value;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <input
          data-el=\\"input-my-component-1\\"
          data-dom-state=\\"MyComponent-input-my-component-1\\"
        />
      
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-my-component-1']\\")
      .forEach((el) => {
        el.removeEventListener(\\"input\\", this.onInputMyComponent1Input);
        el.addEventListener(\\"input\\", this.onInputMyComponent1Input);
        el.value = this.state.name;
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Javascript Test > bindGroup 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { tortilla: \\"Plain\\", fillings: [] };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-component-1
    this.onInputMyComponent1Input = (event) => {
      this.state.tortilla = event.target.value;
      this.update();
    };

    // Event handler for 'input' event on input-my-component-2
    this.onInputMyComponent2Input = (event) => {
      this.state.tortilla = event.target.value;
      this.update();
    };

    // Event handler for 'input' event on input-my-component-3
    this.onInputMyComponent3Input = (event) => {
      this.state.tortilla = event.target.value;
      this.update();
    };

    // Event handler for 'input' event on input-my-component-4
    this.onInputMyComponent4Input = (event) => {
      this.state.fillings = event.target.value;
      this.update();
    };

    // Event handler for 'input' event on input-my-component-5
    this.onInputMyComponent5Input = (event) => {
      this.state.fillings = event.target.value;
      this.update();
    };

    // Event handler for 'input' event on input-my-component-6
    this.onInputMyComponent6Input = (event) => {
      this.state.fillings = event.target.value;
      this.update();
    };

    // Event handler for 'input' event on input-my-component-7
    this.onInputMyComponent7Input = (event) => {
      this.state.fillings = event.target.value;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <input
          type=\\"radio\\"
          value=\\"Plain\\"
          data-el=\\"input-my-component-1\\"
          data-dom-state=\\"MyComponent-input-my-component-1\\"
        />
        <input
          type=\\"radio\\"
          value=\\"Whole wheat\\"
          data-el=\\"input-my-component-2\\"
          data-dom-state=\\"MyComponent-input-my-component-2\\"
        />
        <input
          type=\\"radio\\"
          value=\\"Spinach\\"
          data-el=\\"input-my-component-3\\"
          data-dom-state=\\"MyComponent-input-my-component-3\\"
        />
        <br />
        <br />
        <input
          type=\\"checkbox\\"
          value=\\"Rice\\"
          data-el=\\"input-my-component-4\\"
          data-dom-state=\\"MyComponent-input-my-component-4\\"
        />
        <input
          type=\\"checkbox\\"
          value=\\"Beans\\"
          data-el=\\"input-my-component-5\\"
          data-dom-state=\\"MyComponent-input-my-component-5\\"
        />
        <input
          type=\\"checkbox\\"
          value=\\"Cheese\\"
          data-el=\\"input-my-component-6\\"
          data-dom-state=\\"MyComponent-input-my-component-6\\"
        />
        <input
          type=\\"checkbox\\"
          value=\\"Guac (extra)\\"
          data-el=\\"input-my-component-7\\"
          data-dom-state=\\"MyComponent-input-my-component-7\\"
        />
        <p>
          Tortilla:
          <template data-el=\\"div-my-component-1\\"><!-- state.tortilla --></template>
        </p>
        <p>
          Fillings:
          <template data-el=\\"div-my-component-2\\"><!-- state.fillings --></template>
        </p>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-my-component-1']\\")
      .forEach((el) => {
        el.setAttribute(\\"checked\\", this.state.tortilla === \\"Plain\\");
        el.removeEventListener(\\"input\\", this.onInputMyComponent1Input);
        el.addEventListener(\\"input\\", this.onInputMyComponent1Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-component-2']\\")
      .forEach((el) => {
        el.setAttribute(\\"checked\\", this.state.tortilla === \\"Whole wheat\\");
        el.removeEventListener(\\"input\\", this.onInputMyComponent2Input);
        el.addEventListener(\\"input\\", this.onInputMyComponent2Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-component-3']\\")
      .forEach((el) => {
        el.setAttribute(\\"checked\\", this.state.tortilla === \\"Spinach\\");
        el.removeEventListener(\\"input\\", this.onInputMyComponent3Input);
        el.addEventListener(\\"input\\", this.onInputMyComponent3Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-component-4']\\")
      .forEach((el) => {
        el.setAttribute(\\"checked\\", this.state.fillings === \\"Rice\\");
        el.removeEventListener(\\"input\\", this.onInputMyComponent4Input);
        el.addEventListener(\\"input\\", this.onInputMyComponent4Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-component-5']\\")
      .forEach((el) => {
        el.setAttribute(\\"checked\\", this.state.fillings === \\"Beans\\");
        el.removeEventListener(\\"input\\", this.onInputMyComponent5Input);
        el.addEventListener(\\"input\\", this.onInputMyComponent5Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-component-6']\\")
      .forEach((el) => {
        el.setAttribute(\\"checked\\", this.state.fillings === \\"Cheese\\");
        el.removeEventListener(\\"input\\", this.onInputMyComponent6Input);
        el.addEventListener(\\"input\\", this.onInputMyComponent6Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-component-7']\\")
      .forEach((el) => {
        el.setAttribute(\\"checked\\", this.state.fillings === \\"Guac (extra)\\");
        el.removeEventListener(\\"input\\", this.onInputMyComponent7Input);
        el.addEventListener(\\"input\\", this.onInputMyComponent7Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.tortilla);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-component-2']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.fillings);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Javascript Test > bindProperty 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { value: \\"hello\\" };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <input
        data-el=\\"input-my-component-1\\"
        data-dom-state=\\"MyComponent-input-my-component-1\\"
      />\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-my-component-1']\\")
      .forEach((el) => {
        el.value = this.state.value;
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Javascript Test > classDirective 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { focus: true };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"disabled\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <input
        data-el=\\"input-my-component-1\\"
        data-dom-state=\\"MyComponent-input-my-component-1\\"
      />\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-my-component-1']\\")
      .forEach((el) => {
        el.className = \`form-input \${this.props.disabled ? \\"disabled\\" : \\"\\"} \${
          this.state.focus ? \\"focus\\" : \\"\\"
        }\`;
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Javascript Test > context 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;
    this.context = state.activeTab;

    this.state = { activeTab: 0 };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.disabled = this.getContext(this._root, \\"disabled\\");

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"div-my-component-1\\"><!-- state.activeTab --></template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.activeTab);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // get Context Helper
  getContext(el, token) {
    do {
      let value;
      if (el?.context?.get) {
        value = el.context.get(token);
      } else if (el?.context?.[token]) {
        value = el.context[token];
      }
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Javascript Test > each 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { numbers: [\\"one\\", \\"two\\", \\"three\\"] };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <ul>
        <template data-el=\\"for-my-component\\">
          <li>
            <template data-el=\\"div-my-component-1\\"><!-- num --></template>
          </li>
        </template>
      </ul>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='for-my-component']\\")
      .forEach((el) => {
        let array = this.state.numbers;
        this.renderLoop(el, array, \\"num\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-component-1']\\")
      .forEach((el) => {
        const num = this.getScope(el, \\"num\\");
        this.renderTextNode(el, num);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Javascript Test > eventHandlers 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      log: function log(msg = \\"hello\\") {
        console.log(msg);
      },
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'click' event on button-my-component-1
    this.onButtonMyComponent1Click = (a) => {
      this.state.log(\\"hi\\");
    };

    // Event handler for 'click' event on button-my-component-2
    this.onButtonMyComponent2Click = (event) => {
      this.state.log(event);
    };

    // Event handler for 'click' event on button-my-component-3
    this.onButtonMyComponent3Click = (event) => {
      this.state.log(event);
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <button data-el=\\"button-my-component-1\\">Log</button>
        <button data-el=\\"button-my-component-2\\">Log</button>
        <button data-el=\\"button-my-component-3\\">Log</button>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='button-my-component-1']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onButtonMyComponent1Click);
        el.addEventListener(\\"click\\", this.onButtonMyComponent1Click);
      });

    this._root
      .querySelectorAll(\\"[data-el='button-my-component-2']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onButtonMyComponent2Click);
        el.addEventListener(\\"click\\", this.onButtonMyComponent2Click);
      });

    this._root
      .querySelectorAll(\\"[data-el='button-my-component-3']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onButtonMyComponent3Click);
        el.addEventListener(\\"click\\", this.onButtonMyComponent3Click);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Javascript Test > html 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { html: \\"<b>bold</b>\\" };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div data-el=\\"div-my-component-1\\"></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-component-1']\\")
      .forEach((el) => {
        el.innerHTML = this.state.html;
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Javascript Test > ifElse 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      show: true,
      toggle: function toggle() {
        self.state.show = !self.state.show;
        self.update();
      },
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'click' event on button-my-component-1
    this.onButtonMyComponent1Click = (event) => {
      this.state.toggle(event);
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <template data-el=\\"show-my-component\\">
        <button data-el=\\"button-my-component-1\\">Hide</button>
      </template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-my-component']\\")
      .forEach((el) => {
        const whenCondition = this.state.show;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='button-my-component-1']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onButtonMyComponent1Click);
        el.addEventListener(\\"click\\", this.onButtonMyComponent1Click);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Javascript Test > imports 1`] = `
"import Button from \\"./Button.js\\";

/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { disabled: false };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <button type=\\"button\\" data-el=\\"button-my-component\\"><slot></slot></button>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='button-my-component']\\")
      .forEach((el) => {
        el.setAttribute(\\"disabled\\", this.state.disabled);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Javascript Test > lifecycleHooks 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.updateDeps = [[]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  disconnectedCallback() {
    // onUnMount
    console.log(\\"onDestroy\\");
    this.destroyAnyNodes(); // clean up nodes when component is destroyed
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    console.log(\\"onMount\\");
  }

  onUpdate() {
    const self = this;

    console.log(\\"onAfterUpdate\\");
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Javascript Test > reactive 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      name: \\"Steve\\",
      get lowercaseName() {
        return self.state.name.toLowerCase();
      },
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <input
          data-el=\\"input-my-component-1\\"
          data-dom-state=\\"MyComponent-input-my-component-1\\"
        />
      
        Lowercase:
        <template data-el=\\"div-my-component-1\\"><!-- state.lowercaseName --></template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-my-component-1']\\")
      .forEach((el) => {
        el.value = this.state.name;
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.lowercaseName);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Javascript Test > reactiveWithFn 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      a: 2,
      b: 5,
      result: null,
      calculateResult: function calculateResult(a_, b_) {
        self.state.result = a_ * b_;
        self.update();
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.updateDeps = [[this.state.a, this.state.b]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-component-1
    this.onInputMyComponent1Input = (event) => {
      this.state.a = event.target.value;
      this.update();
    };

    // Event handler for 'input' event on input-my-component-2
    this.onInputMyComponent2Input = (event) => {
      this.state.b = event.target.value;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <input
          type=\\"number\\"
          data-el=\\"input-my-component-1\\"
          data-dom-state=\\"MyComponent-input-my-component-1\\"
        />
        <input
          type=\\"number\\"
          data-el=\\"input-my-component-2\\"
          data-dom-state=\\"MyComponent-input-my-component-2\\"
        />
      
        Result:
        <template data-el=\\"div-my-component-1\\"><!-- state.result --></template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        self.state.calculateResult(self.state.a, self.state.b);
        self.updateDeps[0] = __next;
      }
    })(self.updateDeps[0], [self.state.a, self.state.b]);
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-my-component-1']\\")
      .forEach((el) => {
        el.removeEventListener(\\"input\\", this.onInputMyComponent1Input);
        el.addEventListener(\\"input\\", this.onInputMyComponent1Input);
        el.value = this.state.a;
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-component-2']\\")
      .forEach((el) => {
        el.removeEventListener(\\"input\\", this.onInputMyComponent2Input);
        el.addEventListener(\\"input\\", this.onInputMyComponent2Input);
        el.value = this.state.b;
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.result);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Javascript Test > slots 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <slot>default</slot>
        <slot name=\\"Test\\"><div>default</div></slot>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Javascript Test > style 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <input class=\\"form-input\\" data-dom-state=\\"MyComponent-input-my-component-1\\" />
      <style>
        input {
          color: red;
          font-size: 12px;
        }
      
        .form-input:focus {
          outline: 1px solid blue;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Javascript Test > textExpressions 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { a: 5, b: 12 };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        normal:
      
        <template data-el=\\"div-my-component-1\\"><!-- state.a + state.b --></template>
        <br />
      
        conditional
      
        <template data-el=\\"div-my-component-2\\">
          <!-- state.a > 2 ? 'hello' : 'bye' -->
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.a + this.state.b);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-component-2']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.a > 2 ? \\"hello\\" : \\"bye\\");
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Typescript Test > basic 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { name: \\"Steve\\" };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-component-1
    this.onInputMyComponent1Input = (event) => {
      this.state.name = event.target.value;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <input
          data-el=\\"input-my-component-1\\"
          data-dom-state=\\"MyComponent-input-my-component-1\\"
        />
      
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-my-component-1']\\")
      .forEach((el) => {
        el.removeEventListener(\\"input\\", this.onInputMyComponent1Input);
        el.addEventListener(\\"input\\", this.onInputMyComponent1Input);
        el.value = this.state.name;
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Typescript Test > bindGroup 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { tortilla: \\"Plain\\", fillings: [] };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-component-1
    this.onInputMyComponent1Input = (event) => {
      this.state.tortilla = event.target.value;
      this.update();
    };

    // Event handler for 'input' event on input-my-component-2
    this.onInputMyComponent2Input = (event) => {
      this.state.tortilla = event.target.value;
      this.update();
    };

    // Event handler for 'input' event on input-my-component-3
    this.onInputMyComponent3Input = (event) => {
      this.state.tortilla = event.target.value;
      this.update();
    };

    // Event handler for 'input' event on input-my-component-4
    this.onInputMyComponent4Input = (event) => {
      this.state.fillings = event.target.value;
      this.update();
    };

    // Event handler for 'input' event on input-my-component-5
    this.onInputMyComponent5Input = (event) => {
      this.state.fillings = event.target.value;
      this.update();
    };

    // Event handler for 'input' event on input-my-component-6
    this.onInputMyComponent6Input = (event) => {
      this.state.fillings = event.target.value;
      this.update();
    };

    // Event handler for 'input' event on input-my-component-7
    this.onInputMyComponent7Input = (event) => {
      this.state.fillings = event.target.value;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <input
          type=\\"radio\\"
          value=\\"Plain\\"
          data-el=\\"input-my-component-1\\"
          data-dom-state=\\"MyComponent-input-my-component-1\\"
        />
        <input
          type=\\"radio\\"
          value=\\"Whole wheat\\"
          data-el=\\"input-my-component-2\\"
          data-dom-state=\\"MyComponent-input-my-component-2\\"
        />
        <input
          type=\\"radio\\"
          value=\\"Spinach\\"
          data-el=\\"input-my-component-3\\"
          data-dom-state=\\"MyComponent-input-my-component-3\\"
        />
        <br />
        <br />
        <input
          type=\\"checkbox\\"
          value=\\"Rice\\"
          data-el=\\"input-my-component-4\\"
          data-dom-state=\\"MyComponent-input-my-component-4\\"
        />
        <input
          type=\\"checkbox\\"
          value=\\"Beans\\"
          data-el=\\"input-my-component-5\\"
          data-dom-state=\\"MyComponent-input-my-component-5\\"
        />
        <input
          type=\\"checkbox\\"
          value=\\"Cheese\\"
          data-el=\\"input-my-component-6\\"
          data-dom-state=\\"MyComponent-input-my-component-6\\"
        />
        <input
          type=\\"checkbox\\"
          value=\\"Guac (extra)\\"
          data-el=\\"input-my-component-7\\"
          data-dom-state=\\"MyComponent-input-my-component-7\\"
        />
        <p>
          Tortilla:
          <template data-el=\\"div-my-component-1\\"><!-- state.tortilla --></template>
        </p>
        <p>
          Fillings:
          <template data-el=\\"div-my-component-2\\"><!-- state.fillings --></template>
        </p>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-my-component-1']\\")
      .forEach((el) => {
        el.setAttribute(\\"checked\\", this.state.tortilla === \\"Plain\\");
        el.removeEventListener(\\"input\\", this.onInputMyComponent1Input);
        el.addEventListener(\\"input\\", this.onInputMyComponent1Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-component-2']\\")
      .forEach((el) => {
        el.setAttribute(\\"checked\\", this.state.tortilla === \\"Whole wheat\\");
        el.removeEventListener(\\"input\\", this.onInputMyComponent2Input);
        el.addEventListener(\\"input\\", this.onInputMyComponent2Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-component-3']\\")
      .forEach((el) => {
        el.setAttribute(\\"checked\\", this.state.tortilla === \\"Spinach\\");
        el.removeEventListener(\\"input\\", this.onInputMyComponent3Input);
        el.addEventListener(\\"input\\", this.onInputMyComponent3Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-component-4']\\")
      .forEach((el) => {
        el.setAttribute(\\"checked\\", this.state.fillings === \\"Rice\\");
        el.removeEventListener(\\"input\\", this.onInputMyComponent4Input);
        el.addEventListener(\\"input\\", this.onInputMyComponent4Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-component-5']\\")
      .forEach((el) => {
        el.setAttribute(\\"checked\\", this.state.fillings === \\"Beans\\");
        el.removeEventListener(\\"input\\", this.onInputMyComponent5Input);
        el.addEventListener(\\"input\\", this.onInputMyComponent5Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-component-6']\\")
      .forEach((el) => {
        el.setAttribute(\\"checked\\", this.state.fillings === \\"Cheese\\");
        el.removeEventListener(\\"input\\", this.onInputMyComponent6Input);
        el.addEventListener(\\"input\\", this.onInputMyComponent6Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-component-7']\\")
      .forEach((el) => {
        el.setAttribute(\\"checked\\", this.state.fillings === \\"Guac (extra)\\");
        el.removeEventListener(\\"input\\", this.onInputMyComponent7Input);
        el.addEventListener(\\"input\\", this.onInputMyComponent7Input);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.tortilla);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-component-2']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.fillings);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Typescript Test > bindProperty 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { value: \\"hello\\" };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <input
        data-el=\\"input-my-component-1\\"
        data-dom-state=\\"MyComponent-input-my-component-1\\"
      />\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-my-component-1']\\")
      .forEach((el) => {
        el.value = this.state.value;
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Typescript Test > classDirective 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { focus: true };
    if (!this.props) {
      this.props = {};
    }

    this.componentProps = [\\"disabled\\"];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.getAttributeNames().forEach((attr) => {
      const jsVar = attr.replace(/-/g, \\"\\");
      const regexp = new RegExp(jsVar, \\"i\\");
      this.componentProps.forEach((prop) => {
        if (regexp.test(prop)) {
          const attrValue = this.getAttribute(attr);
          if (this.props[prop] !== attrValue) {
            this.props[prop] = attrValue;
          }
        }
      });
    });

    this._root.innerHTML = \`
      <input
        data-el=\\"input-my-component-1\\"
        data-dom-state=\\"MyComponent-input-my-component-1\\"
      />\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-my-component-1']\\")
      .forEach((el) => {
        el.className = \`form-input \${this.props.disabled ? \\"disabled\\" : \\"\\"} \${
          this.state.focus ? \\"focus\\" : \\"\\"
        }\`;
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Typescript Test > context 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;
    this.context = state.activeTab;

    this.state = { activeTab: 0 };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this.disabled = this.getContext(this._root, \\"disabled\\");

    this._root.innerHTML = \`
      <div>
        <template data-el=\\"div-my-component-1\\"><!-- state.activeTab --></template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.activeTab);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // get Context Helper
  getContext(el, token) {
    do {
      let value;
      if (el?.context?.get) {
        value = el.context.get(token);
      } else if (el?.context?.[token]) {
        value = el.context[token];
      }
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Typescript Test > each 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { numbers: [\\"one\\", \\"two\\", \\"three\\"] };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <ul>
        <template data-el=\\"for-my-component\\">
          <li>
            <template data-el=\\"div-my-component-1\\"><!-- num --></template>
          </li>
        </template>
      </ul>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='for-my-component']\\")
      .forEach((el) => {
        let array = this.state.numbers;
        this.renderLoop(el, array, \\"num\\");
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-component-1']\\")
      .forEach((el) => {
        const num = this.getScope(el, \\"num\\");
        this.renderTextNode(el, num);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // scope helper
  getScope(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        if (template.context) {
          child.context = context;
        }
        this.nodesToDestroy.push(child);
        collection.unshift(child);
      });
    }
    collection.forEach((child) => template.after(child));
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Typescript Test > eventHandlers 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      log: function log(msg = \\"hello\\") {
        console.log(msg);
      },
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'click' event on button-my-component-1
    this.onButtonMyComponent1Click = (a) => {
      this.state.log(\\"hi\\");
    };

    // Event handler for 'click' event on button-my-component-2
    this.onButtonMyComponent2Click = (event) => {
      this.state.log(event);
    };

    // Event handler for 'click' event on button-my-component-3
    this.onButtonMyComponent3Click = (event) => {
      this.state.log(event);
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <button data-el=\\"button-my-component-1\\">Log</button>
        <button data-el=\\"button-my-component-2\\">Log</button>
        <button data-el=\\"button-my-component-3\\">Log</button>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='button-my-component-1']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onButtonMyComponent1Click);
        el.addEventListener(\\"click\\", this.onButtonMyComponent1Click);
      });

    this._root
      .querySelectorAll(\\"[data-el='button-my-component-2']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onButtonMyComponent2Click);
        el.addEventListener(\\"click\\", this.onButtonMyComponent2Click);
      });

    this._root
      .querySelectorAll(\\"[data-el='button-my-component-3']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onButtonMyComponent3Click);
        el.addEventListener(\\"click\\", this.onButtonMyComponent3Click);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Typescript Test > html 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { html: \\"<b>bold</b>\\" };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div data-el=\\"div-my-component-1\\"></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-component-1']\\")
      .forEach((el) => {
        el.innerHTML = this.state.html;
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Typescript Test > ifElse 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      show: true,
      toggle: function toggle() {
        self.state.show = !self.state.show;
        self.update();
      },
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'click' event on button-my-component-1
    this.onButtonMyComponent1Click = (event) => {
      this.state.toggle(event);
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <template data-el=\\"show-my-component\\">
        <button data-el=\\"button-my-component-1\\">Hide</button>
      </template>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      if (el?.context) {
        child.context = el.context;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='show-my-component']\\")
      .forEach((el) => {
        const whenCondition = this.state.show;

        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-el='button-my-component-1']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onButtonMyComponent1Click);
        el.addEventListener(\\"click\\", this.onButtonMyComponent1Click);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Typescript Test > imports 1`] = `
"import Button from \\"./Button.js\\";

/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { disabled: false };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <button type=\\"button\\" data-el=\\"button-my-component\\"><slot></slot></button>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='button-my-component']\\")
      .forEach((el) => {
        el.setAttribute(\\"disabled\\", this.state.disabled);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Typescript Test > lifecycleHooks 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    this.updateDeps = [[]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  disconnectedCallback() {
    // onUnMount
    console.log(\\"onDestroy\\");
    this.destroyAnyNodes(); // clean up nodes when component is destroyed
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    console.log(\\"onMount\\");
  }

  onUpdate() {
    const self = this;

    console.log(\\"onAfterUpdate\\");
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Typescript Test > reactive 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      name: \\"Steve\\",
      get lowercaseName() {
        return self.state.name.toLowerCase();
      },
    };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <input
          data-el=\\"input-my-component-1\\"
          data-dom-state=\\"MyComponent-input-my-component-1\\"
        />
      
        Lowercase:
        <template data-el=\\"div-my-component-1\\"><!-- state.lowercaseName --></template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-my-component-1']\\")
      .forEach((el) => {
        el.value = this.state.name;
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.lowercaseName);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Typescript Test > reactiveWithFn 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {
      a: 2,
      b: 5,
      result: null,
      calculateResult: function calculateResult(a_, b_) {
        self.state.result = a_ * b_;
        self.update();
      },
    };
    if (!this.props) {
      this.props = {};
    }

    this.updateDeps = [[this.state.a, this.state.b]];

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-component-1
    this.onInputMyComponent1Input = (event) => {
      this.state.a = event.target.value;
      this.update();
    };

    // Event handler for 'input' event on input-my-component-2
    this.onInputMyComponent2Input = (event) => {
      this.state.b = event.target.value;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <input
          type=\\"number\\"
          data-el=\\"input-my-component-1\\"
          data-dom-state=\\"MyComponent-input-my-component-1\\"
        />
        <input
          type=\\"number\\"
          data-el=\\"input-my-component-2\\"
          data-dom-state=\\"MyComponent-input-my-component-2\\"
        />
      
        Result:
        <template data-el=\\"div-my-component-1\\"><!-- state.result --></template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    const self = this;

    (function (__prev, __next) {
      const __hasChange = __prev.find((val, index) => val !== __next[index]);
      if (__hasChange !== undefined) {
        self.state.calculateResult(self.state.a, self.state.b);
        self.updateDeps[0] = __next;
      }
    })(self.updateDeps[0], [self.state.a, self.state.b]);
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='input-my-component-1']\\")
      .forEach((el) => {
        el.removeEventListener(\\"input\\", this.onInputMyComponent1Input);
        el.addEventListener(\\"input\\", this.onInputMyComponent1Input);
        el.value = this.state.a;
      });

    this._root
      .querySelectorAll(\\"[data-el='input-my-component-2']\\")
      .forEach((el) => {
        el.removeEventListener(\\"input\\", this.onInputMyComponent2Input);
        el.addEventListener(\\"input\\", this.onInputMyComponent2Input);
        el.value = this.state.b;
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.result);
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Typescript Test > slots 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <slot>default</slot>
        <slot name=\\"Test\\"><div>default</div></slot>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Typescript Test > style 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = {};
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <input class=\\"form-input\\" data-dom-state=\\"MyComponent-input-my-component-1\\" />
      <style>
        input {
          color: red;
          font-size: 12px;
        }
      
        .form-input:focus {
          outline: 1px solid blue;
        }
      </style>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // grab previous input state
    const preStateful = this.getStateful(this._root);
    const preValues = this.prepareHydrate(preStateful);

    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();

    // hydrate input state
    if (preValues.length) {
      const nextStateful = this.getStateful(this._root);
      this.hydrateDom(preValues, nextStateful);
    }
  }

  getStateful(el) {
    const stateful = el.querySelectorAll(\\"[data-dom-state]\\");
    return stateful ? Array.from(stateful) : [];
  }
  prepareHydrate(stateful) {
    return stateful.map((el) => {
      return {
        id: el.dataset.domState,
        value: el.value,
        active: document.activeElement === el,
        selectionStart: el.selectionStart,
      };
    });
  }
  hydrateDom(preValues, stateful) {
    return stateful.map((el, index) => {
      const prev = preValues.find((prev) => el.dataset.domState === prev.id);
      if (prev) {
        el.value = prev.value;
        if (prev.active) {
          el.focus();
          el.selectionStart = prev.selectionStart;
        }
      }
    });
  }

  updateBindings() {}

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;

exports[`webcomponent > svelte > Typescript Test > textExpressions 1`] = `
"/**
 * Usage:
 *
 *  <my-component></my-component>
 *
 */
class MyComponent extends HTMLElement {
  get _root() {
    return this.shadowRoot || this;
  }

  constructor() {
    super();
    const self = this;

    this.state = { a: 5, b: 12 };
    if (!this.props) {
      this.props = {};
    }

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        normal:
      
        <template data-el=\\"div-my-component-1\\"><!-- state.a + state.b --></template>
        <br />
      
        conditional
      
        <template data-el=\\"div-my-component-2\\">
          <!-- state.a > 2 ? 'hello' : 'bye' -->
        </template>
      </div>\`;
    this.pendingUpdate = true;

    this.render();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;
    this.render();
    this.onUpdate();
    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-el='div-my-component-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.a + this.state.b);
      });

    this._root
      .querySelectorAll(\\"[data-el='div-my-component-2']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.state.a > 2 ? \\"hello\\" : \\"bye\\");
      });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    if (el?.context) {
      textNode.context = el.context;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-component\\", MyComponent);
"
`;
