// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`webcomponent Basic 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-component></my-basic-component>
 *
 */
class MyBasicComponent extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = { name: \\"Steve\\" };

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-basic-component-1
    this.onInputMyBasicComponent1Input = (event) => {
      this.state.name = event.target.value;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <input data-name=\\"input-my-basic-component-1\\" />
      
        Hello! I can run in React, Vue, Solid, or Liquid!
      </div>
      <style></style>\`;
    this.pendingUpdate = true;
    this.render();

    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;

    this.render();
    this.onUpdate();

    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-name='input-my-basic-component-1']\\")
      .forEach((el) => {
        el.value = this.state.name;
        if (el.props) {
          el.props.value = this.state.name;
          el.update();
        }

        el.removeEventListener(\\"input\\", this.onInputMyBasicComponent1Input);
        el.addEventListener(\\"input\\", this.onInputMyBasicComponent1Input);
      });
  }
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-component\\", MyBasicComponent);
"
`;

exports[`webcomponent Basic Child Component 1`] = `
"import MyBasicComponent from \\"./basic.raw\\";
import MyBasicOnMountUpdateComponent from \\"./basic-onMount-update.raw\\";

/**
 * Usage:
 *
 *  <my-basic-child-component></my-basic-child-component>
 *
 */
class MyBasicChildComponent extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = { name: \\"Steve\\" };

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <my-basic-component></my-basic-component>
      
        <div>
          <my-basic-on-mount-update-component></my-basic-on-mount-update-component>
        </div>
      </div>
      <style></style>\`;
    this.pendingUpdate = true;
    this.render();

    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;

    this.render();
    this.onUpdate();

    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"my-basic-child-component\\", MyBasicChildComponent);
"
`;

exports[`webcomponent BasicFor 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-for-component></my-basic-for-component>
 *
 */
class MyBasicForComponent extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-basic-for-component-1
    this.onInputMyBasicForComponent1Input = (event) => {
      const person = this.getContext(event.currentTarget, \\"person\\");

      this.state.name = event.target.value + \\" and \\" + person;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <template data-name=\\"for-my-basic-for-component\\">
          <input data-name=\\"input-my-basic-for-component-1\\" />
      
          Hello
          <template data-name=\\"div-my-basic-for-component-1\\">
            <!-- person -->
          </template>
          ! I can run in Qwik, Web Component, React, Vue, Solid, or Liquid!
        </template>
      </div>
      <style></style>\`;
    this.pendingUpdate = true;
    this.render();

    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    console.log(\\"onMount code\\");
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;

    this.render();
    this.onUpdate();

    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-name='for-my-basic-for-component']\\")
      .forEach((el) => {
        let array = this.state.names;
        this.renderLoop(el, array, \\"person\\");
      });

    this._root
      .querySelectorAll(\\"[data-name='input-my-basic-for-component-1']\\")
      .forEach((el) => {
        el.value = this.state.name;
        if (el.props) {
          el.props.value = this.state.name;
          el.update();
        }

        el.removeEventListener(\\"input\\", this.onInputMyBasicForComponent1Input);
        el.addEventListener(\\"input\\", this.onInputMyBasicForComponent1Input);
      });

    this._root
      .querySelectorAll(\\"[data-name='div-my-basic-for-component-1']\\")
      .forEach((el) => {
        const person = this.getContext(el, \\"person\\");
        this.renderTextNode(el, person);
      });
  }
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (itemName !== undefined) {
          child[\\"__\\" + itemName] = value;
        }
        if (itemIndex !== undefined) {
          child[\\"__\\" + itemIndex] = index;
        }
        if (collectionName !== undefined) {
          child[\\"__\\" + collectionName] = array;
        }
        this.nodesToDestroy.push(child);
        collection.push(child);
      });
    }
    collection.reverse().forEach((child) => template.after(child));
  }

  getContext(el, name) {
    do {
      let value = el[\\"__\\" + name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }
}

customElements.define(\\"my-basic-for-component\\", MyBasicForComponent);
"
`;

exports[`webcomponent BasicForShow 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-for-show-component></my-basic-for-show-component>
 *
 */
class MyBasicForShowComponent extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'input' event on input-my-basic-for-show-component-1
    this.onInputMyBasicForShowComponent1Input = (event) => {
      const person = this.getContext(event.currentTarget, \\"person\\");

      this.state.name = event.target.value + \\" and \\" + person;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <template data-name=\\"for-my-basic-for-show-component\\">
          <template data-name=\\"show-my-basic-for-show-component\\">
            <input data-name=\\"input-my-basic-for-show-component-1\\" />
      
            Hello
            <template data-name=\\"div-my-basic-for-show-component-1\\">
              <!-- person -->
            </template>
            ! I can run in Qwik, Web Component, React, Vue, Solid, or Liquid!
          </template>
        </template>
      </div>
      <style></style>\`;
    this.pendingUpdate = true;
    this.render();

    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;

    this.render();
    this.onUpdate();

    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-name='for-my-basic-for-show-component']\\")
      .forEach((el) => {
        let array = this.state.names;
        this.renderLoop(el, array, \\"person\\");
      });

    this._root
      .querySelectorAll(\\"[data-name='show-my-basic-for-show-component']\\")
      .forEach((el) => {
        const person = this.getContext(el, \\"person\\");
        const whenCondition = person === this.state.name;
        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-name='input-my-basic-for-show-component-1']\\")
      .forEach((el) => {
        el.value = this.state.name;
        if (el.props) {
          el.props.value = this.state.name;
          el.update();
        }

        el.removeEventListener(
          \\"input\\",
          this.onInputMyBasicForShowComponent1Input
        );
        el.addEventListener(\\"input\\", this.onInputMyBasicForShowComponent1Input);
      });

    this._root
      .querySelectorAll(\\"[data-name='div-my-basic-for-show-component-1']\\")
      .forEach((el) => {
        const person = this.getContext(el, \\"person\\");
        this.renderTextNode(el, person);
      });
  }
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (itemName !== undefined) {
          child[\\"__\\" + itemName] = value;
        }
        if (itemIndex !== undefined) {
          child[\\"__\\" + itemIndex] = index;
        }
        if (collectionName !== undefined) {
          child[\\"__\\" + collectionName] = array;
        }
        this.nodesToDestroy.push(child);
        collection.push(child);
      });
    }
    collection.reverse().forEach((child) => template.after(child));
  }

  getContext(el, name) {
    do {
      let value = el[\\"__\\" + name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }
}

customElements.define(\\"my-basic-for-show-component\\", MyBasicForShowComponent);
"
`;

exports[`webcomponent BasicOnMountUpdate 1`] = `
"/**
 * Usage:
 *
 *  <my-basic-on-mount-update-component></my-basic-on-mount-update-component>
 *
 */
class MyBasicOnMountUpdateComponent extends HTMLElement {
  constructor() {
    super();
    const self = this;
    this.onInitOnce = false;
    this.state = { name: \\"PatrickJS\\", names: [\\"Steve\\", \\"PatrickJS\\"] };

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        Hello
        <template data-name=\\"div-my-basic-on-mount-update-component-1\\">
          <!-- state.name -->
        </template>
      </div>
      <style></style>\`;
    this.pendingUpdate = true;
    this.render();
    this.onInit();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onInit() {
    if (!this.onInitOnce) {
      this.state.name = \\"PatrickJS onInit\\";
      this.update();
      this.onInitOnce = true;
    }
  }

  onMount() {
    // onMount
    this.state.name = \\"PatrickJS onMount\\";
    this.update();
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;

    this.render();
    this.onUpdate();

    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(
        \\"[data-name='div-my-basic-on-mount-update-component-1']\\"
      )
      .forEach((el) => {
        this.renderTextNode(el, this.state.name);
      });
  }
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(
  \\"my-basic-on-mount-update-component\\",
  MyBasicOnMountUpdateComponent
);
"
`;

exports[`webcomponent Button 1`] = `
"/**
 * Usage:
 *
 *  <button></button>
 *
 */
class Button extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {};
    this.props = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <template data-name=\\"show-button\\">
        <a data-name=\\"a-button-1\\">
          <template data-name=\\"div-button-1\\"><!-- props.text --></template>
        </a>
      </template>
      
      <template data-name=\\"show-button-2\\">
        <button type=\\"button\\" data-name=\\"button-button-1\\">
          <template data-name=\\"div-button-2\\"><!-- props.text --></template>
        </button>
      </template>
      
      <style></style>\`;
    this.pendingUpdate = true;
    this.render();

    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;

    this.render();
    this.onUpdate();

    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-name='show-button']\\").forEach((el) => {
      const whenCondition = this.props.link;
      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-name='a-button-1']\\").forEach((el) => {
      el.href = this.props.link;
      if (el.props) {
        el.props.href = this.props.link;
        el.update();
      }

      el.target = this.props.openLinkInNewTab ? \\"_blank\\" : undefined;
      if (el.props) {
        el.props.target = this.props.openLinkInNewTab ? \\"_blank\\" : undefined;
        el.update();
      }
    });

    this._root.querySelectorAll(\\"[data-name='div-button-1']\\").forEach((el) => {
      this.renderTextNode(el, this.props.text);
    });

    this._root.querySelectorAll(\\"[data-name='show-button-2']\\").forEach((el) => {
      const whenCondition = !this.props.link;
      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-name='div-button-2']\\").forEach((el) => {
      this.renderTextNode(el, this.props.text);
    });
  }
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"button\\", Button);
"
`;

exports[`webcomponent Columns 1`] = `
"/**
 * Usage:
 *
 *  <column></column>
 *
 */
class Column extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {
      getColumns() {
        return self.props.columns || [];
      },
      getGutterSize() {
        return typeof self.props.space === \\"number\\"
          ? self.props.space || 0
          : 20;
      },
      getWidth(index) {
        const columns = this.getColumns();
        return (columns[index] && columns[index].width) || 100 / columns.length;
      },
      getColumnCssWidth(index) {
        const columns = this.getColumns();
        const gutterSize = this.getGutterSize();
        const subtractWidth =
          (gutterSize * (columns.length - 1)) / columns.length;
        return \`calc(\${this.getWidth(index)}% - \${subtractWidth}px)\`;
      },
    };
    this.props = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div class=\\"builder-columns div\\">
        <template data-name=\\"for-column\\">
          <div class=\\"builder-column div-2\\">
            <template data-name=\\"div-column-1\\"><!-- column.content --></template>
      
            <template data-name=\\"div-column-2\\"><!-- index --></template>
          </div>
        </template>
      </div>
      <style>
        .div {
          display: flex;
          flex-direction: column;
          align-items: stretch;
          line-height: normal;
        }
        @media (max-width: 999px) {
          .div {
            flex-direction: row;
          }
        }
        @media (max-width: 639px) {
          .div {
            flex-direction: row-reverse;
          }
        }
        .div-2 {
          flex-grow: 1;
        }
      </style>\`;
    this.pendingUpdate = true;
    this.render();

    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;

    this.render();
    this.onUpdate();

    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-name='for-column']\\").forEach((el) => {
      let array = this.props.columns;
      this.renderLoop(el, array, \\"column\\", \\"index\\");
    });

    this._root.querySelectorAll(\\"[data-name='div-column-1']\\").forEach((el) => {
      const column = this.getContext(el, \\"column\\");
      this.renderTextNode(el, column.content);
    });

    this._root.querySelectorAll(\\"[data-name='div-column-2']\\").forEach((el) => {
      const index = this.getContext(el, \\"index\\");
      this.renderTextNode(el, index);
    });
  }
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (itemName !== undefined) {
          child[\\"__\\" + itemName] = value;
        }
        if (itemIndex !== undefined) {
          child[\\"__\\" + itemIndex] = index;
        }
        if (collectionName !== undefined) {
          child[\\"__\\" + collectionName] = array;
        }
        this.nodesToDestroy.push(child);
        collection.push(child);
      });
    }
    collection.reverse().forEach((child) => template.after(child));
  }

  getContext(el, name) {
    do {
      let value = el[\\"__\\" + name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }
}

customElements.define(\\"column\\", Column);
"
`;

exports[`webcomponent Image 1`] = `
"/**
 * Usage:
 *
 *  <image></image>
 *
 */
class Image extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {
      scrollListener: null,
      imageLoaded: false,
      load: false,
      setLoaded() {
        self.state.imageLoaded = true;
        self.update();
      },
      isBrowser() {
        return (
          typeof window !== \\"undefined\\" &&
          window.navigator.product != \\"ReactNative\\"
        );
      },
      useLazyLoading() {
        // TODO: Add more checks here, like testing for real web browsers
        return !!self.props.lazy && self.state.isBrowser();
      },
    };
    this.props = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'load' event on img-image-1
    this.onImgImage1Load = (event) => {
      this.state.setLoaded();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  disconnectedCallback() {
    // onUnMount
    if (this.state.scrollListener) {
      window.removeEventListener(\\"scroll\\", this.state.scrollListener);
    }
    this.destroyAnyNodes(); // clean up nodes when component is destroyed
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <picture data-name=\\"picture-image-1\\">
        <template data-name=\\"show-image\\">
          <img class=\\"img\\" data-name=\\"img-image-1\\" />
        </template>
      
        <source data-name=\\"source-image-1\\" />
      </picture>
      
      <slot></slot>
      
      <style>
        .img {
          opacity: 1;
          transition: opacity 0.2s ease-in-out;
          object-fit: cover;
          object-position: center;
        }
      </style>\`;
    this.pendingUpdate = true;
    this.render();

    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {
    // onMount
    if (this.state.useLazyLoading()) {
      // throttled scroll capture listener
      const listener = () => {
        if (pictureRef) {
          const rect = pictureRef.getBoundingClientRect();
          const buffer = window.innerHeight / 2;

          if (rect.top < window.innerHeight + buffer) {
            this.state.load = true;
            this.update();
            this.state.scrollListener = null;
            this.update();
            window.removeEventListener(\\"scroll\\", listener);
          }
        }
      };

      this.state.scrollListener = listener;
      this.update();
      window.addEventListener(\\"scroll\\", listener, {
        capture: true,
        passive: true,
      });
      listener();
    }
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;

    this.render();
    this.onUpdate();

    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-name='show-image']\\").forEach((el) => {
      const whenCondition = !this.state.useLazyLoading() || this.state.load;
      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll(\\"[data-name='img-image-1']\\").forEach((el) => {
      el.alt = this.props.altText;
      if (el.props) {
        el.props.alt = this.props.altText;
        el.update();
      }

      el.setAttribute(
        \\"aria-role\\",
        this.props.altText ? \\"presentation\\" : undefined
      );
      if (el.props) {
        el.props.ariaRole = this.props.altText ? \\"presentation\\" : undefined;
        el.update();
      }

      el.className =
        \\"builder-image\\" + (this.props.class ? \\" \\" + this.props.class : \\"\\");
      if (el.props) {
        el.props.class =
          \\"builder-image\\" + (this.props.class ? \\" \\" + this.props.class : \\"\\");
        el.update();
      }

      el.src = this.props.image;
      if (el.props) {
        el.props.src = this.props.image;
        el.update();
      }

      el.removeEventListener(\\"load\\", this.onImgImage1Load);
      el.addEventListener(\\"load\\", this.onImgImage1Load);

      el.srcset = this.props.srcset;
      if (el.props) {
        el.props.srcset = this.props.srcset;
        el.update();
      }

      el.sizes = this.props.sizes;
      if (el.props) {
        el.props.sizes = this.props.sizes;
        el.update();
      }
    });

    this._root
      .querySelectorAll(\\"[data-name='source-image-1']\\")
      .forEach((el) => {
        el.srcset = this.props.srcset;
        if (el.props) {
          el.props.srcset = this.props.srcset;
          el.update();
        }
      });
  }
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"image\\", Image);
"
`;

exports[`webcomponent ImageState 1`] = `
"/**
 * Usage:
 *
 *  <img-state-component></img-state-component>
 *
 */
class ImgStateComponent extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = { canShow: true, images: [\\"http://example.com/qwik.png\\"] };

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div>
        <template data-name=\\"for-img-state-component\\">
          <img data-name=\\"img-img-state-component-1\\" />
        </template>
      </div>
      <style></style>\`;
    this.pendingUpdate = true;
    this.render();

    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;

    this.render();
    this.onUpdate();

    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-name='for-img-state-component']\\")
      .forEach((el) => {
        let array = this.state.images;
        this.renderLoop(el, array, \\"item\\", \\"itemIndex\\");
      });

    this._root
      .querySelectorAll(\\"[data-name='img-img-state-component-1']\\")
      .forEach((el) => {
        const item = this.getContext(el, \\"item\\");
        const itemIndex = this.getContext(el, \\"itemIndex\\");

        el.className = \\"custom-class\\";
        if (el.props) {
          el.props.class = \\"custom-class\\";
          el.update();
        }

        el.src = item;
        if (el.props) {
          el.props.src = item;
          el.update();
        }

        el.key = itemIndex;
        if (el.props) {
          el.props.key = itemIndex;
          el.update();
        }
      });
  }
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (itemName !== undefined) {
          child[\\"__\\" + itemName] = value;
        }
        if (itemIndex !== undefined) {
          child[\\"__\\" + itemIndex] = index;
        }
        if (collectionName !== undefined) {
          child[\\"__\\" + collectionName] = array;
        }
        this.nodesToDestroy.push(child);
        collection.push(child);
      });
    }
    collection.reverse().forEach((child) => template.after(child));
  }

  getContext(el, name) {
    do {
      let value = el[\\"__\\" + name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }
}

customElements.define(\\"img-state-component\\", ImgStateComponent);
"
`;

exports[`webcomponent Img 1`] = `
"import { Builder } from \\"@builder.io/sdk\\";

/**
 * Usage:
 *
 *  <img-component></img-component>
 *
 */
class ImgComponent extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {};
    this.props = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <img data-name=\\"img-img-component-1\\" />
      <style></style>\`;
    this.pendingUpdate = true;
    this.render();

    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;

    this.render();
    this.onUpdate();

    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-name='img-img-component-1']\\")
      .forEach((el) => {
        Object.assign(el.style, {
          objectFit: this.props.backgroundSize || \\"cover\\",
          objectPosition: this.props.backgroundPosition || \\"center\\",
        });

        el.key = (Builder.isEditing && this.props.imgSrc) || \\"default-key\\";
        if (el.props) {
          el.props.key =
            (Builder.isEditing && this.props.imgSrc) || \\"default-key\\";
          el.update();
        }

        el.alt = this.props.altText;
        if (el.props) {
          el.props.alt = this.props.altText;
          el.update();
        }

        el.src = this.props.imgSrc;
        if (el.props) {
          el.props.src = this.props.imgSrc;
          el.update();
        }
      });
  }
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"img-component\\", ImgComponent);
"
`;

exports[`webcomponent Input block 1`] = `
"import { Builder } from \\"@builder.io/sdk\\";

/**
 * Usage:
 *
 *  <form-input-component></form-input-component>
 *
 */
class FormInputComponent extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {};
    this.props = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <input data-name=\\"input-form-input-component-1\\" />
      <style></style>\`;
    this.pendingUpdate = true;
    this.render();

    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;

    this.render();
    this.onUpdate();

    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-name='input-form-input-component-1']\\")
      .forEach((el) => {
        el.key =
          Builder.isEditing && this.props.defaultValue
            ? this.props.defaultValue
            : \\"default-key\\";
        if (el.props) {
          el.props.key =
            Builder.isEditing && this.props.defaultValue
              ? this.props.defaultValue
              : \\"default-key\\";
          el.update();
        }

        el.placeholder = this.props.placeholder;
        if (el.props) {
          el.props.placeholder = this.props.placeholder;
          el.update();
        }

        el.type = this.props.type;
        if (el.props) {
          el.props.type = this.props.type;
          el.update();
        }

        el.name = this.props.name;
        if (el.props) {
          el.props.name = this.props.name;
          el.update();
        }

        el.value = this.props.value;
        if (el.props) {
          el.props.value = this.props.value;
          el.update();
        }

        el.defaultValue = this.props.defaultValue;
        if (el.props) {
          el.props.defaultValue = this.props.defaultValue;
          el.update();
        }

        el.required = this.props.required;
        if (el.props) {
          el.props.required = this.props.required;
          el.update();
        }
      });
  }
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"form-input-component\\", FormInputComponent);
"
`;

exports[`webcomponent Section 1`] = `
"/**
 * Usage:
 *
 *  <section-component></section-component>
 *
 */
class SectionComponent extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {};
    this.props = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <section data-name=\\"section-section-component-1\\">
        <slot></slot>
      </section>
      <style></style>\`;
    this.pendingUpdate = true;
    this.render();

    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;

    this.render();
    this.onUpdate();

    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-name='section-section-component-1']\\")
      .forEach((el) => {
        Object.assign(
          el.style,
          this.props.maxWidth && typeof this.props.maxWidth === \\"number\\"
            ? {
                maxWidth: this.props.maxWidth,
              }
            : undefined
        );
      });
  }
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"section-component\\", SectionComponent);
"
`;

exports[`webcomponent SectionState 1`] = `
"/**
 * Usage:
 *
 *  <section-state-component></section-state-component>
 *
 */
class SectionStateComponent extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = { max: 42, items: [42] };
    this.props = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <template data-name=\\"show-section-state-component\\">
        <template data-name=\\"for-section-state-component\\">
          <section data-name=\\"section-section-state-component-1\\">
            <slot></slot>
          </section>
        </template>
      </template>
      <style></style>\`;
    this.pendingUpdate = true;
    this.render();

    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;

    this.render();
    this.onUpdate();

    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-name='show-section-state-component']\\")
      .forEach((el) => {
        const whenCondition = this.state.max;
        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-name='for-section-state-component']\\")
      .forEach((el) => {
        let array = this.state.items;
        this.renderLoop(el, array, \\"item\\");
      });

    this._root
      .querySelectorAll(\\"[data-name='section-section-state-component-1']\\")
      .forEach((el) => {
        const item = this.getContext(el, \\"item\\");
        Object.assign(el.style, {
          maxWidth: item + this.state.max,
        });
      });
  }
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (itemName !== undefined) {
          child[\\"__\\" + itemName] = value;
        }
        if (itemIndex !== undefined) {
          child[\\"__\\" + itemIndex] = index;
        }
        if (collectionName !== undefined) {
          child[\\"__\\" + collectionName] = array;
        }
        this.nodesToDestroy.push(child);
        collection.push(child);
      });
    }
    collection.reverse().forEach((child) => template.after(child));
  }

  getContext(el, name) {
    do {
      let value = el[\\"__\\" + name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }
}

customElements.define(\\"section-state-component\\", SectionStateComponent);
"
`;

exports[`webcomponent Select block 1`] = `
"import { Builder } from \\"@builder.io/sdk\\";

/**
 * Usage:
 *
 *  <select-component></select-component>
 *
 */
class SelectComponent extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {};
    this.props = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <select data-name=\\"select-select-component-1\\">
        <template data-name=\\"for-select-component\\">
          <option data-name=\\"option-select-component-1\\">
            <template data-name=\\"div-select-component-1\\">
              <!-- option.name || option.value -->
            </template>
          </option>
        </template>
      </select>
      <style></style>\`;
    this.pendingUpdate = true;
    this.render();

    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;

    this.render();
    this.onUpdate();

    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-name='select-select-component-1']\\")
      .forEach((el) => {
        el.value = this.props.value;
        if (el.props) {
          el.props.value = this.props.value;
          el.update();
        }

        el.key =
          Builder.isEditing && this.props.defaultValue
            ? this.props.defaultValue
            : \\"default-key\\";
        if (el.props) {
          el.props.key =
            Builder.isEditing && this.props.defaultValue
              ? this.props.defaultValue
              : \\"default-key\\";
          el.update();
        }

        el.defaultValue = this.props.defaultValue;
        if (el.props) {
          el.props.defaultValue = this.props.defaultValue;
          el.update();
        }

        el.name = this.props.name;
        if (el.props) {
          el.props.name = this.props.name;
          el.update();
        }
      });

    this._root
      .querySelectorAll(\\"[data-name='for-select-component']\\")
      .forEach((el) => {
        let array = this.props.options;
        this.renderLoop(el, array, \\"option\\", \\"index\\");
      });

    this._root
      .querySelectorAll(\\"[data-name='option-select-component-1']\\")
      .forEach((el) => {
        const option = this.getContext(el, \\"option\\");
        const index = this.getContext(el, \\"index\\");

        el.value = option.value;
        if (el.props) {
          el.props.value = option.value;
          el.update();
        }

        el.setAttribute(\\"data-index\\", index);
        if (el.props) {
          el.props.dataIndex = index;
          el.update();
        }
      });

    this._root
      .querySelectorAll(\\"[data-name='div-select-component-1']\\")
      .forEach((el) => {
        const option = this.getContext(el, \\"option\\");
        this.renderTextNode(el, option.name || option.value);
      });
  }
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (itemName !== undefined) {
          child[\\"__\\" + itemName] = value;
        }
        if (itemIndex !== undefined) {
          child[\\"__\\" + itemIndex] = index;
        }
        if (collectionName !== undefined) {
          child[\\"__\\" + collectionName] = array;
        }
        this.nodesToDestroy.push(child);
        collection.push(child);
      });
    }
    collection.reverse().forEach((child) => template.after(child));
  }

  getContext(el, name) {
    do {
      let value = el[\\"__\\" + name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }
}

customElements.define(\\"select-component\\", SelectComponent);
"
`;

exports[`webcomponent Shadow DOM 1`] = `
"/**
 * Usage:
 *
 *  <smile-reviews></smile-reviews>
 *
 */
class SmileReviews extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = { reviews: [], name: \\"test\\", showReviewPrompt: false };
    this.props = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'click' event on button-smile-reviews-1
    this.onButtonSmileReviews1Click = (event) => {
      this.state.showReviewPrompt = true;
      this.update();
    };

    // Event handler for 'click' event on button-smile-reviews-2
    this.onButtonSmileReviews2Click = (event) => {
      this.state.showReviewPrompt = false;
      this.update();
    };

    if (true) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div data-name=\\"div-smile-reviews-1\\">
        <button data-name=\\"button-smile-reviews-1\\">Write a review</button>
      
        <template data-name=\\"show-smile-reviews\\">
          <input placeholder=\\"Email\\" />
      
          <input placeholder=\\"Title\\" class=\\"input\\" />
      
          <textarea
            placeholder=\\"How was your experience?\\"
            class=\\"textarea\\"
          ></textarea>
      
          <button class=\\"button\\" data-name=\\"button-smile-reviews-2\\">Submit</button>
        </template>
      
        <template data-name=\\"for-smile-reviews\\">
          <div class=\\"review\\" data-name=\\"div-smile-reviews-2\\">
            <img class=\\"img\\" data-name=\\"img-smile-reviews-1\\" />
      
            <div data-name=\\"div-smile-reviews-3\\">
              <div>
                N:
                <template data-name=\\"div-smile-reviews-4\\"><!-- index --></template>
              </div>
      
              <div>
                <template data-name=\\"div-smile-reviews-5\\">
                  <!-- review.author -->
                </template>
              </div>
      
              <div>
                <template data-name=\\"div-smile-reviews-6\\">
                  <!-- review.reviewMessage -->
                </template>
              </div>
            </div>
          </div>
        </template>
      </div>
      <style>
        .input {
          display: block;
        }
        .textarea {
          display: block;
        }
        .button {
          display: block;
        }
        .review {
          margin: 10px;
          padding: 10px;
          background: white;
          display: flex;
          border-radius: 5px;
          box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .img {
          height: 30px;
          width: 30px;
          margin-right: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;
    this.render();

    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {
    // onMount
    fetch(
      \`https://stamped.io/api/widget/reviews?storeUrl=builder-io.myshopify.com&apiKey=\${
        this.props.apiKey || \\"pubkey-8bbDq7W6w4sB3OWeM1HUy2s47702hM\\"
      }&productId=\${this.props.productId || \\"2410511106127\\"}\`
    )
      .then((res) => res.json())
      .then((data) => {
        this.state.reviews = data.data;
        this.update();
      });
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;

    this.render();
    this.onUpdate();

    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-name='div-smile-reviews-1']\\")
      .forEach((el) => {
        el.setAttribute(\\"data-user\\", this.state.name);
        if (el.props) {
          el.props.dataUser = this.state.name;
          el.update();
        }
      });

    this._root
      .querySelectorAll(\\"[data-name='button-smile-reviews-1']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onButtonSmileReviews1Click);
        el.addEventListener(\\"click\\", this.onButtonSmileReviews1Click);
      });

    this._root
      .querySelectorAll(\\"[data-name='show-smile-reviews']\\")
      .forEach((el) => {
        const whenCondition = this.state.showReviewPrompt;
        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-name='button-smile-reviews-2']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onButtonSmileReviews2Click);
        el.addEventListener(\\"click\\", this.onButtonSmileReviews2Click);
      });

    this._root
      .querySelectorAll(\\"[data-name='for-smile-reviews']\\")
      .forEach((el) => {
        let array = this.state.reviews;
        this.renderLoop(el, array, \\"review\\", \\"index\\");
      });

    this._root
      .querySelectorAll(\\"[data-name='div-smile-reviews-2']\\")
      .forEach((el) => {
        const review = this.getContext(el, \\"review\\");

        el.key = review.id;
        if (el.props) {
          el.props.key = review.id;
          el.update();
        }
      });

    this._root
      .querySelectorAll(\\"[data-name='img-smile-reviews-1']\\")
      .forEach((el) => {
        const review = this.getContext(el, \\"review\\");

        el.src = review.avatar;
        if (el.props) {
          el.props.src = review.avatar;
          el.update();
        }
      });

    this._root
      .querySelectorAll(\\"[data-name='div-smile-reviews-3']\\")
      .forEach((el) => {
        el.className = this.state.showReviewPrompt
          ? \\"bg-primary\\"
          : \\"bg-secondary\\";
        if (el.props) {
          el.props.class = this.state.showReviewPrompt
            ? \\"bg-primary\\"
            : \\"bg-secondary\\";
          el.update();
        }
      });

    this._root
      .querySelectorAll(\\"[data-name='div-smile-reviews-4']\\")
      .forEach((el) => {
        const index = this.getContext(el, \\"index\\");
        this.renderTextNode(el, index);
      });

    this._root
      .querySelectorAll(\\"[data-name='div-smile-reviews-5']\\")
      .forEach((el) => {
        const review = this.getContext(el, \\"review\\");
        this.renderTextNode(el, review.author);
      });

    this._root
      .querySelectorAll(\\"[data-name='div-smile-reviews-6']\\")
      .forEach((el) => {
        const review = this.getContext(el, \\"review\\");
        this.renderTextNode(el, review.reviewMessage);
      });
  }
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (itemName !== undefined) {
          child[\\"__\\" + itemName] = value;
        }
        if (itemIndex !== undefined) {
          child[\\"__\\" + itemIndex] = index;
        }
        if (collectionName !== undefined) {
          child[\\"__\\" + collectionName] = array;
        }
        this.nodesToDestroy.push(child);
        collection.push(child);
      });
    }
    collection.reverse().forEach((child) => template.after(child));
  }

  getContext(el, name) {
    do {
      let value = el[\\"__\\" + name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }
}

customElements.define(\\"smile-reviews\\", SmileReviews);
"
`;

exports[`webcomponent Stamped 1`] = `
"import { kebabCase } from \\"lodash\\";
import { snakeCase } from \\"lodash\\";

/**
 * Usage:
 *
 *  <smile-reviews></smile-reviews>
 *
 */
class SmileReviews extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {
      reviews: [],
      name: \\"test\\",
      showReviewPrompt: false,
      kebabCaseValue() {
        return kebabCase(\\"testThat\\");
      },
      snakeCaseValue() {
        return snakeCase(\\"testThis\\");
      },
    };
    this.props = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'click' event on button-smile-reviews-1
    this.onButtonSmileReviews1Click = (event) => {
      this.state.showReviewPrompt = true;
      this.update();
    };

    // Event handler for 'click' event on button-smile-reviews-2
    this.onButtonSmileReviews2Click = (event) => {
      this.state.showReviewPrompt = false;
      this.update();
    };

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div data-name=\\"div-smile-reviews-1\\">
        <button data-name=\\"button-smile-reviews-1\\">Write a review</button>
      
        <template data-name=\\"show-smile-reviews\\">
          <input placeholder=\\"Email\\" />
      
          <input placeholder=\\"Title\\" class=\\"input\\" />
      
          <textarea
            placeholder=\\"How was your experience?\\"
            class=\\"textarea\\"
          ></textarea>
      
          <button class=\\"button\\" data-name=\\"button-smile-reviews-2\\">Submit</button>
        </template>
      
        <template data-name=\\"for-smile-reviews\\">
          <div class=\\"review\\" data-name=\\"div-smile-reviews-2\\">
            <img class=\\"img\\" data-name=\\"img-smile-reviews-1\\" />
      
            <div data-name=\\"div-smile-reviews-3\\">
              <div>
                N:
                <template data-name=\\"div-smile-reviews-4\\"><!-- index --></template>
              </div>
      
              <div>
                <template data-name=\\"div-smile-reviews-5\\">
                  <!-- review.author -->
                </template>
              </div>
      
              <div>
                <template data-name=\\"div-smile-reviews-6\\">
                  <!-- review.reviewMessage -->
                </template>
              </div>
            </div>
          </div>
        </template>
      </div>
      <style>
        .input {
          display: block;
        }
        .textarea {
          display: block;
        }
        .button {
          display: block;
        }
        .review {
          margin: 10px;
          padding: 10px;
          background: white;
          display: flex;
          border-radius: 5px;
          box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .img {
          height: 30px;
          width: 30px;
          margin-right: 10px;
        }
      </style>\`;
    this.pendingUpdate = true;
    this.render();

    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {
    // onMount
    fetch(
      \`https://stamped.io/api/widget/reviews?storeUrl=builder-io.myshopify.com&apiKey=\${
        this.props.apiKey || \\"pubkey-8bbDq7W6w4sB3OWeM1HUy2s47702hM\\"
      }&productId=\${this.props.productId || \\"2410511106127\\"}\`
    )
      .then((res) => res.json())
      .then((data) => {
        this.state.reviews = data.data;
        this.update();
      });
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;

    this.render();
    this.onUpdate();

    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-name='div-smile-reviews-1']\\")
      .forEach((el) => {
        el.setAttribute(\\"data-user\\", this.state.name);
        if (el.props) {
          el.props.dataUser = this.state.name;
          el.update();
        }
      });

    this._root
      .querySelectorAll(\\"[data-name='button-smile-reviews-1']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onButtonSmileReviews1Click);
        el.addEventListener(\\"click\\", this.onButtonSmileReviews1Click);
      });

    this._root
      .querySelectorAll(\\"[data-name='show-smile-reviews']\\")
      .forEach((el) => {
        const whenCondition = this.state.showReviewPrompt;
        if (whenCondition) {
          this.showContent(el);
        }
      });

    this._root
      .querySelectorAll(\\"[data-name='button-smile-reviews-2']\\")
      .forEach((el) => {
        el.removeEventListener(\\"click\\", this.onButtonSmileReviews2Click);
        el.addEventListener(\\"click\\", this.onButtonSmileReviews2Click);
      });

    this._root
      .querySelectorAll(\\"[data-name='for-smile-reviews']\\")
      .forEach((el) => {
        let array = this.state.reviews;
        this.renderLoop(el, array, \\"review\\", \\"index\\");
      });

    this._root
      .querySelectorAll(\\"[data-name='div-smile-reviews-2']\\")
      .forEach((el) => {
        const review = this.getContext(el, \\"review\\");

        el.key = review.id;
        if (el.props) {
          el.props.key = review.id;
          el.update();
        }
      });

    this._root
      .querySelectorAll(\\"[data-name='img-smile-reviews-1']\\")
      .forEach((el) => {
        const review = this.getContext(el, \\"review\\");

        el.src = review.avatar;
        if (el.props) {
          el.props.src = review.avatar;
          el.update();
        }
      });

    this._root
      .querySelectorAll(\\"[data-name='div-smile-reviews-3']\\")
      .forEach((el) => {
        el.className = this.state.showReviewPrompt
          ? \\"bg-primary\\"
          : \\"bg-secondary\\";
        if (el.props) {
          el.props.class = this.state.showReviewPrompt
            ? \\"bg-primary\\"
            : \\"bg-secondary\\";
          el.update();
        }
      });

    this._root
      .querySelectorAll(\\"[data-name='div-smile-reviews-4']\\")
      .forEach((el) => {
        const index = this.getContext(el, \\"index\\");
        this.renderTextNode(el, index);
      });

    this._root
      .querySelectorAll(\\"[data-name='div-smile-reviews-5']\\")
      .forEach((el) => {
        const review = this.getContext(el, \\"review\\");
        this.renderTextNode(el, review.author);
      });

    this._root
      .querySelectorAll(\\"[data-name='div-smile-reviews-6']\\")
      .forEach((el) => {
        const review = this.getContext(el, \\"review\\");
        this.renderTextNode(el, review.reviewMessage);
      });
  }
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      children.forEach((child) => {
        if (itemName !== undefined) {
          child[\\"__\\" + itemName] = value;
        }
        if (itemIndex !== undefined) {
          child[\\"__\\" + itemIndex] = index;
        }
        if (collectionName !== undefined) {
          child[\\"__\\" + collectionName] = array;
        }
        this.nodesToDestroy.push(child);
        collection.push(child);
      });
    }
    collection.reverse().forEach((child) => template.after(child));
  }

  getContext(el, name) {
    do {
      let value = el[\\"__\\" + name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }
}

customElements.define(\\"smile-reviews\\", SmileReviews);
"
`;

exports[`webcomponent Submit button block 1`] = `
"/**
 * Usage:
 *
 *  <submit-button></submit-button>
 *
 */
class SubmitButton extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {};
    this.props = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <button type=\\"submit\\" data-name=\\"button-submit-button-1\\">
        <template data-name=\\"div-submit-button-1\\"><!-- props.text --></template>
      </button>
      <style></style>\`;
    this.pendingUpdate = true;
    this.render();

    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;

    this.render();
    this.onUpdate();

    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-name='div-submit-button-1']\\")
      .forEach((el) => {
        this.renderTextNode(el, this.props.text);
      });
  }
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"submit-button\\", SubmitButton);
"
`;

exports[`webcomponent Text 1`] = `
"import { Builder } from \\"@builder.io/sdk\\";

/**
 * Usage:
 *
 *  <text></text>
 *
 */
class Text extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {};
    this.props = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div data-name=\\"div-text-1\\"></div>
      <style></style>\`;
    this.pendingUpdate = true;
    this.render();

    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;

    this.render();
    this.onUpdate();

    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-name='div-text-1']\\").forEach((el) => {
      el.contentEditable = allowEditingText || undefined;
      if (el.props) {
        el.props.contentEditable = allowEditingText || undefined;
        el.update();
      }

      el.innerHTML = this.props.text || this.props.content || \\"\\";
      if (el.props) {
        el.props.innerHtml = this.props.text || this.props.content || \\"\\";
        el.update();
      }
    });
  }
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"text\\", Text);
"
`;

exports[`webcomponent Textarea 1`] = `
"/**
 * Usage:
 *
 *  <textarea></textarea>
 *
 */
class Textarea extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {};
    this.props = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <textarea data-name=\\"textarea-textarea-1\\"></textarea>
      <style></style>\`;
    this.pendingUpdate = true;
    this.render();

    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;

    this.render();
    this.onUpdate();

    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root
      .querySelectorAll(\\"[data-name='textarea-textarea-1']\\")
      .forEach((el) => {
        el.placeholder = this.props.placeholder;
        if (el.props) {
          el.props.placeholder = this.props.placeholder;
          el.update();
        }

        el.name = this.props.name;
        if (el.props) {
          el.props.name = this.props.name;
          el.update();
        }

        el.value = this.props.value;
        if (el.props) {
          el.props.value = this.props.value;
          el.update();
        }

        el.defaultValue = this.props.defaultValue;
        if (el.props) {
          el.props.defaultValue = this.props.defaultValue;
          el.update();
        }
      });
  }
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"textarea\\", Textarea);
"
`;

exports[`webcomponent Video 1`] = `
"/**
 * Usage:
 *
 *  <video></video>
 *
 */
class Video extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {};
    this.props = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <video preload=\\"none\\" data-name=\\"video-video-1\\"></video>
      <style></style>\`;
    this.pendingUpdate = true;
    this.render();

    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;

    this.render();
    this.onUpdate();

    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll(\\"[data-name='video-video-1']\\").forEach((el) => {
      Object.assign(el.style, {
        width: \\"100%\\",
        height: \\"100%\\",
        ...this.props.attributes?.style,
        objectFit: this.props.fit,
        objectPosition: this.props.position,
        // Hack to get object fit to work as expected and
        // not have the video overflow
        borderRadius: 1,
      });

      el.key = this.props.video || \\"no-src\\";
      if (el.props) {
        el.props.key = this.props.video || \\"no-src\\";
        el.update();
      }

      el.poster = this.props.posterImage;
      if (el.props) {
        el.props.poster = this.props.posterImage;
        el.update();
      }

      el.autoPlay = this.props.autoPlay;
      if (el.props) {
        el.props.autoPlay = this.props.autoPlay;
        el.update();
      }

      el.muted = this.props.muted;
      if (el.props) {
        el.props.muted = this.props.muted;
        el.update();
      }

      el.controls = this.props.controls;
      if (el.props) {
        el.props.controls = this.props.controls;
        el.update();
      }

      el.loop = this.props.loop;
      if (el.props) {
        el.props.loop = this.props.loop;
        el.update();
      }
    });
  }
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"video\\", Video);
"
`;

exports[`webcomponent multipleOnUpdate 1`] = `
"/**
 * Usage:
 *
 *  <multiple-on-update></multiple-on-update>
 *
 */
class MultipleOnUpdate extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>
      <style></style>\`;
    this.pendingUpdate = true;
    this.render();

    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    console.log(\\"Runs on every update/rerender\\");

    console.log(\\"Runs on every update/rerender as well\\");
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;

    this.render();
    this.onUpdate();

    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"multiple-on-update\\", MultipleOnUpdate);
"
`;

exports[`webcomponent multipleOnnUpdateWithDeps 1`] = `
"/**
 * Usage:
 *
 *  <multiple-on-update-with-deps></multiple-on-update-with-deps>
 *
 */
class MultipleOnUpdateWithDeps extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = { a: \\"a\\", b: \\"b\\", c: \\"c\\", d: \\"d\\" };

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>
      <style></style>\`;
    this.pendingUpdate = true;
    this.render();

    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    console.log(\\"Runs when a or b changes\\", this.state.a, this.state.b);

    console.log(\\"Runs when c or d changes\\", this.state.c, this.state.d);
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;

    this.render();
    this.onUpdate();

    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"multiple-on-update-with-deps\\", MultipleOnUpdateWithDeps);
"
`;

exports[`webcomponent onInit & onMount 1`] = `
"/**
 * Usage:
 *
 *  <on-init></on-init>
 *
 */
class OnInit extends HTMLElement {
  constructor() {
    super();
    const self = this;
    this.onInitOnce = false;
    this.state = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>
      <style></style>\`;
    this.pendingUpdate = true;
    this.render();
    this.onInit();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onInit() {
    if (!this.onInitOnce) {
      console.log(\\"onInit\\");
      this.onInitOnce = true;
    }
  }

  onMount() {
    // onMount
    console.log(\\"onMount\\");
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;

    this.render();
    this.onUpdate();

    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"on-init\\", OnInit);
"
`;

exports[`webcomponent onInit 1`] = `
"/**
 * Usage:
 *
 *  <on-init></on-init>
 *
 */
class OnInit extends HTMLElement {
  constructor() {
    super();
    const self = this;
    this.onInitOnce = false;
    this.state = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>
      <style></style>\`;
    this.pendingUpdate = true;
    this.render();
    this.onInit();
    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onInit() {
    if (!this.onInitOnce) {
      console.log(\\"Runs once every update/rerender\\");
      this.onInitOnce = true;
    }
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;

    this.render();
    this.onUpdate();

    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"on-init\\", OnInit);
"
`;

exports[`webcomponent onMount & onUnMount 1`] = `
"/**
 * Usage:
 *
 *  <comp></comp>
 *
 */
class Comp extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  disconnectedCallback() {
    // onUnMount
    console.log(\\"Runs on unMount\\");
    this.destroyAnyNodes(); // clean up nodes when component is destroyed
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>
      <style></style>\`;
    this.pendingUpdate = true;
    this.render();

    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {
    // onMount
    console.log(\\"Runs on mount\\");
  }

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;

    this.render();
    this.onUpdate();

    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"comp\\", Comp);
"
`;

exports[`webcomponent onUpdate 1`] = `
"/**
 * Usage:
 *
 *  <on-update></on-update>
 *
 */
class OnUpdate extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>
      <style></style>\`;
    this.pendingUpdate = true;
    this.render();

    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    console.log(\\"Runs on every update/rerender\\");
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;

    this.render();
    this.onUpdate();

    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"on-update\\", OnUpdate);
"
`;

exports[`webcomponent onUpdateWithDeps 1`] = `
"/**
 * Usage:
 *
 *  <on-update-with-deps></on-update-with-deps>
 *
 */
class OnUpdateWithDeps extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = { a: \\"a\\", b: \\"b\\" };

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    if (undefined) {
      this.attachShadow({ mode: \\"open\\" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = \`
      <div></div>
      <style></style>\`;
    this.pendingUpdate = true;
    this.render();

    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  onMount() {}

  onUpdate() {
    console.log(\\"Runs when a or b changes\\", this.state.a, this.state.b);
  }

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;

    this.render();
    this.onUpdate();

    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {}
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }
}

customElements.define(\\"on-update-with-deps\\", OnUpdateWithDeps);
"
`;
