import todosState from "../shared/todos-state.lite";
import Todo from "./todo.lite";

/**
 * Usage:
 *
 *  <todos></todos>
 *
 */
class Todos extends HTMLElement {
  constructor() {
    super();
    const self = this;

    this.state = {};

    // used to keep track of all nodes created by show/for
    this.nodesToDestroy = [];
    // batch updates
    this.pendingUpdate = false;

    // Event handler for 'click' event on input-todos-1
    this.onInputTodos1Click = (event) => {
      const newValue = !todosState.allCompleted;

      for (const todoItem of todosState.todos) {
        todoItem.completed = newValue;
      }
    };

    if (undefined) {
      this.attachShadow({ mode: "open" });
    }
  }

  destroyAnyNodes() {
    // destroy current view template refs before rendering again
    this.nodesToDestroy.forEach((el) => el.remove());
    this.nodesToDestroy = [];
  }

  get _root() {
    return this.shadowRoot || this;
  }

  connectedCallback() {
    this._root.innerHTML = `
      <section class="main">
        <template data-name="show-todos">
          <input class="toggle-all" type="checkbox" data-name="input-todos-1" />
        </template>
      
        <ul class="todo-list">
          <template data-name="for-todos">
            <todo data-name="todo-todos"></todo>
          </template>
        </ul>
      </section>
      <style></style>`;
    this.pendingUpdate = true;
    this.render();

    this.onMount();
    this.pendingUpdate = false;
    this.update();
  }

  showContent(el) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLTemplateElement/content
    // grabs the content of a node that is between <template> tags
    // iterates through child nodes to register all content including text elements
    // attaches the content after the template

    const elementFragment = el.content.cloneNode(true);
    const children = Array.from(elementFragment.childNodes);
    children.forEach((child) => {
      if (el?.scope) {
        child.scope = el.scope;
      }
      this.nodesToDestroy.push(child);
    });
    el.after(elementFragment);
  }

  onMount() {}

  onUpdate() {}

  update() {
    if (this.pendingUpdate === true) {
      return;
    }
    this.pendingUpdate = true;

    this.render();
    this.onUpdate();

    this.pendingUpdate = false;
  }

  render() {
    // re-rendering needs to ensure that all nodes generated by for/show are refreshed
    this.destroyAnyNodes();
    this.updateBindings();
  }

  updateBindings() {
    this._root.querySelectorAll("[data-name='show-todos']").forEach((el) => {
      const whenCondition = todosState.todos.length;
      if (whenCondition) {
        this.showContent(el);
      }
    });

    this._root.querySelectorAll("[data-name='input-todos-1']").forEach((el) => {
      el.setAttribute("checked", todosState.allCompleted);

      el.removeEventListener("click", this.onInputTodos1Click);
      el.addEventListener("click", this.onInputTodos1Click);
    });

    this._root.querySelectorAll("[data-name='for-todos']").forEach((el) => {
      let array = todosState.todos;
      this.renderLoop(el, array, "todo");
    });

    this._root.querySelectorAll("[data-name='todo-todos']").forEach((el) => {
      const todo = this.getContext(el, "todo");

      el.setAttribute("todo", todo);
      el.props.todo = todo;
      el.update();
    });
  }

  // Helper to render content
  renderTextNode(el, text) {
    const textNode = document.createTextNode(text);
    if (el?.scope) {
      textNode.scope = el.scope;
    }
    el.after(textNode);
    this.nodesToDestroy.push(el.nextSibling);
  }

  // Helper to render loops
  renderLoop(template, array, itemName, itemIndex, collectionName) {
    const collection = [];
    for (let [index, value] of array.entries()) {
      const elementFragment = template.content.cloneNode(true);
      const children = Array.from(elementFragment.childNodes);
      const localScope = {};
      let scope = localScope;
      if (template?.scope) {
        const getParent = {
          get(target, prop, receiver) {
            if (prop in target) {
              return target[prop];
            }
            if (prop in template.scope) {
              return template.scope[prop];
            }
            return target[prop];
          },
        };
        scope = new Proxy(localScope, getParent);
      }
      children.forEach((child) => {
        if (itemName !== undefined) {
          scope[itemName] = value;
        }
        if (itemIndex !== undefined) {
          scope[itemIndex] = index;
        }
        if (collectionName !== undefined) {
          scope[collectionName] = array;
        }
        child.scope = scope;
        this.nodesToDestroy.push(child);
        collection.push(child);
      });
    }
    collection.reverse().forEach((child) => template.after(child));
  }

  getContext(el, name) {
    do {
      let value = el?.scope?.[name];
      if (value !== undefined) {
        return value;
      }
    } while ((el = el.parentNode));
  }
}

customElements.define("todos", Todos);
